<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
  <url>
    <loc>http://www.light3moon.com/2015/01/11/VI%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>VI 命令备忘</title>
        <pubTime>2015-01-10T16:12:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>我的一些常用的 vi 使用命令备忘。</p>
<h2 id="新建">新建</h2>
<ul>
<li>在 shell 直接 vi file 就能创建以 file 命名的文件。</li>
<li>:e file，在里面内存打开（创建）file 文件。（其中 ： 表示是命令模式）</li>
</ul>
<h2 id="保存">保存</h2>
<ul>
<li>:s，保存当前文件。</li>
<li>:q!，退出，不保存。</li>
<li>:q，退出当前窗口。:qa，退出所有窗口。 </li>
<li>:c，关闭当前窗口。</li>
</ul>
<h2 id="复制、粘贴">复制、粘贴</h2>
<ul>
<li>c， 复制。</li>
<li>p， 粘贴。</li>
</ul>
<h2 id="移动">移动</h2>
<ul>
<li>i， 上。</li>
<li>k， 下。</li>
<li>j， 左。</li>
<li>l， 右。</li>
<li>gg， 回到文件最第一行。</li>
<li>GG， 回到文件最后一行。</li>
<li>nG， 跳转到第n行。</li>
<li>ctrl+i(k,j,l)， 在窗口之间移动。</li>
</ul>
<h2 id="跳转">跳转</h2>
<ul>
<li>ctrl+o， 能回到跳转前的位置。</li>
<li>ctrl+i， 就是o的反操作。</li>
</ul>
<h2 id="撤销">撤销</h2>
<ul>
<li>u， 撤销。</li>
<li>ctrl+r， 恢复（就是反撤销）。</li>
</ul>
<h2 id="搜索">搜索</h2>
<ul>
<li>/ xx， 向后搜索 xx。支持正则表达式。</li>
<li>？ xx， 向前搜索 xx。</li>
<li>n， 下一个。</li>
<li>N， 上一个。</li>
</ul>
<h2 id="替换">替换</h2>
<p>:s，用法为 “:[range]s/target/replace/g” 。其中 range 可以是全文（%），target 是你要替换的字符串，replace 是你要换成的东西（/是分隔符），后面的 g 参数，表示替换一行中所有出现的字符串。例如：你要全文替换 hello 为 hello_world</p>
<pre>
:%s/hello/hello_world/g
</pre> 

<p>典型的用法就是在 linux 下打开某些 window 下编辑的代码，会在每行结尾有一个 ^M 的符号，可以使用替换命令替换掉： %s/^M//g （注意这里输入的 ^M 要按住 ctrl + v 和 ctrl + M 输入）。</p>
<h2 id="大小写转化">大小写转化</h2>
<p>gu(gU)，u是变小写，U是变大写，后面可以接范围命令，例如 guw 就是把当前一个单词变成小写。</p>
<h2 id="v">v</h2>
<p>视图模式，可以使用任何移动命令进行选择，选择后可以使用复制、粘贴、对齐等操作。</p>
<h2 id="标记">标记</h2>
<ul>
<li><p>:ma A-Z(a-z)，在当前位置做标记。可以设置 A 到 Z 个标记。</p>
</li>
<li><p>:marks，显示当前做的标记。</p>
</li>
<li><p>` A-Z，跳转到某个标记处。</p>
</li>
</ul>
<h2 id="q">q</h2>
<p>录制命令。qx：其中 x 是录制宏的编号，应该可以从 a ~ z 吧。按 qx 后就进入了录制模式，vi 会有 rercdring 的提示，录制完成后，再次按 q 推出。之后用 @x 来播放，x 就是宏的编号。@x 前面可以加范围的命令，例如 10@x ，表示10行进行这个命令。</p>
<h2 id="代码展开">代码展开</h2>
<p>代码展开命令。有些代码默认是折叠的，使用 zo 命令可以全部展开。</p>
<ul>
<li>zo 展开当前</li>
<li>zO 展开所有</li>
<li>zr 展开所有</li>
</ul>
<h2 id="==">==</h2>
<p>连续按2次 “=” 号键，就会自动对该行代码进行缩进对齐。并且前面可以加行数前缀。</p>
<h2 id="分屏编辑">分屏编辑</h2>
<ul>
<li>split： 上下分屏</li>
<li>vsplit： 左右分屏</li>
</ul>
<h2 id=":nohl">:nohl</h2>
<p>这是vi里的一个命令来的，就是去掉一些搜索结果时候的高亮显示。有时候高亮太多时，用这个比较好。</p>
<h2 id="16进制编辑">16进制编辑</h2>
<p>%!xxd 或者 %!xxd -r</p>
<h2 id="外部命令">外部命令</h2>
<p>在命令模式下，前面加 ！ 号，然后后面就可以执行外部 shell 命令。例如 :！pwd 就是显示当前路径。</p>
<h2 id="插件使用">插件使用</h2>
<p>插件、插件配置以及 vi 配置在附件里。</p>
<ul>
<li><p>可以看附件里的 vi 配置设置的快捷键参数，例如 F2、F3 这些。</p>
</li>
<li><p>wm（这个是 vi 配置里的快捷键），开启文件管理插件，类似 IDE 的那种。</p>
</li>
<li><p>superTab</p>
<ul>
<li>tab 键进行标签切换。</li>
<li>:b 1，切换到1号标签，标签号在 tab 上有显示。</li>
<li>在标签上按 d 键可以关闭这个标签。</li>
</ul>
</li>
<li><p>如果窗口大小乱了，可以使用窗口管理命令：</p>
<ul>
<li>ctrl + w + “+”， 放大该窗口。（注意是先按 ctrl，再按 w，再按 +号）</li>
<li>ctrl + w + “-“， 缩小该窗口。</li>
</ul>
</li>
</ul>
<h2 id="附件">附件</h2>
<p><a href="http://pan.baidu.com/s/1c0F6QTq" target="_blank" rel="external">vi 配置以及插件配置文件</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/BBK%20%E5%B7%A5%E4%BD%9C%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>BBK 工作编译脚本分析</title>
        <pubTime>2015-01-18T16:01:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>在 bbk 搞 apk 开发，通常一个人要用 N 个仓库，但是又不让 repo ，所以就搞了这个东西，还是借鉴了以前的在搞 MiniGUI 的脚本。</p>
<p>之前我们大家一起摸索出一套在服务器上统一编译 apk 的方法。服务器上的编译是由一个脚本来执行的，这样能够省很多事情。我们本机，如果相关的仓库不多的话，可以手动编译，但是如果相关的仓库很多的话，手动就很麻烦了。这几天抽了点时间，参看了下服务上的编译脚本，自己整理出一套适用于本机的编译脚本。拿出来和大家分享一下，不对的地方欢迎指正。</p>
<h2 id="功能">功能</h2>
<p>首先先确定下想要什么功能。我想要的功能是：</p>
<ol>
<li>一个命令，能帮我把我想要的仓库全都 clone 下来。</li>
<li>一个命令，能帮我把我想要的仓库全部更新。</li>
<li>一个命令，能帮我把我想要的仓库全部切换到指定的版本。</li>
<li>一个命令，能帮我把我的模块全部编译出来。</li>
</ol>
<h2 id="工作环境配置文件（-inc）">工作环境配置文件（.inc）</h2>
<p>根据上面的几个需求，开始打造我们的脚本。首先我们设定一个编译环境：不同的编译环境，环境变量不同，不同的编译环境，彼此不影响。这样的话，对于多个项目就很方便。例如说：有一个项目叫 H8，另外一个叫 H9 。可以先在 H8 中工作，后来因为需要，要切换到 H9 。打造不同的环境能够方便在多个项目中自由的切换。这样的话，就设计一个工作环境配置，然后用一个命令去读取这个配置，并且按照这个配置设置环境。我把配置文件放到在 home 目录的 /bin/inc 下面（注意这里是 linux 下的环境，不是 window 的，window 下可以用 cygwin 来模拟 linux 的环境）。这里还有一个约定，要把 home 目录下的 bin 文件夹设到环境变量里面去，这样这个下面的脚本可以在任何路径下被访问到（我的脚本放在这个目录下）。这个可以在 .bashrc 中设置一下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/1.png" alt=""></p>
<p>先来看看环境配置文件的信息：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/2.png" alt=""></p>
<p>我定义了下面几个可以配置的环境变量：</p>
<ul>
<li><p><strong>BUILD_PATH:</strong><br>工作环境目录。这个是这个配置对应的工作环境的目录，这里假设这个工作环境叫 test（对应配置文件为 test.inc）。这个目录是我本机 cygwin 的目录。</p>
</li>
<li><p><strong>CONFIG_PATH:</strong><br>工作环境配置目录。这个目录下放置一些工作环境的配置文件（后面会介绍有哪些配置）。这里设置的是在 <code>BUILD_PATH</code> 下面的 config 文件夹。</p>
</li>
<li><p><strong>TARGET_REPO_PREFIX：</strong><br>目标仓库前缀。就是我们的仓库地址（以及每个人的账号）。从仓库 URL 可以看得出，仓库的前缀是一样的，只有后面的路径不一样而已。</p>
</li>
<li><p><strong>ANDROID_CMD：</strong><br>android sdk 命令设置。这个是为了兼顾 linux 和 window 而设置的变量。linux 下，直接使用 android 就可以调用，window 下是 android.bat 。</p>
</li>
<li><p><strong>ERROR_OUTPUT:</strong><br>错误信息输出文件。用来保存错误信息，方便查看。这里配置的是 CONFIG_PATH 下面的 error 文件。</p>
</li>
<li><p><strong>MESSAGE_OUTPUT：</strong><br>信息输出文件。（这个暂时没用到）</p>
</li>
<li><p><strong>TARGET_REPOS：</strong><br>目录仓库配置文件。就是自己模块的以及自己模块相关（依赖）的仓库列表文件。脚本会去读这个列表文件。这里配置的是 <code>CONFIG_PATH</code> 下面的 target_repos 文件。</p>
</li>
<li><p><strong>BUILD_REPOS:</strong><br>编译仓库配置文件。由于一些仓库有多级目录，所以这个和 <code>TARGET_REPOS</code> 有点不一样。这里配置的是 <code>CONFIG_PATH</code> 下面的 <code>build_repos</code> 文件。</p>
</li>
<li><p><strong><code>BUILD_LIB_REPOS</code>:</strong><br>编译 LIB 配置文件。有些时候不想编译全部的模块，只要编一个就行了，但是需要先把 jar 先编出来，这个是只编译自己依赖的 jar 仓库的。这里配置的是 <code>CONFIG_PATH</code> 下面的 <code>build_lib_repos</code> 文件。</p>
</li>
<li><p><strong><code>COPY_LIBS_PATH</code>:</strong><br>某些 jar 仓库编译比较麻烦，所以服务器上会帮我们编译好，这个时候我们可以偷懒，直接去用服务上编出来的 libout （像 contentview、词典的 jar）。这个路径下放置已经编译好的 jar ，脚本编译的时候会去把这个路径下的 jar、so copy 到 libout 下，当做已经编译好了的。不过要注意一点，切换版本的时候，注意这个下面的库要和你切换的版本对应。也就是说切换版本的时候，记得更换这目录下的 jar 。当然如果你不偷懒，所有的仓库都自己编译，就不需要注意这一点了。这里配置的是 <code>CONFIG_PATH</code> 下面的 <code>copy_libs</code> 文件夹。</p>
</li>
</ul>
<p>上面这段配置文件作用很明显了，导出几个变量到当前 shell 环境中，然后打印一下这些值，最后自动进入设置好的当前环境工作目录。</p>
<h2 id="工作环境切换脚本（sw）">工作环境切换脚本（sw）</h2>
<p>切换工作环境脚本放到 /bin 下面：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/3.png" alt=""></p>
<p>前面说了，在 .bashrc 中把 home 目录下的 \bin 加入到环境变量中，这样 \bin 下面的 sw （switch）脚本就能被找到。这个脚本接收一个参数，使用方式如下：</p>
<pre>
$ sw test
</pre>

<p>后面那个参数就是你要切换的工作环境的名字。例如说这里的 test （假设这里的工作环境叫 test，你也可以叫 H8、H9 之类的）。上面脚本第一段是判断下参数是否合法（不为空，只有一个参数）。</p>
<p>如果不合法的话，就打印一段提示，告诉使用者用法。如果合法的话，就会进入到 home 目录下的 /bin/inc 下（前面说，我把工作环境配置文件放到这个目录下，如果你要添加新的工作环境，在这个目录加新的配置文件就可以了）。配置文件以 .inc 为后缀（模板在前面说过了）。然后就在 /bin/inc 下查找匹配输入参数的配置文件。例如我上面输入的是 sw test，那么就会去查找 test.inc ，如果没找到就提示没找到。如果找到了的话：</p>
<ol>
<li>导入（读取）配置文件的内容（source $INCFILE 就是干这件事的）。这里会把配置文件里面定义的环境变量都导出到当前 shell 环境中。</li>
<li>改变当前 shell bash 的显示，把切换的环境变量的名字作为 bash 的显示，这样就能清楚的知道自己是在哪个工作环境下面了。并且重新开启一个 bash。上张效果图： ^_^</li>
</ol>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/4.png" alt=""></p>
<p>当你想退出当前工作环境的时候，输入 exit 就可以，或者可以直接 sw xx 切换到另外一个工作环境。</p>
<h2 id="仓库配置文件">仓库配置文件</h2>
<p>这个就是上面的 .inc 文件中指定的那3个仓库列表文件。服务器上的是上次郭跃华收集的依赖关系然后用一个小程序生成出来的。我们本机自己的仓库没那么多，而且也没那么复杂，所以这里我就采用了比较原始的办法，自己手动写。</p>
<p>自己把自己的模块以及依赖关系整理出来（你自己肯定知道，自己都不知道的面壁去），然后按照依赖关系（编译顺序）写成一个列表（其实 TARGET_REPOS 不需要按照这个顺序写的）。拿我负责的3个模块来看看吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/5.png" alt=""><br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/6.png" alt=""></p>
<p>上边的是我配置的 TARGET_REPOS ，下边的是 BUILD_REPOS。可以看到其实差别就只是在于那些有多级目录的仓库而已。这里写的有3个模块：闹钟、听力测试和中学视频课堂，上面的是依赖库。最后上的那部分是 jar 依赖库，中的是 project 依赖库。其实这里并不是完整的依赖关系，省掉了 contentview.jar 和 dict.jar 的仓库及其依赖仓库。前面也说了，某些 jar 比较难编译（其实就是依赖的东西多），可以偷懒直接用服务器编出来的。这里就直接使用了服务器编译出来的 contentview.jar 和 dict.jar（还带了几个 so）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/7.png" alt=""></p>
<p>不过前面也说了，偷懒的话要注意，切换版本的时候，这几个 jar 和 so 要记得自己换成对应版本的。如果不偷懒，全都自己编的话，就不用担心版本问题了，脚本会帮你统一切换的。各有利弊，大家自己衡量吧。</p>
<h2 id="命令脚本（bbk_mk）">命令脚本（bbk_mk）</h2>
<p>这个脚本是主要部分了，和前面的 sw 一样，放到 home 目录的 /bin 下面（bbk makefile ?? 其实这个名字我也是随便取的，大家可以改成自己喜欢的）。先来看看脚本的入口：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/8.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/9.png" alt=""></p>
<ol>
<li><strong>co(clone)：</strong> clone 配置文件列表中所有的仓库。</li>
<li><strong>de(delete)：</strong> 删除配置文件列表中所有的仓库（删除哦，使用前要慎重考虑下）。</li>
<li><strong>up(update)：</strong> 更新配置文件列表中所有的仓库。</li>
<li><strong>rc(recover)：</strong> 恢复配置文件列表中所有的仓库。</li>
<li><strong>sw(switch)：</strong> 将配置文件列表中所有的仓库切换要指定版本。</li>
<li><strong>lo(local)：</strong> 本地化配置文件列表中所有的仓库（其实就是执行 android update project，但是这个命令本质上是生成一些本地的环境变量，所以我给它取名为本地化）。</li>
<li><strong>cl(clean)：</strong> 清除所有仓库的编译结果（包括 libout、apk 以及每个仓库中的 libs、bin、gen、obj 文件夹）</li>
<li><strong>bu(build)：</strong> 编译配置文件列表中所有的仓库（编译之前你要确定你已经调用过 lo 命令了）。</li>
<li><strong>lb(lib)：</strong> 编译 lib 库配置文件列表中所有的仓库（这个和上面的区别仅仅是只编译 \lib 下面的仓库而已，其实是由你指定的那个配置文件决定的）。</li>
</ol>
<p>这个脚本的用法是这样的：</p>
<pre>
$ bbk_mk command params
</pre>

<p>例如说要 clone 所有的仓库就敲 bbk_mk co，要切换到某一个分支就敲 bbk_mk sw branch ，要编译所有的仓库就敲 bbk_mk bu 。</p>
<p>上面这8条命令的功能就囊括了我最开始想要要的功能。下面就来看看是怎么实现些功能的吧。</p>
<p>这个脚本确实挺简单的，跑的就只是右边那个 if eles 语句而已。那个语句也是先判断下传入的参数是否合法（必须要有1个以上的参数，并且这个参数不为空）。不合法的话，给出提示（func_tip）。合法的话，就根据不同的命令（第一个参数），执行不同的功能。其实大家看到了，这里所有的功能都是调用一个函数来完成的，从这个函数的命令大概可以猜得到这个函数是干什么的。func_do_trav_repos 这个函数就是遍历所有的仓库列表，然后做某一件事情。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/10.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/11.png" alt=""></p>
<p>上面就是 func_do_trav_repo 的实现。左边开始的一段可以看做是预处理， lo(local), cl(clean), bu(build) 这3个命令用的仓库配置文件是 BUILD_REPOS， lb(lib)用的是 BUILD_LIB_REPOS，其它的命令用的是 <code>TARGET_REPOS</code>。根据前面说明就知道为什么要这样。然后 cl(clean) 命令要执行一个 <code>func_clean_output</code> 函数，这个函数就是去删除 libout, apk 目录，比较简单我就不贴出来了。bu(build) 和 lb(lib) 命令要执行一个 func_copy_libs 函数，这个函数就是去 copy 那个方便偷懒的从服务器上弄下来的 jar、so 到 libout 下面的，也是比较简单，我也不贴了。后面就是删除上一次的错误输出文件。</p>
<p>然后后面这句 cat $target_file | while read path ，前面一半就是去读取指定配置文件（linux 的 cat 命令），后面一半是把前面一半读出来的每一行做为 while 循环的输入。循环体里面为了在配置文件中支持空行和注释（以”#”开头），用了一个 case 做判断。当读到有效数据的时候就把当前的累加计数、命令、仓库路径，原始路径，命令参数传给 func_do_tarv_repos_impl（原始路径在执行命令开始的时候使用 $PWD 保存的）。这个函数又根据不同的命令做不同的事情。</p>
<p>func_clone_impl： co 命令的实现：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/12.png" alt=""></p>
<p>首先判断下当前工作命令下 lib, libproject, project 这3个目录存在存在，不存在的话就创建。这里是为了和服务器的目录结构保持一致。服务器是用 repo 的，所有不需要手动做，我们本地悲剧点，就只能手动了 -_-|| 。然后下面那段判断也是为了和服务器的目录结构保持一致，判断传递过来的仓库路径是以什么开头的。看看前面定义的仓库配置文件，就会发现有很明显的规律，/lib/xx 的是放在 lib 目录下的，/libproject/xx 的是放在 libproject 目录下的， /project/xx 是放在 project 目录下的。这里使用了 linux 下的一个命令 expr 进行简单的正则表达式匹配。expr match string 返回值代表匹配个数，而匹配表达式最前面的 ^ 表示匹配最开始的部分。这么解释这里就很容易理解了，例如： if [ $(expr match $path “^/lib/“) = 5 ] 就 $path 这个路径，最开头的5个字符是 /lib/ 那么这样就可以判断这个仓库是在 lib 目录下的。根据上面判断出不同的目录，进入到想要的目录，然后在这里执行 git clone 命令。至于完整的仓库路径就是：前缀（就是前面配置里写的，每个人的都不一样，用户名不同） + 路径（也是配置文件里读的）。这里注意一点，要想让脚本顺便的执行 clone 命令，如果你的 private key（私钥）是带密码的，是需要输密码的，可以使用 ssh 代理来帮你输密码（eval <code>ssh-agent</code>, ssh-add），不然的话，每一个仓库敲一次密码就和手动 clone 没啥区别了。当然如果你的 private key 没密码，就不用管。执行完一次 clone 命令后，重新回到原来的目录下面。</p>
<p>这样 clone 下面的仓库目录结构就和服务器上的是一样的。上张效果图： ^_^</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/13.png" alt=""></p>
<p>func_update_impl： up 命令的实现：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/14.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/15.png" alt=""></p>
<p>这个其实很简单，就是 git pull 命令。只不过加了个错误检测而已。错误检测的做法是：</p>
<ol>
<li>先将错误输出流（linux 有12个文件描述符，系统使用的是 0、1、2，分别代表标准输入、输出和错误，自己可以使用的是 3~9）重定向到我们指定的错误文件中（ERROR_OUTPUT）。具体做法是：先拿 4 号文件符临时保存错误输出，然后把错误输出重定向到错误文件中，然后再把原来保存错误输出的 4 号文件重新定向到错误输出（就是恢复一下原来的错误输出）。</li>
<li>func_check_error 在错误文件中使用 grep 命令查找是否有 Error、error、fatal、BUILD FAILED 这些关键字，如果有的话就认为有错误的，返回 1，如果没错误就返回 0。</li>
<li>根据 func_check_error 的返回值来判断，如果有错误就退出脚本执行，并且打印出错误信息，没错误就继续执行。</li>
</ol>
<p>后面那几个 func_switch_impl、func_local_impl、func_build_impl 都是和这个差不多的，大家自己去看下具体的脚本文件就知道了。我自己感觉用起来还是不错的，大家要就觉得好用可以拿去用。</p>
<p>要是觉得有什么可以改进的地方欢迎提出来。</p>
<p>额，最后说一句：这个是基于 linux 下的 bash shell 脚本，在 linux 下可以使用（废话），window 下 cygwin 也可以使用（相应的软件包要齐全，git、ssh、grep、expr 要装好）。</p>
<p>来个附件： 附件里带的有上面写的脚本，还有例子中的配置文件，大家可以拿去玩一下。</p>
<p><a href="http://pan.baidu.com/s/1eQy2S1c" target="_blank" rel="external">本机编译脚本分享</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Gitweb/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Gitweb</title>
        <pubTime>2015-01-13T12:48:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>Git web 是一个可以在 web 上查看 git 仓库的程序。例如可以在 web 上查看所有的 git 分支， git 的 commit、diff 等。</p>
<p>参考资料： <a href="http://www.cnblogs.com/wanghongmei/archive/2011/06/22/2087391.html" target="_blank" rel="external">ubuntu 上安装 gitweb</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Git%20%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Git 使用备忘</title>
        <pubTime>2015-01-13T12:13:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>简单的 git 使用教程。</p>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>git clone</li>
</ul>
<p>从服务拷贝代码副本到本地（类似 svn checkout）</p>
<ul>
<li>git add</li>
</ul>
<p>添加本机文件到服务器</p>
<ul>
<li>查看git仓库路径</li>
</ul>
<p>这个好像没直接的命令可以查看，可以去 git 代码的根目录下的 .git/config 里去看。</p>
<ul>
<li>git checkout</li>
</ul>
<p>切换分支。一般在切换分支前需要 git pull 更新到最新。这个命令，还有另外一个用处，当你想恢复一个文件时候，可以使用 git checkout xx （你还可以先把这个文件先删掉）。</p>
<ul>
<li><p>git branch</p>
<ul>
<li>git branch name ：创建新的分支（name）。</li>
<li>git branch -a ：查看所有的分支信息。</li>
<li>git branch -d name ：删除本地分支 name。</li>
<li>git push origin :name ：删除远程分支 name。</li>
</ul>
</li>
<li><p>git diff</p>
</li>
</ul>
<p>和 svn diff 类似的东西。</p>
<ul>
<li>git merge-base branch-A branch-B</li>
</ul>
<p>找到2个分支最近一次的公共 commit 。</p>
<ul>
<li>git merge branch-A</li>
</ul>
<p>把 branch-A 合并到当前分支。</p>
<ul>
<li>git init</li>
</ul>
<p>创建仓库。如果是在远程的服务器上，一般要用 git init —bare 来创建仓库。 创建仓库的话需要配置一下仓库访问权限，否则别人无法提交代码到你创建的仓库。</p>
<p>1: 修改 config ： 加上 sharedrepositiory = 1 这个属性。</p>
<pre config="brush:bash;toolbar:false;">
[core]
    repositoryformatversion = 0
    filemode = true
    bare = true
    sharedrepository = 1
[receive]
    enyNonFastforwards = true
</pre>

<p>2: 把 object 和 refs 目录（当然你改全部的也行）权限改成其它的人（同一组或者指定组的人）可以有写的权限（chmod 777 就可以）。</p>
<ul>
<li>git log</li>
</ul>
<p>git log 查看 log， git log -p xx 可以单独查看这个文件的修改记录。</p>
<ul>
<li>git tag</li>
</ul>
<p>打标签，查看标签。</p>
<ul>
<li>git show</li>
</ul>
<p>显示一个 commit 的详细信息，还可以显示一个 tag 的详细信息。</p>
<h2 id="初始化配置">初始化配置</h2>
<h3 id="1-">1.</h3>
<p>下面的命令将修改/home/[username]/.gitconfig文件，也就是说下面的配置只对每一个ssh的用户可见，所以每个人都需要做。</p>
<ul>
<li><p>提交代码的log里面会显示提交者的信息</p>
<pre>
[user]
  git config --global user.name [username]
  git config --global user.email [email]
</pre>
</li>
<li><p>在git命令中开启颜色显示</p>
<pre>
[color]
  git config --global color.ui true
</pre>

</li>
</ul>
<p>如果不太确定 .gitconfig 的位置的，可以用 git config  —global 命令来配置，git 会自动保存配置文件的。</p>
<h3 id="2-">2.</h3>
<p>下面的命令将修改/etc/gitconfig文件，这是全局配置，所以admin来做一次就可以了。</p>
<pre config="brush:bash;toolbar:false;">
// 配置一些git的常用命令alias
sudo git config --system alias.st status     // git st
sudo git config --system alias.ci commit     // git commit
sudo git config --system alias.co checkout   // git co
sudo git config --system alias.br  branch    // git branch
</pre>

<h3 id="3-">3.</h3>
<p>也可以进入工作根目录，运行git config -e，这样就只会修改工作区的.git/config文件，但是暂时还用不着. git config文件的override顺序是3&gt;1&gt;2.</p>
<h2 id="代码提交流程里">代码提交流程里</h2>
<ul>
<li><p>先确定下本地的修改： git status</p>
</li>
<li><p>看下diff: git diff</p>
</li>
<li><p>提交修改代码：git add xx</p>
</li>
<li><p>确认提交修改：git commit -m”xx” （-m 是注释信息，偷懒的话可以使用 git commit -am”xx”，可以把上面那一步也省了，不过好像不太好）</p>
</li>
<li><p>然后合并别人的代码：git pull （如果有冲突的话，需要解决冲突；有时候无法找到默认的分子，可以用 git pull origin xx 更新指定的分支，这个 origin 是仓库的名字，可以通过 git branch -a 看到，一般是 /remote/xx/branch，xx 就是，默认是 origin）</p>
</li>
<li><p>最后提交本地修改代码： git push (如果也是找不到默认分支的话，可以使用 git push origin xx(分支名)，如果不想每次都这么写，可以在第一次提交的时候使用 -u 参数，以后会默认提交到上次提交的分支 )</p>
</li>
<li><p>可以查看下提交记录： git log</p>
</li>
</ul>
<h2 id="忽略规则配置">忽略规则配置</h2>
<p>在仓库代码目录下可以新建一个叫 .gitignore 的文件来配置提交代码时忽略的文件类型：</p>
<pre>
*.class
*.apk
*.ap_
*.swp
tags
bin/
gen/
doc/
local.properties
proguard/
build.xml
</pre>

<h2 id="创建远程分支">创建远程分支</h2>
<p>要创建一个新的远程分支，首先要创建一个本地分支（git branch xx），例如 git branch test。然后再把这个本地分支 push 到服务器上去：</p>
<pre>
# ：号左边的是本地的分支，右边的是远程分支
# 当然你可以把本地分支 push 到服务器用不同的名字，但是我觉得还是一样的比较好
git push origin test:test
</pre>

<p>然后如果要删掉某个远程分支的话，这么弄就行了：</p>
<pre>
# 把本地的留空就是删除了
git push origin :test
</pre>

<h2 id="删除误添加的文件">删除误添加的文件</h2>
<p>如果在 git all —all 不小心添加了不想提交的文件（在 git status 中可以可得到添加的文件）。可以使用 git rm —cached xx 删掉误添加的文件。当然这个是还没 commit 的时候，可以这样简单的就删除掉，如果已经 commit 了，就不是这么简单的弄了。所以每次提交的时候都要 status 检查下本次提交的内容。</p>
<h2 id="撤销_add_的文件">撤销 add 的文件</h2>
<p>使用 git reset xx ，撤销 add 的问题，特别适用于使用 add —all 但是发现多添加了文件。注意这个是 add 但是还没 commit 的时候。</p>
<h1 id="撤销_commit">撤销 commit</h1>
<p>如果只是本地 commit 还没 push 到服务器，可以使用 git reset —hard xx（回到某个提交，xx 可以是 commit 的 id）。如果 push 到服务器的，要稍微麻烦点。但是最后每次提交前确定一下，这种操作还是少一点比较好。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/18/Linux%20Shell%20%E8%BF%9B%E9%98%B6%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Linux Shell 进阶环境脚本分析</title>
        <pubTime>2015-01-18T15:44:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>之前编译环境脚本是用候哥的，简单方便。不过有个缺点就是如果要特别指定一些配置的话，不太方便，需要每次都自己去设置。最近从其志那弄了个高级点的，据说源头是万哥那个的 -_-|| 。来看下吧。</p>
<h2 id="用法">用法</h2>
<p>在分析脚本之前先说说用法吧，很简单：</p>
<pre>
/* 切换编译环境 */
sw xx

/* autogen */
cfg
make
make install

/* cmake */
cm
make
make install
</pre>

<p>然后终端显示会相应的变成 xx 。这就表示已经设置成 xx 的编译环境了。</p>
<h2 id="sw-sh">sw.sh</h2>
<pre config="brush:bash;toolbar:false;">
#! /bin/bash

#check weather exe
if [ "$1" = "" -o $# -ne 1 ]; then
echo "Usage: $0 <target_name>"
echo "  target_name: build target name"
exit 1
else
cd /home/mingming/bin/inc

INCFILE="$1.inc"

#check file
INCFILE=`find . -iname $INCFILE`
if [ "$INCFILE" = "" ]; then
echo "Can't find the path: $INCFILE."
exit 1
fi
echo "Found match path: $INCFILE"
echo "Setting $1 env ..."
echo 

export TARGET_NAME=$1

#set env
export PS1="\[\033[01;35m\]$1\[\033[01;34m\] \w \$\[\033[00m\] "
source $INCFILE
fi

#/bin/bash
</target_name></pre>

<p>这个脚本很短，也比较容易理解。它会把输入的第一个参数（就是 sw xx 的 xx），作为这个编译环境的名字。然后去 /home/mingming/bin/inc 下去找对应的环境配置文件： xx.inc 。这个路径可以自己指定。如果找不到就报错。找到后就把这个名字 export 一下，后面的配置文件会用到的。然后把终端显示相应的改成编译环境的名字。最后读入配置文件的信息。</p>
<h2 id="inc">inc</h2>
<p>我的配置文件放在 /home/mingming/bin/inc 下，一般新建一个编译环境，就只要新写一个配置文件就可以了。现在来看看一个比较简单的 MiniGUI PC 上的线程版的配置文件吧：</p>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

#cfg
export minigui_configure_flags="\
--with-ttfsupport=ft2 \
--enable-ttfcache \
--enable-jpgsupport \
--enable-pngsupport \
--disable-dlcustomial \
--disable-splash \
--disable-screensaver"

export cmake_minigui_configure_flags="\
-Dwith_osname:STRING=linux \
-Dimage_pngsupport:BOOL=ON \
-Dimage_jpegsupport:BOOL=ON \
-Dwith_fontttfsupport:STRING=ft2 \
-Dfont_ttfenablecache:BOOL=ON \
-Dlicense_splash:BOOL=OFF \
-Dlicense_screensaver:BOOL=OFF \
-Dial_dlcustom:BOOL=OFF"

export mdolphin_configure_flags="\
--enable-focusring_tv"


export minigui_src="${ss}/minigui/rel-3-0"
export mgplus_src="${ss}/mgplus/rel-3-0"
export mgeff_src="${ss}/mgeff/rel-0-8"
export gvfb_src="${ss}/gvfb/trunk"


#env
export PREFIX="${tt}/${TARGET_NAME}"
export pp=$PREFIX
export BUILDPATH="${bb}/${TARGET_NAME}"

export MG_RES_PATH=$ss/res-trunk
export MG_CFG_PATH=$PREFIX/etc
export MG_CFG_FILE=$PREFIX/etc/MiniGUI.cfg
export libs_base="-L$PREFIX/lib -L/usr/local/lib -Wl,-rpath-link=$PREFIX/lib"
export extra_libs="-lpthread -lfreetype -lpng -ljpeg"
export CFLAGS="-g -Wall -I$PREFIX/include -I/usr/local/include"
export CPPFLAGS=$CFLAGS
export CXXFLAGS=$CFLAGS
export LDFLAGS="${libs_base}"
export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
export PATH=$extra_path:$PREFIX/bin:/home/mingming/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
export LD_LIBRARY_PATH="${tt}/${TARGET_NAME}/lib":$LD_LIBRARY_PATH

export CC=gcc
export AR=ar
export RANLIB=ranlib
export HOST=


cd $BUILDPATH
</pre>

<p>这个文件其实很一目了然了。开始的那个几个 flags 是相应设置 MiniGUI configure, MiniGUI cmake 的。如果有别的库需要编译的话，可以多加。后面就是设置安装路径（PREFIX）、CFLAGS、CXXFLAGS、LDFLAGS 等。这里注意下后面几个编译变量：</p>
<ul>
<li>PKG_CONFIG_PATH：这个是设置 pkgconfig 的文件路径，编译一些库必须要指定这个才能正确编译。</li>
<li>PATH：这个是指定一些库的配置脚本的，例如 freetype-config 等，有些库如果要链接另外一个库的话，必须要有这些配置脚本才能正确编译。注意会优先找放在前面的</li>
<li>LD_LIBRARY_PATH：这个是设置链接时候的路径。也是优先找放在前面的。不设置这个的话，很容易老去链接 /usr/lib 或是 /usr/local/lib 下的，交叉编译特别有用。</li>
</ul>
<h2 id="cfg">cfg</h2>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

#. common_flags.inc

echo $PWD |grep minigui > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$minigui_configure_flags $common_minigui_configure_flags"
fi

echo $PWD |grep mgplus > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mgplus_configure_flags $common_mgplus_configure_flags"
fi

echo $PWD |grep mgeff > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mgeff_configure_flags $common_mgeff_configure_flags"
fi

echo $PWD |grep mgutils > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mgutils_configure_flags $common_mgutils_configure_flags"
fi

echo $PWD |grep mgncs > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$ncs_configure_flags $common_mgncs_configure_flags"
fi

echo $PWD |grep mginit > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mginit_configure_flags $common_mginit_configure_flags"
fi

echo $PWD |grep core > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mdolphin_configure_flags $common_mdolphin_core_configure_flags"
fi

echo $PWD |grep mdtv > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mdtv_configure_flags $common_mdtv_configure_flags"
fi

echo $PWD |grep curl > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$curl_configure_flags $common_curl_configure_flags"
fi

echo $PWD |grep xml2 > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$xml2_configure_flags $common_libxml_configure_flags"
fi

echo $PWD |grep xslt > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$xslt_configure_flags $common_libxslt_configure_flags"
fi

echo $PWD |grep dfb > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$dfb_configure_flags $common_dfb_core_configure_flags"
fi

if [ ! -e configure ]; then
echo autogen.sh
./autogen.sh
fi

cmd="./configure $FLAGS --prefix=$PREFIX $common_configure_flags $*"

echo $cmd
$cmd
</pre>

<p>这个配合前面的 inc 文件也很简单了。它就是把之前 inc 文件里 export 的那些配置变量用到不同的库的 configure 上（如果没有 configure 的话，会先执行 autogen.sh）。不过这里可以看到局限性：就是这个脚本是根据当前的文件名判断应该使用哪个配置变量的。例如你的当前编译目录是： /home/mingming/build/pc-ths/minigui 的话，它就会使用 minigui<em>configure_flags 。所以编译库的文件夹名字不能随便乱取，要和这个脚本的对应。如果要新加的库的话，在这个脚本和加上那几句就可以，还有 inc 文件里也要加上相应的配置变量（不过如果你需要特别的配置的话，可以不加）。这个是简单的，复杂的可以参看附件里交叉编译 ST7167 的 ^</em>^。</p>
<h2 id="cm">cm</h2>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

#. common_flags.inc

echo $PWD |grep cmake_minigui > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$minigui_src"
FLAGS="$cmake_minigui_configure_flags $common_cmake_minigui_configure_flags"
fi

echo $PWD |grep cmake_mgplus > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgplus_src"
FLAGS="$cmake_mgplus_configure_flags $common_cmake_mgplus_configure_flags"
fi

echo $PWD |grep cmake_mgeff > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgeff_src"
FLAGS="$cmake_mgeff_configure_flags $common_cmake_mgeff_configure_flags"
fi

echo $PWD |grep cmake_mgutils > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgutils_src"
FLAGS="$cmake_mgutils_configure_flags $common_cmake_mgutils_configure_flags"
fi

echo $PWD |grep cmake_mgncs > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgncs_src"
FLAGS="$cmake_mgncs_configure_flags $common_cmake_mgncs_configure_flags"
fi

echo $PWD |grep cmake_gvfb > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$gvfb_src"
FLAGS="$cmake_gvfb_configure_flags $common_cmake_gvfb_configure_flags"
fi


cmd="cmake $SOURCE -DCMAKE_INSTALL_PREFIX=$PREFIX $FLAGS $common_cmake_configure_flags $*"

echo $cmd
$cmd
</pre>

<p>这个是和 cfg 类似的，只不过是 cmake 的而已。也就是说如果你的库同时支持 autogen 和 cmake，你 inc 文件里就要写2份配置。</p>
<h2 id="注意事项">注意事项</h2>
<p>原来我的 sw.sh 是 sw 的，然后是放在 ～/bin/ 下的，不过后来发现这样，终端显示的名字改变不了。好像是改变后马上又变会 ~/.bashrc 里设置的默认的了。晕～～后来把 sw 改成 sw.sh ，然后放到 ~/build/ 下才算可以正常修改终端的显示名字。真是奇怪，估计和 .bashrc 里哪个冲突了吧，不过我暂时还发现是哪个。</p>
<h2 id="附件">附件</h2>
<p><a href="http://pan.baidu.com/s/1hq6BqWO" target="_blank" rel="external">set.zip</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Linux%20shell%20%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Linux shell 环境脚本分析</title>
        <pubTime>2015-01-13T12:50:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>侯哥之前帮我在编译服务器上弄了个工作环境，vim啊，调试不同的minigui版本都挺好用的。不过总想弄明白这些脚本是咋回事。在不停的提问、百度、google之下，稍微明白了点；赶紧记下来吧，免得又忘记了。</p>
<h2 id="bashrc">bashrc</h2>
<p>目前的工作环境的目录安排是这样的（以下目录分别是在/home/xx/下）：</p>
<ul>
<li>source：源代码存放目录.</li>
<li>build：编译产生的中间文件目录.</li>
<li>target：minigui的库路径.</li>
</ul>
<p>每个不同的minigui版本在source下存放不同的源代码（例如rel－3－0）；在build下用mkdir建立相应的目录（build/rel-3-0），然后build/rel-3-0下有可以建立minigui目录（用于编译此版本的minigui），mg－sample（编译此版本的实例程序）；在target也建立相应的目录（target/rel-3-0）。以上目录建立完成后就可以用命令：</p>
<pre>
envbuild rel－3－0
</pre>

<p>来自动切换到rel－3－0版本的编译环境。此时会自动进入到build/rel－3－0目下。然后可以用lndir命令把source下rel－3－0的源代码链接过来，这样就能保证源代码目录的“干净”（编译都在build下）。把源码链接过来后，就可以用acfg命令配置生成makefile文件；然后用mi命令就编译，把编译好的库安装到相应的target/rel-3-0目录下。之后在build可以把mg－sample的链接过来，然后配置自动生成makefile文件，编译、运行实例程序了（这个时候会链接正确的minigui库哦）。</p>
<p>以上这些功能是怎样通过脚本来实现的呢，那从.bashrc看起吧。</p>
<pre config="brush:bash;toolbar:false;">
ss=/home/mingming/source
bb=/home/mingming/build
tt=/home/mingming/target
ftp=/home/ftp/pub
alias make='make -j5'
alias mc='make clean'
alias mi='make -j5 install'
alias mci='make clean; make -j5 install'
alias cfg='./configure --prefix=${TARGET_CFG}'
alias acfg='./autogen.sh;./configure --prefix=${TARGET_CFG}'
alias acmci='./autogen.sh;./configure --prefix=${TARGET_CFG}; mci'
#alias envbuild=". ${bb}/env.rc $*; cd ${bb}/${TARGET}"
#alias envsource="$ss/cd.sh $*"
alias buildtarget3="${ss}/build-target-3.sh $*"
alias envbuild=". ${bb}/env.sh $*"
alias envtarget=". ${tt}/set-env.sh $*"
alias cpexe="${bb}/cpexe1.sh $*"
export ss bb tt ftp
</pre>

<p>.bashrc这个脚本其实它的很具体的一些的东西我还是不太清楚，但是我目前知道的一点就是它是bash shell的环境配置文件（ubuntu上默认的shell是bash）。在它里面设置的一些环境信息会在用户登录的时候读入到shell中。我们先来看看上面这段.bashrc里的内容。ss、bb、tt分别就是上面我说的建立的source、build、target目录。后面的几个alias就能知道前面的acfg、mi的真正面目啦（alias这个命令看网上的说法应该是定义一个命令的别名，可以说是相当于简写？）。后面就定义了envbuild和envtarget命令啦。这里可以看到envbuild和envtarget还分别用到了build/env.sh和target/set-env.sh，这个2个脚本我们后面再看。这里可以看到这2个命令最后还有一个 $<em> 的符号。我虽然没确切的明白这个符号什么意思，但是我猜应该是传递envbuild xx这个命令后接的所有参数的意思（例如envbuild rel－3－0，那 $</em> 应该就只有一个参数：rel－3－0）。我可是根据后面的脚本这样猜的咧，应该是对的吧。</p>
<h2 id="env-sh">env.sh</h2>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

if test $# -eq 0; then
echo "target is not specify!"
echo "configure failed!"
exit 1
fi

export TARGET_NAME=$1
export TARGET=$1
TT=$tt
BB=$bb
TARGET_HOME=$TT
DEBUG=$2

if test -z $DEBUG; then
DEBUG="-O2 -Wall"

else
shift
a=""
for i in $@; do
a="$a $i"
echo $a
done
DEBUG=$a
fi

CFLAGS="-I${TARGET_HOME}/${TARGET_NAME}/include $DEBUG" 
CPPFLAGS="-I${TARGET_HOME}/${TARGET_NAME}/include $DEBUG" 
LDFLAGS="-L${TARGET_HOME}/${TARGET_NAME}/lib" 

export CFLAGS CPPFLAGS LDFLAGS
</pre>

<p>env.sh脚本刚开始是一个测试命令。test这个命令，会检测后面的表达式，若条件成立，则由$?返回0值，否则返回非0值（一般是1）；然后if由$?的返回值决定执行流程，若$?为0则执行then后面的语句。这里就可以看得到出这个检测命令的意思就是如果evnbuild后面什么参数（就是你的环境目录啦）都没给的话（$# -eq 0）就会提示错误信息，然后退出。</p>
<p>然后是又定义了几个变量，其中有用到 $1、$2 的值的。这2个我网上查到的信息是第1个和第2个参数的值。这个是env.sh的参数哦，可是我们好像没有显示的给env.sh什么参数啊；但是结合前面envbuild的定义就可以看得出了：env.sh $<em> 。所以我前面猜这个 $</em> 是后面所有参数的意思，这里看来应该是这样了。这里把TARGET_NAME＝$1（我们假设之前的envbuild命令后面接的是rel－3－0），TARGET_HOME＝$TT（TT=$tt）然后后面的：</p>
<pre>
LDFLAGS="-L${TARGET_HOME}/${TARGET_NAME}/lib" 
CFLAGS="-I${TARGET_HOME}/${TARGET_NAME}/include $DEBUG"
</pre>

<p>就可以知道为什么编译mg－sample能够链接到正确的库路径了。这里解析得到的就是：/home/mingming/target/rel-3-0/lib；正好就是之前minigui库的安装路径。如果换成rel-3-0-arena的版本的话，也能正确的找到minigui的库路径。</p>
<p>这里还有个 if test -z $DEBUG 的测试命令。DEBUG＝$2，这个我猜应该是envbuild后接了minigui的版本名字，后面再接一些特定的调试开关命令用的。因为$1是minigui的版本名字。这样就很好理解了，如果你什么调试开关都不写的话（这样test -z $DEBUG就成立），就用默认调试开关DEBUG＝”-O2 -Wall”；否则就将你输入的调试开关赋给DEBUG。然后可以看到CFLAGS最后将DEBUG给拼接上去了。</p>
<pre config="brush:bash;toolbar:false;">
#change TARGET for copy file.
TARGET_CFG=$TT/$TARGET_NAME
export TARGET_CFG
export TARGET_HOME

export PS1="\[\033[01;31m\]$TARGET_NAME\[\033[01;34m\] \w \$\[\033[00m\] "
#echo "Target is $1..."
export PATH=$TARGET_CFG/bin:$PATH

target=$TARGET_NAME
export TARGET_NAME=$target

if test -d $BB/$target; then
cd $BB/$target
if test  -f self.sh; then
. ./self.sh
fi
fi

if test -d $TT/$target; then
envtarget $TARGET_NAME
cd $TT/$target
if test  -f self.sh; then
. ./self.sh
fi
fi
cd $BB/$target



#./configure --prefix=${TARGET_CFG}
</pre>

<p>这里的PS1是根据当前的mingiui版本名字（也就是envbuild命令后面给的名字）改变shell的提示符。具体的代码含义可以去 其志 的个人wiki地盘去看 ^_^。PATH变量也增加了当前minigui库安装路径的bin目录。这里说下 export PATH=$TARGET_CFG/bin:$PATH 这样的用法，就是相当于在当前变量的基础上增加某些表达式，在设置某些查找库、二进制文件的路径上很有用。</p>
<p>接下来的 test -d $BB/$target 这个测试，应该是当/home/mingming/build/rel-3-0目录存在（假设是envbuild rel-3-0），并且该目录下有self.sh这个脚本文件，就去执行这个self.sh的脚本。这个应该估计是针对某些特殊minigui版本配置用的脚本，目前我还没用这个。</p>
<p>然后是 test -d $TT/$target 这个测试。这个测试是当/home/mingming/target/rel-3-0目录存在（同之前的假设），就会执行 envtarget $TARGET_NAME 这个命令。最后我们可以再看一下set-env.sh这个脚本了。（环环相扣啊）</p>
<h2 id="set-env-sh">set-env.sh</h2>
<pre config="brush:bash;toolbar:false;">
#/bin/bash
if test $# -eq 0; then
echo "error:Target is not specic."
exit 0
fi

TT=$tt
SS=$ss
TT_DIR=$TT/$1

export MG_CFG_PATH=$TT_DIR/etc
export MG_RES_PATH=$SS/res-trunk/
export LD_LIBRARY_PATH=$TT_DIR/lib:$LD_LIBRAY_PATH
export PATH=$TT_DIR/bin:$PATH
export BOOTCLASSPATH=$TT_DIR/usr/local/share/jamvm/classes.zip:$TT_DIR/usr/share/classpath/glibj.zip:$TT_DIR/usr/local/share/mgjni/mgjni.zip
export CLASSPATH=.:$TT_DIR/usr/share/jamvm/classes.zip:$TT_DIR/usr/share/classpath/glibj.zip

echo "Target is $1..."
export PS1="\[\033[01;31m\]$1\[\033[01;34m\] \w \$\[\033[00m\] "

cd $TT_DIR
if test  -f ./self.sh; then
source self.sh
fi

cd $TT_DIR/bin
</pre>

<p>哈哈，到这里就可以可以看到所有的minigui的一些环境信息都设置好了：</p>
<ul>
<li>MG_CFG_PATH：Minigui.cfg配置文件的路径</li>
<li>MG_RES_PATH：minigui资源文件的路径</li>
<li>LD_LIBRARY_PATH：minigui的链接库路径</li>
</ul>
<p>有一些java运行时的，暂时没用到；其它的是和前面重复定义了的 -_-||。最后执行完set-env.sh（应该说是执行完envtarget命令）后，env.sh最后会 cd $BB/$target 进入到相应的环境build目录下。</p>
<p>现在我大致上知道我现在用的这些脚本在后面干了些什么事了。不过上次听万大师的介绍，他用的脚本更强了，可以根据环境的不同配置不同的mingiui的configure。不过这个好像更麻烦，以后有空再研究下了。</p>
<h2 id="改进">改进</h2>
<p>有些项目用默认的 MiniGUI configure 不行了，所以就要手动改 configure 配置。这里可以在 .bashrc 里加2个映射命令：</p>
<pre>
alias cb='cd ${bb}/${TARGET_NAME};./build.sh;cd ${bb}/${TARGET_NAME}/minigui'
alias acb='./autogen.sh;cd ${bb}/${TARGET_NAME};./build.sh;cd ${bb}/${TARGET_NAME}/minigui'
</pre>

<p>然后在 /build/ 目录下放一个 build.sh 的 configure 脚本，MiniGUI 的编译源代码要放到 /build/minigui/ 下（一般我都是这么做的）。要用指定配置选项的时候就用 cb, acb 命令，要用默认配置选项的时候就用 cfg, acfg 命令。手法很简陋，但是自己用着还是蛮顺手的。</p>
<h2 id="附件">附件</h2>
<p><a href="http://pan.baidu.com/s/1hq6BqWO" target="_blank" rel="external">set.zip</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/10/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Linux 命令备忘</title>
        <pubTime>2015-01-10T15:55:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>百度、google都能搜得到，但是很杂。这里记录下我记不清的，但是又比较常用的一些linux命令用法。</p>
<h2 id="mount">mount</h2>
<p>挂载设备命令，一般挂载存储设备就用这个了（硬盘、U盘等）。</p>
<pre>
mount [-t vfstype] [-o options] device dir
</pre>

<p>其中：</p>
<ul>
<li><p>-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：</p>
<ul>
<li>光盘或光盘镜像：iso9660</li>
<li>DOS fat16文件系统：msdos</li>
<li>Windows 9x fat32文件系统：vfat （一般U盘的是这种文件系统）</li>
<li>Windows NT ntfs文件系统：ntfs</li>
<li>Mount Windows文件网络共享：smbfs</li>
<li>UNIX(LINUX) 文件网络共享：nfs</li>
</ul>
</li>
<li><p>-o options 主要用来描述设备或档案的挂接方式。常用的参数有：</p>
<ul>
<li>loop：用来把一个文件当成硬盘分区挂接上系统</li>
<li>ro：采用只读方式挂接设备</li>
<li>rw：采用读写方式挂接设备</li>
<li>iocharset：指定访问文件系统所用字符集</li>
</ul>
</li>
<li><p>device 要挂接(mount)的设备。</p>
</li>
<li><p>dir设备在系统上的挂接点(mount point)。</p>
</li>
</ul>
<p>具体的可以去看 man mount 。在挂载 samba 的时候如果说啥 mount 格式错误，一般是没有装 smbfs ， apt-get install 装一个就好。<br>查看电脑上的文件系统：fdisk -l 或 more /proc/partitions （一般要有root权限）。一般的用法是：</p>
<pre config="brush:bash;toolbar:false;">
// /mnt/windows 必须存在
// 用完了卸载用 sudo umount /mnt/windows
sudo mount -t ntfs /dev/sda1 /mnt/windows 

// 挂载 samba 网络设备（以 192.168.0.8 为例）
sudo mount -t smbfs -o username=****,password="****" 192.168.0.8:/xx /mnt/samba
</pre>

<p>要想在一开机就让linux自己挂载某个硬盘分区可以这样：编辑/etc/fstab，加入以下一行：</p>
<pre>
/dev/sda1 /mnt/windows ntfs defaults 0 0
</pre>

<p>卸载命令是：umount </p>
<h2 id="find">find</h2>
<p>查找文件命令。常用的形式： find path -type f -name filename -depth 。</p>
<ul>
<li>path: 路径，一般当前路径可以用 “.” 表示。</li>
<li>-type：查找的文件类型，f 表示普通文件。其他的可以看 man find。</li>
<li>-name：查找文件的名字，可以用正则表达式（不过我基本上只会用*而已）。</li>
<li>-depth：表示递归查找（查找子目录），好像可以设置深度的，具体的看 man 吧。</li>
</ul>
<h2 id="grep">grep</h2>
<p>查找文件内容命令。常用的形式： grep -Irn findstrings filenames。</p>
<ul>
<li>I：表示忽略小写。</li>
<li>r: 表示查找子目录。</li>
<li>n：表示显示行号。</li>
<li>v：这个表示方向查找，就是显示不包含查找内容的文件。例如 grep -Irn xx . | grep -v svn 就可以不去查找可恶的svn目录下的的东西。</li>
<li>l：表示只显示文件名字，例如 grep -lr xx . 搜索结果就只显示文件名。</li>
<li>findstrings：要查找的字符串，同样支持正则表达式。字符串可以加“”这样遇到要查找一些特殊字符不要加转意字符()，否则一些字符是命令的需要加转意字符。例如 grep -Irn “path\list” .</li>
<li>filenames：要查找的文件。</li>
</ul>
<h2 id="sed">sed</h2>
<p>流编辑器，功能十分强大，但是我目前就会用它的一点点功能而已，简单的说它能将输入文件一行一行的做处理。这样它和 grep , find 配合起来做替换的话，就十分方便了。常用形式：sed ‘s/old/new/g’ -i files 。</p>
<ul>
<li>‘s’：这个是替换命令，和vim的替换命令差不多。</li>
<li>-i：将输出写入原文件，也就是修改原文件的内容；如果不加的话就会输出到标准输出（一般是终端）。</li>
<li>files：输入的文件，可以是多个。</li>
</ul>
<p>这里与 grep 配合一个就可以在一个工程项目里做全局的替换了：（在工程的根目录弄） </p>
<pre>
# grep -r old * | sed 's/old/new/g' -i
</pre>

<h2 id="apt-get_install">apt-get install</h2>
<p>从网上下载并安装软件包。用法很简单，一般就是 sudo apt-get install xx ，但是一般会记不住包的名字。可以使用 aptitude search 关键字 （apt-cache search xx）来搜索。软件源可以修改 /etc/apt/source.list （不过一般用图形界面比较方便点），然后使用 sudo apt-get update 来更新。还有 apt-get install xx 的下载包的缓存地址在 /var/cache/apt/archives 里，这里其实可以备份起来，下次重装系统的时候就不用再重新下载了。</p>
<p>aptitude dist-upgrade xx 可以单独更新某个包。</p>
<h2 id="chmod_和_chown">chmod 和 chown</h2>
<p>chmod 是修改文件权限的，例如添加所属组的读写权限、添加其它用户的读写权限等。chown 是修改文件的拥有者，拥有者对该文件拥有所有权限。</p>
<h2 id="mkswap,_swapon">mkswap, swapon</h2>
<p>用来创建和挂载swap分区（linux下的虚拟内存），一般在板子上开发时，可以拿U盘做swap分区（事先要格式化成swap分区格式的）。一般用法是： mkswap /dev/sda 创建swap分区（假设/dev/sda是你的U盘），然后 swapon /dev/sda 挂载上就可以了。然后可以用 free 查看结果。</p>
<h2 id="删除不需要的内核">删除不需要的内核</h2>
<ul>
<li>dpkg —get-selections | grep linux ：可以查看自己安装了多少内核。用 uname -a 可以看到自己目前用的是哪个内核。</li>
<li>然后用 apt-get remove xxxx 就可以把自己不要的内核删掉（删掉后会自动把 grub 中对应的启动项目也删掉）。</li>
<li>不过某些时候 grub 会检测到一些没有办法启动的启动项目，这个时候可以修改 grub 的菜单文件把无用的项目去掉：<ul>
<li>grub1（ubuntu 9.10 之前）：/boot/grub/menu.lst</li>
<li>grub2（ubuntu 10.04 之后）：  /boot/grub/grub.cfg</li>
</ul>
</li>
</ul>
<h2 id="patch">patch</h2>
<p>linux打补丁命令。由 vim diff 等工具生成的 .patch 文件可由该命令对源代码打补丁。一般形式为： patch -p0 &lt; xx.patch 。p0 代表是源代码目标的第几层（文件夹深度），0就代表是根目录。一般是把 .patch 文件复制到源代码包的根目录，然后用上面的形式进行打补丁。更多的用 man patch 自己看吧。</p>
<h2 id="ftp">ftp</h2>
<p>用 ftp 上传东西的时候，如果发的不是文本文件，在上传之前要使用 binary 命令，转化为二进制传输模式，否则上传后的文件可能无法正常使用。</p>
<h2 id="解压_rpm_包">解压 rpm 包</h2>
<p>rpm 包可以使用 rpm -i 直接安装，也可以使用 rpm2cpio xxx.rpm | cpio -div 进行解压。</p>
<h2 id="修改用户权限">修改用户权限</h2>
<ul>
<li><p>useradd<br>添加一个新用户，一般新建立一个用户就会相应的建立这个用户同名的用户组。如果要新建立用户组的话，可以用 groupadd 。</p>
</li>
<li><p>usermod<br>修改指定用户的信息。可以修改这个用户的用户目录（home目录）、shell 环境（bash 还是 sh）、所属于的用户组等。其中修改说属的用户组就可以赋予和删除用户相应的用户组的权限。使用 </p>
</li>
</ul>
<pre>
usermod -a -G group1 user1
</pre>

<p>就可以将 user1 添加到 group1 组中。具体的用法可以看 man。其中</p>
<pre>
// 可以看到有哪些组, 组里有哪些用户
cat /ect/groups

// 可以看到用户的一些信息
cat /ect/passwd
</pre>

<ul>
<li><p>chgrp<br>chgrp -R file 可以改变这个文件的所属于组。</p>
</li>
<li><p>权限说明<br>一般我们最常用的也就是 777 755 644 这三种 Linux主机文件目录权限原理：</p>
</li>
</ul>
<pre config="brush:bash;toolbar:false;">
444 r--r--r--
600 rw-------
644 rw-r--r--
666 rw-rw-rw-
700 rwx------
744 rwxr--r--
755 rwxr-xr-x
777 rwxrwxrwx
</pre>

<p>三位数字代表9位的权限，分成3部分，第一部分3位表示所有者的权限，第二部分3位表示同组用户权限，第三部分3位表示其他用户权限，r代表读取权限等于4，w代表写入权限等于2，x代表执行权限等于1</p>
<p>比如777，第一位7等于4+2+1，所以就是rwx，所有者有读取、写入、执行的权限，第二位7也是4+2+1，rwx，同组用户具有读取、写入、执行权限，第三位7，代表其他用户有读取、写入、执行的权限。<br>比如744，第一位7等于4+2+1，rwx，所有者具有读取、写入、执行权限，第二位4等于4+0+0，r—，同组用户只有读取权限、第三位4，也是r—，其他用户只有读取权限。</p>
<h2 id="修改用户密码">修改用户密码</h2>
<p>passwd user 可以修改指定用户的登陆密码，当然如果修改别的用户要有 root 权限。</p>
<h2 id="监视某个端口">监视某个端口</h2>
<pre>
# 这里是监视网络流量
watch -n 1 "/sbin/ifconfig eth0 | grep bytes"
</pre>

<h2 id="查看磁盘空间">查看磁盘空间</h2>
<p>虽然有 fdisk 可用，但是 df -h 效果更好。</p>
<h2 id="wget">wget</h2>
<p>这个东西下 http 的挺好用的。一般用法比较简单，直接 wget url 就行了。</p>
<h2 id="压缩">压缩</h2>
<p>可以用 tar，也可以用 zip：</p>
<pre>
// gz 格式的
tar -xzvf xx.tar.gz      // 解压
tar -zvf xx.tar          // 解压
tar -czvf xx.tar.gz xx   // 压缩

// bz2 格式的
bzip2 xx.tar.bz2  // 解压 

// 递归（文件夹）中的打包为 xx.zip，其中 -0 表示不压缩，仅仅是存储
// 不加 -0 则表示用默认压缩
zip -r -0 xx.zip xx 

// 将 xx 这个文件加入到 xx.zip 中，其中能保持 xx 的文件树结构
zip -g xx.zip xx
</pre>

<h2 id="dpkg">dpkg</h2>
<ul>
<li>安装 deb 包： dpkg -i package-file.deb</li>
<li>卸载 deb 包： dpkg -r package-name</li>
<li>包名可以通过 dpkg —info package-file.deb 查看</li>
</ul>
<h2 id="df">df</h2>
<p>查看磁盘分区大小，可以加 -h 显示单位。</p>
<h2 id="xargs">xargs</h2>
<p>可以显示指定让上一个命令的输出作为下一个命令的输入参数。例如： </p>
<pre>
# 先搜索以 buildin 结尾的文件，然后再删掉。
find . -iname *.buildin | xargs rm 
</pre>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 消息机制源码分析</title>
        <pubTime>2015-01-21T13:07:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>现在不少的GUI都是基于消息机制的。所谓的消息机制我个人的理解是：当用户与GUI交互时发生了一些事件（如按下键盘、点击鼠标等），这个时候就要告诉GUI发生了某个事件（发送消息），GUI在监听是不是有事件发生（获取消息），当GUI得知有事件发生时就要做出某些动作来响应用户的这些事件（消息处理函数），当GUI处理完一个事件的响应函数后会继续监听别的事件直到GUI退出位置（消息循环）。大致应该是这样，不过其实还有不少东西的：例如，同步、异步处理，消息优先级，消息队列等。具体的来看看 MiniGUI 的实现吧。</p>
<p>N早以前开了个头～～MS放弃写了～～ -_-|| 留个名吧～～</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 源码分析笔记</title>
        <pubTime>2015-01-21T13:12:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>随手记记，免得忘记。</p>
<h2 id="线程版启动的线程">线程版启动的线程</h2>
<p>线程版的 MiniGUI 在 InitGUI 后，会启动额外3个线程：</p>
<ul>
<li><p>__mg_desktop（pthread_t）：桌面线程，线程函数 DesktopMain。这个线程用于运行桌面处理函数，处理各种桌面消息，以及分发各种消息给所需要的窗口。</p>
</li>
<li><p>__mg_parsor：事件循环线程，线程函数 EventLoop。这个线程用于不停的接受底层驱动事件（鼠标、键盘等），然后转化为 MiniGUI 消息放入消息队列。</p>
</li>
<li><p>__mg_timer：全局计数线程，线程函数 TimerEntry。这个线程用于提供 MiniGUI 最小计数单位（定时器用）。</p>
</li>
</ul>
<p>所以，加上 MiniGUI 应用程序本身，如果不再额外创建线程的话，线程版的 MiniGUI 一共有4个线程。</p>
<h2 id="有层_alpha_的时候会忽略逐点_alpha">有层 alpha 的时候会忽略逐点 alpha</h2>
<p>目前的 MiniGUI 是这样的，如果既要有层 alpha 有要逐点 alpha，只能分2次混合，一次使用逐点 alpha，一次使用层 alpha，中间使用 memdc 倒一次。这个可以看看 GAL_UpperBlit、GAL_LowerBlit、GAL_MapSurface、GAL_CalculateBlit、GAL_CalculateBlitN 等等这些函数。有空最好把目前 MiniGUI BitBlt 的流程总结下。哎～～以前写 GAL 的时候有点印象的，隔了段时间又忘记了。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B1/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程1</title>
        <pubTime>2015-01-19T12:25:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<h2 id="前言：">前言：</h2>
<p>MiniGUI 采用的机制是与win32十分类似的消息机制，基本上与win32的sdk一致。win32上经典的Framework MFC 采用的是C++，面向对象的方法，自定控件可以直接使用继承的方式，十分方便。MiniGUI 使用的是c语音，重所周知这是一个面向过程的语言。但是其实它也可以使用类似c++的面向对象的思想（详细的可以看一本叫做 《Object-Oriented Programming with ANSI-C》的书，具体的就不在这里研究了）。MiniGUI 本身自带的控件就是用c语言来模仿一些面向对象思想来实现的。</p>
<p> 飞漫的编程指南上也提到了自定控件的方法。但是与其它的章节比起来篇幅太小了 -_-||。网上这方面的资料更是少得可怜，在csdn和pudn上我可以随便搜到MFC、VB、Dephi等自定义控件的例子，但是MiniGUI基本上就没看到。想当初自己研究，很费劲，走了不少弯路。现在总结了一些心得，希望开发定义控件的弟兄们少走些弯路。</p>
<h2 id="自定控件的方法">自定控件的方法</h2>
<p>MiniGUI 原有的控件用一个叫做 WNDCLASS 的来表示。从名字就可以看出了，飞漫把这玩意当类来对待了。不过c++（面向对象的语言相对来说本人对c++比较熟悉，就拿这个举例子了）里的自定义控件可都是子类化某个原有的控件类，然后写好类之后，实例化得到控件对象就可以使用了。</p>
<p>飞漫的编程指南里说到了3种方法：</p>
<ol>
<li>对已经建立的控件实例进行子类化，子类化的结果只会影响这一个控件实例。</li>
<li>是对某个控件类进行子类化，将影响其后创建的所有该控件类的控件实例。 </li>
<li>是在某个控件类的基础上新注册一个子类化的控件类，不会影响原有控件类。在 Windows 中，这种技术又称为超类化。</li>
</ol>
<p>恕本人水平及理解能力有限，我目前只理解和使用了第1和第3种方法，第2种我愣是没明白怎么回事。要是哪位兄弟理解了的，望留言或发email告诉我。 那现在我就说说我理解了的这2种方法吧。</p>
<h3 id="对已建立的控件进（实例）行子类化">对已建立的控件进（实例）行子类化</h3>
<p>MiniGUI 的控件就是一类特殊的子窗口，所以它们也有自己的过程处理函数 typedef int (* WNDPROC) (HWND, int, WPARAM, LPARAM) 。这种方式的实现其实就是替换掉已经创建了的控件原来的过程出来函数。这个函数其实是每个控件结构体变量里一个函数指针所指向的。通过函数指针指向不同的处理函数就能实现控件的不同功能已经不同的属性。再配合上每个控件的实例数据（后面再说这个东东），是不是有点像面向对象的感觉了呢 ^_^。</p>
<p>这种方法只会对你替换了过程处理函数的控件实例才生效。个人感觉比较适用的情况是：一个工程里，有好几个界面用到了同一个控件或者一个界面用到了好几个控件；但是这些控件都是和本工程关系比较紧密的，其他工程基本上用不到的。例如：一个项目里需要画N个直方图，这些直方图只是数据不一样而已，绘图方法基本一致；但是别的工程基本上用不到这个东西。其实这个用一个函数来实现也可以，让其传入绘图dc和相应的区域坐标就可以了。不过我感觉用函数这种方法没有封装成控件来得方便。</p>
<ol>
<li>函数使用的绘图相关的变量是和父窗口相关的，用起来不怎么方便。</li>
<li>提供给工程里别的模块使用话，在MiniGUI这种gui编程中，封装成控件，使用消息机制更符合MiniGUI的编程方式。</li>
</ol>
<p>哎~~总之大家自己可以感受封装成控件的好处的，我表达能力有限，好像没怎么说清楚。不过这样弄有点点代价。就是MiniGUI的控件都有自己的数据结构变量，会稍微占有一些额外的资源，不过都能跑GUI的设备了，这些应该问题不大啦。</p>
<h3 id="对控件类进行子类化">对控件类进行子类化</h3>
<p>这种方法与上一种相比，应该算是更接近C++的自定义控件的方法。上一种是针对原有控件实例的，而这种是针对控件类了。是改动整了类，正如飞漫编程指南上写的，这种方法能影响到每一个创建的控件实例。 这种方法要是向MiniGUI 注册自己的类，然后自己设计控件数据（不是指GUI系统的调用的控件窗口数据（这些例如客户区、私有DC、托管窗口之类的），而是指保存控件某些行为的数据（例如ctrl_button里的BUTTONDATA这一些的数据））和过程处理函数。</p>
<p>这种方法我个人认为比较适用用于像扩展按钮（Button）、编辑框（Edit）、进度条（ProgressBar）之类的通用性比较强的控件。例如你觉得MiniGUI原来的Button不怎么好看，就可以自己弄一个，然后你写的所有工程都可以用你写的好看的Button来装饰了。</p>
<p>这里先介绍些理论的东西，之后再结合实际来讲解具体的方法。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B2/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程2</title>
        <pubTime>2015-01-19T12:34:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<h2 id="控件功能确认">控件功能确认</h2>
<p>咋接着上次的教程继续。这次我们依托一个例子来说明如何使用MiniGUI中的第一种方法（也就是子类化已经创建的控件实例）。假设我们的例子是：某个学校的某个年级的某些班在某个时间搞了某次考试。考试过后经老师研究决定把考试成绩按班为单位分成3个分数段：差、中等、好。现在咱们就要用MiniGUI来整一个统计图来直观的显示这个3个分数段的学生比例。但是有几个班就有几个统计图啊。你可能说，我可以只画一个图然后切换数据显示不就行啦。哎呀，那么大的窗口你就忍心只放一个图么，再说了你偏要这么弄，那咋的教程也进没办法进行下去了。所以我决定在界面上放上2个统计图（其实放多少个都可以，反正代码只有写一次 ^_^）。然后再弄1个按钮在切换不同的班级数据显示。最终的效果如下图：</p>
<p> <img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control2/1.jpeg" alt=""></p>
<h2 id="控件设计">控件设计</h2>
<p>OK，首先让我们确定下要“继承”哪一个MiniGUI的控件。哎，其实这问题太明显了。我们要的是一个统计直方图，基本上控件都是自己画出来的了，MiniGUI原来控件的一些特性基本上用不到，那当然是选择继承CTRL_STATIC啦，这个控件本身没多少自己数据（占用资源少），而且如果你不设置任何信息在上面的话，就是白花花的一块画布啊，赶紧画吧。</p>
<p>第二次OK，让我们设计下我们这个控件的数据结构：我们需要保存3个分数段的学生人数（弄个int的3元素的数组啦）；班级的名字（弄个32个字符的char数组啦）；控件附加数据（DWORD类型，这个为什么要要，在后面的注意事项里再说）。所以我们的控件的数据结构就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _statgdata_st</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> nData[<span class="number">3</span>];</div><div class="line">    <span class="keyword">char</span> strName[<span class="number">32</span>];</div><div class="line">        </div><div class="line">    DWORD dwUserAddData;</div><div class="line">} STATGDATA;</div><div class="line"><span class="keyword">typedef</span> STATGDATA* PSTATGDATA;</div></pre></td></tr></table></figure>

<p>第三次OK，然后我们再来设计下我控件对外的接口。MiniGUI 采用消息机制，那和外部打交道的当然就是消息啦。注意我这里说设计的消息是指控件自定义的消息，不是MiniGUI 原有的消息。</p>
<ol>
<li>初始化。观众又要说了不是有MSG_CREATE消息么，为什么还要自己再弄一个。嘿嘿，这个在同样在后面的注意事项再说。我把它整成STATGM_INIT；不要任何参数；主要负责初始化控件数据变量。</li>
<li>设置控件数据。这个就不多什么了，没这个你还怎么操作控件？我把它整成STATGM_SETDATA；WPARAM 传入字符串指针来设置strName；LPARAM传入int数组首地址来设置nData。</li>
<li>设置控件附加数据。这个说了后面再说的。我把它整成STATGM_SETADDDATA；WPARAM传入DWORD的附加数据。</li>
<li>获取控件附加数据。有了前面的设置附加数据能没这个么。我把它整成STATGM_GETADDDATA；WPARAM传入获取的DWORD指针。为啥不用SendMessage的返回值，那个是int的，DWORD在MiniGUI的定义为unsigned long 其实还是和int的有区别的。</li>
</ol>
<p>对了，应该还有一个STATGM_GETDATA的来获取当前控件的数据值的，但是我一想反正是弄了小例子而已，大家有兴趣的自己去改我的源代码啦。所以我们的消息就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_BASE         MSG_USER + 3000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_INIT         STATGM_BASE + 1</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_SETDATA      STATGM_BASE + 2</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_SETADDDATA   STATGM_BASE + 3</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_GETADDDATA   STATGM_BASE + 4</span></div></pre></td></tr></table></figure>

<p>第四次OK，控件数据结构和消息都设计好了，可以开工写了。其实C语言，MiniGUI的API的调用大家都会，我这里就是主要说一下使用这样方式自定义控件的注意事项，也算为把之前挖的坑给填了 ^_^ 。</p>
<h2 id="需要注意的问题">需要注意的问题</h2>
<h3 id="1：如何继承父类（我们这里是CTRL_STATIC）">1：如何继承父类（我们这里是CTRL_STATIC）</h3>
<p>飞漫的编程指南里，写的是用一个全局的WNDPROC 变量来保存SetWindowCallbackProc() 的返回值来获取原来控件的过程处理函数指针。然后在新的过程处理函数消息处理过后再利用这个全局变量来跳转到父类控件的过程处理函数去执行。我个人不怎么喜欢这样方式。我的方法是用如下这段代码来获得父类控件的过程处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WNDCLASS wcStatic;</div><div class="line"></div><div class="line">wcStatic.spClassName =  CTRL_STATIC;</div><div class="line">wcStatic.opMask = <span class="number">0x00FF</span>;</div><div class="line"></div><div class="line">GetWindowClassInfo (&wcStatic);</div><div class="line">wpOldStatic = wcStatic.WinProc;</div></pre></td></tr></table></figure>

<p>其中wpOldStatic是自定义控件源文件的文件变量。我定义一个接口函数把这段代码封装起来，然后在子类化控件实例前调用。注意这个一定要获取正确不然得不到正确的继承效果的，一般来整个项目的初始化过程里调用。然后我再解释下那个opMask为啥要设置成0x00FF。这个是飞漫的API编程手册里没写清楚的地方之一（至少我看的2.0.4的没写）。这个DWORD的掩码告诉下面的GetWindowClassInfo() 函数你想要获取的控件类的信息。然后这个函数会把控件类的相关信息填入你传入的WNDCLASS指针里。不过要注意你传入的WNDCLASS的spClassName字段你要填好，不然这个函数不知道你要获取的是哪个控件类的信息。opMask掩码含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_STYLE       0x0001  <span class="comment">// 获取风格信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_HCURSOR     0x0002  <span class="comment">// 获取鼠标信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_BKCOLOR     0x0004  <span class="comment">// 获取背景颜色信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_WINPROC     0x0008  <span class="comment">// 获取过程处理函数信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_ADDDATA     0x0010  <span class="comment">// 获取附加数据信息</span></span></div></pre></td></tr></table></figure>

<p>我们要的就是 COP_WINPROC(0x0008)这个啦，不过为什么设置为0x00FF咧。哎，这个就代表我以后的信息全部获取，当然也就包括控件的过程处理函数啦。</p>
<h3 id="2：如何子类化控件实例">2：如何子类化控件实例</h3>
<p>飞漫的编程手册里介绍的是用 SetWindowCallbackProc? () 来替换掉要子类化的控件实例的过程处理函数。没错就是用这个函数来替换，不过需要注意一个问题。你控件需要初始化吧。大家说：响应MSG_CREATE消息不就得啦。嘿嘿，这就不行了吧。大家仔细想想看，MSG_CREATE消息是什么时候发送的？是在控件创建好之后就发送了。那你是什么时候替换掉它的过程处理函数的？你别告诉我可以再控件实例创建好之前替换。你替换时候的控件句柄哪来的，不创建好后你能GetDlgItem到控件句柄？所以如果这个时候你把初始化控件变量的代码写到了MSG_CREATE里的话，你就着道了。你的控件数据是不会被初始化的，这个对于指针来说，意味着什么会C、C++的人不用我说了吧。所以我才在上面说要自己整一个初始化的消息让外部在替换的时候告诉控件：要初始化啦。 这样我就把实例化封装成一个接口函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InstanceStatGCtrl (HWND hCtrl)</div><div class="line">{</div><div class="line">    SetWindowCallbackProc (hCtrl, StatGraphProc);</div><div class="line">    SendMessage (hCtrl, STATGM_INIT, <span class="number">0L</span>, <span class="number">0L</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>每次子类化控件实例，把该控件实例的句柄传入这个函数就可以啦。</p>
<h3 id="3：控件数据如何实现每个实例保存一份">3：控件数据如何实现每个实例保存一份</h3>
<p>C++里有类和对象的概念，每个类的对象都拥有自己的数据（叫成员变量，或者叫实例变量），也有所有对象公用的数据（叫类数据，在定义类的数据时加上static即可）。可是C语言是没有真正的类的数据的，只有结构体。MiniGUI的每个控件都有2个附件数据，都是DWORD类似的其实就是unsigned long，在一般的linux上是32bit的。用于保存控件的私有数据（其实就是可以理解为每个控件实例自己的数据）。又有人问了，这只是一个32bit的数据，怎么保存各种各样的数据啊？嘿嘿，C语言忘了指针了么。如果你拿这个32bit的空间来保持数值确实不能干什么事，但是如果你是拿来保持地址呢。这个地址指向了你希望保持数据的首地址，那这就把这个问题给解决了。</p>
<p>我把控件的数据类型定义成一个结构体，然后在初始化话的时候给它申请内存空间，然后把地址（也就是这个结构体的变量的指针）保存到附加数据里。然后在后面的消息处理中，通过获取控件的附加数据（获取后强制转化为控件结构体指针），就能够操控每个控件实例的数据了。别了在控件销毁时释放内存哦。</p>
<p>但是这里还要特别强调一点。MiniGUI每个控件有2个附加数据。这不是随便用其中的一个的。其中dwAdditionalData2（附加数据2）是被MiniGUI原有的控件用掉了的，用来保存它们的控件私有数据去啦。所以像这种“继承”至MiniGUI原有控件的绝对不能使用dwAdditionalData2，不然控件就很容易出乱子，甚至程序崩溃，因为MiniGUI原来的控件也是使用指针的方式来保持的，你把它原来的弄掉了，然后它原来的代码又用这个指针干原来的事情，想想看多危险的情况啊。这个在飞漫的编程指南里有提到，但是仅仅是在44页的一个不起眼的地方用了一个小字体一笔带过而已 -_-|| 。</p>
<p>所以，我现在一个例子的这种情况应该使用dwAdditionalData1（附加数据1）来保存我们自定义控件的数据。不过这个附近数据还有一个用途就是应用程序的开发人员来保持一些特定应用程序的一些数据的。但是这里被我们用掉了，咋办咧。嘿嘿，这个也好办，还记得我设计的时候说设计了一个设置控件附加数据的消息么，MiniGUI 有SetWindowAdditianlData() 的API了，我为什么还要设计这个接口咧。这就是原因啦，本来设计保留给应用程序的dwAdditionalDtat1别我的控件占用掉了，我们控件的开发原则就是尽量方便外部应用程序的使用，不能让人家不能使用原有的功能啊。所以我在自定义控件的结构体里增加了一个DWORD类型的数据，然后提供结构给外部来设置和获取。不过这里一定要告诉使用控件的人，让他使用你提供的消息来设置和获取控件附加数据，而不是直接使用SetWindowAdditionalData 和GetWindowAdditionalData 。</p>
<p>这里再啰嗦一点：外部的应用程序不管什么情况下，都不要轻易的使用SetWindowAdditionalData2和GetWindowAdditionalData2。这个之前说过了，是保存MiniGUI 原有控件数据的指针，不是开放给外部应用程序使用的。</p>
<p>其他的一些通常的MiniGUI GUI编程的一些就不多说，看我的源代码相信大家都会。这次介绍子类化已有控件实例的方法。下次我将结合自己写的一些通用自定义控件介绍子类化控件类和完全自己从头开始写自定义控件类（我管某一种方式叫完全自己从头开始写，至于准不准确大家自己看着办了，话说我还没开始介绍咧 -_-||）的方法。</p>
<p>本人比较懒散些，所以更新慢是必然的，请大家多多包涵。飞漫的MiniGUI的3.0版本都出来了，据说和1.6/2.0 区别很多，本人这些全是在2.0的基本上研究的，哎，不知道过时了没 -_-|| 。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="&quot;http://download.csdn.net/detail/mingming_killer/4045894&quot;">下载地址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B3/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程3</title>
        <pubTime>2015-01-19T12:52:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。之前介绍了子类化已有的控件实例的方法，现在介绍子类化类和完全自己重新开始写控件类的方法。这个2种区别就是：子类化类，其实就是OOP里的继承，继承一个已有的控件类，在其基础上作扩展。完全自己重新开始写控件类是我自己的叫法，可以理解为MFC（我个人对MFC相对来说熟悉些，就拿这个做类比了）里的继承自CObject。 这次先介绍完全自己重新开始写控件类的方法。这里我以我自己写的一个MiniGUI的扩展控件类为例子来介绍。MiniGUI里原来的有CTRL_BUTTON这个控件类。刚开始2.0.4 classic风格我觉得不怎么好看（其实是我头头觉得不怎么好看），后来折腾了下弄成fashion风格了的，BS_AUTOCHECKBOX和 BS_RADIOBUTTON已经感觉不错了，不输给台式机的那些控件库了，不过基本的Button功能和那些.net，java的Button比起来还是有一定差距。其实最主要的是我接手的一个项目里，之前负责人，弄了一个类似.net，java，winXP那样的Button，就是鼠标放上去会有外观变化的，然后全部用图片来表现Button。刚开始感觉不错，后来拿到代码一看。额的个神啊，他竟然每个窗口里使用一些CTRL_STATIC来充当Button，然后窗口相应鼠标事件，检测当鼠标移动到某个STATIC上的时候就加载不同的图片。额的个神、额的个神，光光是这些判断代码都快烦死了，而已都是一大堆、一大堆的坐标计算；最要命的是每个窗口都有。一个项目那么多个界面（窗口），要我维护这个，想整死我啊。以前用MFC起手的我，立刻想到了把这玩意封装成控件。他原意其实就是要Button好看点，好我就以这个扩展的Button为例子来说明。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<p>首先我把这个扩展控件取名为CTRL_BUTTONEX（”button_ex”）。ButtonEx首先就要尽量具备MiniGUI CTRL_BUTTON BS_PUSHBUTTON的基本功能，这样才能在功能上不影响使用者的使用。其次，就是美观，这也是扩展这个控件的原始目的。看看.net，java的Button，他们首先Button的背景都比较好看；其实他们支持在Button上放图标（icon），并且放了图标后还能写文本上去；最后他们Disable的状态也比较好看。所以我们基本就可以确定ButtonEx的功能了。（其实以下这些功能是经过我好几个版本的更新才得到的，其中参考了MiniGUI原来Button的实现和网上不少其他扩展控件的实现）：</p>
<ol>
<li>Button的基本功能。能发送按钮按下通知码；在WS_TABSTOP风格下能在Dialog中使用TAB键遍历焦点；在焦点状态能使用Space和Enter键执行按下操作。这些都是MiniGUI PushButton? 的基本功能。</li>
<li>Button原有的界面表现。正常状态，按下状态，焦点状态和无效状态。新增鼠标移动到控件客户区时自动进入焦点状态。</li>
<li>支持图标文本混合显示方式。</li>
</ol>
<h2 id="二、概要设计">二、概要设计</h2>
<p>好，功能确定了，下面进行设计。首先我把这个控件取名为CTRL_BUTTONEX（”button_ex”）。然后先设计ButtonEx的最基本功能Button它有4种状态：正常（Normal），控件在没有焦点，使能情况下的状态；焦点（Focus），控件出处输入焦点的状态；点击、按下（Click），控件在焦点状态下被按下或者鼠标点击的状态；无效（Disable），控件被EnableWindow设置成无效时的状态。这4种状态的转化我在MiniGUI原来基础上新增鼠标移入客户区进入Focus状态。其他就是MiniGUI原来Button的状态转化了：Noraml就多说了。控件在tab（left、up、right、down）便利到的情况下下进入Focus状态；在Focus下，按下鼠标左键、space、enter键进入到Click状态；在Click下，鼠标左键在客户区弹起、space、enter键弹起，进入到Focus状态（并判定发送Click事件，向父窗口发送Click通知码）；如果鼠标左键在客户区之外弹起则进入Normal状态（并判定无Click事件发生，不向父窗口发送通知码）；Disable windows事件发生进入到Disable状态；Enable window事件发送进入到Normal状态。状态图转化详见下图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/1.jpeg" alt="&quot;图 1 状态转化图&quot;"></p>
<p>然后控件能在WS_TABSTOP风格下在Dialog中能被tab、left、up、right、down便利焦点。在焦点状态下按下space、enter键发送按下事件。这些靠处理MSG_KEYDOWN来实现。<br>最后我们来设计ButtonEx的外观表现形式。这里我经过了几个版本的升级，参考了MiniGUI原来Button的表现手法和网上一些扩展控件的表现方法，决定设计出几种不同的风格来供使用者选择。</p>
<h3 id="1：BEXS_IMAGE">1：BEXS_IMAGE</h3>
<p>我把这个叫做图片风格。分别用4张不同的图片来表现4种状态。图片支持bmp（支持透明色）、png（支持alpha通道）、gif、jpeg（支持透明色）。外观全部交由图片负责，因此这个风格不支持显示文本。好不好看全靠外部图片PS处理。这里说明下，现在一般使用MiniGUI的色深是16bit，但是载入24bit的bmp只要PS里颜色渐变不是特别BT，不会有太大的失真。32bit带alpha通道的png在2.0.4的API下也能保留alpha通道信息。因此这种可以做出外观上不规则的Button（它响应鼠标还是以矩形来算的）。bmp、jpg在设置了透明色后也能有这种效果，不过图层边缘的渐变造成透明时的锯齿问题（这里的透明平滑算法我至今还没弄出来，现在只能在图像处理软件里弄）。最终效果如下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/2.jpeg" alt="&quot;图 2 BEXS_IMAGE效果&quot;"></p>
<h3 id="2：BEXS_BKIMAGE">2：BEXS_BKIMAGE</h3>
<p>我把这个风格叫做背景图片风格。它用4张不同的图片来变现4种状态的背景。然后能在其基础上放置图标（icon），写文本，图标和文本能在Click中显示动态效果，图标能在Disable状态下表现alpha混合特效。它的背景图片模式与BEXS_IMAGE一致，支持bmp、png、gif、jpeg，也能透过alpha通道或是透明色变现出不规则形状。Icon支持的图片格式和背景图片一样。可以显示文本，在有icon的情况下显示文本。Icon和文本的动态点击效果其实只要在Focus和Click下稍微改动下Icon和文本位置形成一定的位置偏差就即可看到动态效果。至于Disable下Icon的alpha混合特效，是应用了2.0.4的newgal接口提供的高级图像处理API来完成的。方法是在Disable下把Icon以一定的alpha值，半透明的绘制在背景上，这样看上去就像背景透过了一部分Icon一样，从而达到表现Dsiable状态的效果。文本让用户设置2种不同的颜色，分别在Disable和非Disable下显示。这些其实就是.net，java里Button控件的功能。不过这个风格用好了，效果不低于.net，java的Button控件哦。不过折腾这些东西实现费了我不少时间。最终效果如下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/3.jpeg" alt="&quot;图 3 BEXS_BKIMAGE效果&quot;"></p>
<h3 id="3：BEXS_DRAW">3：BEXS_DRAW</h3>
<p>我把这个风格叫做编程绘制风格。顾名思意，4种状态的背景表现方式全部通过代码编程的方式绘制。其实这个风格是我学习之用的，基本上没什么实用价值，因为它的特效BEXS_BKIMAGE中都有，但是又没BEXS_BKIMAGE花哨。而且这个风格的核心颜色渐变算法我是照抄MiniGUI 2.0.4 fashion里Button的。但是在表现形式上有些不同。Normal状态基本一样，都是用2种颜色来混合渐变效果，由中间的基色调向上、下渐变至第2种颜色；不过ButtonEx里可以设置这2种颜色。Focus状态也基本一样，在外围画一圈虚线，ButtonEx也可是设置虚线的颜色。Click状态有所不同，ButtonEx里我强制用Click动态效果来表现这个状态，因为MiniGUI里用了另外2种颜色来渐变，我试了下在加Icon的情况下效果不怎么好，于是就采用动态效果来表现了。Disable状态我另外用一种颜色来进行单一填充，然后Icon alpha混合上这种颜色，类似于winXP上按钮Disable的效果。控件边框用实线画成一个带圆角的矩形，在Disable和非Disable下有2种不同颜色选择。文本和Icon同BEXS_BKIMAGE。不过这个风格还是有点好处的，就是使用者不用PS背景图片了，对于不会PS的人来说比较方便，之用去网上下一些Icon就可以了（一般网上下的Icon可以直接使用了，但是网上一般下不到Button背景图片）。其实这个风格最终效果也还是可以的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/4.jpeg" alt="&quot;图 4 BEXS_DRAW效果&quot;"></p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>控件有3个风格，有些成员变量能够几个风格公用，有些是类变量（C++ Class中的static变量），有些则是实例变量（C++ Class中的普通变量）。我将BEXS_DRAW风格的一些变量设计成类变量，因为我觉得这种风格的背景基本上应该都是一样的，其它2个风格的设计成实例变量。实例变量数据结构我将其命名为BEXDATA：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _bexdata_st</div><div class="line">{</div><div class="line">    … …</div><div class="line">} BEXDATA;</div><div class="line"><span class="keyword">typedef</span> BEXDATA* PBEXDATA;</div></pre></td></tr></table></figure>

<p>类变量数据结构我将其命名为BEXCDATA：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typdef <span class="keyword">struct</span> _bexcdata_st</div><div class="line">{</div><div class="line">    … …</div><div class="line">} BEXCDATA;</div><div class="line">typdef BEXCDATA* PBEXCDATA;</div></pre></td></tr></table></figure>

<p>根据上面的说明，控件一共有4中状态，因为我们需要一个变量在保存当前控件的状态，设计一个枚举类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _bexuistate_en</div><div class="line">{</div><div class="line">    BEXUI_NORMAL = <span class="number">0</span>,   <span class="comment">// 正常状态</span></div><div class="line">    BEXUI_FOCUS,        <span class="comment">// 焦点状态</span></div><div class="line">    BEXUI_CLICK,        <span class="comment">// 按下状态</span></div><div class="line">    BEXUI_DISABLE       <span class="comment">// 禁用状态</span></div><div class="line">        </div><div class="line">} BEXUISTATE;</div></pre></td></tr></table></figure>

<ul>
<li>成员数据结构：</li>
</ul>
<p>BEXS_IMAGE 和 BEXS_BKIMAGE 都需要4张图片，并且都支持图片透明色。所以设计如下变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PBITMAP pbmpButton[<span class="number">4</span>];  <span class="comment">// 图片指针数组</span></div><div class="line">BOOL bTrans;            <span class="comment">// 是否使用图片透明颜色</span></div><div class="line">POINT pointTrans;       <span class="comment">// 透明像素点位置</span></div></pre></td></tr></table></figure>

<p>这里图片控件内部只引用外部应用程序的图片，图片的加载和卸载都交由外部应用程序负责（我认为这样比较好，因为外部程序的初始化和销毁正好可以做这些事情）。bTrans表示当前控件是否要使用透明颜色，pointTrans是一个点（x，y）的变量，保存当前透明颜色在控件使用的图片中的坐标。BEXS_BKIMAGE和BEXS_DRAW能够在控件中显示文本，因为MiniGUI的基本窗口结构中就保存了窗口的标题文本，所以这里只要设计保存文本颜色的变量就够了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gal_pixel pixelTextNormal;      <span class="comment">// 正常文本颜色</span></div><div class="line">gal_pixel pixelTextDisable;     <span class="comment">// 控件无效文本颜色</span></div></pre></td></tr></table></figure>

<p>所有的风格都支持点击（BEXUI_CLICK）动态效果，设计如下2个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BOOL bClickEffect;  <span class="comment">// 是否使用Click 状态特效</span></div><div class="line"><span class="keyword">int</span>  nClickEffect;  <span class="comment">// Click 状态特效幅度</span></div></pre></td></tr></table></figure>

<p>BEXS_BKIMAGE和BEXS_DRAW能够放置图标在控件上；图标支持透明色；设置摆放位置；无效状态特效；设计如下变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PBITMAP pbmpIcon;       <span class="comment">// 图标图片指针</span></div><div class="line">BOOL bIconTrans;        <span class="comment">// 是否使用图标图片透明颜色</span></div><div class="line">POINT pointIconTrans;   <span class="comment">// 透明像素点位置</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> nIconLeft;          <span class="comment">// 图标距控件客户区左端距离</span></div><div class="line"><span class="keyword">int</span> nIconDx;            <span class="comment">// 图标距文本距离</span></div><div class="line"></div><div class="line">BOOL bIconDisableEffect;            <span class="comment">// 是否使用disable 状态特效</span></div><div class="line">HDC hIconDC;                        <span class="comment">// ICON Alpha 混合DC</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> nIconDisableAlpha;    <span class="comment">// ICON Alpha 混合值</span></div></pre></td></tr></table></figure>

<ul>
<li>类数据结构：</li>
</ul>
<p>只有BEXS_DRAW风格需要用到类成员。BEXS_DRAW风格正常状态的背景由2种颜色渐变形成，从中间由一种颜色（我称为基色）纵向向顶部和底部渐变到另外一种（我称为渐变色），呈对称形状。设计2个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RGB rgbRenderNormalBase;    <span class="comment">// 基色颜色</span></div><div class="line">RGB rgbRenderNormalShade;   <span class="comment">// 渐变颜色</span></div></pre></td></tr></table></figure>

<p>这里用RGB变量保存，因为这里需要进行颜色渐变运算，直接用像素值保存容易产生颜色与设置有误差的情况。BEXS_DRAW风格的BEXUI_FOCUS状态在控件上加上一圈虚线表示；BEXUI_DISABLE状态背景换成另外一种颜色表示；控件具有边框。设计如下变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gal_pixel pixelFocus;       <span class="comment">// BEXS_FOCUS状态虚线颜色</span></div><div class="line">gal_pixel pixelDisableBk;   <span class="comment">// BEXUI_DISABLE状态背景颜色</span></div><div class="line">gal_pixel pixelBorder;      <span class="comment">// 边框颜色</span></div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>首先就是控件注册和卸载的接口，这个在之前的教程里已经详细说过了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterButtonExControl (<span class="keyword">void</span>);</div><div class="line">BOOL UnregisterButtonExControl (<span class="keyword">void</span>);</div></pre></td></tr></table></figure>

<h4 id="实例接口：">实例接口：</h4>
<p>实例接口就是消息，这个也在前面的教程说过了的。首先先确定本控件自定义消息的范围。因为MiniGUI留给用户的自定义消息范围是：0x0800 ~ 0xEFFF。一般的应用程序都会有自己的消息，所以作为提供给外部程序使用的控件应尽量避免自定义消息定义冲突，所以这里我设计从自定消息的最大范围从后向前定义（应用程序一般都是从前向后定义的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_BEXMBASE    0xEFFF</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_BEXMXX      MSG_BEXMBASE – 1</span></div><div class="line">… …</div></pre></td></tr></table></figure>

<ul>
<li>1: 设置控件通用数据。<br>我把状态图片（pbmpButton[4]、bTrans、pointTrans）、文本颜色（pixelTextNormal、pixelTextDisable）、点击特效（bClickEffect、nClickEffect）这些变量归结到一个接口来设置，叫通用数据设置。wParam传入设置PBEXDATA，lParam传入需要设置的变量（这个32bit的变量每一个位可以代表一个设置变量的开关）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_IMAGE           0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_TEXTCOLOR       0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_CLICKEFFECT     0x00000004L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_ALL             ((BEX_COM_IMAGE)| (BEX_COM_TEXTCOLOR) | (BEX_COM_CLICKEFFECT))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_SETCOMDATA         MSG_BEXMBASE – 1</span></div></pre></td></tr></table></figure>

<ul>
<li>2: 获取控件通用数据。<br>和设置相对应：wParam传入获取PBEXDATA，lParam传入需要获取的变量：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_GETCOMDATA     MSG_BEXMBASE - 2</span></div></pre></td></tr></table></figure>

<ul>
<li>3: 设置控件图标数据。<br>我把图标图片（pbmpIcon），图标位置，图标无效状态特效这些变量归结到一个接口来设置，叫做图标数据设置。wParam和lParam与通用数据的相似：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_IMAGE          0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_POSTION        0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_DISABLEEFFECT  0x00000004L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_ALL            ((BEX_ICON_IMAGE) | (BEX_ICON_POSTION) | (BEX_ICON_DISABLEEFFECT))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_SETICON            MSG_BEXMBASE – 3</span></div></pre></td></tr></table></figure>

<ul>
<li>4: 获取控件图标数据。<br>和设置对应：wParam传入获取PBEXDATA，lParam传入需要获取的数据：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_GETICON  MSG_BEXMBASE – 4</span></div></pre></td></tr></table></figure>

<h4 id="类接口：">类接口：</h4>
<p>类接口就是函数了。我这里设计的和上面实例的相似。 </p>
<ul>
<li>1: 设置类数据。<br>PBEXCDATA传入的是设置的变量指针，DWORD传入32bit的设置变量类型：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_CDATA_RENDER    0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_CDATA_DEFAULT   0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_CDATA_ALL       ((BEX_CDATA_RENDER))</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> BexSetCData (<span class="keyword">const</span> PBEXCDATA pSetCData, DWORD dwMask);</div></pre></td></tr></table></figure>

<p>这里我把目前所有的类变量都统一到一个开关里设置了（测我的测试使用来看，这是比较方便的）；BEX_CDATA_DEFAULT是把所有的类变量设置成默认值。</p>
<ul>
<li>2: 获取类数据。<br>这个和设置对应，PBEXCDATA传入获取的变量指针，DWORD传入32bit的获取变量类型：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> BexGetCData (<span class="keyword">const</span> PBEXCDATA pSetCData, DWORD dwMask);</div></pre></td></tr></table></figure>

<h4 id="通知码：">通知码：</h4>
<p>据我的理解，一般的消息是针对控件自己的，通知码是针对别的控件的（一般是父控件）。</p>
<ul>
<li>1: 点击通知码。<br>在控件处于BEXUI_CLICK状态下在客户区弹起鼠标左键或是在控件BEXUI_CLICK状态弹起enter、space按键发送，表示控件被按下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXN_CLICKED    0</span></div></pre></td></tr></table></figure>

<p>目前就暂时设置这一个通知码，感觉作为Button来说就这个通知码用得最多，就先设计这一个了。</p>
<p>这里以一个Button功能的扩展控件说明如何完全自己写MiniGUI的控件。本次教程先介绍ButtonEx的设计，下次将介绍ButtonEx的具体实现。从1月14号起的头，拖到30号才写完，怎能用茶几、杯具来形容 -_-|| 。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="&quot;http://download.csdn.net/detail/mingming_killer/4045894&quot;">下载地址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/20/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B4/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程4</title>
        <pubTime>2015-01-20T09:35:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。上次介绍了ButtonEx控件的设计，这次介绍ButtonEx的具体实现。这里我不打算说C语言的语法和简单的MiniGUI API调用，我就只说一些需要注意的问题。因为我认为这些才是大家真正需要了解的。</p>
<h2 id="注册类">注册类</h2>
<p>不管你是自己完全重新开始写控件类，还是继承现有的控件类。自己的控件类被外部程序使用前就必需要注册（通常是应用程序初始化的时候）。我目前还没深入看MiniGUI内部创建控件的过程。但是只有注册了的控件类，才能被CreateWindow()创建（自己外部写的控件只能通过CreateWindow来创建，能使用对话框模板的控件数据来创建）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterButtonExControl (<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    WNDCLASS BEXClass;</div><div class="line">        </div><div class="line">    … …</div><div class="line">        </div><div class="line">    <span class="comment">// 填写控件类信息</span></div><div class="line">    BEXClass.spClassName    = CTRL_BUTTONEX;</div><div class="line">    BEXClass.dwStyle        = WS_NONE;</div><div class="line">    BEXClass.dwExStyle      = WS_EX_NONE;</div><div class="line">    BEXClass.iBkColor       = PIXEL_lightwhite;</div><div class="line">    BEXClass.hCursor        = GetSystemCursor (IDC_HAND_POINT);</div><div class="line">    BEXClass.WinProc        = ButtonExProc;</div><div class="line">    BEXClass.dwAddData      = (DWORD)pCData;</div><div class="line">        </div><div class="line">    … …</div><div class="line">        </div><div class="line">    <span class="comment">// 注册ButtonEx 类</span></div><div class="line">    <span class="keyword">return</span> RegisterWindowClass (&BEXClass);</div><div class="line">        </div><div class="line">}</div></pre></td></tr></table></figure>

<p>还记得在教程2里提到的获取控件类信息的函数GetWindowClassInfo()吗。那里获取的信息正是你这里注册的信息。注意这里要把WNDCLASS的所有变量都填满，不然当应用程序程序使用你的控件时程序会出错的。填满好信息后，调用RegisterWindowClass()注册控件类。在控件使用前要进行注册，当控件使用完后（通常是应用程序退出前），就要注销之前注册的控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL UnregisterButtonExControl (<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    … …</div><div class="line">        </div><div class="line">    <span class="comment">// 卸载ButtonEx 类</span></div><div class="line">    <span class="keyword">return</span> UnregisterWindowClass (CTRL_BUTTONEX);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>调用UnregisterWindowClass()来注销控件类，传入的参数是之类注册的控件类名字（字符串）。</p>
<h2 id="类变量">类变量</h2>
<p>在教程2中介绍了实例变量的保存方法（复习下：使用每个窗口的dwAdditionalData2保存控件数据变量指针 ^_^），这里说下类变量如何保存。其实这个MS根本就不用说，因为实例变量是每个控件实例都有一份的，所有要特殊处理下。这个所有的控件都共用一份的，直接弄个全局变量就行了。建议使用static变量，这样能让类变量只具有文件范围，防止外部随便访问（谁让C语言没有类呢）。</p>
<h2 id="继承父类">继承父类</h2>
<p>虽然我把这个叫做完全自己写控件类，但是实际上它还是继承了一个父类的，就是所有的控件的父类（相当于CObject）。这个其实就是一个函数的调用，在之前也说过了的。这个函数就是：</p>
<pre>
DefaultControlProc (HWND, int, WPARAM, LPARAM);
</pre>

<p>在控件的过程处理函数结尾，调用父类的这个处理函数，让其处理一些本控件不处理的系统消息。</p>
<h2 id="功能实现">功能实现</h2>
<p>其实光是完全自己重新写控件需要注意的问题，上面就已经说完了。但是既然我的这个例子是Button功能的控件，就说下和这个控件相关功能实现注意的一些问题吧。先说功能相关的实现，界面图形表现的实现放在下面说。</p>
<h3 id="1：在对话框中正确得到键盘输入">1：在对话框中正确得到键盘输入</h3>
<p>这里涉及到一个关键的消息的返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> MSG_GETDLGCODE:</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> DLGC_PUSHBUTTON;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个消息API手册解释的非常简单，仅仅只是把这个消息的名字复制了一下。但是如果这个消息处理不正确，你的控件就无法在对话框（Dialog）中正确的得到键盘输入。不过这里的ButtonEx控件和这个没多大的关系，但是还是说明一下吧。这个消息的含义是获取对话框码。因为你如果创建的窗口是对话框的话，它会比一般的窗口多处理一些消息，这些消息包括某些按键的响应。因为对话框有些功能：tab、left、right、up、down遍历WS_TAPSTOP风格控件；esc发送IDCANCEL；BS_DEFPUSHBUTTON响应enter按键。就是说如果你不不响应这个消息（默认返回值为0），你的控件在对话框下就无法得到收到tab、left、right、up、down、enter、esc这些按键的消息。但是某些控件是需要这些值的，例如listview、listbox、eidt等。这时就要给予MSG_GETDLGCODE消息正确的返回值，告诉对话框你的控件要处理这些按键消息。这样对话框处理函数才会“放过”这些按键的消息，发送到你的控件处理。这些值包括如下（可以用或来同时获得）：</p>
<pre>
DLGC_WANTARROWS     要处理上下左右按键
DLGC_WANTTAB        要处理tab键
DLGC_WANTALLKEYS    要处理所有的按键
DLGC_WANTENTER      要处理enter键
</pre>

<h3 id="2：使用控件风格">2：使用控件风格</h3>
<p>你可以给你的控件设计多种风格，然后通过创建控件时，指定不同的风格获得不同的功能。我不太清楚从MiniGUI多少版本起，开始有2个变量来保存风格了：一个普通的风格，一个扩展风格。控件风格用的是普通的风格变量，这是一个32bit DWORD类型，每一位代表一个风格，然后通过位运算得到当前风格的设置情况。高16bit被MiniGUI用来保存通用窗口的风格了（WS_TABSTOP、WS_VISABLE等），留给控件用的是低16bit，这点要清楚，不然如果你自己控件的风格定义成高16bit的话，就会出现逻辑错误了。然后通过GetWindowStyle()来获取当前普通风格。ButtonEx的风格定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_TYPEMASK   0x0000FFFFL</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_IMAGE      0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_BKIMAGE    0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_DRAW       0x00000004L</span></div></pre></td></tr></table></figure>

<h3 id="3：发送通知码">3：发送通知码</h3>
<p>给父窗口发送通知码的API是这个：</p>
<p>NotifyParent (HWND parent, int id, int code);</p>
<p>第一个、和最后一个参数没什么好说的，第二个参数是当前控件的ID号，这个通过GetDlgCtrlID ()函数获取。这里是虽然是简单的API调用，可以编程指南里没写，网上又搜不到，我是看源代码才知道，要这么用的 -_-|| 。</p>
<h3 id="4：判断鼠标点击">4：判断鼠标点击</h3>
<p>MiniGUI原来的Button是只要在控件客户区弹起鼠标左键才会发送点击通知码的。不仅仅MiniGUI的Button这样，MFC、.net、java等GUI的Button都是这样（不知道谁先这么规定的）。要实现这个功能，要在鼠标左键按下时捕获鼠标，然后弹起鼠标后再释放，这样才能判断弹起的鼠标左键的坐标。这里提示下，本来MSG_LBUTTONUP得到的鼠标坐标是client坐标的，但是一捕获鼠标后就变成srceen坐标了，注意坐标转换。</p>
<h2 id="界面表现实现">界面表现实现</h2>
<p>这里主要说的MiniGUI中一些图像API的使用，以及需要注意的一些问题。这里先说下颜色的一些基本知识吧（知道了的可以忽略）。图片由像素组成，例如一张90x40的bmp（位图），就由90x40个像素组成。每个像素又由如干位（bit）组成，例如8bit、16bit、24bit，这个就是我们说的色深。计算机里的颜色一般用用得最普遍的RGB（红、绿、蓝）三色组成。现在用一个数值分别表示这三种颜色的亮度，例如范围为255，值越小就越黑，值越大就越亮，这样由3个0~255的数值混合可以组合成很多种颜色（这个叫做像素值，pixel）。这里就可以看到刚刚说范围是0~255，这样一种颜色就需要8bit（2^8），3种颜色就是24bit（3x8），这就是我们平常说的24色深。这样的颜色组合能够达到2^24=16777216种，已经达到人眼的分辨率极限。但是一般在嵌入式中，一般显示屏幕达不到这么高的颜色显示，现在一般带GUI的嵌入式产品的主流色深是16bit，就说分给RGB每个分量的位数不足8bit，这样有些颜色就会显示不出来。所以这里要特别注意，在ButtonEx控件中使用的图片，如果是24bit的话是会有可能失真的。不过不用太担心，因为16bit的能够显示大多数常用的颜色的，所以只要使用的图片颜色渐变效果不是特别夸张都不会有太大的失真（一般界面那些花哨的效果都是由颜色渐变弄出来的）。</p>
<p>不过大家在用的桌面操作系统的色深是32bit，那除了刚刚说的24bit用于RGB之外，还有8bit是用来干什么了咧？32bit的色深还有8bit用来表示alpha通道，这个通道用来表示颜色的透明度（我至今不明白为什么叫alpha -_-||）。在8bit的情况下，数值越小透明度越高，0表示完全透明，255表示完全不透明。大家在网上看到的png格式的图片就是带alpha通道的。</p>
<p>这里再说说图片格式。bmp最高是24bit色深，bmp不带alpha通道信息，因此bmp本身不带透明信息。并且bmp是没有压缩过的图片格式，所以一般bmp格式的图片都比较大（这个很好理解：例如一张1024x768x24bit的bmp大小就是：1024x768x24/8x2^20=2.25MB）。MiniGUI无需外部库就支持bmp格式图片（因为直接读取它的数据就是图片信息，要不然怎么叫位图咧）。jpg最高也是24bit的，同样也不带alpha通道信息，但是这种图片格式是经过压缩算法的，所以同样大小的图片，jpg格式的能比bmp格式的小得多。MiniGUI需要外部jpeg库才能支持这样格式的图片。png图片，最高色深32bit，这个是带alpha通道信息的，而且也是经过压缩算法的，体检很小，所以网上那些透明的很好看的图片一般都是png的（又可以透明，体积又小）。MiniGUI同样需要外部png库才能支持这种格式。gif么，我不太清楚，它一般是用于动画的，不过也可以用来表示静态图片（一帧动画不就是静态的么-_-||）。gif也可以带alpha通道，MiniGUI无需外部库就可以支持这种格式。我这里只是说说一般嵌入式产品用到的图片格式，还有其它的一些专业的格式，我就不说了，而且我本人也不是太了解。</p>
<p>上面罗嗦这么多，其实主要是ButtonEx要使用到以上说到的那些格式的图片，如果你连图片的特性都不清楚的话，是不可能很好的应用它们的。好，现在就说说如何应用这些图片来使我们的ButtonEx变得好看起来。</p>
<h3 id="1：背景图片">1：背景图片</h3>
<p>这里说的背景图片不光光单指BEXS_BKIMAGE的背景，也包括BEXS_IMAGE，BEXS_IMAGE其实所有的都通过图片来表现了（这里没BEXS_DRAW什么事了）。背景推荐用bmp。因为一般按钮不会太大，所以图片不会太大，jpg也省不了多少空间。但是jpg的压缩是失真的，能不用就尽量不用啦。bmp虽然不带alpha通道信息，但是一般作为button的背景不太需要这个，而且就算需要，也有办法代替。如果用png的话，就我的测试发现，稍微大点的32bit的png用在16bit上就能看出失真了（这个不能算明显，但肉眼也能看得出，大家看我教程3中有一张中的第1个按钮和第3个按钮就知道了），所以还是用bmp的效果好。这里如果要做到一些类似圆角的按钮效果的话，其实用不带alpha通道的bmp也能做到，而且在16bit色深下bmp效果还好些。</p>
<p>如果窗口没有背景图片。这种情况最好办，窗口如果不带背景图片，那它就是单一的一种RGB颜色。可以通过种种方法得到窗口的背景颜色。然后把图片的背景弄成这种颜色，哈哈，这样用户一看就感觉按钮时圆角的啦。但是建议这样不规则形状的图片，不要弄得太夸张，因为就2.0.4版本的MiniGUI还是不支持不规则窗口的，所以响应鼠标还是以矩形来算的，弄得太夸张的话，很容易就露馅了。经我测试这种方法既不需要开启透明颜色，效果也是最好的。如果窗口窗口有背景图片，就稍微麻烦一点了。因为如果有背景图片的话，用上面那种方法就不行了，因为背景图片可不是单一的一种颜色了。这个时候如果用bmp的话，就需要开启透明颜色。这里就说之前设计说那个开启背景透明颜色的功能了。这里主要用到MiniGUI BITMAP结构里的bmType、bmColorkey这2个变量。这个看API手册和飞漫的mde里那个高级的绘图例子就清楚了，你看我的源代码也可以清楚 ^_^ 。不过这里提醒一下，用这个方法，MiniGUI在用图片绘图图像的时候是只能透明掉你指定的那一种颜色的；但是目前一些的图像处理软件，如PS，是会很“好心”的帮你的图片的图层和背景过渡的部分加上适当的过渡颜色的。所以出来的效果就是有锯齿，因为那些过渡的颜色没有被透明掉。目前的处理办法是：1：采用“抗锯齿”的算法。其实只要把那些过渡的颜色在内存中换成透明的颜色就行了，它们之间的RGB值差别不是很大的。不过我现在还没怎么研究MiniGUI中RGB值到pixel值之间的转化，所以这个函数也是没弄。2：处理图片。就是手动把那些过渡值换成背景颜色（这个把图片放大就看出来了）。</p>
<h3 id="2：图标图片">2：图标图片</h3>
<p>主要是BEXS_BKIMAGE和BEXS_DRAW风格用到这个了。这个推荐用png图片。原因其实上面已经说了，因为按钮的背景是图片（BEXS_DRAW的虽然不是图片，但是也不是单一的颜色），不是单一的颜色，用bmp透明效果不怎么好。一般图标比较小（一般是16x16、32x32），所以即使是32bit的png用到16bit上也不怎么失真。带alpha透明通道后效果很好。这里说一下，MiniGUI载入图片，不管原来图片存储的是什么格式的，载入后在内存中都是BITMAP变量（MiniGUI通过图片的后缀自行判断）。正常状态的图标没什么好说的，直接载入，然后用绘图函数画就是了。</p>
<p>现在说说 <code>BEXUI_DISABLE</code> 状态的特效。这个特效是使图标呈现一定的透明效果。注意这里说的透明不是说png图片自己带alpha信息。这里再说说，png原来带的alpha通道叫做逐点alpha信息。是每个像素都有的（32bit中的8bit），能够精确到每个像素点。我这里说的是不管它原来逐点的alpha信息是什么，整个图片以一个统一的alpha值进行透明（这个又叫做alpha混合）。不过这里提醒下，BITMAP结构里有一个bmAlphaPixelFormat的变量，叫做私有像素格式。所谓的私有像素格式就是和MiniGUI使用的图像格式不一样的格式。例如我使用的miniugi是1280x1024-16bpp，就是16bit的色深，但是我载入的png是32bit的，它们的颜色格式肯定不一样。所以这个私有像素格式就保存了图片自己的图像格式。经过我实验，凡是有私有像素格式的BITMAP变量，均无法使用bmAlpha、bmColorKey变量。就是说如果我们载入的是32bit带alpha的png就无法使用BITMAP的alpha变量来实现alpha混合效果。但是咋有“曲线救国”办法：MiniGUI的内存DC结构也有alpha变量可以设置。我们可以把png先绘制到一个内存DC里，然后设置内存DC的alpha变量，就可以显示BEXUI_DISALBE状态的alpha混合效果了。这里的内存DC可以看成是一张画布，我们把png图片完整的信息绘制到画布上，然后把这个画布弄成“半透明”，最后再把这张画布贴到控件的客户区上。效果见教程3中的Disable图片，很cool吧。这也就是之前设计图标变量时，为什么还会有一个HDC变量。不过开启这个效果是要额外占用资源的，因为每个控件都额外需要创建一个HDC，所以资源比较紧张的情况下还是关掉吧（关掉的话ButtonEx不会创建这个alpha混合用的HDC的）。</p>
<p>至于 BEXS_DRAW 风格的那个颜色渐变算法是照搬飞漫2.0.4中fashion风格下Button的绘制算法的。我只是稍微改了一点点而已，我自己也没啥好说的，因为基本算是照抄。不过用这个风格可以省去自己P图了，直接去网上找一些png图标就可以了。</p>
<p>上面说了这么多，感觉好像也挺混乱的。哎~~因为本来我对这些东西就接触不多，都是临时自己琢磨的。说得不对的请大家指正。可能光看我写的文字还是没啥子感觉，不过这个算是个思路吧。具体还是看代码吧，我的代码里为什么用这个API，为什么这样做，都有详细注释的，相信大家都能看的懂。</p>
<p>这里顺带介绍下附带的代码。这个是用source insight建立的工程，共有4个自定义控件：ButtonEx、SLEditEx、RollShow、ProgressbarEx。分别是按钮自定义控件（这次介绍的就是它了），单行编辑框自定义控件，滚动显示控件，进度条控件。这是我到目前为止用MiniGUI写的自定义控件，里面都有详细的功能、说明、注释，大家可以参考、参考。后面几次的教程也是以这个工程为例子的。</p>
<p>这次介绍了如何自己完全从头开始写MiniGUI的控件，并且也“趁机”介绍了下MiniGUI中一些图片，绘图处理的方法。下次我将介绍如果通过继承MiniGUI原有的控件，来扩展原有控件的功能。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="&quot;http://download.csdn.net/detail/mingming_killer/4045894&quot;">下载地址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B5/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程5</title>
        <pubTime>2015-01-21T06:40:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。上次以ButtonEx控件的开发为例介绍了如果自己完全重新开始写控件，这次我以一个扩展单行编辑框控件为例介绍如何在原有控件的基础上扩展自定义功能（继承原有控件功能）。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<p>MiniGUI原来的单行编辑框控件 <code>CTRL_SLEdit</code> 除了具有编辑框的基本编辑功能外，就提供了一个限制输入字符长度的功能。没有类似MFC中CEdit限制输入类型，字符还是数字，数字还可以限制范围（不过CEdit是在输入完之后才能判断的）。不过这些功能对于应用程序还是比较有用的。于是我决定在CTRL_SLEDIT的基础上扩展这些功能：</p>
<ol>
<li>2种编辑模式：文本；数字。文本模式可以输入任意字符，数字模式只能输入0~9、+、-和小数点。</li>
<li>文本模式提供过滤输入字符的功能，能够指定屏蔽掉特定的字符；提供反向过滤功能，就是能够指定只允许输入特定的字符。</li>
<li>数字模式提供指定是否限定输入整数；并在此基础上提供指定输入范围功能。</li>
</ol>
<h2 id="二、概要设计">二、概要设计</h2>
<p>这里因为继承了 <code>CTRL_SLEDIT</code>，所有只需专注控件的扩展功能就行了。要实现以上功能，最关键的就是在 <code>CTRL_SLEDIT</code> 接受到键盘输入之后，把输入显示到屏幕上之前，进行自己的过滤算法判定；当输入的是不符合用户设定的字符则截断，不发送给父类 CTRL_SLEDIT 处理（这样它就显示不出来了）；当输入是符合用户设定的字符就发送给父类处理（这样它就能正常显示出来）。流程图如下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control5/1.jpeg" alt="图 1 CTRL_SLEDIT流程图"></p>
<ul>
<li>1：EEXMODE_TEXT</li>
</ul>
<p>文本模式能让用户指定不允许输入某些字符（过滤），还是只允许输入某些字符（反过滤）。不过注意，这里针对的是字符，而不是字符串。字符串又要麻烦很多了。这个模式我只是顺带做了一下，下面的数字模式才是比较实用的。（汉字是占2个字符(字节)，所以这里MS也不能过滤了 -_-||）</p>
<ul>
<li>2：EEXMODE_DIGITAL</li>
</ul>
<p>首先数字编辑模式就只能输入’0~9’、’+’、’-‘、’.’这些字符。在此基础上能让用户选择能否输入小数，开启的话就能输入小数；关闭的话就能输入整数。还能让用户指定数值的输入范围（闭区间）。</p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>SLEditEx 的控件变量都是实例变量。控件变量数据结构我命名为EEXDATA：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typdef <span class="keyword">struct</span> _eexdata_st</div><div class="line">{</div><div class="line">    ... ...</div><div class="line">} EEXDATA;</div><div class="line">typdef EEXDATA* PEEXDATA;</div></pre></td></tr></table></figure>

<p>首先需要一个变量能保存当前的编辑模式。这里我没有使用控件本身的风格变量，因为父类CTRL_SLEDIT把那低16bit用得差不多了，我懒得去搅和了，自己拿一个变量来保存得了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编辑模式定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _eexmode_en</div><div class="line">{</div><div class="line">    EEXMODE_TEXT,         <span class="comment">// 文本编辑模式</span></div><div class="line">    EEXMODE_DIGITAL,      <span class="comment">// 数字编辑模式</span></div><div class="line">        </div><div class="line">} EEXMODE;</div><div class="line"></div><div class="line">EEXMODE nMode;            <span class="comment">// 编辑模式</span></div></pre></td></tr></table></figure>

<p>由于继承原有控件，所以控件数据占用了留给应用程序的dwAdditionalData1（附加数据1，忘记了怎么回事的赶快回头看教程2 ^_^），所以还要多加一个DWORD：</p>
<pre>
DWORD dwUserAddData; // 用户控件附加数据
</pre>

<p>文本模式需要一个标志来表示当前是过滤还是反过滤；我把过滤（反过滤）的字符存入一个静态字符数组中（不用动态链表了，那个麻烦，我把这个数组大小设置成512，应该够了）：</p>
<pre>
char strFilterChar[EEX_MAXCHAR];    // 过滤字符串 
BOOL bFilter;                       // 过滤模式标志
</pre>

<p>数字编辑模式也需要一个标志来表示当前是否允许输入小数；还需要2个浮点型来保存允许输入的最大值和最小值（浮点型可以表示整型的整数部分，但是整型就无法表示浮点型的小数部分了，所以要用浮点型）。如果设置的最小值大于最大值的话，我就把这种情况设计成不限制输入范围。这里我还多设计了一个范围的数据结构，其实为了下面的消息接口，因为一个消息只能传递2个参数，我把范围和允许输入小数的开关的设置放到一个接口里去了。但是这需要传递3个参数，所以我就弄了一个范围的数据结构出来，把2个参数整合成1个来传递。（其实完全可以用之前ButtonEx控件的那个钟传递参数的方法：1个参数传递控件变量指针，1个参数传递要设置的变量类型；不过这2个中传递方法我也说不上哪种好，哪种不好，我这里都用了，大家看自己喜欢了。其实MiniGUI原来的控件里也是这2种都用了的，例如：CTRL_LISTVIEW）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 限定输入数字范围数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _eexrange_st</div><div class="line">{</div><div class="line">    <span class="keyword">double</span> dMin;      <span class="comment">// 最小值</span></div><div class="line">    <span class="keyword">double</span> dMax;      <span class="comment">// 最大值</span></div><div class="line">        </div><div class="line">} EEXRANGE;</div><div class="line"><span class="keyword">typedef</span> EEXRANGE* PEEXRANGE;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">double</span> dMin;       <span class="comment">// 允许输入最小值</span></div><div class="line"><span class="keyword">double</span> dMax;       <span class="comment">// 允许输入最大值</span></div><div class="line">BOOL  bInteger;    <span class="comment">// 输入是否是整数标志</span></div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>注册和卸载的接口，之前的教程说过了的：</p>
<pre>
BOOL RegisterSLEditExControl (void);
BOOL UnregisterSLEditExControl (void);
</pre>

<p>消息为什么定义成下面这个样子，之前的教程也数过了的。这里为什么减去25咧。因为我的这些控件都是在一个工程里的，当然要防止消息定义冲突啦，我给之前的ButtonEx预留了25个消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_EEXMBASE    (0xEFFF-25)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_EEXMXX      MSG_EEXMBASE – 1</span></div></pre></td></tr></table></figure>

<ul>
<li>1：设置控件附加数据。这个之前教程说过了的（我MS重复这句话很多次了-_-||）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DWORD* pdwAddData;</div><div class="line">wParam = (WPARAM)pdwAddData;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETADDDATA     MSG_EEXMBASE - 1</span></div></pre></td></tr></table></figure>

<ul>
<li>2：获取控件附加数据和设置相对应：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DWORD* pdwAddData; </div><div class="line">wParam = (WPARAM)pdwAddData;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETADDDATA     MSG_EEXMBASE - 2</span></div></pre></td></tr></table></figure>

<ul>
<li>3：设置当前编辑模式。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nMode;</div><div class="line">wParam = (WPARAM)nMode;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETEDITMODE    MSG_EEXMBASE - 3</span></div></pre></td></tr></table></figure>

<ul>
<li>4：获取当前编辑模式。和设置对应，直接用返回值获取</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wParam = <span class="number">0</span>;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETEDITMODE    MSG_EEXMBASE - 4</span></div></pre></td></tr></table></figure>

<ul>
<li>5：设置数字模式下的编辑属性。包括是否允许输入小数，输入范围：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PEEXRANGE pRange; </div><div class="line">BOOL bInteger;</div><div class="line">wParam = (WPARAM)pRange;</div><div class="line">lParam = (LPARAM)bInteger;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETDIGITALRANGE    MSG_EEXMBASE - 5</span></div></pre></td></tr></table></figure>

<ul>
<li>6：获取数字模式下输入范围，和设置相对应，允许输入小数标志用返回值获取：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PEEXRANGE pRange;</div><div class="line">wParam = (WPARAM)pRange;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETDIGITALRANGE    MSG_EEXMBASE - 6</span></div></pre></td></tr></table></figure>

<ul>
<li>7：设置文本编辑模式下过滤字符：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* pstrFilter; </div><div class="line">BOOL bFilter;</div><div class="line">wParam = (WPARAM)pstrFilter;</div><div class="line">lParam = (LPARAM)bFilter;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETFILTERCHAR      MSG_EEXMBASE - 7</span></div></pre></td></tr></table></figure>

<ul>
<li>8：获取文本模式过滤字符，和设置相对应，过滤标志用返回值获取：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* pstrFilter; </div><div class="line">wParam = (WPARAM)pstrFilter;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETFILTERCHAR      MSG_EEXMBASE - 8</span></div></pre></td></tr></table></figure>

<h3 id="3：通知码">3：通知码</h3>
<ul>
<li>1：输入非法通知码。当输入不符合设置的规则时发送。这里定义成3是因为父类把0~2用掉了，这个要注意啊。</li>
</ul>
<pre>
#define EEXN_INPUTINVALID 3
</pre>

<h2 id="四、功能实现">四、功能实现</h2>
<h3 id="1：文本模式过滤">1：文本模式过滤</h3>
<p>这个功能实现起来很简单。就是拿当前输入的字符去和设置的过滤字符想比较可以了，在过滤字符里就不符合，不在就符合。这里说一下我在判断函数（<code>EEX_ValidateInput</code>）用到的一些strex开头的函数（像strexFind()、strexInsert()等）。这些strex开头的函数也是我自己写的，主要用于实现像CString里的一些常用的字符串操作功能，C语言原来的字符串操作函数很多功能没有，只好自己写了。具体的大家可以去看工程里include里的StringEx.h，这里我是打包成了另外一个库了的，里面还包括了一些常用的数据结构的C语言实现（链表、队列等）。大家其实完全可以自己实现的，我个人感觉我写的也不是特别好 -_-||，又需要的话我再放代码上来吧。</p>
<h3 id="2：数字模式过滤">2：数字模式过滤</h3>
<p>这里我判断的方法是：</p>
<ol>
<li>首先拿当前输入和”0123456789-+.”比较，也就是说首先只允许输入0~9、-、+、.（如果设置了只能输入整数的话，则不允许输入.）。</li>
<li>对于通过了1的字符来说，只要再同时满足一下2个条件就是有效的数字： “-“, “+”只能出现一次并且只能在第一个位置。 “.”只能出现一次。</li>
<li>对于通过了2的字符来说，只需要再验证当前输入的数字是否在设置的范围内就完成了判断了。</li>
</ol>
<p>我感觉我的方法应该还是对的，不知道大家还什么更好的方法没有 ^_^ 。不过这里有个小问题：就是在最后判断范围的时候，在判断下限的时候我使用整数判断。因为我是在显示到屏幕之前进行判断的，如果是小数的话会有问题。例如下限是1.5，本来用户是想输入1.7的，先输入的是1；如果是小数判断的话，1比1.5要小，不在范围内，就会被判定成不合法，从而屏蔽掉输入。所以这里我判断下限的时候采用了整数判断的方法，会造成下限范围设置成小数时，只能限制整数的问题，但总比不能输入要好，不知道大家有什么好办法解决没有。</p>
<h2 id="五、注意问题">五、注意问题</h2>
<p>其实前面那些看代码也能明白，现在说说最关键的，就是继承父类控件需要注意的一些问题（同时也包括了实现本控件需要注意的一些问题 ^_^）。</p>
<ul>
<li>1：调用父类过程处理函数</li>
</ul>
<p>就是在自己的控件过程处理函数最后，把自己不处理的消息都转发给父类控件过程处理函数处理。这样才能享有父类控件原有的功能，而且这样才能叫得上“继承啊“。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">WNDCLASS EEXClass;</div><div class="line"></div><div class="line">EEXClass.spClassName = CTRL_SLEDIT;</div><div class="line">EEXClass.opMask = <span class="number">0x00FF</span>;</div><div class="line"><span class="keyword">if</span> (GetWindowClassInfo (&EEXClass) == FALSE)</div><div class="line"> 	<span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line">old_ctrl_proc = EEXClass.WinProc;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">return</span> (*old_ctrl_proc) (hCtrl, message, wParam, lParam);</div></pre></td></tr></table></figure>

<p>至于获取时候的注意事项，忘记了的要回头去看教程2了哦。然后继承的方式也需要在使用前注册，使用完成后卸载，也是只能使用CreateWindow()来创建，方法和教材4中的一样。</p>
<ul>
<li>2：为每份控件实例保存数据</li>
</ul>
<p>这个上面也提到了的，方法和教程2的一样，要用附加数据1保存，然后自己多加一个DWORD的变量出来提供给外部应用程序使用即可。</p>
<ul>
<li>3：其它</li>
</ul>
<ol>
<li><p>判断输入消息选用 <code>MSG_CHAR</code>。为什么选用这个，而不用 <code>MSG_KEYDOWN</code> 呢。因为 <code>MSG_CHAR</code> 是经过字符翻译了的。我们的控件判断只关心有意义的字符，像delete、insert、home、pageup、pagedown、left、right、up、down之类的我们根本不用管。正好 <code>MSG_CHAR</code> 是不会翻译这些按键消息的 ^_^。</p>
</li>
<li><p>有关MSG_GETDLGCODE。还记上次教程我说过控件在dialog中要想正确获取按键所有就要处理这个消息的吗。没错像编辑框这种控件确实是要正确处理这个消息才能正确的获取所有的键盘输入。但是这里我建议大家不要画蛇添足，因为父类已经帮我们处理，直接把这条消息扔给父类的处理函数就行了。</p>
</li>
<li><p>编辑框控件有个能用鼠标选中一串字符然后用输入的字符代替掉选中字符的功能。这个功能在数字模式下要进行特别的处理，这个、这个大家还是看我代码吧，这里不好说呢 ^_^ 。</p>
</li>
</ol>
<h2 id="六、总结">六、总结</h2>
<p>好了，我觉得需要注意的就是这么多了，其它的大家看代码就OK了。其实扩展原有控件类（继承）的方法和自己重新开始写，大体上来说基本类似，就是注意下以下的问题就行了：</p>
<ol>
<li>最后调用的父类处理函数。继承的当然是调用父类的啦（注意获取父类处理函数的注意事项）；自己重新开始写是调用 DefaultControlProc()。</li>
<li>注意一些已经被父类用掉了的资源。像保存实例数据变量的附加数据，风格变量、通知码等。扩展的需要注意，重新写的就不用在意啦，放心用 ^_^。所以大家在写自己的自定义控件的时，一开始就确定好，到底是继承还是重新开始写。</li>
</ol>
<p>好，到这里MiniGUI2.0版本以前本人会的自定义控件的方法就全部介绍完了。据说3.0的自定义控件的方法比2.0的简单了很多，更接近于OOP。但是本人最近一直没什么时间用3.0，所以只好“落伍“一下了 -_-||。 我写的ControlEx中还有2个扩展控件：进度条和滚动显示。后面的教程都只是说我写的这些控件的具体实现的了，就不说MiniGUI自定义控件的方法了。</p>
<p>哎，2月3号的起的头，又拖到8号才写完。发现我越来越懒了，杯具 -_-|| 。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="&quot;http://download.csdn.net/detail/mingming_killer/4045894&quot;">下载地址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B6/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程6</title>
        <pubTime>2015-01-21T08:07:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。之前就已经介绍完MiniGUI 2.0以前本人掌握的自定义控件的方法了（3.0的好像不太一样了呢，目前本人还没研究过）。恩，让我们来回顾下先：</p>
<ol>
<li>对已经创建了的控件实例进行子类化。</li>
<li>对某个控件的子类进行子类化；这个又可以分为针对某个已有的控件（继承父类，类似之前的SLEditEx），重新自己写（继承自最顶层的DefaultControl，类似之前的ButtonEx）。</li>
</ol>
<p>这里主要是把ControlEx工程中剩下的2个自定义控件RollShow和ProgressBarEx的实现过程也介绍下，这里都是采用第2种方法。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<p>滚动控件，顾名思义，就是像街上某些广告牌一样，能将一条字符串信息在指定的空间内滚动的显示。我这里是学习目的，所以功能上就简化些：</p>
<ol>
<li>控件自定判断当前的字符能否在当前的矩形空间里显示完全，能则正常显示，不能则滚动显示。</li>
<li>滚动只要从右到左滚动就可以，能够持续的滚动，直到显示的字符串改变能够在空间内完整显示为止。</li>
</ol>
<p>最终效果见下图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control6/1.jpeg" alt="" title="图 1 CTRL_ROLLSHOW效果图"></p>
<h2 id="二、概要设计">二、概要设计</h2>
<p>我把控件取名为CTRL_ROLLSHOW，自己重新写（继承顶层的DefaultContorl）。因为它主要就是一些显示功能，MiniGUI原有的控件的一些功能也不能有效的“帮上什么忙”，所以选择自己重新写，这样灵活性还高些。</p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>ROLLSHOW的主要是用来显示字符串，我设计成控件只保存当前显示字符串的指针，这样外部可以方便的修改，而且控件也无需管理字符串的缓冲空间。滚动的效果用定时器来实现，本来我是想设计成所有的ROLLLSHOW控件只创建一个定时器来管理滚动效果的，不过我发现这样以我目前的水平来实现有些困难。所以我弄成每一个ROLLSHOW实例都自己创建一个定时器，这里要注意下，MiniGUI有限定thread下一个应该用程序最多只能创建16个定时器（这个和MiniGUI的内部实现有关）。不过其实也不要紧，因为一般这个ROLLSHOW控件在显示的界面中不会创建好很多个的，所以这个方案也凑活行得通了^_^ 。用一个int来保存滚动的速度（定时器的间隔）。然后用2个变量分别保存当前的文字显示颜色和背景颜色。最后用一个RECT变量来保存当前文本滚动的区域：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RollShow 数据数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _rsdata_st</div><div class="line">{</div><div class="line">    <span class="keyword">char</span>* pstrText;         <span class="comment">// 显示字符串指针</span></div><div class="line">        </div><div class="line">    <span class="keyword">int</span> nStep;              <span class="comment">// 滚动步长</span></div><div class="line">    <span class="keyword">int</span> nTimerSpeed;        <span class="comment">// 定时器时间</span></div><div class="line">        </div><div class="line">    gal_pixel pixelText;    <span class="comment">// 文本颜色</span></div><div class="line">    gal_pixel pixelBk;      <span class="comment">// 背景颜色</span></div><div class="line">        </div><div class="line">        </div><div class="line">    RECT rcText;            <span class="comment">// 文本显示区域</span></div><div class="line">        </div><div class="line">} RSDATA;</div><div class="line"><span class="keyword">typedef</span> RSDATA* PRSDATA;</div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>注册和卸载的接口，老规矩了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterRollShowControl (<span class="keyword">void</span>);</div><div class="line">BOOL UnregisterRollShowControl (<span class="keyword">void</span>);</div></pre></td></tr></table></figure>

<p>消息为什么定义成下面这个样子，也是老规矩了的，25*2是因为之前已经有了2个自定义控件了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_RSMBASE     (0xEFFF-25*2)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_RSMXX       MSG_RSMBASE – 1</span></div></pre></td></tr></table></figure>

<ul>
<li>1：设置控件数据。这个和ButtonEx的设计思路一样了：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_TEXT         0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_COLOR        0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_SPEED        0x00000004L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_ALL          ((RS_TEXT) | (RS_COLOR) | (RS_SPEED))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RSM_SETDATA     MSG_RSMBASE – 1</span></div></pre></td></tr></table></figure>

<ul>
<li>2：获取控件数据。和设置相对应：wParam传入获取PRSDATA，lParam传入需要获取的变量：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RSM_GETDATA     MSG_RSMBASE - 2</span></div></pre></td></tr></table></figure>

<ul>
<li>3：通知控件显示字符串已被修改。这个消息用于让控件重新计算当前显示字符串的空间，重新判断是否要滚动显示：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RSM_TEXTMODIFIED    MSG_RSMBASE - 3</span></div></pre></td></tr></table></figure>

<ul>
<li>3：通知码 本控件目前不需要通知码。</li>
</ul>
<h2 id="四、功能实现">四、功能实现</h2>
<p>这里最主要的就是滚动的动态功能实现了。这里如果要用自己方法弄也可以，但是既然我们用的MiniGUI，咋要就要好好挖掘MiniGUI的API，这个时候你就会发现MiniGUI有几个API为ROLLSHOW的实现提供了很好的解决办法。一个是GetTextExtent()、一个是DrawText()。GetTextExtent能够计算出给定字符串在指定的DC中输出所需要的空间大小，这个API可以用来实现判断当前字符串是否需要滚动显示的功能。</p>
<p>DrawText 是在给定的一个RECT空间内按照预定的几种对齐格式进行文本输出。好了，先来让我们想象一下——拿一张白纸，然后再拿一张上面写了字的白纸；然后以一定的速度拿着写了字的白纸从没有字的白纸上从右到左的移动。OK，我们看到了什么——这个就是我们要的滚动效果啊。那张没字的白纸就相当于控件的客户区，有字的白纸就相当于DrawText中指定的RECT空间，我只要在定时器中以一定的速度改变这个RECT的位置就可以实现滚动功能了。我这里只是调用这些上层的API而已，剩下的事情就交给MiniGUI解决吧 ^_^。想象能力差点的，请看下面的图，黑色的矩形表示控件客户区，红色的矩形表示显示文本的DrawText的RECT空间：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control6/2.jpeg" alt="" title="图 2 滚动效果实现图"></p>
<h2 id="五、注意问题">五、注意问题</h2>
<p>那些自定控件实现方法需要注意的问题我前面的教程已经说过了，这里说下专门针对实现本控件需要注意的问题吧。我认为这里需要注意点的问题，第一个前面的说的定时器数量的问题，我用的MiniGUI版本的thread模式最多只能同时存在16个，这个在使用的时候需要注意，不过创建太多的本控件实例就没啥问题。 第二个就是控件的背景透明问题。如果是父窗口没有使用背景图片的，就把控件的背景颜色设置成父窗口的背景颜色就行了。如果父窗口使用了背景图片的，也好办，使用CreateWindowEx创建控件实例并指定WS_EX_TRANSPARENT风格也可以解决问题。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="&quot;http://download.csdn.net/detail/mingming_killer/4045894&quot;">下载地址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B7/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程7</title>
        <pubTime>2015-01-21T09:48:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。这次给大家介绍的是界面美观的进度条控件。它功能上和MiniGUI原有的进度条控件（CTRL_PROGRESSBAR）是一样的（其实进度条也就是那些功能，哪还能整出别点什么花样哦）。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<ol>
<li>要具有MiniGUI原有进度条控件的所有功能，像设置范围，设置步进值，设置当前位置等；垂直、水平风格；还有一些通知码。因为本控件的主要目的是美观，但是这要保证实用性，所以原有的功能必需要有。</li>
<li>可以设置2套图片，分别用来表示进度条本身和背景。每套图片分为3个部分：头、身体、尾。头和尾可有，可无；背景也是可有，可无。图片格式支持bmp、gif、jpg、png（jpg、png依赖于MiniGUI的配置）。</li>
</ol>
<p>最终效果见下图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control7/1.jpeg" alt="" title="图 1 CTRL_PROGRESSBAREX效果图"></p>
<h2 id="二、概要设计">二、概要设计</h2>
<p>我把控件取名为CTRL_PROGRESSBAREX，自己重新写（继承顶层的DefaultContorl）。虽然ProgressBarEx需要MiniGUI原有控件的功能，但是我认为实现这些功能的代码量都不大；并且自己重新写能有更高的灵活性，权衡了一下我还是选择自己重新写。其实这里主要工作在于用图片表现控件的外观上了。</p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>为了实现ProgressBarEx最基本功能，用4个int型来保存当前控件的进度的最大值、最小值、当前位置和步进值。控件有2套图片，每套3张，一共是6个bitmap指针（这里采用和之前ButtonEx同样的方式，控件只保存指针）。然后是用一个BOOL变量保存是否实现百分比文本，用2个gal_pixel变量保存进图条超过文本和没超过时的2种不同的颜色。最后是我在测试的时候发现的问题，在有些平台上进度条重绘会闪烁，所以我增加了一个条件编译是否使用内存DC（绘图缓冲）。ProgressBarEx的数据结构如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ProgressBarEx 数据数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _pbarexdata_st</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> nMin;               <span class="comment">// 最大值</span></div><div class="line">    <span class="keyword">int</span> nMax;               <span class="comment">// 最小值</span></div><div class="line">    <span class="keyword">int</span> nPos;               <span class="comment">// 当前位置</span></div><div class="line">    <span class="keyword">int</span> nStep;              <span class="comment">// 步进值</span></div><div class="line">        </div><div class="line">    PBITMAP pbmpHead;       <span class="comment">// 进度条头部图片指针</span></div><div class="line">    PBITMAP pbmpBody;       <span class="comment">// 进度条身体图片指针</span></div><div class="line">    PBITMAP pbmpTrail;      <span class="comment">// 进度条尾部图片指针</span></div><div class="line">        </div><div class="line">    PBITMAP pbmpBkHead;     <span class="comment">// 进度条背景头部图片指针</span></div><div class="line">    PBITMAP pbmpBkBody;     <span class="comment">// 进度条背景身体图片指针</span></div><div class="line">    PBITMAP pbmpBkTrail;    <span class="comment">// 进度条背景尾部图片指针</span></div><div class="line">         </div><div class="line">    BOOL bShowPrecent;      <span class="comment">// 是否显示百分比</span></div><div class="line">    gal_pixel pixelOff;     <span class="comment">// 进度还没到文本区域时文本的颜色</span></div><div class="line">    gal_pixel pixelOn;      <span class="comment">// 进度条已经达到文本区域时文本的颜色</span></div><div class="line">        </div><div class="line">    HDC hMemDC;             <span class="comment">// 绘图内存DC </span></div><div class="line">        </div><div class="line">} PBAREXDATA;</div><div class="line"><span class="keyword">typedef</span> PBAREXDATA* PPBAREXDATA;</div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>注册和卸载的接口，老规矩了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterProgressBarExControl (<span class="keyword">void</span>);</div><div class="line">BOOL UnregisterProgressBarExControl (<span class="keyword">void</span>);</div></pre></td></tr></table></figure>

<p>消息为什么定义成下面这个样子，也是老规矩了的，25*3是因为之前已经有了3个自定义控件了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_PBEXMBASE   (0xEFFF-25*3)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_PBEXMXX     MSG_PBEXMBASE – 1</span></div></pre></td></tr></table></figure>

<ul>
<li>1：设置控件数据。这个和ButtonEx的设计思路一样了：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEX_IMAGE      0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEX_PRECENT    0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEX_ALL        ((PBEX_IMAGE) | (PBEX_PRECENT))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETDATA   MSG_PBEXMBASE – 1</span></div></pre></td></tr></table></figure>

<ul>
<li>2：获取控件数据。和设置相对应：wParam传入获取PBAREXDATA，lParam传入需要获取的变量：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_GETDATA   MSG_PBEXMBASE - 2</span></div></pre></td></tr></table></figure>

<ul>
<li>3：以下这些是与MiniGUI原有进度条控件消息接口相对应的，具体的可以查阅MiniGUI的API手册：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETRANGE      MSG_PBEXMBASE - 3</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETSTEP       MSG_PBEXMBASE - 4</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETPOS        MSG_PBEXMBASE - 5</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_DELTAPOS      MSG_PBEXMBASE - 6</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_STEPIT        MSG_PBEXMBASE - 7</span></div></pre></td></tr></table></figure>

<h3 id="3：通知码">3：通知码</h3>
<p>这里也是和MiniGUI原有的进度条控件的通知码相对应的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXN_REACHMAX 	 1</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXN_REACHMIN 	 2</span></div></pre></td></tr></table></figure>

<h3 id="4：风格">4：风格</h3>
<p>这里也是和MiniGUI原有的进度条控件的风格相对应： -_-||</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXS_NOTIFY        0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXS_VERTICAL      0x00000002L</span></div></pre></td></tr></table></figure>

<h2 id="四、功能实现">四、功能实现</h2>
<p>这里主要说说如何用图片正确的表现进度条外观了。我这里设计成进度条的外观由3个部分组成：头、身体、尾；每个部分由一张图片组成；其中头和尾可有，可无；由于进度条的特性，身体的图片只要能表现本进度条步进的最小单位即可。这样整个控件外观都由图片来表现，图片好的话，控件就会很漂亮。在绘制控件的时候，主要就是处理用图片正确的拼凑当前进度，这个要注意以下几个问题：</p>
<ul>
<li><p>1: 背景。控件的背景是可有、可无的。没有当然就不要说什么了。如果有的话，背景是不管当前进度如何，都是显示100%的，这个很好理解。可以看看上面效果图的第2个控件实例。</p>
</li>
<li><p>2: 进度条身体的拼凑。这个首先来看看没有头、尾的情况。没有头、尾，那进度条就只有身体的图片组成，这个主要就是计算当前进度的区域长度（垂直的是高度），然后这个长度，需要多少张当前的身体图片来拼凑。有头、尾的话，就把头和尾的图片贴上去，然后在计算剩下的部分需要多少身体图片。可以参照下面的图，应该就比较好理解了：</p>
</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control7/2.jpeg" alt="" title="图 2 进度条身体拼凑"></p>
<ul>
<li>3: 透明。这个问题其实在ButtonEx中已经讨论过了。我这里不提供非png格开启的透明颜色的选项。因为如果要用bmp或是jpg的话，请把图片背景弄成窗口背景颜色就行了。如果窗口背景是图片的话，您还是用png吧 -_-|| 。这里也顺带说说，为什么要把这些图片弄成3张。其实弄成一张也可以，而且这样还方便PS处理。但是这样做有个问题，就是集合在一张里的话，就要用MiniGUI的图像处理API去分割图片；这在16bit的运行环境下处理32bit的png的话，就造成透明颜色的失真。这个也是在ButtonEx中说过了的。</li>
</ul>
<h2 id="五、注意问题">五、注意问题</h2>
<p>这里也没什么需要注意的问题了，因为需要注意的地方之前的教程都说过了。这里顺带说下，之前说的那个画面闪烁的问题。可以使用内存DC缓冲解决；当然代价就是多一点点系统内存开销。这个可以根据实际情况是否开启（开关条件编译宏即可）。因为不同的硬件平台不一样，有的会闪烁，有的就不会。</p>
<p>到这里我就全部介绍完我之前自己写的那些MiniGUI自定义控件了。目前先到这里吧，看看以后还有没有需要更新的地方了。如果对之前我写的控件有什么好的改进建议或是开发别的MiniGUI控件，欢迎和我一起讨论 ^_^。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="&quot;http://download.csdn.net/detail/mingming_killer/4045894&quot;">下载地址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Repo%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Repo 命令备忘</title>
        <pubTime>2015-01-13T12:37:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>repo 其实本身就是一个 git 仓库，只不过这个仓库记录了别的 git 仓库的地址，版本号信息而已。这个 git 仓库在项目的根目录的 .repo/mainfests 下面。其实就是一个 xml 文件，然后里面记录了各个项目的版本号而已，repo 自身是一个脚本。</p>
<h2 id="download_repo">download repo</h2>
<p> 下载 repo 的地址: <a href="http://android.git.kernel.org/repo" target="_blank" rel="external">http://android.git.kernel.org/repo</a> ，可以用 wget <a href="http://android.git.kernel.org/repo" target="_blank" rel="external">http://android.git.kernel.org/repo</a> 或者 curl <a href="http://android.git.kernel.org/repo&gt;~/bin/repo" target="_blank" rel="external">http://android.git.kernel.org/repo&gt;~/bin/repo</a>  来下载 repo , Repo脚本授权：chmod a+x ~/bin/repo</p>
<h2 id="repo_ini">repo ini</h2>
<p>repo init -u URL ,  在当前目录安装 repository ，会在当前目录创建一个目录 “.repo”  -u 参数指定一个URL，从这个URL 中取得repository 的 manifest 文件。  </p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git  
</pre>

<p>可以用 -m 参数来选择 repository 中的某一个特定的 manifest 文件，如果不具体指定，那么表示为默认的 namifest 文件(default.xml)    repoinit -u git://android.git.kernel.org/platform/manifest.git -m dalvik-plus.xml 可以用 -b 参数来指定某个manifest 分支。</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git -b release-1.0
</pre>

<p>可以用命令: repo help init 来获取 repo init 的其他用法。</p>
<h2 id="查看_repo_可用的版本信息">查看 repo 可用的版本信息</h2>
<p>先 repo init 把 repo 仓库安装下来，然后 cd ./repo/manifests 下，然后 git branch -a 就可以看到了。</p>
<p>repo branch 也可以看到当前 repo 用的分支。</p>
<h2 id="repo_sync_[project-list]">repo sync [project-list]</h2>
<p>下载最新本地工作文件，更新成功，这本地文件和repository 中的代码是一样的。可以指定需要更新的project ，如果不指定任何参数，会同步整个所有的项目。如果是第一次运行 repo sync ，则这个命令相当于 git clone ，会把 repository 中的所有内容都拷贝到本地。如果不是第一次运行 repo sync ，则相当于 git remote update ;  git rebaseorigin/branch .  repo sync 会更新 .repo 下面的文件。如果在merge 的过程中出现冲突，这需要手动运行  git  rebase —continue</p>
<h2 id="repo_update[_project-list_]">repo update[ project-list ]</h2>
<p>上传修改的代码，如果你本地的代码有所修改，那么在运行 repo sync 的时候，会提示你上传修改的代码，所有修改的代码分支会上传到 Gerrit (基于web 的代码review 系统), Gerrit 受到上传的代码，会转换为一个个变更，从而可以让人们来review 修改的代码。</p>
<h2 id="repo_diff_[_project-list_]">repo diff [ project-list ]</h2>
<p>显示提交的代码和当前工作目录代码之间的差异。</p>
<h2 id="repo_download_target_revision">repo download  target revision</h2>
<p>下载特定的修改版本到本地，例如:  repo downloadpltform/frameworks/base 1241 下载修改版本为 1241 的代码</p>
<h2 id="repo_start_newbranchname">repo start newbranchname</h2>
<p>创建新的branch分支。 “.” 代表当前工作的branch 分支。</p>
<h2 id="repo_prune_[project_list]">repo prune [project list]</h2>
<p>删除已经merge 的 project</p>
<h2 id="repo_forall_[_project-lists]_-c_command">repo forall [ project-lists] -c command</h2>
<p>对每一个 project 运行 command 命令。例如你要用 repo 创建一个新的分支（其实就是让每个项目创建一个分支）： </p>
<pre>
# repo 本地创建一个 xx 分支
repo forall -c git branch xx
# repo 创建远程分支（把本地分支 push 到服务器上去）
# origin 是默认的远程路径名字
repo forall -c git push origin xx:xx
</pre>

<h2 id="repo_status">repo status</h2>
<p>显示 project 的状态</p>
<h2 id="签名错误">签名错误</h2>
<p>有些时候 repo 的时候会出现</p>
<pre>
gpg: 于 2013年10月02日 星期三 00时44分27秒 CST 创建的签名，使用 RSA，钥匙号 692B382C
gpg: 无法检查签名：找不到公钥
</pre>

<p>这样的错误。这是因为前后 key 不一样导致的，把 home 目录下的 .repoconfig 删掉，让 repo 自动导入一次 key 就可以了。</p>
<h2 id="创建新的远程分支">创建新的远程分支</h2>
<p>首先要创建对应的 git 的各个仓库的分支，可以参加前面 repo forall 命令的使用。然后去 .repo/mainfests 这个仓库下创建自己的 repo 分支。然后可以自己创建分支所用的 xml 文件，提交到刚刚新创建的 repo 分支就可以了。然后就可以用下面的命令 down 新分支代码了：</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git -b my-branch -m my-branch.xml
repo sync
</pre>

<h2 id="创建远程仓库">创建远程仓库</h2>
<ol>
<li><p>先本地库的创建，在一个本地一个目录把要创建仓库的目录创建好：</p>
<pre>
# 在本地仓库目录，创建裸仓库
git init
# 把本地仓库先提交到一个分支，一般开始是 master
git add
git commit
</pre>
</li>
<li><p>提交远程服务器<br>命令： git remote add <name> <url><br>如:<br><pre><br>git remote add origin gitrepo:android/android4.1/platform/external/abc.git<br></pre><br>origin 是远程仓库的别名（路径），然后后面的 url 一定要是远程服务器的 url 。弄好后可以用 git remote -v 或是 git config -l 查看。如果一开始远程别名弄错了，可以用 git remote rename old new 来重命名。如果 url 错了，可以用 git remote set-url origin xx 来重新指定远程服务器 url 。确保正确后，用 git push origin master:master 把本地仓库提交远程服务器。</url></name></p>
</li>
<li><p>在 repo 中添加新的仓库<br>进入 .repo/manifests 这个 repo 仓库，编辑 default.xml (视自己项目使用的 xml 不用，编辑不同的 xml 文件)。照着原有的模版添加刚刚新创建的仓库就好。例如： <code>&lt;project path=&quot;external/abc&quot; name=&quot;platform/external/abc&quot; /&gt;</code>。然后把修改提交到自己项目的 repo 仓库分支就 OK 了，例如: git push origin default:default。</p>
</li>
</ol>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Rsa%20%E9%AA%8C%E8%AF%81%E7%AE%80%E4%BB%8B/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Rsa 验证简介</title>
        <pubTime>2015-01-13T12:33:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p> 如果不是用密码来进行验证的话，那么就可以使用 rsa 数据签名来进行验证。签名分为公钥和私钥2个。公钥是可以公开出来的，密钥是自己个人持有的。一般来使用 RSA 验证的话，是自己生成一对公钥/私钥。然后把公钥放置到服务器上，自己持有公钥和私钥，然后就可以通过公钥来验证了。下面上使用简介：</p>
<p>假设客户端的用户 charlee 要以 guest 用户登录到服务器上。首先在客户端执行下面的命令:</p>
<pre>
// ssh-keygen: 
// -t 指定公钥类型，默认的是 rsa 的
// -c 是生成的公钥注释，如果不指定的话就是自己机子的终端显示的那个东西
// 其它的一些选项可以自己去查帮助文档
</pre>

<pre>
[charlee@client:~]$ ssh-keygen -t rsa -c "your_email@youremail.com"
Generating public/private rsa1 key pair.
Enter file in which to save the key (/home/charlee/.ssh/id_rsa): 回车 （这个是让你指定输出文件，直接敲回车就是括号里那个默认的路径、文件）
Enterpassphrase (empty for no passphrase):  回车 （这个是让你输入你公钥的密码，直接敲回车就不设定密码）
Enter same passphrase again:   回车
Your identification has been sabed in /home/charlee/.ssh/id_rsa
Your public key has been saved in /home/charlee/.ssh/id_rsa.pub
</pre>

<p>生成的文件保存在主目录的 .ssh 目录下，id_rsa 为客户端密钥，id_rsa.pub 为客户端公钥。之后，通过 U 盘等方式将公钥 id_rsa.pub 复制到服务器上，并执行下列命令。</p>
<p>[guest@server:~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</p>
<p>其实还可以执行 ssh-copy-id mingming@192.168.0.8 把公钥弄到服务器上。其中 id_rsa.pub 是客户端的用户 charlee 的公钥。这样在客户端即可通过以下的命令连接服务器。到此基本可以配对两台机的公钥了。</p>
<p>[charlee@client:~]$ ssh -l guest server</p>
<p>若不想每次登录服务器时都输入密码，可以先执行下列命令：</p>
<pre>
// 如果提示 ssh not find agent 之类的，可以输入 eval `ssh-agent` 启动 ssh agent
[charlee@client:~]$ ssh-add
Enter passphrase for /home/charlee/.ssh/id_rsa: 输入密码
Identity added: /home/charlee/.ssh/id_rsa (/home/charlee/.ssh/id_rsa)
</pre>

<p>以后登录服务器就不需要输入密码了。</p>
<p>如果出现： Permissions 0464 for ‘.ssh/id_rsa’ are too open. 之类的错误，把私钥文件（id_rsa）权限改为 600 就可以了。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/10/Test/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Test</title>
        <pubTime>2015-01-10T03:07:14.000Z</pubTime>
        
        <tag>test </tag>
         
         <content><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>This is a blod text: <strong>Ha Ha 粗体字体</strong></p>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/11/GDB%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>GDB 命令备忘</title>
        <pubTime>2015-01-10T16:25:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>一些常用的 gdb 使用命令备忘。help 可以查看命令，help xx 可以查看具体命令的所有参数。</p>
<h2 id="编译带调试符号的程序">编译带调试符号的程序</h2>
<p>要想用 gdb 调试，编译的时候要带上 debug 符号，就是用 gcc 编译的时候带上 -g 参数编译（bu要带 -o 开启优化模式，这个会把所有的调试符号优化掉）。</p>
<h2 id="file">file</h2>
<p>file app，装载要调试的应用程序。</p>
<h2 id="list_（l）">list （l）</h2>
<p>list fun，可查看对应函数 fun 的代码。可以接很多参数，例如行号等。函数名是可以使用 tab 键补全的。</p>
<h2 id="breakpoint_(b)">breakpoint (b)</h2>
<p>break fun，在函数 fun 出设置断点。也是可以接很多参数的，例如说行号等。</p>
<ul>
<li><p>b fun if condition，设置条件断点，只有当 condition 为 true 时才中断。</p>
</li>
<li><p>i breakpoint（b），显示当前设置的断点。</p>
</li>
<li><p>delete breakpoint 1，删除1号断点，编号可以使用 i b 查看，如果不加参数，则会删除所有断点。</p>
</li>
<li><p>disable breakpoint 1，禁止1号断点。</p>
</li>
<li><p>enable breakpoint 1，开启1号断点。</p>
</li>
</ul>
<h2 id="watch">watch</h2>
<p>watch condition (watch i&gt;99)，监视变量的变化达到条件时停止程序执行。注意：监视点的设定不依赖于断点的位置，但是与变量的作用域有关。也就是说，要设置监视点必须在程序运行时才可设置。</p>
<p>还有一个作用是，硬件写断点。这种断点和普通的 break 有点不同，需要每次挂载 gdb 后，先利用普通的 break 让程序停下来，然后查看出你要查看变量的地址（用p）。然后再用 watch 命令设置。然后每次程序重新运行都要重新设置，因此每次变量地址的都不一样。</p>
<h2 id="控制命令">控制命令</h2>
<ul>
<li><p>run (r): 运行程序。</p>
</li>
<li><p>next (n): 下一步，跳过函数。</p>
</li>
<li><p>setp (s): 下一步，进入函数。</p>
</li>
<li><p>continue (c): 继续执行。</p>
</li>
</ul>
<h2 id="info_(i)">info (i)</h2>
<p>显示某些内容。</p>
<ul>
<li><p>i breakpoints(b)，显示当前断点。</p>
</li>
<li><p>i variables，显示所有全局变量和静态变量。</p>
</li>
<li><p>i functions，显示所有函数名字。</p>
</li>
<li><p>i local，显示当前函数中的变量。</p>
</li>
<li><p>i file，显示调试文件的信息。</p>
</li>
<li><p>i prog，显示调试程序的执行状态</p>
</li>
</ul>
<h2 id="print_(p)">print (p)</h2>
<p>p var，显示变量 var 的值，或者 p exp，可以显示该表达式的值。这样可以查看几乎任何变量的值。只要你确定改变量是什么类型的指针，可以直接转化为该类型就行了，例如 p *(PDC)hdc 就可以查看这个结构的值了。还可以通过添加参数来设置输出格式：</p>
<pre>
/x 按十六进制格式显示变量
/d 按十进制格式显示变量
/u 按十六进制格式显示无符号整型
/o 按八进制格式显示变量
/t 按二进制格式显示变量
/a 按十六进制格式显示变量
/c 按字符格式显示变量
/f 按浮点数格式显示变量
</pre>

<p>其实它还有一个功能就是执行函数。调试 MiniGUI 的时候，最典型的用法用法就是可以将你想查看的一些 memdc 中的图像信息输出到屏幕上进行检查。方法是调用 BitBlt ，注意这种情况一些宏定义的变量无法直接使用，而是要填入真正的数值，这些可以从代码里面去差。例如先把屏幕一块地方填充成红色，然后再把 memdc 中的内容输入到屏幕的这个地方：</p>
<pre config="brush:bash;toolbar:false;">
// SetBrushColor(hdc, color) 的宏定义是 SetDCAttr(hdc, DC_ATTR_BRUSH_COLOR, color)
// DC_ATTR_BRUSH_COLOR 值就是2
// HDC_SCREEN 的值就是0
// 如果自己知道 rgb 对应的 pixel 值的话，也可以不用 RGB2Pixel
p SetDCAttr(0, 2, RGB2Pixel(0, 255, 0, 0))

p FillBox(0, 400, 0, 360, 480)

p BitBlt(memdc, 0, 0, 0, 0, 0, 400, 0, 0)
</pre>

<h2 id="x">x</h2>
<p>x /nfu <addr>，查看addr地址处的内存信息。n是显示多少字节，后面的显示的格式，和 p 命令是一样的。</addr></p>
<h2 id="thread">thread</h2>
<p>用法：thread xx。切换当前活动线程。用于调试多线程程序。xx 为线程号，用 info thread（th）查看，每个线程的第一个数字就是线程号。 </p>
<h2 id="backtrace_(bt)">backtrace (bt)</h2>
<p>backtrace [-n] [n] 显示程序中的当前位置和表示如何到达当前位置的栈跟踪。<br>-n：表示只打印栈底上n层的栈信息<br> n：表示只打印栈顶上n层的栈信息<br>不加参数，表示打印所有栈信息。</p>
<h2 id="call">call</h2>
<p>call func_name，调用和执行一个函数。例如 call print(“abcd\n”)。</p>
<h2 id="查看_coredump_文件">查看 coredump 文件</h2>
<p>首先要让程序在崩溃的时候产生 coredump 文件。输入 ulimit -c unlimited 命令（注意这个只对一个终端有效）。然后在程序崩溃的时候，就会产生 core.xx 的文件。使用 gdb app core.xx 命令查看（app 就是产生 core.xx 的程序）。然后就和普通的 gdb 用法一样了，用 bt 查看崩溃时的堆栈信息啊，但是就是不能执行而已。</p>
<h2 id="disassemble">disassemble</h2>
<p>对当前的执行到的代码反汇编。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20float%20%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>(转) float 类型在内存中的表示</title>
        <pubTime>2015-01-19T12:22:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<h2 id="标准">标准</h2>
<p>先说一下计算机中二进制的算法：</p>
<h3 id="整数">整数</h3>
<p>整数的二进制算法大家应该很熟悉，就是不断的除以2取余数，然后将余数倒序排列。比如求9的二进制： </p>
<pre>
9/2=4 余 1 
4/2=2 余 0 
2/2=1 余 0 
1/2=0 余 1
</pre> 

<p>一直计算到商为0为止，然后将得到的余数由下到上排列，就得到了9的二进制：1001。 从上面的算法我们可以看到，用整数除以2，最终都能够到0。因此，整数是可以用二进制来精确表示的。</p>
<h3 id="小数">小数</h3>
<p>小数的二进制算法和整数的大致相反，就是不断的拿小数部分乘以2取积的整数部分，然后正序排列。比如求0.9的二进制：</p>
<pre> 
0.9*2=1.8 取 1 
0.8*2=1.6 取 1 
0.6*2=1.2 取 1 
0.2*2=0.4 取 0 
0.4*2=0.8 取 0 
0.8*2=1.6 取 1 
… … 
</pre>

<p>如此循环下去。因此我么得到的二进制小数也是无限循环的：0.11100110011… 从小数的二进制算法中我们可以知道，如果想让这种算法停止，只有在小数部分是0.5的时候才可以，但是很不幸，这类的小数很少。所以大部分小数是很难用二进制来精确表示的。</p>
<p>OK，有了上面的知识，我们进入正题：看看float类型在内存中是如何表示的。float类型又称为单精度浮点类型，在 <a href="http://en.wikipedia.org/wiki/IEEE_754-2008" title="IEEE 754-2008" target="_blank" rel="external">IEEE 754-2008</a> 中是这样定义它的结构的：</p>
<pre>
S    EEEEEEEE  FFFFFFFFFFFFFFFFFFFFFFF
31   30        23 22 21 ... ...      0
</pre>

<p>float类型总共4个字节——32位：</p>
<ul>
<li><p><strong>符号位</strong><br>其中最左边的为符号位，0为正，1为负。</p>
</li>
<li><p><strong>指数</strong><br>接下来的E是指数，一共8位，也用二进制来表示。</p>
</li>
<li><p><strong>尾数</strong><br>最后的F是小数部分，尾数正是由这23位的小数部分+1位组成的。（这个稍后解释）。</p>
</li>
</ul>
<p>这里我们需要多说一下指数。虽然指数也是用8位二进制来表示的，但是IEEE在定义它的时候做了些手脚，使用了偏移来计算指数。IEEE规定，在float类型中，用来计算指数的偏移量为 <strong>127</strong> 。也就是说，如果你的指数实际是0，那么在内存中存的就是 <strong>0+127=127</strong> 的二进制。稍后我们来看这个到底如何使用。</p>
<h2 id="实例">实例</h2>
<p>好了，看了这么多，我们该演示一下计算机如何将一个十进制的实数转换为二进制的。就拿6.9这个数字来举例吧。-_-||!</p>
<p>首先，我们按照上面说的方法，分别将整数和小数转换成对应的二进制。这样 6.9 的二进制表示就是 110.1110011001100…（整数的部分按整数转化为二进制，小数部分按小数部分转化）。这里就看出来 了，6.9 转换成二进制，小数部分是无限循环的，这在现在的计算机系统上是无法精确表示的。这是计算机在计算浮点数的时候常常不精确的原因之一。</p>
<p>其次，将小数点左移（或右移）到第一个有效数字之后。说的通俗些，就是把小数点移到第一个1之后。这样的话，对于上面的 110.1110011001100… 我们就需要把小数点左移2位，得到 1.101110011001100… 。</p>
<p>接下来的事情就有意思了。首先我们把得到的 1.101110011001100.. 这个数，从小数点后第一位开始，数出23个来，填充到上面float内存 结构的尾数部分（就是那一堆F的地方），我们这里数出来的就是 10111001100110011001100。这里又要发生一次不精确了，小数点后超出 23位的部分都将被舍弃，太惨了。</p>
<p>不过，这里有一个可能让大家觉得特别坑爹的事情，就是小数点前面的1也不要了。仔细看看上面的内存结构，确实没有地方存放这个1。原因是这样的：IEEE觉得，既然我们大家都约定把小数点移动到第一个有效数字之后，那也就默认小数点前面一定有且只有一个1，所以把这个1存起来也浪费，干脆就不要了，以后大家都这么默契的来就好。这也是为什么我上面说尾数是 <strong>23位+1位</strong> 的原因。</p>
<p>填充完尾数，该填充指数了。这个指数就是刚才我们把小数点移动的位数，左移为正，右移为负，再按照上面所说的偏移量算法，我们填充的指数应该是 2+127=129 。转换成8位二进制就是 10000001。</p>
<p>最后，根据这个数的正负来填充符号位。我们这里是正数，所以填0。这样6.9的在内存中的存储结果就出来了：</p>
<pre>
0  10000001  10111001100110011001100
</pre>

<p>总结一下，实数转二进制float类型的方法：</p>
<ol>
<li>分别将实数的整数和小数转换为二进制</li>
<li>左移或者右移小数点到第一个有效数字之后</li>
<li>从小数点后第一位开始数出23位填充到尾数部分 </li>
<li>把小数点移动的位数，左移为正，右移为负，加上偏移量127，将所得的和转换为二进制填充到指数部分</li>
<li>根据实数的正负来填充符号位，0为正，1为负</li>
</ol>
<p>如果需要把float的二进制转换回十进制的实数，只要将上面的步骤倒着来一边就行了。</p>
<h2 id="需要注意的东西">需要注意的东西</h2>
<h3 id="23位尾数填充的问题">23位尾数填充的问题</h3>
<p>虽然在IEEE754标准中我没有找到相应的描述，但是在实际处理的时候，截取23位尾数需要对第24位进行零舍一入的操作，至少在Java虚拟机中是这么做的。有兴趣的可以试试0.7f-0.6f。</p>
<h3 id="运算时向右对阶操作的舍入问题">运算时向右对阶操作的舍入问题</h3>
<p>这个也是在实际操作时遇到的问题。到目前为止我还无法确定向右对阶操作是否也进行了零舍一入的操作。有兴趣的可以试试9.6f-6.9f。</p>
<h3 id="指数全零问题">指数全零问题</h3>
<p>全部为零的指数说明当前所表示的是一个特殊的float数字。全零的float类型分为两种情况：</p>
<ul>
<li><p><strong>尾数全零</strong><br>此时代表当前float数为0。根据符号位，分为+0和-0。这两个在JVM上相等的。这里需要解释一下。因为IEEE的默认1的问题，所以float类型没有办法表示0，因此只能在已有的规定上做一些强制性的规则来表示0，也就有了上面的这个全零的说法。 </p>
</li>
<li><p><strong>尾数不全为零</strong><br>此时说明当前的float数是一个非规格化的数。</p>
</li>
</ul>
<h3 id="指数全一问题">指数全一问题</h3>
<p>指数全部为一也说明这个float数是一个不寻常的数字。它也分为两种情况：</p>
<ul>
<li><p><strong>尾数全零</strong><br>此时根据符号位的不同，分为正无穷（+infinity）和负无穷（-infinity）。注意，这两个东西在JVM中是不相等的。</p>
</li>
<li><p><strong>尾数不全为零</strong><br>此时表示此float数纯粹不是一个数（NaN，Not a Number）。这个NaN也分QNaN（Quiet NaN）和SNaN（Signalling NaN）。至于这两个NaN有什么区别，下面这段话倒是说明了，但是我没有这方面的知识，所以不敢妄加翻译，只好把原文放在这里：</p>
</li>
</ul>
<p>A QNaN is a NaN with the most significant fraction bit set. QNaN’s propagate freely through most arithmetic operations. These values pop out of an operation when the result is not mathematically defined.<br>An SNaN is a NaN with the most significant fraction bit clear. It is used to signal an exception when used in operations. SNaN’s can be handy to assign to uninitialized variables to trap premature usage.<br>Semantically, QNaN’s denote indeterminate operations, while SNaN’s denote invalid operations.</p>
<p>最后一句话说的明白，QNaN就是一个不确定操作的结果，而SNaN纯粹就是一个非法的操作结果。</p>
<p>OK，废话了这么多，我觉得对float类型也大致有个了解了。float明白了以后，double类型也就好说了，基本和上面一样，只是指数和尾数的位数不一样而已。</p>
<p><a href="http://blog.csdn.net/nethibernate/article/details/6120382" title="原始出处" target="_blank" rel="external">原始出处</a></p>
<h2 id="我的话">我的话</h2>
<p>这个作者写的很好，很好的说明了 float 在内存中是怎么存放的。从这里可以看得出，为什么 float 运算比 int 要慢很多（多了太多的运算）。所以以前嵌入式 Soc 不给力的时候嵌入式的 app 一般不使用 float。现在我能理解以前 MiniGUI 用定点数代替 float 的做法了：</p>
<p>就是把一个 int 类型拆成2部分：例如 32bit 的，高 16bit 当作整数部分，低 16bit 当作小数部分来表示和运算。这样的话，因为整数和小数的位数都是固定的，所以叫定点数。这样表示 float 的方法比正统的 float 要快很多，虽然精度比 float 差，但是在一些不太要紧的场合很实用。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20gimp%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%8B%BE%E8%89%B2%E5%99%A8%E6%8B%BE%E5%8F%96%E7%9A%84%E9%A2%9C%E8%89%B2%E7%9A%84alpha%E5%80%BC/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>(转) gimp中如何查看拾色器拾取的颜色的alpha值</title>
        <pubTime>2015-01-19T02:18:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>其实非常简单，按住shift然后点击颜色拾取，就会弹出一个小窗口告诉你所拾取的颜色的包括alpha的各种信息。还可以查看hsv信息或者cmyk信息</p>
<p>这个开源的图像处理工具很强大，在 linux 上可以替代 PhotoShop。不过由于功能太多，简单的处理反而不太方便，平常使用可以用在线的一个图像工具也挺好用的：</p>
<p><a href="http://apps.pixlr.com/editor/" title="在线PS工具" target="_blank" rel="external">在线PS工具</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20unlocked_ioctl%20%E5%92%8C%E5%A0%B5%E5%A1%9E%EF%BC%88waitqueue%EF%BC%89%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>(转) unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</title>
        <pubTime>2015-01-19T02:31:16.000Z</pubTime>
        
        <tag>basics </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>学习了驱动程序的设计，感觉在学习驱动的同时学习linux内核，也是很不错的过程哦，做了几个实验，该做一些总结，只有不停的作总结才能印象深刻。</p>
<p>我的平台是虚拟机，fedora14，内核版本为2.6.38.1.其中较之前的版本存在较大的差别，具体的实现已经在上一次总结中给出了。今天主要总结的是ioctl和堵塞读写函数的实现。</p>
<h2 id="一、ioctl函数的实现">一、ioctl函数的实现</h2>
<p>首先说明在2.6.36以后ioctl函数已经不再存在了，而是用<code>unlocked_ioctl</code>和<code>compat_ioctl</code>两个函数实现以前版本的ioctl函数。同时在参数方面也发生了一定程度的改变，去除了原来ioctl中的struct inode参数，同时改变了返回值。</p>
<p>但是驱动设计过程中存在的问题变化并不是很大，同样在应用程序设计中我们还是采用ioctl实现访问，而并不是<code>unlocked_ioctl</code>函数，因此我们还可以称之为ioctl函数的实现。ioctl函数的实现主要是用来实现具体的硬件控制，采用相应的命令控制硬件的具体操作，这样就能使得硬件的操作不再是单调的读写操作。使得硬件的使用更加的方便。ioctl函数实现主要包括两个部分，首先是命令的定义，然后才是ioctl函数的实现，命令的定义是采用一定的规则。</p>
<p>ioctl的命令主要用于应用程序通过该命令操作具体的硬件设备，实现具体的操作，在驱动中主要是对命令进行解析，通过switch-case语句实现不同命令的控制，进而实现不同的硬件操作。</p>
<p>ioctl函数的命令定义方法：</p>
<pre>
int (*unlocked_ioctl)(struct file*filp,unsigned int cmd,unsigned long arg)
</pre>

<p>虽然其中没有指针的参数，但是通常采用arg传递指针参数。cmd是一个命令。<strong>每一个命令由一个整形数据构成（32bits），将一个命令分成四部分，每一部分实现具体的配置，设备类型（幻数）8bits，方向2bits，序号8bits，数据大小13/14bits</strong>。命令的实现实质上就是通过简单的移位操作，将各个部分组合起来而已。</p>
<p>一个命令的分布的大概情况如下：</p>
<pre config="brush:bash;toolbar:false;">
|---方向位(31-30)|----数据长度(29-16)----------------|---------设备类型（15-8）------|----------序号（7-0）----------|
|----------------------------------------------------------------------------------------------------------------------------------------|
</pre>

<p>其中方向位主要是表示对设备的操作，比如读设备，写设备等操作以及读写设备等都具有一定的方向，2个bits只有4种方向。数据长度表示每一次操作（读、写）数据的大小，一般而已每一个命令对应的数据大小都是一个固定的值，不会经常改变，14bits说明可以选择的数据长度最大为16k。</p>
<p>设备类型类似于主设备号（由于8bits，刚好组成一个字节，因此经常采用字符作为幻数，表示某一类设备的命令），用来区别不同的命令类型，也就是特定的设备类型对应特定的设备。序号主要是这一类命令中的具体某一个，类似于次设备号（256个命令），也就是一个设备支持的命令多达256个。</p>
<p>同时在内核中也存在具体的宏用来定义命令以及解析命令。但是大部分的宏都只是定义具体的方向，其他的都需要设计者定义。</p>
<p>主要的宏如下：</p>
<pre config="brush:bash;toolbar:false;">

#include<linux ioctl.h="">

_IO(type,nr)                表示定义一个没有方向的命令，
_IOR(type,nr,size)          表示定义一个类型为type，序号为nr，数据大小为size的读命令
_IOW(type,nr,size)          表示定义一个类型为type，序号为nr，数据大小为size的写命令
_IOWR(type,nr,size)         表示定义一个类型为type，序号为nr，数据大小为size的写读命令

</linux></pre>

<p>通常的type可采用某一个字母或者数字作为设备命令类型。是实际运用中通常采用如下的方法定义一个具体的命令:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//头文件</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;linux/ioctl.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/*定义一系列的命令*/</span></div><div class="line"><span class="comment">/*幻数，主要用于表示类型*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAGIC_NUM 'k'</span></div><div class="line"><span class="comment">/*打印命令*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_PRINTF _IO(MAGIC_NUM,1)</span></div><div class="line"><span class="comment">/*从设备读一个int数据*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_READ _IOR(MAGIC_NUM,2,int)</span></div><div class="line"><span class="comment">/*往设备写一个int数据*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_WRITE _IOW(MAGIC_NUM,3,int)</span></div><div class="line"></div><div class="line"><span class="comment">/*最大的序列号*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEM_MAX_CMD 3</span></div></pre></td></tr></table></figure>

<p>还有对命令进行解析的宏，用来确定具体命令的四个部分（方向，大小，类型，序号）具体如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*确定命令的方向*/</span></div><div class="line">_IOC_DIR(nr)                    </div><div class="line"><span class="comment">/*确定命令的类型*/</span></div><div class="line">_IOC_TYPE(nr)                     </div><div class="line"><span class="comment">/*确定命令的序号*/</span></div><div class="line">_IOC_NR(nr)                           </div><div class="line"><span class="comment">/*确定命令的大小*/</span></div><div class="line">_IOC_SIZE(nr)</div></pre></td></tr></table></figure>

<p>上面的几个宏可以用来命令，实现命令正确性的检查。</p>
<p>ioctl的实现过程主要包括如下的过程：</p>
<ol>
<li>命令的检测</li>
<li>指针参数的检测</li>
<li>命令的控制switch-case语句</li>
</ol>
<p>1、命令的检测主要包括类型的检查，数据大小，序号的检测，通过结合上面的命令解析宏可以快速的确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*检查类型，幻数是否正确*/</span></div><div class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd)!=MAGIC_NUM)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"><span class="comment">/*检测命令序号是否大于允许的最大序号*/</span></div><div class="line"><span class="keyword">if</span>(_IOC_NR(cmd)&gt; MEM_MAX_CMD)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div></pre></td></tr></table></figure>

<p>2、主要是指针参数的检测。指针参数主要是因为内核空间和用户空间的差异性导致的，因此需要来自用户空间指针的有效性。使用<code>copy_from_user</code>,<code>copy_to_user</code>,<code>get_user</code>,<code>put_user</code>之类的函数时，由于函数会实现指针参量的检测，因此可以省略，但是采用<code>__get_user()</code>,<code>__put_user()</code>之类的函数时一定要进行检测。具体的检测方法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span>(_IOC_DIR(cmd) & _IOC_READ)</div><div class="line">        err = !access_ok(VERIFY_WRITE,(<span class="keyword">void</span> *)args,_IOC_SIZE(cmd));</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_IOC_DIR(cmd) & _IOC_WRITE)</div><div class="line">        err = !access_ok(VERIFY_READ,(<span class="keyword">void</span> *)args,_IOC_SIZE(cmd));</div><div class="line"><span class="keyword">if</span>(err)<span class="comment">/*返回错误*/</span></div><div class="line">        <span class="keyword">return</span> -EFAULT;</div></pre></td></tr></table></figure>

<p><strong>当方向是读时，说明是从设备读数据到用户空间，因此要检测用户空间的指针是否可写，采用<code>VERIFY_WRITE</code>，而当方向是写时，说明是往设备中写数据，因此需要检测用户空间中的指针的可读性<code>VERIFY_READ</code>。检查通常采用<code>access_ok()</code>实现检测，第一个参数为读写，第二个为检测的指针，第三个为数据的大小</strong>。</p>
<p>3、命名的控制：命令的控制主要是采用switch和case相结合实现的，这于window编程中的检测各种消息的实现方式是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*根据命令执行相应的操作*/</span></div><div class="line">        <span class="keyword">switch</span>(cmd)</div><div class="line">        {</div><div class="line">                <span class="keyword">case</span> MEMDEV_PRINTF:</div><div class="line">                        printk(<span class="string">"&lt;--------CMD MEMDEV_PRINTF Done------------&gt;\n\n"</span>);</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MEMDEV_READ:</div><div class="line">                        ioarg = &mem_devp-&gt;data;</div><div class="line">                        ...</div><div class="line">                        ret = __put_user(ioarg,(<span class="keyword">int</span> *)args);</div><div class="line">                        ioarg = <span class="number">0</span>;</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MEMDEV_WRITE:</div><div class="line">                        ...</div><div class="line">                        ret = __get_user(ioarg,(<span class="keyword">int</span> *)args);</div><div class="line">                        printk(<span class="string">"&lt;--------CMD MEMDEV_WRITE Done ioarg = %d---------&gt;\n\n"</span>,ioarg); </div><div class="line">                        ioarg = <span class="number">0</span>;</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                        ret = -EINVAL;</div><div class="line">                        printk(<span class="string">"&lt;-------INVAL CMD---------&gt;\n\n"</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">        }</div></pre></td></tr></table></figure>

<p>这只是基本的框架结构，实际中根据具体的情况进行修改。这样就实现了基本的命令控制。<br>文件操作支持的集合如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*添加该模块的基本文件操作支持*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations mem_fops =</div><div class="line">{</div><div class="line">        <span class="comment">/*结尾不是分号，注意其中的差别*/</span></div><div class="line">        .owner = THIS_MODULE,</div><div class="line">        .llseek = mem_llseek,</div><div class="line">        .read = mem_read,</div><div class="line">        .write = mem_write,</div><div class="line">        .open = mem_open,</div><div class="line">        .release = mem_release,</div><div class="line">        <span class="comment">/*添加新的操作支持*/</span></div><div class="line">        .unlocked_ioctl = mem_ioctl,</div><div class="line">};</div></pre></td></tr></table></figure>

<p>需要注意不是ioctl,而是unlocked_ioctl。</p>
<h2 id="二、设备的堵塞读写方式实现，通常采用等待队列。">二、设备的堵塞读写方式实现，通常采用等待队列。</h2>
<p>设备的堵塞读写方式，默认情况下的读写操作都是堵塞型的，具体的就是如果需要读数据，当设备中没有数据可读的时候应该等待设备中有设备再读，当往设备中写数据时，如果上一次的数据还没有被读完成，则不应该写入数据，就会导致进程的堵塞，等待数据可读写。但是在应用程序中也可以采用非堵塞型的方式进行读写。只要在打开文件的时候添加一个<code>O_NONBLOCK</code>,这样在不能读写的时候就会直接返回，而不会等待。</p>
<p>因此我们在实际设计驱动设备的同时需要考虑读写操作的堵塞方式。堵塞方式的设计主要是通过等待队列实现，通常是将等待队列（实质就是一个链表）的头作为设备数据结构的一部分。在设备初始化过程中初始化等待队列的头。最后在设备读写操作的实现添加相应的等待队列节点，并进行相应的控制。</p>
<p>等待队列的操作基本如下：</p>
<p>1、等待队列的头定义并初始化的过程如下：</p>
<p>方法一：</p>
<pre>
struct wait_queue_head_t mywaitqueue;
init_waitqueue_head(&mywaitqueue);
</pre>
方法二：
<pre>
DECLARE_WAIT_QUEUE_HEAD(mywaitqueue);
</pre>
以上的两种都能实现定义和初始化等待队列头。

2、创建、移除一个等待队列的节点，并添加、移除相应的队列。
定义一个等待队列的节点:`DECLARE_WAITQUEUE(wait,tsk)`
其中tsk表示一个进程，可以采用current当前的进程。
添加到定义好的等待队列头中。
<pre>
add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
即：add_wait_queue(&mywaitqueue,&wait);
</pre>

<p>移除等待节点</p>
<pre>
remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
即：remove_wait_queue(&mywaitqueue,&wait);
</pre>

<p>3、等待事件<br><code>wait_event(queue,condition)</code>;当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下不能被信号打断。<br><code>wait_event_interruptible(queue,condition)</code>;当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下能被信号打断。</p>
<p>4、唤醒等待队列<br><code>wait_up(wait_queue_head_t *q)</code>,唤醒该等待队列头对应的所有等待。<br><code>wait_up_interruptible(wait_queue_head_t *q)</code>唤醒处于<code>TASK_INTERRUPTIBLE</code>的等待进程。</p>
<p>应该成对的使用。即<code>wait_event</code>于<code>wait_up</code>,而<code>wait_event_interruptible</code>与<code>wait_up_interruptible</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">wait_event和wait_event_interruptible的实现都是采用宏的方式，都是一个重新调度的过程，如下所示：</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> wait_event_interruptible(wq, condition)                \</span></div><div class="line">({                                    \</div><div class="line">    <span class="keyword">int</span> __ret = <span class="number">0</span>;                            \</div><div class="line">    <span class="keyword">if</span> (!(condition))                        \</div><div class="line">        __wait_event_interruptible(wq, condition, __ret);    \</div><div class="line">    __ret;                                \</div><div class="line">})</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __wait_event_interruptible(wq, condition, ret)            \</span></div><div class="line"><span class="keyword">do</span> {                                    \</div><div class="line">     <span class="comment">/*此处存在一个声明等待队列的语句，因此不需要再重新定义一个等待队列节点*/</span></div><div class="line">    DEFINE_WAIT(__wait);                        \</div><div class="line">                                    \</div><div class="line">    <span class="keyword">for</span> (;;) {                            \</div><div class="line">        <span class="comment">/*此处就相当于add_wait_queue()操作，具体参看代码如下所示*/</span></div><div class="line">        prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);    \</div><div class="line">        <span class="keyword">if</span> (condition)                        \</div><div class="line">            <span class="keyword">break</span>;                        \</div><div class="line">        <span class="keyword">if</span> (!signal_pending(current)) {                \</div><div class="line">            <span class="comment">/*此处是调度，丢失CPU，因此需要wake_up函数唤醒当前的进程</span></div><div class="line">		根据定义可知，如果条件不满足，进程就失去CPU,能够跳出for循环的出口只有</div><div class="line">                1、当条件满足时2、当signal_pending（current）=1时。</div><div class="line">                1、就是满足条件，也就是说wake_up函数只是退出了schedule函数，</div><div class="line">                而真正退出函数还需要满足条件	</div><div class="line">                2、说明进程可以被信号唤醒。也就是信号可能导致没有满足条件时就唤醒当前的进程。 </div><div class="line">               这也是后面的代码采用while判断的原因.防止被信号唤醒。   </div><div class="line">	   */</div><div class="line">            schedule();                    \</div><div class="line">            <span class="keyword">continue</span>;                    \</div><div class="line">        }                            \</div><div class="line">        ret = -ERESTARTSYS;                    \</div><div class="line">        <span class="keyword">break</span>;                            \</div><div class="line">    }                                \</div><div class="line">    finish_wait(&wq, &__wait);                    \</div><div class="line">} <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFINE_WAIT_FUNC(name, function)				\</span></div><div class="line">	wait_queue_t name = {						\</div><div class="line">		.<span class="keyword">private</span>	= current,				\</div><div class="line">		.func		= function,				\</div><div class="line">		.task_list	= LIST_HEAD_INIT((name).task_list),	\</div><div class="line">	}</div><div class="line"></div><div class="line"><span class="keyword">void</span> prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, <span class="keyword">int</span> state)</div><div class="line">{</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	wait-&gt;flags &= ~WQ_FLAG_EXCLUSIVE;</div><div class="line">	spin_lock_irqsave(&q-&gt;lock, flags);</div><div class="line">	<span class="keyword">if</span> (list_empty(&wait-&gt;task_list))</div><div class="line">               <span class="comment">/*添加节点到等待队列*/</span></div><div class="line">		__add_wait_queue(q, wait);</div><div class="line">	set_current_state(state);</div><div class="line">	spin_unlock_irqrestore(&q-&gt;lock, flags);</div><div class="line">}</div><div class="line">唤醒的操作也是类似的。</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> wake_up_interruptible(x)	__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></div><div class="line"> </div><div class="line">  <span class="keyword">void</span> __wake_up(wait_queue_head_t *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</div><div class="line">{</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	spin_lock_irqsave(&q-&gt;lock, flags);</div><div class="line">	__wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);</div><div class="line">	spin_unlock_irqrestore(&q-&gt;lock, flags);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(wait_queue_head_t *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</div><div class="line">{</div><div class="line">	wait_queue_t *curr, *next;</div><div class="line"></div><div class="line">	list_for_each_entry_safe(curr, next, &q-&gt;task_list, task_list) {</div><div class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &&</div><div class="line">				(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>等待队列通常用在驱动程序设计中的堵塞读写操作，并不需要手动的添加节点到队列中，直接调用即可实现，具体的实现方法如下：</p>
<p>1、在设备结构体中添加等待队列头，由于读写都需要堵塞，所以添加两个队列头，分别用来堵塞写操作，写操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;linux/wait.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> mem_dev</div><div class="line">{</div><div class="line">        <span class="keyword">char</span> *data;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line">        <span class="comment">/*添加一个并行机制*/</span></div><div class="line">        spinlock_t lock;</div><div class="line"></div><div class="line">        <span class="comment">/*添加一个等待队列t头*/</span></div><div class="line">        wait_queue_head_t rdqueue;</div><div class="line">        wait_queue_head_t wrqueue;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>2、然后在模块初始化中初始化队列头:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*初始化函数*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> memdev_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">       ....</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MEMDEV_NR_DEVS; i)</div><div class="line">        {</div><div class="line">                mem_devp[i].size = MEMDEV_SIZE;</div><div class="line">                <span class="comment">/*对设备的数据空间分配空间*/</span></div><div class="line">                mem_devp[i].data = kmalloc(MEMDEV_SIZE,GFP_KERNEL);</div><div class="line">                <span class="comment">/*问题，没有进行错误的控制*/</span></div><div class="line">                <span class="built_in">memset</span>(mem_devp[i].data,<span class="number">0</span>,MEMDEV_SIZE);</div><div class="line"></div><div class="line">                <span class="comment">/*初始化定义的互信息量*/</span></div><div class="line">                <span class="comment">//初始化定义的自旋锁ua</span></div><div class="line">                spin_lock_init(&(mem_devp[i].lock));</div><div class="line">                <span class="comment">/*初始化两个等待队列头,需要注意必须用括号包含起来，使得优先级正确*/</span></div><div class="line">                init_waitqueue_head(&(mem_devp[i].rdqueue));</div><div class="line">                init_waitqueue_head(&(mem_devp[i].wrqueue));</div><div class="line">        }</div><div class="line">      ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3、确定一个具体的条件，比如数据有无，具体的条件根据实际的情况设计。</strong></p>
<pre>
/*等待条件*/
static bool havedata = false;
</pre>

<p>4、在需要堵塞的读函数，写函数中分别实现堵塞，首先定义等待队列的节点，并添加到队列中去，然后等待事件的唤醒进程。但是由于读写操作的两个等待队列都是基于条件havedata的，所以在读完成以后需要唤醒写，写完成以后需要唤醒读操作，同时更新条件havedata，最后还要移除添加的等待队列节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*read函数的实现*/</span></div><div class="line"><span class="keyword">static</span> ssize_t mem_read(<span class="keyword">struct</span> file *filp,<span class="keyword">char</span> __user *buf, size_t size,loff_t *ppos)</div><div class="line">{</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> mem_dev *dev = filp-&gt;private_data;</div><div class="line"></div><div class="line">        <span class="comment">/*参数的检查，首先判断文件位置*/</span></div><div class="line">        <span class="keyword">if</span>(p &gt;= MEMDEV_SIZE)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">/*改正文件大小*/</span></div><div class="line">        <span class="keyword">if</span>(count &gt; MEMDEV_SIZE - p)</div><div class="line">                count = MEMDEV_SIZE - p;</div><div class="line">         <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*添加一个等待队列节点到当前进程中*/</span></div><div class="line">        DECLARE_WAITQUEUE(wait_r,current);</div><div class="line"></div><div class="line">        <span class="comment">/*将节点添加到等待队列中*/</span></div><div class="line">        add_wait_queue(&dev-&gt;rdqueue,&wait_r);</div><div class="line"></div><div class="line">        <span class="comment">/*添加等待队列，本来采用if即可，但是由于信号等可能导致等待队列的唤醒，因此采用循环，确保不会出现误判*/</span></div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!havedata)</div><div class="line">        {</div><div class="line">                <span class="comment">/*判断用户是否设置为非堵塞模式读,告诉用户再读*/</span></div><div class="line">                <span class="keyword">if</span>(filp-&gt;f_flags & O_NONBLOCK)</div><div class="line">                        <span class="keyword">return</span> -EAGAIN;</div><div class="line"></div><div class="line">                <span class="comment">/*依据条件havedata判断队列的状态，防止进程被信号唤醒*/</span></div><div class="line">                wait_event_interruptible(dev-&gt;rdqueue,havedata);</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_lock(&dev-&gt;lock);</div><div class="line">        <span class="comment">/*从内核读数据到用户空间，实质就通过private_data访问设备*/</span></div><div class="line">        <span class="keyword">if</span>(copy_to_user(buf,(<span class="keyword">void</span> *)(dev-&gt;data p),count))</div><div class="line">        {</div><div class="line">                <span class="comment">/*出错误*/</span></div><div class="line">                ret = -EFAULT;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">                <span class="comment">/*移动当前文件光标的位置*/</span></div><div class="line"></div><div class="line">                *ppos = count;</div><div class="line">                ret = count;</div><div class="line"></div><div class="line">                printk(KERN_INFO <span class="string">"read %d bytes(s) from %d\n"</span>,count,p);</div><div class="line">        }</div><div class="line">      </div><div class="line">        spin_unlock(&dev-&gt;lock);</div><div class="line">	 <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*将等待队列节点从读等待队列中移除*/</span></div><div class="line">        remove_wait_queue(&dev-&gt;rdqueue,&wait_r);</div><div class="line">	<span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">        <span class="comment">/*更新条件havedate*/</span></div><div class="line">        havedata = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">/*唤醒写等待队列*/</span></div><div class="line">        wake_up_interruptible(&dev-&gt;wrqueue);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*write函数的实现*/</span></div><div class="line"><span class="keyword">static</span> ssize_t mem_write(<span class="keyword">struct</span> file *filp,<span class="keyword">const</span> <span class="keyword">char</span> __user *buf,size_t size,loff_t *ppos)</div><div class="line">{</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*获得设备结构体的指针*/</span></div><div class="line">        <span class="keyword">struct</span> mem_dev *dev = filp-&gt;private_data;</div><div class="line"></div><div class="line">        <span class="comment">/*检查参数的长度*/</span></div><div class="line">        <span class="keyword">if</span>(p &gt;= MEMDEV_SIZE)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(count &gt; MEMDEV_SIZE - p)</div><div class="line">                count = MEMDEV_SIZE - p;</div><div class="line">	  <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*定义并初始化一个等待队列节点，添加到当前进程中*/</span></div><div class="line">        DECLARE_WAITQUEUE(wait_w,current);</div><div class="line">        <span class="comment">/*将等待队列节点添加到等待队列中*/</span></div><div class="line">        add_wait_queue(&dev-&gt;wrqueue,&wait_w);</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="comment">/*添加写堵塞判断*/</span></div><div class="line">        <span class="comment">/*为何采用循环是为了防止信号等其他原因导致唤醒*/</span></div><div class="line">        <span class="keyword">while</span>(havedata)</div><div class="line">        {</div><div class="line">                <span class="comment">/*如果是以非堵塞方式*/</span></div><div class="line">                <span class="keyword">if</span>(filp-&gt;f_flags & O_NONBLOCK)</div><div class="line">                        <span class="keyword">return</span> -EAGAIN;</div><div class="line">        <span class="comment">/*分析源码发现，wait_event_interruptible 中存在DECLARE_WAITQUEUE和add_wait_queue的操作，因此不需要手动添加等待队列节点*/</span></div><div class="line">                wait_event_interruptible(&dev-&gt;wrqueue,(!havedata));</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_lock(&dev-&gt;lock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(copy_from_user(dev-&gt;data p,buf,count))</div><div class="line">                ret = -EFAULT;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">                <span class="comment">/*改变文件位置*/</span></div><div class="line">                *ppos = count;</div><div class="line">                ret = count;</div><div class="line">                printk(KERN_INFO <span class="string">"writted %d bytes(s) from %d\n"</span>,count,p);</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_unlock(&dev-&gt;lock);</div><div class="line">	</div><div class="line">	<span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*将该等待节点移除*/</span></div><div class="line">        remove_wait_queue(&dev-&gt;wrqueue,&wait_w);</div><div class="line">	<span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">        <span class="comment">/*更新条件*/</span></div><div class="line">        havedata = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">/*唤醒读等待队列*/</span></div><div class="line">        wake_up_interruptible(&dev-&gt;rdqueue);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>5、应用程序采用两个不同的进程分别进行读、写，然后检测顺序是否可以调换，检查等待是否正常。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>(转) 内存对齐</title>
        <pubTime>2015-01-19T02:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<h2 id="为什么要内存对齐">为什么要内存对齐</h2>
<p>简单的说内存对齐能够提高 cpu 读取数据的速度，减少 cpu 访问数据的出错性（有些 cpu 必须内存对齐，否则指针访问会出错）。</p>
<p>对于所有直接操作内存的程序员来说,数据对齐都是很重要的问题.数据对齐对你的程序的表现甚至能否正常运行都会产生影响.就像本文章阐述的一样,理解了对齐的本质还能够解释一些处理器的”奇怪的”行为.</p>
<h3 id="内存存取粒度">内存存取粒度</h3>
<p>程序员通常倾向于认为内存就像一个字节数组.在C及其衍生语言中,char * 用来指代”一块内存”,甚至在JAVA中也有byte[]类型来指代物理内存.</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/1.jpeg" alt=""></p>
<p>然而,你的处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存.我们将上述这些存取单位称为内存存取粒度.</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/2.jpeg" alt=""></p>
<p>高层(语言)程序员认为的内存形态和处理器对内存的实际处理方式之间的差异产生了许多有趣的问题.如果你不理解内存对齐,你编写的程序将有可能产生下面的问题,按严重程度递增:</p>
<ol>
<li>程序运行速度变慢</li>
<li>应用程序产生死锁</li>
<li>操作系统崩溃</li>
<li>你的程序会毫无征兆的出错,产生错误的结果</li>
</ol>
<h3 id="内存对齐基础">内存对齐基础</h3>
<p>为了说明内存对齐背后的原理,我们考察一个任务,并观察内存存取粒度是如何对该任务产生影响的.这个任务很简单:先从地址0读取4个字节到寄存器,然后从地址1读取4个字节到寄存器.</p>
<p>首先考察内存存取粒度为1byte的情况:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/3.jpeg" alt=""></p>
<p>这迎合了那些天真的程序员的观点:从地址0和地址1读取4字节数据都需要相同的4次操作.现在再看看存取粒度为双字节的处理器(像最初的68000处理器)的情况:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/4.jpeg" alt=""></p>
<p>从地址0读取数据,双字节存取粒度的处理器读内存的次数是单字节存取粒度处理器的一半.因为每次内存存取都会产生一个固定的开销,最小化内存存取次数将提升程序的性能.</p>
<p>但从地址1读取数据时由于地址1没有和处理器的内存存取边界对齐,处理器就会做一些额外的工作.地址1这样的地址被称作非对齐地址.由于地址1是非对齐的,双字节存取粒度的处理器必须再读一次内存才能获取想要的4个字节,这减缓了操作的速度.</p>
<p>最后我们再看一下存取粒度为4字节的处理器(像68030,PowerPC® 601)的情况:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/5.jpeg" alt=""></p>
<p>在对齐的内存地址上,四字节存取粒度处理器可以一次性的将4个字节全部读出;而在非对齐的内存地址上,读取次数将加倍.既然你理解了内存对齐背后的原理,那么你就可以探索该领域相关的一些问题了.</p>
<h3 id="懒惰的处理器">懒惰的处理器</h3>
<p>处理器对非对齐内存的存取有一些技巧.考虑上面的四字节存取粒度处理器从地址1读取4字节的情况,你肯定想到了下面的解决方法:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/6.jpeg" alt=""></p>
<p>处理器先从非对齐地址读取第一个4字节块,剔除不想要的字节,然后读取下一个4字节块,同样剔除不要的数据,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
<p>有些处理器并不情愿为你做这些工作.最初的68000处理器的存取粒度是双字节,没有应对非对齐内存地址的电路系统.当遇到非对齐内存地址的存取时,它将抛出一个异常.最初的Mac OS并没有妥善处理这个异常,它会直接要求用户重启机器.悲剧.</p>
<p>随后的680x0系列,像68020,放宽了这个的限制,支持了非对齐内存地址存取的相关操作.这解释了为什么一些在68020上正常运行的旧软件会在68000上崩溃.这也解释了为什么当时一些老Mac编程人员会将指针初始化成奇数地址.在最初的Mac机器上如果指针在使用前没有被重新赋值成有效地址,Mac会立即跳到调试器.通常他们通过检查调用堆栈会找到问题所在.</p>
<p>所有的处理器都使用有限的晶体管来完成工作.支持非对齐内存地址的存取操作会消减”晶体管预算”,这些晶体管原本可以用来提升其他模块的速度或者增加新的功能.以速度的名义牺牲非对齐内存存取功能的一个例子就是MIPS.为了提升速度,MIPS几乎废除了所有的琐碎功能.</p>
<p>PowerPC各取所长.目前所有的PowPC都硬件支持非对齐的32位整型的存取.虽然牺牲掉了一部分性能,但这些损失在逐渐减少.另一方面,现今的PowPC处理器缺少对非对齐的64-bit浮点型数据的存取的硬件支持.当被要求从非对齐内存读取浮点数时,PowerPC会抛出异常并让操作系统来处理内存对齐这样的杂事.软件解决内存对齐要比硬件慢得多.</p>
<h2 id="内存对齐的例子">内存对齐的例子</h2>
<p>在实际的编程中（以 C 语言为例），编译器都会为你自动对齐的。</p>
<p>在结构中，编译器为结构的每个成员按<strong>其自身的自然对界（alignment）条件分配空间</strong>。各个成员按照它们被声明的顺序在内存中顺序存储，<strong>第一个成员的地址和整个结构的地址相同</strong>。</p>
<p>例如，下面的结构各成员空间分配情况(假设对齐方式大于2字节,即#pragma pack(n), n = 2,4,8…下文将讨论#pragmapack())：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> test </div><div class="line">{</div><div class="line">     <span class="keyword">char</span> x1;</div><div class="line">     <span class="keyword">short</span> x2;</div><div class="line">     <span class="keyword">float</span> x3;</div><div class="line">     <span class="keyword">char</span> x4;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，即偏移地址是2的倍数。因此，编译器在x2和x1之间填充了一个空字节，将x2放在了偏移地址为2的位置。结构的第三个成员x3和第四个成员x4恰好落在其自然对界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，<strong>是该结构所有成员中要求的最大对界单元</strong>，因而test结构的自然对界条件为4字节，<strong>整个结构体的大小是最大对界单元大小的整数倍(结构体内部有结构体时也遵循这个规则，下文将提到)</strong>，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。</p>
<h3 id="#pragma_pack()">#pragma pack()</h3>
<p>该预处理指令用来改变对齐参数。在缺省情况下，C编译器为每一个变量或数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对齐参数：</p>
<pre config="brush:bash;toolbar:false;">
使用伪指令#pragma pack (n)，C编译器将按照n字节对齐。
使用伪指令#pragma pack ()，取消自定义字节对齐方式。
</pre>

<p>也可以写成：</p>
<pre config="brush:bash;toolbar:false;">
#pragma pack(push,n)
#pragma pack(pop)
</pre>

<p><code>#pragma pack (n)</code>表示每个成员的对齐单元不大于n（n为2的整数次幂）。这里规定的是上界，只影响对齐单元大于n的成员，对于对齐字节不大于n的成员没有影响。其实从字面意思，pack是“包裹，打包”的意思，#pragma pack(n)规定n个字节是一个“包裹”，个人认为实在不理解的话可以认为处理器一次性可以从内存中读/写n个字节，这样好理解。对于大小小于n的成员，当然是按照自己的对齐条件对齐，因为不论怎么放都可以一次性取出。对于对齐条件大于n个字节的成员，成员按照自身的对齐条件对齐和按照n字节对齐需要相同的读取次数，但按照n字节对齐节省空间，何乐而不为呢。</p>
<h3 id="结构体内成员如何找出自己的位置">结构体内成员如何找出自己的位置</h3>
<p>看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> pack(8)</span></div><div class="line"><span class="keyword">struct</span> s1</div><div class="line">{</div><div class="line">    <span class="keyword">short</span> a;</div><div class="line">    <span class="keyword">long</span> b;</div><div class="line">};</div><div class="line"><span class="keyword">struct</span> s2</div><div class="line">{</div><div class="line">    <span class="keyword">short</span> c;</div><div class="line">    s1 d;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e;</div><div class="line">};</div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> pack()</span></div></pre></td></tr></table></figure>

<p>成员对齐有一个重要的条件：每个成员分别对齐。即每个成员按自己的方式对齐.</p>
<p>也就是说上面虽然指定了按8字节对齐，但并不是所有的成员都是以8字节对齐。其对齐的规则是，每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是8字节)中较小的一个对齐。并且结构的长度必须为所用过的所有对齐参数的整数倍(只要是最大的对齐参数的整数倍即可)，不够就补空字节(视编译器而定)。</p>
<p>S1中，成员a是2字节默认按2字节对齐，指定对齐参数为8，这两个值中取2，a按2字节对齐；成员b是4个字节，默认是按4字节对齐，这时就按4字节对齐，a后补2个字节后存放b，所以sizeof(S1)应该为8。8是4的倍数，满足上述的第3条规则。</p>
<p>S2中，c和S1中的a一样，按2字节对齐，而d是个结构，它是8个字节，它按什么对齐呢?对于结构来说，它的默认对齐方式就是该结构定义(声明)时它的所有成员使用的对齐参数中最大的一个，S1的是4，小于指定的8。所以成员d就是按4字节对齐，c后补2个字节，后面是8个字节的结构体d。成员e是8个字节，它是默认按8字节对齐，和指定的一样，所以它对到8字节的边界上，这时，已经使用了12个字节了，所以d后又补上4个字节,从第16个字节开始放置成员e。这时，长度为24，已经可以被最大对齐参数8(成员e按8字节对齐)整除。这样，一共使用了24个字节。</p>
<p>如果上面那段代码，如果去掉 #pragma pack 的话，应该是这样的： （未完待续）</p>
<p>原始出处：<br><a href="http://blog.csdn.net/lgouc/article/details/8235471" title="为什么要内存对齐" target="_blank" rel="external">为什么要内存对齐</a><br><a href="http://blog.csdn.net/lgouc/article/details/8235616" title="关于内存对齐" target="_blank" rel="external">关于内存对齐</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ctags%20tag%20%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ctags tag 文件错误问题</title>
        <pubTime>2015-01-19T02:16:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>有些时候用 ctags 打出来的 tag，在 vim 里跳转用的时候，有些会报什么 tag 文件格式错误，然后跳转无效的问题。我遇到好几次了，公司的电脑，自己的电脑。今天突发奇想，打开 tag 文件看了一下，发现文件开头有这么一段：</p>
<pre config="brush:bash;toolbar:false;">
                                int  hash_idx,
                                int  iteration_count,  
                      unsigned char *out,
                      unsigned long  password_len, 
                      unsigned long *outlen)
                const unsigned char *salt, 
!_TAG_FILE_FORMAT   2   /extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED   1   /0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR    Darren Hiebert  /dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME  Exuberant Ctags //
!_TAG_PROGRAM_URL   http://ctags.sourceforge.net    /official site/
!_TAG_PROGRAM_VERSION   5.9~svn20110310 //
"   external/chromium_org/third_party/WebKit/PerformanceTests/SunSpider/tests/sunspider-0.9.1/string-tagcloud.js    /^            '\\r': '\\\\r',$/;"   p
"   external/chromium_org/third_party/WebKit/PerformanceTests/SunSpider/tests/sunspider-0.9/string-tagcloud.js  /^            '\\r': '\\\\r',$/;"   p
"   external/chromium_org/third_party/WebKit/PerformanceTests/SunSpider/tests/sunspider-1.0/string-tagcloud.js  /^            '\\r': '\\\\r',$/;"   p
#1  external/dropbear/libtomcrypt/crypt.tex /^  {                   % THESE headers.$/;"    s
#::B    external/chromium_org/third_party/JSON/JSON-2.59/blib/lib/JSON/backportPP/Compat5005.pm /^    sub B::SVp_IOK () { 0x01000000; }$/;" s
#::B    external/chromium_org/third_party/JSON/JSON-2.59/blib/lib/JSON/backportPP/Compat5005.pm /^    sub B::SVp_NOK () { 0x02000000; }$/;" s
#::B    external/chromium_org/third_party/JSON/JSON-2.59/blib/lib/JSON/backportPP/Compat5005.pm /^    sub B::SVp_POK () { 0x04000000; }$/;" s
</pre>

<p>那几段打 ！ 应该是注释（我不会 ctags 的语法，自己猜的），然后下面应该是真实的记录函数、变量位置的数据了。那么前面那几段感觉就怪怪，于是我尝试把那几段删掉，果然 vim 里面的跳转就能用了。</p>
<p>有些时候就要多猜，呵呵。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/reinterpret_cast%E3%80%81static_cast%20%E5%92%8C%20dynamic_cast%20%E7%9A%84%E5%8C%BA%E5%88%AB/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>reinterpret_cast、static_cast 和 dynamic_cast 的区别</title>
        <pubTime>2015-01-19T02:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>reinterpret_cast 可以转换任意一个32bit整数，包括所有的指针和整数。可以把任何整数转成指针，也可以把任何指针转成整数，以及把指针转化为任意类型的指针，威力最为强大！但不能将非32bit的实例转成指针。总之，只要是32bit的东东，怎么转都行！</p>
<p>static_cast 和 dynamic_cast 可以执行指针到指针的转换，或实例本身到实例本身的转换，但不能在实例和指针之间转换。static_cast 只能提供编译时的类型安全，而 dynamic_cast 可以提供运行时类型安全。举个例子：</p>
<pre> 
class a;
class b:a;
class c 
</pre>

<p>上面三个类a是基类，b继承a，c和ab没有关系。有一个函数 void function(a&amp; a); 现在有一个对象是b的实例b，一个c的实例c。function(static_cast<a&>(b)) 可以通过而 function(static<a&>(c)) 不能通过编译，因为在编译的时候编译器已经知道c和a的类型不符，因此 static_cast 可以保证安全。 </a&></a&></p>
<p>下面我们骗一下编译器，先把c转成类型a </p>
<pre>
b& ref_b = reinterpret_cast<b&>c;
</b&></pre>

<p>然后 function(static_cast<a&>(ref_b)) 就通过了！因为从编译器的角度来看，在编译时并不能知道ref_b实际上是c！ 而 function(dynamic_cast<a&>(ref_b)) 编译时也能过，但在运行时就失败了，因为 dynamic_cast 在运行时检查了 ref_b 的实际类型，这样怎么也骗不过去了。</a&></a&></p>
<p>在应用多态编程时，当我们无法确定传过来的对象的实际类型时使用 dynamic_cast，如果能保证对象的实际类型，用 static_cast 就可以了。至于 reinterpret_cast，我很喜欢，很象c语言那样的暴力转换。</p>
<p>总结一下：</p>
<p><strong>dynamic_cast</strong>: 动态类型转换，一般用在父类和子类指针或应用的互相转化。<br><strong>static_cast</strong>: 静态类型转换，一般是普通数据类型(如: int m=static_cast<int>(3.14))<br><strong>reinterpret_cast</strong>: 重新解释类型转换，很像c的一般类型转换操作<br><strong>const_cast</strong>: 常量类型转换，是把cosnt或volatile属性去掉 </int></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%2010.10%20%E5%AE%89%E8%A3%85%20jdk/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 10.10 安装 jdk</title>
        <pubTime>2015-01-19T01:59:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<ul>
<li><p>在 /etc/apt/sources.list 里新建一个源文件：</p>
<pre>
deb  http://archive.canonical.com/ubuntu maverick partner
</pre>

<ul>
<li><p>然后 apt-get update —&gt; apt-get install sun-java6-jdk 。</p>
</li>
<li><p>值得注意的是，默认ubuntu10.10已经安装了open-JDK 可以使用java -version命令查看，当前默认使用的JDK是哪个类型的。如果直接卸载了openJDK软件包，再使用java -version命令，系统还是使用的open-JDK，这时需要修改ubuntu默认使用JDK的配置，配置默认Java使用哪个</p>
</li>
</ul>
</li>
</ul>
<pre>
sudo update-alternatives –config java  
</pre>

<p>选择“2”，再查看系统使用java的版本。注意：wordpress不好的地方就是在写代码时，经常会修改代码里的内容，上面在sudo update-alternatives –config java这句，config前面是两个“-”,wordpress会显示为一个长“-”。</p>
<ul>
<li><p>更新下 13.04 安装 sun jdk 的方法： </p>
<ul>
<li><p>如果安装了 open jdk 的，要先把 open jdk 卸掉： apt-get purge openjdk*</p>
</li>
<li><p>添加 sun java 源： add-apt-repository ppa:webupd8team/java （如果有问题可以先安装： apt-get install software-properties-common ），然后更新源列表： apt-get update</p>
</li>
<li><p>然后就可以安装 jdk 了： apt-get install oracle-java7-installer（这里装的是7，也可以安装6或是8 oracle-java6-installer, oralce-java8-installer）</p>
</li>
<li><p>如果要卸载之前安装的 sun jdk，用 apt-get purge oracle-java<em> 就行了，不要用 apt-get purge java</em> ，这样能删掉很多别的东西的。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>ubuntu 13.10 之后软件源里面就没 oracle-java6-installer 了，但是如果是编译 android 的话，必须要 jdk6 才行。所以只能去 oracle 官网去下载： <a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html#jdk-6u45-oth-JPR" target="_blank" rel="external">oracle jdk6</a>。 我选的是 *.rpm.bin 下载的（下载还必须要注册 oracle 的帐号才能下，恶心）。然后就是手动安装了。</p>
<ul>
<li><p>先是 chmod+x <em>.rpm.bin ，给这个玩意加上执行权限，然后执行一下，会解压出很多 </em>.rpm 包出来，可能这个东西会自动安装的吧，但是在我到机子上报错了，所以我只好手动安装这票 rpm 包了。</p>
</li>
<li><p>先要装 alien (apt-get install alien)，然后用 alien 把这些 rpm 包转化为 deb 包： alien —scripts —keep-version -d *.rpm 。耐心等一下，就会转化好 deb 包。</p>
</li>
<li><p>安装转化好到 deb 包： dpkg -i *.deb 。就终于装好 oracle-jdk-6 了。</p>
</li>
</ul>
</li>
</ul>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%2014.04%20%E5%AE%89%E8%A3%85%20winusb/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 14.04 安装 winusb</title>
        <pubTime>2015-01-19T02:25:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>今天 win8 突然蓝屏启动不了，说什么 boot File:\BCD 损坏了，我擦，搞什么飞机。只好切换到 ubuntu 下想办法制作个 win8.1 的启动盘修复一下。</p>
<p>度娘了一下，发现 ubuntu 下有个叫 winusb 的软件可以制作 win 的启动盘，但是 14.04 没有对应的源（或者话说被屏蔽掉了）。然后 google 了一个老外的办法，手动安装：</p>
<p>64 bit 的：</p>
<pre config="brush:bash;toolbar:false;">
wget https://launchpad.net/~colingille/+archive/freshlight/+files/winusb_1.0.11+saucy1_amd64.deb
</pre>

<p>32 bit 的：</p>
<pre config="brush:bash;toolbar:false;">
wget https://launchpad.net/~colingille/+archive/freshlight/+files/winusb_1.0.11+saucy1_i386.deb
</pre>

<p>然后：</p>
<pre config="brush:bash;toolbar:false;">
sudo dpkg -i winusb_1.0.11+saucy1*
</pre>

<p>然后好像会出错的，然后再修复下依赖关系：</p>
<pre config="brush:bash;toolbar:false;">
sudo apt-get -f install
</pre>

<p>最后修复依赖关系那会让你装一堆东西，装就行，中间好像让你装 GRUB，然后让你选安装的地方，按 esc 退出去，然后选 yes 不安装 GRUB，这个东西别乱选，不然把 ubuntu 的引导都搞坏了就麻烦了（我的 window 已经歇菜了）。</p>
<p>然后命令行 winusbgui 就可以启动带 gui 的 winusb 了，用起来挺简单的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/winusb/1.png" alt=""></p>
<p>最后说一句，NND，电脑上多装一个系统还是保险点，无缘无故给老子启动文件损坏，操，操~~ &gt;_&lt;</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20libtool%20%E9%94%99%E8%AF%AF/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu libtool 错误</title>
        <pubTime>2015-01-19T02:01:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>使用Ubuntu 8.04以上版本的同事在编译咱们的产品的时候可能会遇到类似如下错误：</p>
<pre config="brush:bash;toolbar:false;">
../libtool: line 841: X--tag=CC: command not found
../libtool: line 874: libtool: ignoring unknown tag : command not found
../libtool: line 841: X--mode=link: command not found
../libtool: line 1008: *** Warning: inferring the mode of operation is deprecated.: command not found
../libtool: line 1009: *** Future versions of Libtool will require --mode=MODE be specified.: command not found
../libtool: line 2253: X-g: command not found
../libtool: line 2253: X-Wall: command not found
../libtool: line 2253: X-I/home/cos/target/pc-ths/include: No such file or directory
../libtool: line 2253: X-I/home/cos/build/pc-ths/include: No such file or directory
../libtool: line 2253: X-Wall: command not found
../libtool: line 2253: X-Wstrict-prototypes: command not found
../libtool: line 2253: X-pipe: command not found
../libtool: line 1967: X-L/home/cos/target/pc-ths/lib: No such file or directory
../libtool: line 1967: X-L/home/cos/build/pc-ths/lib: No such file or directory
../libtool: line 2216: X-Wl,-rpath-link=/home/cos/build/pc-ths/lib: No such file or directory
</pre>

<p>我们知道有一种解决方法是在运行autogen.sh和configure后，修改configure生成的libtool文件，将其中的ECHO修改为echo，然后make;make install即可。</p>
<p>在网上找到另外一种方法， 就是用autoreconf代替autogen.sh，方法如下:</p>
<pre>
autoreconf -i
configure
make
make install
</pre>

<p><a href="http://www.gossamer-threads.com/lists/clamav/devel/41623" target="_blank" rel="external">参考网址</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20minicom%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu minicom 使用问题总结</title>
        <pubTime>2015-01-19T01:57:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="键盘无法输入">键盘无法输入</h2>
<p>一般来说 每秒位数/奇偶校验/位数 设置成 xxxx 8N1 就可以了的，但是有些时候还是不能输入命令。这个时候可以尝试把 硬件流控制（Hardware Flow Control），软件流控制（Software Flow Control） 关掉（设置成 off），就可以输入了。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20virtual%20box%20%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu virtual box 问题小结</title>
        <pubTime>2015-01-19T02:14:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="usb">usb</h2>
<p>要在虚拟机中使用 usb 设置（烧录接口）： </p>
<ul>
<li><p>需要先安装 Extension Pack（注意版本要和 virtual box 的版本对应）。最好去虚拟机里把 guset addiations 也装了。</p>
</li>
<li><p>查看下 /etc/group ，看看自己的用户有没有在 vboxusers 这个组下面，如果没在的话，把自己的用户加到这个用户组下面： usermod -a -G group1 user1</p>
</li>
<li><p>在 Settings —&gt; Usb —&gt; Enable USB Controller (USB 2.0) 都勾上。</p>
</li>
</ul>
<p>然后在虚拟机的 Usb devices 下面就可以勾选要使用的 usb 设置了。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 使用问题总结</title>
        <pubTime>2015-01-19T01:54:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="激活_root_账号">激活 root 账号</h2>
<p>默认 root 账号是不能切换和登陆的，只能用 sudo 来了临时获取一个命令的 root 执行权限。有些时候为了方便可以激活 root</p>
<p>账号。 sudo passwd root ，设置一个密码就可以了。</p>
<h2 id="中文输入安装之后无法调出">中文输入安装之后无法调出</h2>
<p>安装了 ibus 无法调出，一般是 ibus demon 没启动，然后输入法也没设置为中文。ibus-setup 可以调出输入法设置，然后把</p>
<p>中文输入法设置好。不过要想个办法让 ibus demon 自动启动（没启动的，ibus-setup 守护进程就启动了）。可以装一个 im-swtich 然后设置默认输入法为 ibus</p>
<h2 id="自动挂载_ntfs_分区">自动挂载 ntfs 分区</h2>
<p>一般来说安装了双系统（window、ubuntu），window 的 ntfs 分区，ubuntu 会默认挂载。可读写，但是无法使用 git 和 repo，因为挂载的权限不太对。同理，移动硬盘的如果也是使用 ntfs 分区的话，也会有这个问题（拿移动硬盘存 android mirror 就会遇到这些问题了）。这个时候可以安装 ntfs-config 这个软件来，然后 sudo 运行，勾选 mount 成可读、写的，然后 auto-config 一下就行了。</p>
<p>然后在 /etc/fstab 会记录 mount 的路径。可以自己编辑的，把自己的 window 分区挂载到自己指定的目录（这个目录要自己提前 mkdir 建好，不然无法挂载的），同理移动硬盘的分区可以自己指定路径的，像下面这样（这样 mount 路径固定，写某些脚本会方便点，不然时不时变一下 mount 路径，烦得很）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/fstab: static file system information.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></div><div class="line"></div><div class="line"><span class="comment">#Entry for /dev/sdc7 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">0</span>cc75462-fe83-<span class="number">4928</span>-bdd9-<span class="number">514750</span>e91f7f   /   ext4    <span class="variable">errors=</span>remount-ro   <span class="number">0</span>   <span class="number">1</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_gpt3 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">5</span>f0a43bf-<span class="number">72</span>d5-<span class="number">45</span>f1-<span class="number">9</span>c66-c5a355ca454a   /boot   ext4    defaults    <span class="number">0</span>   <span class="number">2</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_gpt1 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">6483</span>-<span class="number">74</span>C9  /boot/efi   vfat    defaults    <span class="number">0</span>   <span class="number">1</span></div><div class="line"><span class="comment">#Entry for /dev/sdc8 :</span></div><div class="line"><span class="variable">UUID=</span>b2317adb-c3a3-<span class="number">4608</span>-af58-<span class="number">78</span>b9d8a836dd   /home   ext4    defaults    <span class="number">0</span>   <span class="number">2</span></div><div class="line"><span class="comment">#Entry for /dev/sdc6 :</span></div><div class="line"><span class="comment">#UUID=F084F63784F60040  /media/BIOS_RVY ntfs-3g defaults,locale=en_US.UTF-8 0   0</span></div><div class="line"><span class="comment">#Entry for /dev/sdc2 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">5046</span>ED5746ED3DFA   /media/local/collect    ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/sdc4 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">64</span>C626E5C626B768   /media/local/game   ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_data2 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">32</span>D67187D6714BDB   /media/local/ssd    ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_gpt4 :</span></div><div class="line"><span class="comment">#UUID=E6C0F9E8C0F9BF3D  /media/local/win    ntfs-3g defaults,locale=en_US.UTF-8 0   0</span></div><div class="line"><span class="comment">#Entry for /dev/sdc3 :</span></div><div class="line"><span class="variable">UUID=</span>BAC60DBFC60D7D3F   /media/local/work   ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#Entry for /dev/sdd3 :</span></div><div class="line"><span class="variable">UUID=</span>E214EC8C14EC64CF   /media/removable/media  ntfs-<span class="number">3</span>g defaults,nosuid,nodev,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span>    <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/sdd2 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">27</span>E4DC5E2CC9645D   /media/removable/other  ntfs-<span class="number">3</span>g defaults,nosuid,nodev,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span>    <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/sdd1 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">66118</span>DF048E7A1EE   /media/removable/work   ntfs-<span class="number">3</span>g defaults,nosuid,nodev,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span>    <span class="number">0</span>   <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#Entry for /dev/sdc5 :</span></div><div class="line"><span class="variable">UUID=</span>d1143252-<span class="number">352</span>a-<span class="number">4</span>c36-<span class="number">8560</span>-d35c8661089a   none    swap    sw  <span class="number">0</span>   <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#UUID=F084F63784F60040  /media/BIOS_RVY ntfs-3g defaults,locale=en_US.UTF-8 0   0</span></div></pre></td></tr></table></figure>

<p>然后注意下 UUID 不要去动 ntfs-config 自动生成的（UUID 是每一个硬盘分区的识别号），当然如果生成有错误，可以用下面2个命令查看：</p>
<pre>
blkid -s UUID

ls -l /dev/disk/by-uuid
</pre>

<p>然后有些时候 window 的 ntfs 分区会挂载失败，然后出来下面的错误：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/ubuntu-memos/unable-mount.png" alt="" title="挂载错误"></p>
<p>这个时候可以用 sudo ntfsfix -d xx（xx 就是图中报错的那个 device： /dev/sdc3，这个用上面那个2个命令也可以看得到的）。一般来说输出修复成功就可以挂载了。如果还是实在不行，网上有人话说是因为 win8 的快速启动导致 ntfs 分区没有被 window 完全卸载导致的。实在不行，尝试把 win8 的快速启动关掉吧。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20%E5%BC%80%E5%90%AF%20ftp%20%E6%9C%8D%E5%8A%A1/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 开启 ftp 服务</title>
        <pubTime>2015-01-19T02:03:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="安装vsftpd">安装vsftpd</h2>
<p>直接从源里面安装：</p>
<pre>
sudo apt-get install vsftpd
</pre>

<p>安装完毕后或许会自动生成一个帐户”ftp”，/home下也会增加一个文件夹。<br>如果没有生成这个用户的话可以手动来，生成了就不用了：</p>
<pre>
sudo useradd -m ftp
sudo passwd ftp
</pre>

<p>有”ftp”帐户后还要更改权限：</p>
<pre>
sudo chmod 777 /home/ftp
</pre>

<p>在这个目录下我建立一个文件夹专门保存需要共享的内容</p>
<h2 id="配置文件">配置文件</h2>
<p>通过sudo gedit /etc/vsftpd.conf修改。配置文件比较简单，如下：</p>
<pre config="brush:bash;toolbar:false;">
#独立模式启动
listen=YES

#同时允许4客户端连入，每个IP最多5个进程
max_clients=200
max_per_ip=4

#不允许匿名用户访问，允许本地（系统）用户登录
anonymous_enable=NO
local_enable=YES
write_enable=NO

#是否采用端口20进行数据传输
connect_from_port_20=YES

#生成日志
xferlog_enable=YES

#指定登录转向目录
local_root=/home/ftp/ftp
</pre>

<p>这样，在同局域网的电脑上，用我的IP地址，用帐号”ftp”和对应密码就可以登录了，密码是第一步里面passwd那句指定的。就这样就结束了，请大家拍砖！！对了，更改配置后不要忘了重启ftp服务：</p>
<pre>
sudo /etc/init.d/vsftpd restart
</pre>

<p>此外还有开启关闭服务的命令：</p>
<pre>
sudo /etc/init.d/vsftpd start
sudo /etc/init.d/vsftpd stop
</pre>

]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%9D%99%E6%80%81%E5%BA%93%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>交叉编译静态库常见问题</title>
        <pubTime>2015-01-19T02:07:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>交叉编译静态库，会遇到一些比较郁闷的问题，现在总结一下。</p>
<h2 id="编译库">编译库</h2>
<p>编译静态库的时候，一般不要指定 LDFLAGS 中的 -lxx 去链接某个库（可以设置 -Lxx 链接库的路径）。因为好像指定的话，它老会去链接某些依赖库的 .so（假设之前你这些库都是编成 .a 的）。</p>
<h2 id="编译应用程序">编译应用程序</h2>
<p>编译应用程序的时候，需要以下几个问题：</p>
<ul>
<li><p>这个时候一般需要指定 LDFLAGS 中的 -lxx （这个结合上面说的，可以在编译脚本里定义几个命令：编译库时候 unset xx ，编译应用程序时 export xx）。</p>
</li>
<li><p>注意 -lxx 链接库时的先后顺序。有些时候会出现某些依赖库找不到另外一些依赖库中定义的符号的问题，这个时候就是 -lxx 的顺序不对。动态库是无所谓顺序的，但是静态库一般来说所依赖的库还放到后面去链接。</p>
</li>
<li><p>有些时候就算按照上面的设置了，编应用程序的时候它还是会去链接依赖库的 .so 文件。这个时候可以把依赖库的 .la （所有的，一个不能留）文件移开（但是注意要是重新编译依赖库的时候需要把这些 .la 文件还远回去）。</p>
</li>
</ul>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%E4%BD%BF%E7%94%A8%20pkg-config/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>使用 pkg-config</title>
        <pubTime>2015-01-19T01:51:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>有的使用了共享库的程序，在编译和连接时都很顺利，但是在运行时却发生了找不到共享库的问题，其原因就是库的搜索路径没有设置，或者设置不正确。一般来说，如果库的头文件不在 /usr/include 目录中，那么在编译的时候需要用 -I 参数指定其路径。由于同一个库在不同系统上可能位于不同的目录下，用户安装库的时候也可以将库安装在不同的目录下，所以即使使用同一个库，由于库的路径的 不同，造成了用 -I 参数指定的头文件的路径也可能不同，其结果就是造成了编译命令界面的不统一。如果使用 -L 参数，也会造成连接界面的不统一。编译和连接界面不统一会为库的使用带来麻烦。</p>
<p>为了解决编译和连接界面不统一的问题，人们找到了一些解决办法。其基本思想就是：事先把库的位置信息等保存起来，需要的时候再通过特定的工具将其中 有用的信息提取出来供编译和连接使用。这样，就可以做到编译和连接界面的一致性。</p>
<h2 id="pkg-config">pkg-config</h2>
<p>其中，目前最为常用的库信息提取工具就是下面介绍的 pkg-config。pkg-config 是通过库提供的一个 .pc 文件获得库的各种必要信息的，包括版本信息、编译和连接需要的参数等。这些信息可以通过 pkg-config 提供的参数单独提取出来直接供编译器和连接器使用。</p>
<p>在默认情况下，每个支持 pkg-config 的库对应的 .pc 文件在安装后都位于安装目录中的 lib/pkgconfig 目录下。例如，我们在上面已经将 gstreamer 安装在 /usr/lib/gstreamer 目录下了，那么这个 gstreamer 库对应的 .pc 文件是 /usr/lib/pkgconfig 目录下一个叫 gtreamer-0.10.pc 的文件。</p>
<pre config="brush:bash;toolbar:false;">

prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include/gstreamer-0.10
toolsdir=${exec_prefix}/bin
pluginsdir=${exec_prefix}/lib/gstreamer-0.10
gstcontrol_libs=-lgstcontrol-0.10

Name: GStreamer
Description: Streaming media framework
Requires: glib-2.0, gobject-2.0, gmodule-no-export-2.0, gthread-2.0, libxml-2.0
Version: 0.10.18
Libs: -L${libdir} -lgstreamer-0.10
Cflags: -I${includedir}

</pre>

<p>大概可以看得出是怎么回事了。</p>
<h2 id="使用方法">使用方法</h2>
<p>使用 pkg-config 的 —cflags 参数可以给出在编译时所需要的选项，而 —libs 参数可以给出链接时的选项。例如，假设一个 sample.c 的程序用到了 gstreamer 库，就可以这样编译：</p>
<pre config="brush:bash;toolbar:false;">

//先这样编译（注意是键盘上数字键1旁边的`，不是单引号'）：
$ gcc -c `pkg-config --cflags gstreamer-0.10` sample.c

//然后这样链接：
$ gcc sample.o -o sample `pkg-config --libs gstreamer-0.10`

//或者上面两步也可以合并为以下一步：
$ gcc sample.c -o sample `pkg-config --cflags --libs gstreamer-0.10`

</pre>

<p>可以看到：由于使用了 pkg-config 工具来获得库的选项，所以不论库安装在什么目录下，都可以使用相同的编译和连接命令，带来了编译和连接界面的统一。使用 pkg-config 工具提取库的编译和连接参数有两个基本的前提：库本身在安装的时候必须提供一个相应的 .pc 文件。不这样做的库说明不支持 pkg-config 工具的使用。</p>
<p>pkg-config 必须知道要到哪里去寻找此 .pc 文件。一般来所某些库会指定一个环境变量来寻找 .pc 文件，例如gstreamer就是哟你 PKG_CONFIG_PATH 来寻找的。可以用 export PKG_CONFIG_PATH=XX 设置 .pc 文件的路径。</p>
<h2 id="我的makefile">我的makefile</h2>
<p>这样一来我之前用的makefile模板就可以改成这样啦：</p>
<pre config="brush:bash;toolbar:false;">
#This Makefile is created by mingming-killer

SRCS := $(wildcard *.c)
DEPS := $(SRCS:.c=.d)
OBJS := $(SRCS:.c=.o)

APP = app


CC = gcc
LDFLAGS = `pkg-config --libs gstreamer-0.10` -L$(LIB_PATH) $(LIBS)
CFLAGS = `pkg-config --cflags gstreamer-0.10` -I$(INCLUDE_PATH)
LIBS = -lpthread -lminigui_ths -lm -ljpeg -lpng
LIB_PATH = /usr/local/lib
INCLUDE_PATH = /usr/local/include


# if "make clean" do not create the depend file
ifneq ($(MAKECMDGOALS), clean)

%d: %c
    $(CC) -MM $< > $@

endif



$(APP): $(OBJS)
    $(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)


-include $(DEPS)




.PHONY: clean 
clean:
    -rm -f debug $(APP) $(wildcard *.o ./tmp/*.d *.d *~)
    @echo "it is cleaning."
</pre>

<p>autoconf、automake的工具暂时还不会用，又不像mg-sample那样可以替换里面的文件来直接使用，而且又只是小程序，所以还是用个makefile来搞定吧 ^_^ 。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%20Patch%20%E8%A1%A5%E4%B8%81/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>如何生成 Patch 补丁</title>
        <pubTime>2015-01-19T02:12:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>一般有 2 种方式：</p>
<h2 id="2个文件夹生成_patch">2个文件夹生成 patch</h2>
<p>在2个文件夹之前生成 patch 使用 diff -Nur a b 命令（a、b 2个文件夹）。注意，这样生成 patch 的时候，要把一些不需要的临时文件清理掉（例如 tag、编译的中间文件等），这样才能保证 patch 是干净的。可以重定向到 xx.patch 文件，这样 patch 就生成好了。</p>
<h2 id="git_仓库不同版本生成_patch">git 仓库不同版本生成 patch</h2>
<p>在 git 仓库的不同版本间生成 patch 使用 git diff commita commitb 命令。commit 是每个 git 版本的那一串很长的数字。不过注意这个只能比较已经提交了的。例如说，这个命令如果什么都参数都不加的话，就是比较当前 git 版本和现在 git 仓库代码的区别。不过如果你当前新加入了一些文件，是 diff 不出来的，需要提交以后才能 diff 。这个也是可以通过重定向到 xx.patch 文件的。</p>
<h2 id="git_commit_修改了二进制文件">git commit 修改了二进制文件</h2>
<p>上面那个 git diff 生成的 patch 是普通的文本 patch，用 vi 就可以看到 patch 的内容。但是这种方式不适用于修改了二进制文件的提交（例如修改了图片）。这种文本 patch 无法包含二进制文件的修改的。所以这个时候就使用：</p>
<pre>
git diff --binary commita commitb > xx.patch 
</pre>

<p>来生成二进制形式的 patch。这种 patch 要使用 git apply patch 来打。打之前可以使用 git apply —check patch 来检测 patch 是否有错误。有些时候打 patch 会出现一些空白符号的警告错误，不用理会就行。</p>
<p>有些时候 git diff a b 生成的 patch 会有点不对（你不加 binary 去看 patch 能看出来，patch 多改了一些东西）。如果只是单个 commit 的 patch 可以使用:</p>
<pre>
git show --binary commit > xx.patch
</pre>

<p>来生成 patch，这样就对了（其实只要能打出 diff 的命令都可以生成 patch）。</p>
<h2 id="总结">总结</h2>
<p>以上 2 种方式打出来的 patch 都是 p1 的，还有这个 px 的问题，需要在打 patch 的时候注意。</p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/1986/12/20/%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>文章索引</title>
        <pubTime>1986-12-19T16:00:16.000Z</pubTime>
        
         <content><![CDATA[<h2 id="Linux">Linux</h2>
<p><a href="http://light3moon.com/2015/01/10/Linux 命令备忘" title="Linux 命令备忘" target="_blank" rel="external">Linux 命令备忘</a><br><a href="http://light3moon.com/2015/01/11/VI 命令备忘" title="VI 命令备忘" target="_blank" rel="external">VI 命令备忘</a><br><a href="http://light3moon.com/2015/01/11/GDB 命令备忘" title="GDB 命令备忘" target="_blank" rel="external">GDB 命令备忘</a><br><a href="http://light3moon.com/2015/01/13/Git 使用备忘" title="Git 使用备忘" target="_blank" rel="external">Git 使用备忘</a><br><a href="http://light3moon.com/2015/01/13/Git 使用备忘" title="Rsa 验证简介" target="_blank" rel="external">Rsa 验证简介</a><br><a href="http://light3moon.com/2015/01/13/Repo 命令备忘" title="Repo 命令备忘" target="_blank" rel="external">Repo 命令备忘</a><br><a href="http://light3moon.com/2015/01/13/Gitweb" title="Gitweb" target="_blank" rel="external">Gitweb</a><br><a href="http://light3moon.com/2015/01/13/Linux shell 环境脚本分析" title="Linux shell 环境脚本分析" target="_blank" rel="external">Linux shell 环境脚本分析</a><br><a href="http://light3moon.com/2015/01/19/Linux Shell 进阶环境脚本分析" title="Linux Shell 进阶环境脚本分析" target="_blank" rel="external">Linux Shell 进阶环境脚本分析</a><br><a href="http://light3moon.com/2015/01/19/BBK 工作编译脚本分析" title="BBK 工作编译脚本分析" target="_blank" rel="external">BBK 工作编译脚本分析</a><br><a href="http://light3moon.com/2015/01/19/使用 pkg-config" title="使用 pkg-config" target="_blank" rel="external">使用 pkg-config</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 使用问题总结" title="ubuntu 使用问题总结" target="_blank" rel="external">ubuntu 使用问题总结</a><br><a href="http://light3moon.com/2015/01/19/ubuntu minicom 使用问题总结" title="ubuntu minicom 使用问题总结" target="_blank" rel="external">ubuntu minicom 使用问题总结</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 10.10 安装 jdk" title="ubuntu 10.10 安装 jdk" target="_blank" rel="external">ubuntu 10.10 安装 jdk</a><br><a href="http://light3moon.com/2015/01/19/ubuntu libtool 错误" title="ubuntu libtool 错误" target="_blank" rel="external">ubuntu libtool 错误</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 开启 ftp 服务" title="ubuntu 开启 ftp 服务" target="_blank" rel="external">ubuntu 开启 ftp 服务</a><br><a href="http://light3moon.com/2015/01/19/交叉编译静态库常见问题" title="交叉编译静态库常见问题" target="_blank" rel="external">交叉编译静态库常见问题</a><br><a href="http://light3moon.com/2015/01/19/如何生成 Patch 补丁" title="如何生成 Patch 补丁" target="_blank" rel="external">如何生成 Patch 补丁</a><br><a href="http://light3moon.com/2015/01/19/ubuntu virtual box 问题小结" title="ubuntu virtual box 问题小结" target="_blank" rel="external">ubuntu virtual box 问题小结</a><br><a href="http://light3moon.com/2015/01/19/ctags tag 文件错误问题" title="ctags tag 文件错误问题" target="_blank" rel="external">ctags tag 文件错误问题</a><br><a href="http://light3moon.com/2015/01/19/[转] gimp中如何查看拾色器拾取的颜色的alpha值" title="[转] gimp中如何查看拾色器拾取的颜色的alpha值" target="_blank" rel="external">[转] gimp中如何查看拾色器拾取的颜色的alpha值</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 14.04 安装 winusb" title="ubuntu 14.04 安装 winusb" target="_blank" rel="external">ubuntu 14.04 安装 winusb</a> </p>
<h2 id="Basics_Knowledge">Basics Knowledge</h2>
<p><a href="http://light3moon.com/2015/01/19/[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" title="[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" target="_blank" rel="external">[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</a><br><a href="http://light3moon.com/2015/01/19/reinterpret_cast、static_cast 和 dynamic_cast 的区别" title="reinterpret_cast、static_cast 和 dynamic_cast 的区别" target="_blank" rel="external">reinterpret_cast、static_cast 和 dynamic_cast 的区别</a><br><a href="http://light3moon.com/2015/01/19/[转] 内存对齐" title="[转] 内存对齐" target="_blank" rel="external">[转] 内存对齐</a><br><a href="http://light3moon.com/2015/01/19/Endianness" title="Endianness" target="_blank" rel="external">Endianness</a><br><a href="http://light3moon.com/2015/01/19/[转] float 类型在内存中的表示" title="[转] float 类型在内存中的表示" target="_blank" rel="external">[转] float 类型在内存中的表示</a> </p>
<h2 id="MiniGUI">MiniGUI</h2>
<p><a href="http://light3moon.com/2015/01/19/MiniGUI 自定义控件教程1" title="MiniGUI 自定义控件教程1" target="_blank" rel="external">MiniGUI 自定义控件教程1</a><br><a href="http://light3moon.com/2015/01/19/MiniGUI 自定义控件教程2" title="MiniGUI 自定义控件教程2" target="_blank" rel="external">MiniGUI 自定义控件教程2</a><br><a href="http://light3moon.com/2015/01/19/MiniGUI 自定义控件教程3" title="MiniGUI 自定义控件教程3" target="_blank" rel="external">MiniGUI 自定义控件教程3</a><br><a href="http://light3moon.com/2015/01/20/MiniGUI 自定义控件教程4" title="MiniGUI 自定义控件教程4" target="_blank" rel="external">MiniGUI 自定义控件教程4</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 自定义控件教程5" title="MiniGUI 自定义控件教程5" target="_blank" rel="external">MiniGUI 自定义控件教程5</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 自定义控件教程6" title="MiniGUI 自定义控件教程6" target="_blank" rel="external">MiniGUI 自定义控件教程6</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 自定义控件教程7" title="MiniGUI 自定义控件教程7" target="_blank" rel="external">MiniGUI 自定义控件教程7</a> </p>
<p><a href="http://light3moon.com/2015/01/21/MiniGUI 消息机制源码分析" title="MiniGUI 消息机制源码分析" target="_blank" rel="external">MiniGUI 消息机制源码分析</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 源码分析笔记" title="MiniGUI 源码分析笔记" target="_blank" rel="external">MiniGUI 源码分析笔记</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042205741" title="MiniGUI DC 分析" target="_blank" rel="external">MiniGUI DC 分析</a> </p>
<h2 id="Android_Development">Android Development</h2>
<p><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042118355" title="Java 备忘" target="_blank" rel="external">Java 备忘</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-27/40065680516" title="Java 反射的参数问题" target="_blank" rel="external">Java 反射的参数问题</a><br><a href="http://mingming-killer.diandian.com/post/2013-10-30/40056056697" title="Android 命令备忘" target="_blank" rel="external">Android 命令备忘</a><br><a href="http://mingming-killer.diandian.com/post/2012-02-19/40038133438" title="Android 开发环境搭建全程演示 (jdk+eclipse+android sdk)" target="_blank" rel="external">Android 开发环境搭建全程演示 (jdk+eclipse+android sdk)</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40043137292" title="Android 模拟器使用心得" target="_blank" rel="external">Android 模拟器使用心得</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042612750" title="Android 应用程序开发小问题总结" target="_blank" rel="external">Android 应用程序开发小问题总结</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-22/40042474656" title="Android sdk 本地文档加载慢的解决办法" target="_blank" rel="external">Android sdk 本地文档加载慢的解决办法</a><br><a href="http://mingming-killer.diandian.com/post/2012-04-09/40039374207" title="Android 程序签名问题" target="_blank" rel="external">Android 程序签名问题</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40043044175" title="Linux 下 adb usb 连接 usb 设备问题总结" target="_blank" rel="external">Linux 下 adb usb 连接 usb 设备问题总结</a><br><a href="http://mingming-killer.diandian.com/post/2013-08-26/40052345030" title="64位 ubuntu adb No such file or directory 解决办法" target="_blank" rel="external">64位 ubuntu adb No such file or directory 解决办法</a><br><a href="http://mingming-killer.diandian.com/post/2014-04-24/40061579231" title="Android sdk content loader 0% 的解决方法" target="_blank" rel="external">Android sdk content loader 0% 的解决方法</a><br><a href="http://mingming-killer.diandian.com/post/2013-08-26/40053692186" title="[转] linux 下 ndk-build 出现 Invalid attribute name: package 错误" target="_blank" rel="external">[转] linux 下 ndk-build 出现 Invalid attribute name: package 错误</a><br><a href="http://mingming-killer.diandian.com/post/2011-07-24/40038165328" title="Android中 Error generating final archive: Debug Certificate expired on xx 的错误" target="_blank" rel="external">Android中 Error generating final archive: Debug Certificate expired on xx 的错误</a><br><a href="http://mingming-killer.diandian.com/post/2012-03-02/40038459637" title="反编译 Android apk" target="_blank" rel="external">反编译 Android apk</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042527201" title="Android Gesture 使用简介" target="_blank" rel="external">Android Gesture 使用简介</a><br><a href="http://mingming-killer.diandian.com/post/2012-08-21/40039695400" title="Android View 系统的一些理解" target="_blank" rel="external">Android View 系统的一些理解</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042020328" title="Android 布局笔记" target="_blank" rel="external">Android 布局笔记</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40043824662" title="Android Create Bitmap Out Of Memory" target="_blank" rel="external">Android Create Bitmap Out Of Memory</a><br><a href="http://mingming-killer.diandian.com/post/2012-08-21/40039904672" title="Android OpenGLES 学习笔记" target="_blank" rel="external">Android OpenGLES 学习笔记</a><br><a href="http://mingming-killer.diandian.com/post/2012-08-31/40038128935" title="Android 4.0 访问WebService 出现 android.os.NetworkOnMainThreadException异常" target="_blank" rel="external">Android 4.0 访问WebService 出现 android.os.NetworkOnMainThreadException异常</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042795428" title="Android 自定义 Preference" target="_blank" rel="external">Android 自定义 Preference</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-04/40061663797" title="Android 资源文件夹命名规则" target="_blank" rel="external">Android 资源文件夹命名规则</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-15/40061752791" title="Android 设置广播标志启动还没启动程序" target="_blank" rel="external">Android 设置广播标志启动还没启动程序</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-26/40061843062" title="[转] Android 让应用手动管理应用的数据目录" target="_blank" rel="external">[转] Android 让应用手动管理应用的数据目录</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-26/40061842470" title="Android 优秀开源网络框架" target="_blank" rel="external">Android 优秀开源网络框架</a><br><a href="http://mingming-killer.diandian.com/post/2014-06-17/40062037390" title="apk 捕获全局异常" target="_blank" rel="external">apk 捕获全局异常</a><br><a href="http://mingming-killer.diandian.com/post/2014-07-22/40062251272" title="dmtracedump 的用法" target="_blank" rel="external">dmtracedump 的用法</a><br><a href="http://mingming-killer.diandian.com/post/2014-07-28/40062314377" title="Android 打印函数调用堆栈调试" target="_blank" rel="external">Android 打印函数调用堆栈调试</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-20/40065644503" title="hierarchyviewer 无法使用问题" target="_blank" rel="external">hierarchyviewer 无法使用问题</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2014-08-13/40062497661" title="Android 坑爹大全 —— SeekBar" target="_blank" rel="external">Android 坑爹大全 —— SeekBar</a><br><a href="http://mingming-killer.diandian.com/post/2014-09-19/40063020120" title="Android 坑爹大全 —— Paint mask filter 无效" target="_blank" rel="external">Android 坑爹大全 —— Paint mask filter 无效</a> </p>
<h2 id="Android_Framework">Android Framework</h2>
<p><a href="http://mingming-killer.diandian.com/post/2012-02-19/40038593763" title="如何取得Android源代码" target="_blank" rel="external">如何取得Android源代码</a><br><a href="http://mingming-killer.diandian.com/post/2013-12-19/40060490947" title="获取 Android 源码问题总结" target="_blank" rel="external">获取 Android 源码问题总结</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042629605" title="开启 Android SDK 所有的 API 的方法" target="_blank" rel="external">开启 Android SDK 所有的 API 的方法</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40043597499" title="Android x86 在 X window system 上的调研" target="_blank" rel="external">Android x86 在 X window system 上的调研</a><br><a href="http://mingming-killer.diandian.com/post/2012-08-21/40039144800" title="Android Root Recovery 学习笔记" target="_blank" rel="external">Android Root Recovery 学习笔记</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042663361" title="Android MiniGUI Recovery 笔记" target="_blank" rel="external">Android MiniGUI Recovery 笔记</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40042370948" title="编译 Android 源码问题总结" target="_blank" rel="external">编译 Android 源码问题总结</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-23/40043260736" title="Android 按键映射分析" target="_blank" rel="external">Android 按键映射分析</a><br><a href="http://mingming-killer.diandian.com/post/2013-09-02/40052117745" title="在源码中修改 Android 系统配置" target="_blank" rel="external">在源码中修改 Android 系统配置</a><br><a href="http://mingming-killer.diandian.com/post/2013-11-14/40060119035" title="[转] Android locales 本地化" target="_blank" rel="external">[转] Android locales 本地化</a><br><a href="http://mingming-killer.diandian.com/post/2013-11-15/40060103255" title="[转] Android系统移植与调试之-------&gt;build.prop文件详细赏析" target="_blank" rel="external">[转] Android系统移植与调试之———-&gt;build.prop文件详细赏析</a><br><a href="http://mingming-killer.diandian.com/post/2014-04-28/40061628264" title="Android 4.2 SystemUI 最近任务列表分析" target="_blank" rel="external">Android 4.2 SystemUI 最近任务列表分析</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-04/40061671114" title="编译 framework 自动增加自定义资源" target="_blank" rel="external">编译 framework 自动增加自定义资源</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-15/40061757929" title="forceStopPackage 的副作用" target="_blank" rel="external">forceStopPackage 的副作用</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-17/40061795955" title="vold share 操作清理正在使用磁盘的进程分析" target="_blank" rel="external">vold share 操作清理正在使用磁盘的进程分析</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-20/40061810899" title="Android 开机启动画面分析" target="_blank" rel="external">Android 开机启动画面分析</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-31/40061867491" title="Android Surface flinger 颜色格式分析" target="_blank" rel="external">Android Surface flinger 颜色格式分析</a><br><a href="http://mingming-killer.diandian.com/post/2014-09-09/40062912287" title="Android Provision 的影响和作用" target="_blank" rel="external">Android Provision 的影响和作用</a><br><a href="http://mingming-killer.diandian.com/post/2014-06-17/40062011119" title="Android 智能指针备忘" target="_blank" rel="external">Android 智能指针备忘</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2014-08-22/40062739695" title="Android Binder 分析——原理" target="_blank" rel="external">Android Binder 分析——原理</a><br><a href="http://mingming-killer.diandian.com/post/2014-09-12/40062959178" title="Android Binder 分析——通信模型" target="_blank" rel="external">Android Binder 分析——通信模型</a><br><a href="http://mingming-killer.diandian.com/post/2014-09-23/40063048909" title="Android Binder 分析——数据传递者（Parcel）" target="_blank" rel="external">Android Binder 分析——数据传递者（Parcel）</a><br><a href="http://mingming-killer.diandian.com/post/2014-10-31/40063291795" title="Android Binder 分析——匿名共享内存（Ashmem）" target="_blank" rel="external">Android Binder 分析——匿名共享内存（Ashmem）</a><br><a href="http://mingming-killer.diandian.com/post/2014-10-11/40063168555" title="Android Binder 分析——内存管理" target="_blank" rel="external">Android Binder 分析——内存管理</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-27/40062814789" title="Android Binder 分析——系统服务 Binder 对象的传递" target="_blank" rel="external">Android Binder 分析——系统服务 Binder 对象的传递</a><br><a href="http://mingming-killer.diandian.com/post/2014-11-08/40063333232" title="Android Binder 分析——普通服务 Binder 对象的传递" target="_blank" rel="external">Android Binder 分析——普通服务 Binder 对象的传递</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-19/40062702434" title="Android Binder 分析——多线程支持" target="_blank" rel="external">Android Binder 分析——多线程支持</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-04/40062388014" title="Android Binder 分析——懒人的工具（AIDL）" target="_blank" rel="external">Android Binder 分析——懒人的工具（AIDL）</a><br><a href="http://mingming-killer.diandian.com/post/2014-11-19/40064430905" title="Android Binder 分析——死亡通知（DeathRecipient）" target="_blank" rel="external">Android Binder 分析——死亡通知（DeathRecipient）</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2014-12-22/40065669072" title="Android 一些有意思的命令小工具 —— dumpsys" target="_blank" rel="external">Android 一些有意思的命令小工具 —— dumpsys</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-20/40065655791" title="Android 一些有意思的命令小工具 —— service" target="_blank" rel="external">Android 一些有意思的命令小工具 —— service</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2014-08-08/40062437624" title="工作小笔记——扩展字库乱码排查" target="_blank" rel="external">工作小笔记——扩展字库乱码排查</a><br><a href="http://mingming-killer.diandian.com/post/2014-10-08/40063121053" title="工作小笔记——Android 多用户切换无法启动应用的问题" target="_blank" rel="external">工作小笔记——Android 多用户切换无法启动应用的问题</a><br><a href="http://mingming-killer.diandian.com/post/2014-10-09/40063130162" title="工作小笔记——Android 多用户下的要注意的问题" target="_blank" rel="external">工作小笔记——Android 多用户下的要注意的问题</a><br><a href="http://mingming-killer.diandian.com/post/2014-10-23/40063248496" title="工作小笔记——Android 动态切换系统字体" target="_blank" rel="external">工作小笔记——Android 动态切换系统字体</a><br><a href="http://mingming-killer.diandian.com/post/2014-10-28/40063279653" title="工作小笔记——利用反射需要注意的问题" target="_blank" rel="external">工作小笔记——利用反射需要注意的问题</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-22/40065676359" title="工作小笔记——Android 自带的应用统计服务（UsageStatsService）" target="_blank" rel="external">工作小笔记——Android 自带的应用统计服务（UsageStatsService）</a><br><a href="http://mingming-killer.diandian.com/post/2014-11-24/40064455886" title="工作小笔记——拦截应用内置广告.检测篇" target="_blank" rel="external">工作小笔记——拦截应用内置广告.检测篇</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-27/40065701903" title="工作小笔记——拦截应用内置广告.拦截篇" target="_blank" rel="external">工作小笔记——拦截应用内置广告.拦截篇</a> </p>
<h2 id="Android_Device">Android Device</h2>
<p><a href="http://mingming-killer.diandian.com/post/2014-01-08/40060697037" title="Google android source code build 问题总结" target="_blank" rel="external">Google android source code build 问题总结</a><br><a href="http://mingming-killer.diandian.com/post/2013-12-16/40060463270" title="[转] Nexus7 2rd unlock fastboot" target="_blank" rel="external">[转] Nexus7 2rd unlock fastboot</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-01/40065502652" title="删除遗忘的 vpn 存储凭据" target="_blank" rel="external">删除遗忘的 vpn 存储凭据</a> </p>
<h2 id="Window">Window</h2>
<p><a href="http://mingming-killer.diandian.com/post/2013-07-27/40051133099" title="cygwin 使用备忘" target="_blank" rel="external">cygwin 使用备忘</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-22/40042324975" title="window 在 cygwin 中使用 repo ssh" target="_blank" rel="external">window 在 cygwin 中使用 repo ssh</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-01/40061664796" title="cygwin screen Directory /tmp/uscreens/S-UserName must have mode 700" target="_blank" rel="external">cygwin screen Directory /tmp/uscreens/S-UserName must have mode 700</a><br><a href="http://mingming-killer.diandian.com/post/2014-05-02/40061657220" title="cygwin screen Caption line issue" target="_blank" rel="external">cygwin screen Caption line issue</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2014-05-02/40061677452" title="EFI 安装系统" target="_blank" rel="external">EFI 安装系统</a><br><a href="http://mingming-killer.diandian.com/post/2014-06-17/40062038137" title="提取 OEM window key" target="_blank" rel="external">提取 OEM window key</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-22/40043529497" title="window 下的 linux 开发工具" target="_blank" rel="external">window 下的 linux 开发工具</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-22/40043063359" title="window 开启自带 ftp" target="_blank" rel="external">window 开启自带 ftp</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2014-02-03/40060915144" title="win8.1 自带程序入口" target="_blank" rel="external">win8.1 自带程序入口</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-22/40062749280" title="win8.1 关闭蓝牙的省电功能" target="_blank" rel="external">win8.1 关闭蓝牙的省电功能</a><br><a href="http://mingming-killer.diandian.com/post/2014-09-18/40062981165" title="win8.1 手动连接蓝牙设备" target="_blank" rel="external">win8.1 手动连接蓝牙设备</a><br><a href="http://mingming-killer.diandian.com/post/2014-12-31/40065717557" title="win8.1 微软输入法备忘" target="_blank" rel="external">win8.1 微软输入法备忘</a> </p>
<h2 id="OpenGL">OpenGL</h2>
<p><a href="http://mingming-killer.diandian.com/post/2013-11-03/40056620141" target="_blank" rel="external">OES_draw_texture 详解</a><br><a href="http://mingming-killer.diandian.com/post/2014-06-13/40062006061" title="GL 中的纹理坐标" target="_blank" rel="external">GL 中的纹理坐标</a> </p>
<h2 id="Python">Python</h2>
<p><a href="http://mingming-killer.diandian.com/post/2014-01-07/40060700011" title="Python 使用总结" target="_blank" rel="external">Python 使用总结</a> </p>
<h2 id="Other">Other</h2>
<p><a href="http://mingming-killer.diandian.com/post/2012-11-22/40042628884" title="Eclipse 插件小结" target="_blank" rel="external">Eclipse 插件小结</a><br><a href="http://mingming-killer.diandian.com/post/2014-04-26/40061615417" title="[转] eclipse 代码补齐、注释小窗口崩溃解决方法" target="_blank" rel="external">[转] eclipse 代码补齐、注释小窗口崩溃解决方法</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-22/40043627359" title="[转] 那些 cache 和 buffer（一）" target="_blank" rel="external">[转] 那些 “cache” 和 “buffer”（一）</a><br><a href="http://mingming-killer.diandian.com/post/2012-11-22/40043851115" title="[转] 那些 cache 和 buffer（二）" target="_blank" rel="external">[转] 那些 “cache” 和 “buffer”（二）</a><br><a href="http://mingming-killer.diandian.com/post/2012-12-11/40046147033" title="[转] Dia 无法输入中文" target="_blank" rel="external">[转] Dia 无法输入中文</a><br><a href="http://mingming-killer.diandian.com/post/2014-06-17/40062018531" title="[转] 什么是 VSync" target="_blank" rel="external">[转] 什么是 VSync</a><br><a href="http://mingming-killer.diandian.com/post/2014-06-20/40062030713" title="[转] Java 的模版和 C++ 模版的区别" target="_blank" rel="external">[转] Java 的模版和 C++ 模版的区别</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-08/40062434087" title="[转] unicode 编码表" target="_blank" rel="external">[转] unicode 编码表</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-08/40062440589" title="[转] 字符编码笔记" target="_blank" rel="external">[转] 字符编码笔记</a><br><a href="http://mingming-killer.diandian.com/post/2014-11-25/40064450570" title="[转] 如何在 github 上删除一个仓库" target="_blank" rel="external">[转] 如何在 github 上删除一个仓库</a> </p>
<p><a href="http://mingming-killer.diandian.com/post/2012-11-22/40042558341" title="Private" target="_blank" rel="external">Private</a> </p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/Endianness/</loc>
    <lastmod>2015-01-21T16:27:06.000Z</lastmod>
    <data>
        <display>
        <title>Endianness</title>
        <pubTime>2015-01-19T12:18:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>大、小端这个东西，每隔一段时间我就会忘记，发现维基上有2张图太形象了，记不得的时候看下这2张图就能想起来了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/basics/Endianness/1.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/basics/Endianness/2.png" alt=""></p>
<p>然后总结下，有个简单的记得方法：如果是大端存储的话，那么就是大的数值（专有名词叫 The most significant byte (MSB），俗称高位，就是好说个、十、百、千中的千）是存放在存储的低位的（就是最开始地方）。所以大端存储格式直接按顺序从存储中读出来的位数就是对的。</p>
<p>小端就正好反过来， MSB 是存在存储的高位的（就是后面），所以小端存储的话，从存储中读出来，要把位数反过来。</p>
<p>最后贴个 wiki 地址： <a href="http://en.wikipedia.org/wiki/Endianness" title="Endianness" target="_blank" rel="external">Endianness</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
</urlset>
