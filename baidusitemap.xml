<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Android%20%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BA%94%E7%94%A8%E7%BB%9F%E8%AE%A1%E6%9C%8D%E5%8A%A1%5BUsageStatsService%5D/</loc>
    <lastmod>2015-03-31T09:27:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——Android 自带的应用统计服务（UsageStatsService）</title>
        <pubTime>2015-01-31T02:33:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>最近要弄在 framework 中弄一个统计应用使用时长的功能。刚开始想着要怎么是不是要在 ActivityManagerService（AMS）的几个 Activity 的生命周期那埋几个统计点，后面发现 android 自带了一个 UsageStatsService（USS）的系统服务。这个东西统计的数据已经满足这边的需求了。只不过 android 好像只是统计了数据，并没怎么用（不过不排除 google 服务偷偷的用这个东西，google 服务应用是不开源的），所以还需要改造一下下。不过基本已经算是没啥难度了，不需要验证自己埋点是不是正确的（android 自己的服务准确性上还是值得信赖的）。这里把这个服务和之后自己的改造稍微分析一下，照例先把相关源码的位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># AMS 相关</span></div><div class="line">frameworks/base/services/java/com/android/server/am/UsageStatsService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityStack.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityRecord.java</div><div class="line"></div><div class="line"><span class="comment"># WMS 相关</span></div><div class="line">frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/wm/AppWindowToken.java</div><div class="line"></div><div class="line"><span class="comment"># Parcel 相关</span></div><div class="line">frameworks/base/core/java/android/os/Parcel.java</div><div class="line">frameworks/base/jni/android_os_Parcel.cpp</div><div class="line"></div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line">frameworks/native/include/utils/Unicode.h</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="UsageStatsService">UsageStatsService</h2>
<h3 id="初步认识">初步认识</h3>
<p>USS 虽然说是一个单独系统服务，但是从代码位置来看隶属于 AMS 家族：代码位于 frameworks/base/services/java/com/android/server/am 下面（在 services 包下能单独开一个文件夹的 SS 都是十分庞大的，例如：AM、WM、PM 之类）。它是由 AM 来启动的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ===================== ActivityManagerService.java ========================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>{</div><div class="line">... ...</div><div class="line"></div><div class="line">	<span class="comment">// USS 属于 AMS</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * information about component usage</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> UsageStatsService mUsageStatsService;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="title">ActivityManagerService</span>() {</div><div class="line">... ...</div><div class="line"></div><div class="line">        File dataDir = Environment.getDataDirectory();</div><div class="line">        File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>); </div><div class="line">        systemDir.mkdirs();</div><div class="line">        mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(<span class="keyword">new</span> File(</div><div class="line">                systemDir, <span class="string">"batterystats.bin"</span>).toString());</div><div class="line">        mBatteryStatsService.getActiveStatistics().readLocked();</div><div class="line">        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();</div><div class="line">        mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></div><div class="line">                : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</div><div class="line">        mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 在 AMS 的构造函数被 new 出来</span></div><div class="line">		<span class="comment">// 这个 systemDir 从来上面代码来看是： /data/system，所以传给 USS 的目录是 /data/system/usagestats</span></div><div class="line">        mUsageStatsService = <span class="keyword">new</span> UsageStatsService(<span class="keyword">new</span> File(</div><div class="line">                systemDir, <span class="string">"usagestats"</span>).toString());</div><div class="line">        mHeadless = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"ro.config.headless"</span>, <span class="string">"0"</span>));</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">	<span class="comment">// 前面 Binder SS 篇有说到 SS 初始化的时候会调用 AMS 的 main 函数的</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Context <span class="title">main</span>(<span class="keyword">int</span> factoryTest) {</div><div class="line">        AThread thr = <span class="keyword">new</span> AThread();</div><div class="line">        thr.start();</div><div class="line">       </div><div class="line">        <span class="keyword">synchronized</span> (thr) {</div><div class="line">            <span class="keyword">while</span> (thr.mService == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    thr.wait();</div><div class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                } </div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        ActivityManagerService m = thr.mService;</div><div class="line">        mSelf = m;</div><div class="line">        ActivityThread at = ActivityThread.systemMain();</div><div class="line">        mSystemThread = at;</div><div class="line">        Context context = at.getSystemContext();</div><div class="line">        context.setTheme(android.R.style.Theme_Holo);</div><div class="line">        m.mContext = context; </div><div class="line">        m.mFactoryTest = factoryTest;</div><div class="line">        m.mMainStack = <span class="keyword">new</span> ActivityStack(m, context, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 调用 USS 的 publish 函数</span></div><div class="line">        m.mBatteryStatsService.publish(context);</div><div class="line">        m.mUsageStatsService.publish(context);</div><div class="line">    </div><div class="line">        <span class="keyword">synchronized</span> (thr) {</div><div class="line">            thr.mReady = <span class="keyword">true</span>;</div><div class="line">            thr.notifyAll();</div><div class="line">        }</div><div class="line">   </div><div class="line">        m.startRunning(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ===================== UsageStatsService.java ========================</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This service collects the statistics associated with usage</span></div><div class="line"><span class="comment"> * of various components, like when a particular package is launched or</span></div><div class="line"><span class="comment"> * paused and aggregates events like number of time a component is launched</span></div><div class="line"><span class="comment"> * total duration of a component launch.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageStatsService</span> <span class="keyword">extends</span> <span class="title">IUsageStats</span>.<span class="title">Stub</span> </span>{</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span>(Context context) {</div><div class="line">        mContext = context;</div><div class="line">		<span class="comment">// 向 SM 注册自己</span></div><div class="line">        ServiceManager.addService(SERVICE_NAME, asBinder());</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里如果有个我写的 Binder 系列那些知识的话是很简单的，SS 启动 AMS，然后 AMS 创建 USS，再调用 USS 的 publish 向 SM 注册 USS，这样 framework 中的各个模块（原生的 USS 不对第三方应用开放接口的）就能通过 SM 调用 USS 提供的 IPC 接口了。那我们也清楚了 USS 是在 AMS 初始化的时候启动的。</p>
<h3 id="数据结构">数据结构</h3>
<p>我们初步认识了 USS 之后，来看下 USS 使用的数据结构。在 USS 中有2个内部类（代码不多一次贴全了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageStatsService</span> <span class="keyword">extends</span> <span class="title">IUsageStats</span>.<span class="title">Stub</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line">       </div><div class="line">    <span class="keyword">static</span> IUsageStats sService;</div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line">    <span class="comment">// 这个 Map 基本就是 USS 保存的所有数据了，以 pkg name 为 key，</span></div><div class="line">    <span class="comment">// 每一个 pkg 一个 PkgUsageStatsExtended 数据。</span></div><div class="line">    <span class="comment">// 注释中说这个保存的是从最后一次 checkin 之后的数据，这个后面再说是什么意思。</span></div><div class="line">    <span class="comment">// structure used to maintain statistics since the last checkin.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Map&lt;String, PkgUsageStatsExtended&gt; mStats; </div><div class="line"></div><div class="line">    <span class="comment">// 一共有十个时间范围，下面的时间单位是 ms</span></div><div class="line">    <span class="comment">// 就是说 USS 会给一个组件（component）启动时候划分到下面几个时间段：</span></div><div class="line">    <span class="comment">// 例如说： 250ms ~ 500ms, 2000ms ~ 3000ms, &gt; 5000ms 等</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_LAUNCH_TIME_BINS = <span class="number">10</span>; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] LAUNCH_TIME_BINS = {</div><div class="line">        <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>, <span class="number">1500</span>, <span class="number">2000</span>, <span class="number">3000</span>, <span class="number">4000</span>, <span class="number">5000</span></div><div class="line">    }; </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// TimeStats 主要是保存应用的组件启动时长信息</span></div><div class="line">    <span class="keyword">static</span> class TimeStats {</div><div class="line">        <span class="comment">// 一共启动了几次</span></div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="comment">// 这个是一个数组，里面存放的是 component 启动时间段分布信息，详细看上面的解说</span></div><div class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[NUM_LAUNCH_TIME_BINS];</div><div class="line"></div><div class="line">        TimeStats() {</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> incCount() {</div><div class="line">            count++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这个接口传入的参数是时长，通过时长标记这个组件启动的时间属于上面哪个时间段</span></div><div class="line">        <span class="comment">// 数组的每个元素的数值分布就代表启动的时间段的分布</span></div><div class="line">        <span class="keyword">void</span> add(<span class="keyword">int</span> val) {</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] bins = LAUNCH_TIME_BINS;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM_LAUNCH_TIME_BINS-<span class="number">1</span>; i++) {</div><div class="line">                <span class="keyword">if</span> (val &lt; bins[i]) {</div><div class="line">                    times[i]++;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            times[NUM_LAUNCH_TIME_BINS-<span class="number">1</span>]++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 从 Parcel 打包的数据中实例化自己</span></div><div class="line">        TimeStats(Parcel in) {</div><div class="line">            count = in.readInt();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] localTimes = times;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM_LAUNCH_TIME_BINS; i++) {</div><div class="line">                localTimes[i] = in.readInt();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 把自己写入 Parcel 数据包中，上面的实例化是根据写的顺序来读的</span></div><div class="line">        <span class="comment">// 这里没有显式实现 Parcelable 接口，而是直接写了这2个函数让下面</span></div><div class="line">        <span class="comment">// 的业务函数来调用的，只是内部使用的话都差不多了</span></div><div class="line">        <span class="keyword">void</span> writeToParcel(Parcel out) {</div><div class="line">            out.writeInt(count);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] localTimes = times;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM_LAUNCH_TIME_BINS; i++) {</div><div class="line">                out.writeInt(localTimes[i]);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 这个算是 USS 中基本数据单元，单位是包（packagename）</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PkgUsageStatsExtended</span> </span>{</div><div class="line">        <span class="comment">// 这个 HaspMap 以 ComponentName（String） 为 key，</span></div><div class="line">        <span class="comment">// 保存了这个 pkg 中启动过的组件的时长信息</span></div><div class="line">        <span class="keyword">final</span> HashMap&lt;String, TimeStats&gt; mLaunchTimes</div><div class="line">                = <span class="keyword">new</span> HashMap&lt;String, TimeStats&gt;();</div><div class="line">        <span class="comment">// 这个 pkg 启动过几次</span></div><div class="line">        <span class="keyword">int</span> mLaunchCount;</div><div class="line">        <span class="comment">// 这个 pkg 当前总共使用了多长时间（ms）</span></div><div class="line">        <span class="keyword">long</span> mUsageTime;</div><div class="line">        <span class="comment">// 这个 pkg 当前组件 Paused 的时间戳（ms）</span></div><div class="line">        <span class="keyword">long</span> mPausedTime;</div><div class="line">        <span class="comment">// 这个 pkg 当前组件 Resumed 的时间戳（ms）</span></div><div class="line">        <span class="keyword">long</span> mResumedTime;</div><div class="line">             </div><div class="line">        PkgUsageStatsExtended() {</div><div class="line">            mLaunchCount = <span class="number">0</span>; </div><div class="line">            mUsageTime = <span class="number">0</span>; </div><div class="line">        }    </div><div class="line">        </div><div class="line">        <span class="comment">// 从 Parcel 打包的数据中实例化自己      </span></div><div class="line">        PkgUsageStatsExtended(Parcel in) {</div><div class="line">            mLaunchCount = in.readInt();</div><div class="line">            mUsageTime = in.readLong();</div><div class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launch count: "</span> + mLaunchCount</div><div class="line">                    + <span class="string">", Usage time:"</span> + mUsageTime);</div><div class="line">                 </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numTimeStats = in.readInt();</div><div class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Reading comps: "</span> + numTimeStats);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numTimeStats; i++) {</div><div class="line">                String comp = in.readString();</div><div class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Component: "</span> + comp);</div><div class="line">                TimeStats times = <span class="keyword">new</span> TimeStats(in);</div><div class="line">                mLaunchTimes.put(comp, times);</div><div class="line">            }    </div><div class="line">        }   </div><div class="line">        </div><div class="line">        <span class="comment">// 更新 Resume 信息， AMS 中有组件 Resume 的时候调用</span></div><div class="line">        <span class="keyword">void</span> updateResume(String comp, <span class="keyword">boolean</span> launched) {</div><div class="line">            <span class="keyword">if</span> (launched) {</div><div class="line">                <span class="comment">// 在 launch Resume 的时候才算一次启动</span></div><div class="line">                <span class="comment">// 后面能看到 AMS 哪些地方会埋这个点的</span></div><div class="line">                mLaunchCount ++;</div><div class="line">            }</div><div class="line">            mResumedTime = SystemClock.elapsedRealtime();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 更新 Pause 信息</span></div><div class="line">        <span class="keyword">void</span> updatePause() {</div><div class="line">            mPausedTime =  SystemClock.elapsedRealtime();</div><div class="line">            <span class="comment">// Pause 的时候更新下使用时间</span></div><div class="line">            mUsageTime += (mPausedTime - mResumedTime);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 添加 pkg 组件启动次数信息</span></div><div class="line">        <span class="keyword">void</span> addLaunchCount(String comp) {</div><div class="line">            TimeStats times = mLaunchTimes.get(comp);</div><div class="line">            <span class="comment">// 如果是组件的话，new 一个 TimeStats</span></div><div class="line">            <span class="keyword">if</span> (times == <span class="keyword">null</span>) {</div><div class="line">                times = <span class="keyword">new</span> TimeStats();</div><div class="line">                mLaunchTimes.put(comp, times);</div><div class="line">            }</div><div class="line">            times.incCount();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 添加 pkg 组件启动时长信息</span></div><div class="line">        <span class="keyword">void</span> addLaunchTime(String comp, <span class="keyword">int</span> millis) {</div><div class="line">            TimeStats times = mLaunchTimes.get(comp);</div><div class="line">            <span class="keyword">if</span> (times == <span class="keyword">null</span>) {</div><div class="line">                times = <span class="keyword">new</span> TimeStats();</div><div class="line">                mLaunchTimes.put(comp, times);</div><div class="line">            }</div><div class="line">            times.add(millis);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 把自己写入 Parcel 数据包中，上面的实例化是根据写的顺序来读的</span></div><div class="line">        <span class="keyword">void</span> writeToParcel(Parcel out) {</div><div class="line">            out.writeInt(mLaunchCount);</div><div class="line">            out.writeLong(mUsageTime);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numTimeStats = mLaunchTimes.size();</div><div class="line">            out.writeInt(numTimeStats);</div><div class="line">            <span class="keyword">if</span> (numTimeStats &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, TimeStats&gt; ent : mLaunchTimes.entrySet()) {</div><div class="line">                    out.writeString(ent.getKey());</div><div class="line">                    TimeStats times = ent.getValue();</div><div class="line">                    times.writeToParcel(out);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 清除所有 pkg 信息（包括组件的 TimeStats 信息）</span></div><div class="line">        <span class="keyword">void</span> clear() {</div><div class="line">            mLaunchTimes.clear();</div><div class="line">            mLaunchCount = <span class="number">0</span>;</div><div class="line">            mUsageTime = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面基本上把 USS 的基本数据结构介绍清楚了。其结构是一个 Map，其中以安装了的 pkg 为条，每一条包括：</p>
<ul>
<li>启动总次数</li>
<li>总共时间时间</li>
<li>pkg 中每个组件启动的次数以及每次启动所需要的时间</li>
</ul>
<p>为了增加感性认识，dumpsys 一下 usagestats 这个服务能看到磁盘的保存了的 USS 的数据信息：</p>
<pre>
Date: 20150305
  com.android.systemui: 2 times, 26577889 ms
    com.android.systemui.usb.UsbStorageActivity: 2 starts, 2000-3000ms=2
  com.eebbk.mingming.notificationtest: 1 times, 8625444 ms
    com.eebbk.mingming.notificationtest.MainActivity: 1 starts, 500-750ms=1
  com.bbk.studyos.launcher: 3 times, 11220 ms
    com.bbk.studyos.launcher.activity.Launcher: 3 starts, >=5000ms=1
Date: 20150306
  com.android.systemui: 1 times, 30961918 ms
    com.android.systemui.usb.UsbStorageActivity: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 2 times, 8282 ms
    com.bbk.studyos.launcher.activity.Launcher: 2 starts, 2000-3000ms=1
Date: 20150307
  com.android.systemui: 3 times, 445073 ms
    com.android.systemui.usb.UsbStorageActivity: 3 starts, 250-500ms=1, 2000-3000ms=1
  com.android.providers.usagestats: 1 times, 41882 ms
    com.android.providers.usagestats.viewer.UsageStatsViewer: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 3 times, 27290376 ms
    com.bbk.studyos.launcher.activity.Launcher: 3 starts, >=5000ms=1
Date: 20150309
  com.android.systemui: 4 times, 6534068 ms
    com.android.systemui.usb.UsbStorageActivity: 4 starts, 250-500ms=2, 2000-3000ms=2
  com.eebbk.systemuimodedemo: 2 times, 612236 ms
    com.eebbk.systemuimodedemo.MainActivity: 2 starts, 750-1000ms=1
  com.eebbk.mingming.notificationtest: 1 times, 1813374 ms
    com.eebbk.mingming.notificationtest.MainActivity: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 7 times, 28509 ms
    com.bbk.studyos.launcher.activity.Launcher: 7 starts, 2000-3000ms=1, >=5000ms=2
Date: 20150310
  com.android.systemui: 1 times, 0 ms
    com.android.systemui.usb.UsbStorageActivity: 1 starts, 2000-3000ms=1
  com.bbk.studyos.launcher: 1 times, 1421 ms
    com.bbk.studyos.launcher.activity.Launcher: 1 starts
Date: history.xml (old data version)
</pre>

<p>（这里仔细看，发现组件启动那里的启动次数和后面的时间段分布有些时候会不对，时间段分别那有时会有少几次的情况出现，后面会知道偶尔出现这种情况的原因）</p>
<h3 id="统计埋点">统计埋点</h3>
<p>其实所有的统计流程基本上都是一样的，定下要统计的数据结构，下面就是埋点，然后上报数据，最后服务端保存数据。前面说了埋点是在 AMS 里面的。这里先看看 USS 提供给 AMS 的埋点接口，一共三个：</p>
<ul>
<li><strong>noteResumeComponent:</strong> 通知有组件跑了 Resume 生命周期</li>
<li><strong>notePauseComponent:</strong> 通知有组件跑了 Pause 生命周期</li>
<li><strong>noteLaunchTime:</strong> 通知组件的启动时间</li>
</ul>
<p>下面我们一个一个看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteResumeComponent</span>(ComponentName componentName) {</div><div class="line">    <span class="comment">// 检测下调用者权限</span></div><div class="line">    enforceCallingPermission();</div><div class="line">    String pkgName;</div><div class="line">    <span class="comment">// 喜闻乐见的 SS 业务多线程同步锁，这次 USS 访问 mStats 数据和写文件用的是2个单独的锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">        <span class="comment">// 这个组件必须要包含 pkg name 才能被统计（绝大多数组件都包含 pkg name 的）</span></div><div class="line">        <span class="keyword">if</span> ((componentName == <span class="keyword">null</span>) ||</div><div class="line">                ((pkgName = componentName.getPackageName()) == <span class="keyword">null</span>)) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这里有一个判断：如果当前 Resume 的这个组件和上一次那个是同一个，</span></div><div class="line">        <span class="comment">// 并且还没经过 Pause（后面指定经过 Pause 的话 mIsResumed 是 false 的），</span></div><div class="line">        <span class="comment">// 那么认为应该要调用下当前这个 pkg 的 updatePause 来更新下 Pause 信息。</span></div><div class="line">        <span class="comment">// 因为 Resume 要和 Pause 成对。这种情况的典型场景就是：</span></div><div class="line">        <span class="comment">// 一些启动 activity 的按钮处理没做好，用户一个不小心点击了好多下，</span></div><div class="line">        <span class="comment">// 然后就启动了好多个 activity，上面一个还没来得及 Pause 就有相同的 Resume 了。</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> samePackage = pkgName.equals(mLastResumedPkg);</div><div class="line">        <span class="keyword">if</span> (mIsResumed) {</div><div class="line">            <span class="keyword">if</span> (mLastResumedPkg != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// We last resumed some other package...  just pause it now</span></div><div class="line">                <span class="comment">// to recover.</span></div><div class="line">                <span class="keyword">if</span> (REPORT_UNEXPECTED) Slog.i(TAG, <span class="string">"Unexpected resume of "</span> + pkgName</div><div class="line">                        + <span class="string">" while already resumed in "</span> + mLastResumedPkg);</div><div class="line">                PkgUsageStatsExtended pus = mStats.get(mLastResumedPkg);</div><div class="line">                <span class="keyword">if</span> (pus != <span class="keyword">null</span>) {</div><div class="line">                    pus.updatePause();</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> sameComp = samePackage</div><div class="line">                && componentName.getClassName().equals(mLastResumedComp);</div><div class="line"></div><div class="line">        <span class="comment">// 把 mIsResumed 标志设置为 true</span></div><div class="line">        mIsResumed = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 保存下最后一次 Resume 的 pkg 和 comp 的名字</span></div><div class="line">        mLastResumedPkg = pkgName;</div><div class="line">        mLastResumedComp = componentName.getClassName();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.i(TAG, <span class="string">"started component:"</span> + pkgName);</div><div class="line">        <span class="comment">// 如果 pkg 是第一次，new 一个 PkgUsageStatsExtended 保存</span></div><div class="line">        PkgUsageStatsExtended pus = mStats.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pus == <span class="keyword">null</span>) {</div><div class="line">            pus = <span class="keyword">new</span> PkgUsageStatsExtended();</div><div class="line">            mStats.put(pkgName, pus);</div><div class="line">        }</div><div class="line">        <span class="comment">// 调用 updateResume 更新 Resume 信息，</span></div><div class="line">        <span class="comment">// 注意第二个参数，如果 Resume 是不同的 pkg，那么算这个 pkg 的一次启动次数</span></div><div class="line">        pus.updateResume(mLastResumedComp, !samePackage);</div><div class="line">        <span class="comment">// 如果 Resume 的是不同的组件，那么算这个 pkg 组件的一次启动次数</span></div><div class="line">        <span class="keyword">if</span> (!sameComp) {</div><div class="line">            pus.addLaunchCount(mLastResumedComp);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这个 mLastResumeTimes 的统计数据我们暂时不管它</span></div><div class="line">        Map&lt;String, Long&gt; componentResumeTimes = mLastResumeTimes.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (componentResumeTimes == <span class="keyword">null</span>) {</div><div class="line">            componentResumeTimes = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</div><div class="line">            mLastResumeTimes.put(pkgName, componentResumeTimes);</div><div class="line">        }</div><div class="line">        componentResumeTimes.put(mLastResumedComp, System.currentTimeMillis());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后下面是通知 Pause 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notePauseComponent</span>(ComponentName componentName) {</div><div class="line">    <span class="comment">// 同样是检测调用者的权限</span></div><div class="line">    enforceCallingPermission();</div><div class="line"></div><div class="line">    <span class="comment">// 同样是喜闻乐见的同步锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">        <span class="comment">// 同样得判断这个组件有没有带 pkg name 信息</span></div><div class="line">        String pkgName;</div><div class="line">        <span class="keyword">if</span> ((componentName == <span class="keyword">null</span>) ||</div><div class="line">                ((pkgName = componentName.getPackageName()) == <span class="keyword">null</span>)) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 这个为了保证 Resume、Pause 的成对性，判断 mIsResumed 如果不是 true 就返回</span></div><div class="line">        <span class="keyword">if</span> (!mIsResumed) {</div><div class="line">            <span class="keyword">if</span> (REPORT_UNEXPECTED) Slog.i(TAG, <span class="string">"Something wrong here, didn't expect "</span></div><div class="line">                    + pkgName + <span class="string">" to be paused"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 设置 mIsResumed 为 false</span></div><div class="line">        mIsResumed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.i(TAG, <span class="string">"paused component:"</span>+pkgName);</div><div class="line"></div><div class="line">        <span class="comment">// 调用 updatePause 更新 Pause 信息</span></div><div class="line">        PkgUsageStatsExtended pus = mStats.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pus == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Weird some error here</span></div><div class="line">            Slog.i(TAG, <span class="string">"No package stats for pkg:"</span>+pkgName);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        pus.updatePause();</div><div class="line">    }   </div><div class="line">         </div><div class="line">    <span class="comment">// 在收到组件 Pause 信息的时候保存统计数据到文件中，这个我们后面再具体分析。</span></div><div class="line">    <span class="comment">// 这里稍微注意一下这个函数没在上面的 mStatsLock 的范围中。</span></div><div class="line">    <span class="comment">// 因为 USS 拿了2个锁处理多线程同步问题，读写文件的锁是另外一个，在这个函数会用的。  </span></div><div class="line">    <span class="comment">// Persist current data to file if needed.</span></div><div class="line">    writeStatsToFile(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后是通知启动需要的时间的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteLaunchTime</span>(ComponentName componentName, <span class="keyword">int</span> millis) {</div><div class="line">    <span class="comment">// 还是检测调用者的权限</span></div><div class="line">    enforceCallingPermission();</div><div class="line">    String pkgName;</div><div class="line">    <span class="keyword">if</span> ((componentName == <span class="keyword">null</span>) ||</div><div class="line">            ((pkgName = componentName.getPackageName()) == <span class="keyword">null</span>)) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 在收到组件启动时间的信息的时候也会激发写入文件的操作</span></div><div class="line">    <span class="comment">// 和上面的一样不在 mStatsLock 的范围内</span></div><div class="line">    <span class="comment">// Persist current data to file if needed.</span></div><div class="line">    writeStatsToFile(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 还是喜闻乐见的同步锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">        <span class="comment">// 调用 addLaunchTime 添加组件启动时长信息</span></div><div class="line">        PkgUsageStatsExtended pus = mStats.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pus != <span class="keyword">null</span>) {</div><div class="line">            pus.addLaunchTime(componentName.getClassName(), millis);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里能看到上面的 noteResume 和 notePause 中会有成对的判断（以后自己处理组件生命周期问题的时候也要多加注意）。还有这里组件启动次数和添加组件启动所需时长信息不在同一个地方，这就能解释为什么偶尔会发现这2个数据个数对不上的问题（埋点的地方不一样，总有几次漏的）。还有上面访问 mStats 和读写文件的锁是分开的，可以学习一下多线程互斥问题的时候，要多想想，不要一遇到互斥问题就所有的代码用一个锁锁住。细分可重入的代码块能提高程序并发访问的能力。</p>
<p>上面埋点的接口，下面我们来看下哪些地方埋了这些点，基本上在 AMS 和 WMS 中（AMS、WMS 的代码十分庞大，请善用 grep 神器）。我们还是分成3个部分来说：</p>
<h4 id="noteResumeComponent">noteResumeComponent</h4>
<p>这里我能省略的尽量省略，因为要如何分析 AMS 和 WMS 至少要好几篇才够，先上张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/noteResumeComponent.png" alt=""></p>
<p>Resume 的埋点在 AMS 的 ActivityStack（AS） 的 completeResumeLocked 中。前面一些分析说过 AMS 有一个 activity 的堆栈，相关操作（start activity、resume activity、pause activity 等等）集中在 AS 中。其中 AMS 好像有好几个 AS，但是这里和统计相关的只有一个叫 mMainStack 的主堆栈。大体可以分为2条路：</p>
<ul>
<li><strong>branch1:</strong></li>
</ul>
<p>第一条分支，是比较常见的调用 AMS 的 startActivity 发起的。然后和之前 Binder 的 SS 篇和 Broadcast 篇类似，分为 activity 的进程时候存在。如果不存在，继续走 branch1 后面的。如果进程已经存在，就算 branch 2 前面各种场景调用中的一种，可以直接调用 mMainStack 的 startActivity 相关函数，最后会调用 AS 的 resumeTopActivityLocked 然后去 branch2。这里我们先看进程不存在的情况，告诉 Zygote fork 出进程，然后会跑 ActivityThread（AT） 里面的 main 函数，然后 main 里面会 new AT，然后调用 AT 的 attach 函数，然后会 IPC 调用 AMS 的 attachApplication(Locked)（这些前面那些篇章都分析过了，省略贴代码了）。这里稍微说下 AMS 的 mMainStack（AS） 和 ActivityRecord（AR）这2个东西。在 AMS 的 main 里会创建一个 AS 这里就是主堆栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Context <span class="title">main</span>(<span class="keyword">int</span> factoryTest) {</div><div class="line">    AThread thr = <span class="keyword">new</span> AThread();   </div><div class="line">    thr.start();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (thr) {</div><div class="line">        <span class="keyword">while</span> (thr.mService == <span class="keyword">null</span>) { </div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                thr.wait();                    </div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">            }             </div><div class="line">        }                 </div><div class="line">    }</div><div class="line"></div><div class="line">    ActivityManagerService m = thr.mService;</div><div class="line">    mSelf = m;</div><div class="line">    ActivityThread at = ActivityThread.systemMain(); </div><div class="line">    mSystemThread = at;</div><div class="line">    Context context = at.getSystemContext();</div><div class="line">    context.setTheme(android.R.style.Theme_Holo);</div><div class="line">    m.mContext = context;</div><div class="line">    m.mFactoryTest = factoryTest;  </div><div class="line">    <span class="comment">// new 出来的 AS，最后一参数 mainStack 是 true</span></div><div class="line">    m.mMainStack = <span class="keyword">new</span> ActivityStack(m, context, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    m.mBatteryStatsService.publish(context);</div><div class="line">    m.mUsageStatsService.publish(context);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (thr) {</div><div class="line">        thr.mReady = <span class="keyword">true</span>;</div><div class="line">        thr.notifyAll();</div><div class="line">    }</div><div class="line"></div><div class="line">    m.startRunning(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 AR 这个东西么，经过前面一些 SS 的分析都知道 SS 都喜欢管自己的一些数据结构叫 XxxxRecord（ProcessRecord, ServiceRecord, TaskRecord, BroadcastRecord … …），所以这里的 AR 对应的就是 activity 的记录了。然后在 AS 中的 startActivityLocked 会 new 一个 AR：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startActivityLocked(IApplicationThread caller,</div><div class="line">            Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo,</div><div class="line">            String resultWho, <span class="keyword">int</span> requestCode,</div><div class="line">            <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> startFlags, Bundle options,</div><div class="line">            <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity) {</div><div class="line"></div><div class="line">        <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 启动一个 activity 对应就有一个 AR</span></div><div class="line">        ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, <span class="keyword">this</span>, callerApp, callingUid,</div><div class="line">                intent, resolvedType, aInfo, mService.mConfiguration,</div><div class="line">                resultRecord, resultWho, requestCode, componentSpecified);</div><div class="line">        <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) {</div><div class="line">            outActivity[<span class="number">0</span>] = r;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            <span class="keyword">if</span> (mResumedActivity == <span class="keyword">null</span></div><div class="line">                    || mResumedActivity.info.applicationInfo.uid != callingUid) {</div><div class="line">                <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, <span class="string">"Activity start"</span>)) {</div><div class="line">                    PendingActivityLaunch pal = <span class="keyword">new</span> PendingActivityLaunch();</div><div class="line">                    pal.r = r;</div><div class="line">                    pal.sourceRecord = sourceRecord;</div><div class="line">                    pal.startFlags = startFlags;</div><div class="line">                    mService.mPendingActivityLaunches.add(pal);</div><div class="line">                    mDismissKeyguardOnNextActivity = <span class="keyword">false</span>;</div><div class="line">                    ActivityOptions.abort(options);</div><div class="line">                    <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (mService.mDidAppSwitch) {</div><div class="line">                <span class="comment">// This is the second allowed switch since we stopped switches,</span></div><div class="line">                <span class="comment">// so now just generally allow switches.  Use case: user presses</span></div><div class="line">                <span class="comment">// home (switches disabled, switch to home, mDidAppSwitch now true);</span></div><div class="line">                <span class="comment">// user taps a home icon (coming from home so allowed, we hit here</span></div><div class="line">                <span class="comment">// and now allow anyone to switch again).</span></div><div class="line">                mService.mAppSwitchesAllowedTime = <span class="number">0</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mService.mDidAppSwitch = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            mService.doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        err = startActivityUncheckedLocked(r, sourceRecord,</div><div class="line">                startFlags, <span class="keyword">true</span>, options);</div><div class="line">        <span class="keyword">if</span> (mDismissKeyguardOnNextActivity && mPausingActivity == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Someone asked to have the keyguard dismissed on the next</span></div><div class="line">            <span class="comment">// activity start, but we are not actually doing an activity</span></div><div class="line">            <span class="comment">// switch...  just dismiss the keyguard now, because we</span></div><div class="line">            <span class="comment">// probably want to see whatever is behind it.</span></div><div class="line">            mDismissKeyguardOnNextActivity = <span class="keyword">false</span>;</div><div class="line">            mService.mWindowManager.dismissKeyguard();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里虽然没具体分析 startActivity 的过程，但是我们可以猜到一个 activity 对应一个 AR 记录。并且是在 startActivity 的时候创建的，所以等 AT attach AMS 的时候 AR 取最顶层的 AR 就是当前 startActivity 对应的 AR 记录。所以 AMS 会先调用 mMainStack(AS) topRunningActivityLocked 取顶层的 AR，然后 realStartActivityLocked 去真正的启动 activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span>(IApplicationThread thread,</div><div class="line">            <span class="keyword">int</span> pid) {</div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 取当前的启动 activity 的 AR 记录（顶层）</span></div><div class="line">        <span class="comment">// See if the top visible activity is waiting to run in this process...</span></div><div class="line">        ActivityRecord hr = mMainStack.topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (hr != <span class="keyword">null</span> && normalMode) {</div><div class="line">            <span class="keyword">if</span> (hr.app == <span class="keyword">null</span> && app.uid == hr.info.applicationInfo.uid</div><div class="line">                    && processName.equals(hr.processName)) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="keyword">if</span> (mHeadless) {</div><div class="line">                        <span class="comment">// 调用 mMainStack 的 realStartActivityLocked</span></div><div class="line">                        <span class="comment">// 传过去的 andResume 是 true</span></div><div class="line">                        Slog.e(TAG, <span class="string">"Starting activities not supported on headless device: "</span> + hr);</div><div class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (mMainStack.realStartActivityLocked(hr, app, <span class="keyword">true</span>, <span class="keyword">true</span>)) {</div><div class="line">                        didSomething = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"Exception in new application when starting activity "</span></div><div class="line">                          + hr.intent.getComponent().flattenToShortString(), e);</div><div class="line">                    badApp = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mMainStack.ensureActivitiesVisibleLocked(hr, <span class="keyword">null</span>, processName, <span class="number">0</span>);</div><div class="line">            }</div><div class="line">        }   </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 AS 里的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> realStartActivityLocked(ActivityRecord r,</div><div class="line">            ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</div><div class="line">            <span class="keyword">throws</span> RemoteException {</div><div class="line"></div><div class="line">... ...</div><div class="line">        </div><div class="line">        <span class="comment">// 从 AMS 那里传过来的 andResume 是 true     </span></div><div class="line">        <span class="keyword">if</span> (andResume) {</div><div class="line">            <span class="comment">// As part of the process of launching, ActivityThread also performs</span></div><div class="line">            <span class="comment">// a resume.</span></div><div class="line">            r.state = ActivityState.RESUMED;</div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to RESUMED: "</span> + r</div><div class="line">                    + <span class="string">" (starting new instance)"</span>);</div><div class="line">            r.stopped = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 保存当前 resume 的 AR 记录</span></div><div class="line">            mResumedActivity = r;</div><div class="line">            r.task.touchActiveTime();</div><div class="line">            <span class="keyword">if</span> (mMainStack) {</div><div class="line">                mService.addRecentTaskLocked(r.task);</div><div class="line">            }       </div><div class="line">            <span class="comment">// AMS Resume 的集中埋点处</span></div><div class="line">            completeResumeLocked(r);</div><div class="line">            checkReadyForSleepLocked();</div><div class="line">            <span class="keyword">if</span> (DEBUG_SAVED_STATE) Slog.i(TAG, <span class="string">"Launch completed; removing icicle of "</span> + r.icicle);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// This activity is not starting in the resumed state... which</span></div><div class="line">            <span class="comment">// should look like we asked it to pause+stop (but remain visible),</span></div><div class="line">            <span class="comment">// and it has done so and reported back the current icicle and</span></div><div class="line">            <span class="comment">// other state.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to STOPPED: "</span> + r</div><div class="line">                    + <span class="string">" (starting in stopped state)"</span>);</div><div class="line">            r.state = ActivityState.STOPPED;</div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">        }                       </div><div class="line">                                </div><div class="line">        <span class="comment">// Launch the new version setup screen if needed.  We do this -after-</span></div><div class="line">        <span class="comment">// launching the initial activity (that is, home), so that it can have</span></div><div class="line">        <span class="comment">// a chance to initialize itself while in the background, making the</span></div><div class="line">        <span class="comment">// switch back to it faster and look better.</span></div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            mService.startSetupActivityLocked();</div><div class="line">        }       </div><div class="line">            </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后剩下的流程比较简单，我把代码合并在一起了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =================== ActivityStack.java ======================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Once we know that we have asked an application to put an activity in</span></div><div class="line"><span class="comment">     * the resumed state (either by launching it or explicitly telling it),</span></div><div class="line"><span class="comment">     * this function updates the rest of our state to match that fact.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">completeResumeLocked</span>(ActivityRecord next) {</div><div class="line">        next.idle = <span class="keyword">false</span>;</div><div class="line">        next.results = <span class="keyword">null</span>;</div><div class="line">        next.newIntents = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// schedule an idle timeout in case the app doesn't do it for us.</span></div><div class="line">        Message msg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG);</div><div class="line">        msg.obj = next;</div><div class="line">        mHandler.sendMessageDelayed(msg, IDLE_TIMEOUT);</div><div class="line">                    </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">            <span class="comment">// The activity was never told to pause, so just keep</span></div><div class="line">            <span class="comment">// things going as-is.  To maintain our own state,</span></div><div class="line">            <span class="comment">// we need to emulate it coming back and saying it is</span></div><div class="line">            <span class="comment">// idle.</span></div><div class="line">            msg = mHandler.obtainMessage(IDLE_NOW_MSG);</div><div class="line">            msg.obj = next;</div><div class="line">            mHandler.sendMessage(msg);</div><div class="line">        }   </div><div class="line">        </div><div class="line">        <span class="comment">// 调用 AMS 的 reportResumedActivityLocked，传递当前的 AR 记录</span></div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            mService.reportResumedActivityLocked(next);</div><div class="line">        }</div><div class="line">       </div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            mService.setFocusedActivityLocked(next);</div><div class="line">        }</div><div class="line">        next.resumeKeyDispatchingLocked();</div><div class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">        mService.mWindowManager.executeAppTransition();</div><div class="line">        mNoAnimActivities.clear();</div><div class="line"></div><div class="line">        <span class="comment">// Mark the point when the activity is resuming</span></div><div class="line">        <span class="comment">// TODO: To be more accurate, the mark should be before the onCreate,</span></div><div class="line">        <span class="comment">//       not after the onResume. But for subsequent starts, onResume is fine.</span></div><div class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">synchronized</span> (mService.mProcessStatsThread) {</div><div class="line">                next.cpuTimeAtResume = mService.mProcessStats.getCpuTimeForPid(next.app.pid);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            next.cpuTimeAtResume = <span class="number">0</span>; <span class="comment">// Couldn't get the cpu time of process</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// =================== ActivityManagerService.java ======================</span></div><div class="line"></div><div class="line">    <span class="keyword">void</span> reportResumedActivityLocked(ActivityRecord r) {</div><div class="line">        <span class="comment">//Slog.i(TAG, "**** REPORT RESUME: " + r);</span></div><div class="line">        updateUsageStats(r, <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">void</span> updateUsageStats(ActivityRecord resumedComponent, <span class="keyword">boolean</span> resumed) {</div><div class="line">        <span class="keyword">if</span> (resumed) {</div><div class="line">            <span class="comment">// 调用 USS 的 noteResumeComponent，当前的 AR 中有 ComponentName 信息</span></div><div class="line">            mUsageStatsService.noteResumeComponent(resumedComponent.realActivity);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mUsageStatsService.notePauseComponent(resumedComponent.realActivity);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实 AS 是 AMS 中分出去的一部分，AS 中还有不少回调用 AMS 的地方的。</p>
<ul>
<li><strong>branch2:</strong></li>
</ul>
<p>分支2的话主要是 AMS 和 AS 中有很多种情况会调用 AS 的 resumeTopActivityLocked，例如说按 Home 键回桌面；当前应用挂了，要恢复前一个应用；或者七七八八别的情况。由于这里主要不是分析 AMS 的地方，所以把这里省略了，主要从 resumeTopActivityLocked 这个入口开始说起（分支1中 startActivity 进程已经存在的情况最后也会走这个地方的）。从这里说其实就比较简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> resumeTopActivityLocked(ActivityRecord prev, Bundle options) {</div><div class="line">        <span class="comment">// 取最顶端的 AR 记录，作为下一个要 resume 的 activity</span></div><div class="line">        <span class="comment">// Find the first activity that is not finishing.</span></div><div class="line">        ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 要 resume 的 activity 进程还在</span></div><div class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span> && next.app.thread != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG, <span class="string">"Resume running: "</span> + next);</div><div class="line"></div><div class="line">            <span class="comment">// This activity is now becoming visible.</span></div><div class="line">            mService.mWindowManager.setAppVisibility(next.appToken, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            <span class="comment">// schedule launch ticks to collect information about slow apps.</span></div><div class="line">            next.startLaunchTickingLocked();</div><div class="line"></div><div class="line">            ActivityRecord lastResumedActivity = mResumedActivity;</div><div class="line">            ActivityState lastState = next.state;</div><div class="line"></div><div class="line">            mService.updateCpuStats();     </div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to RESUMED: "</span> + next + <span class="string">" (in existing)"</span>);</div><div class="line">            next.state = ActivityState.RESUMED;</div><div class="line">            <span class="comment">// 保存当前的 resume 的 AR 信息</span></div><div class="line">            mResumedActivity = next;       </div><div class="line">            next.task.touchActiveTime();   </div><div class="line">            <span class="keyword">if</span> (mMainStack) {</div><div class="line">                mService.addRecentTaskLocked(next.task);</div><div class="line">            }</div><div class="line">            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>);</div><div class="line">            updateLRUListLocked(next);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// Deliver all pending results.</span></div><div class="line">                ArrayList a = next.results;</div><div class="line">                <span class="keyword">if</span> (a != <span class="keyword">null</span>) {</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</div><div class="line">                    <span class="keyword">if</span> (!next.finishing && N &gt; <span class="number">0</span>) {</div><div class="line">                        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(</div><div class="line">                                TAG, <span class="string">"Delivering results to "</span> + next</div><div class="line">                                + <span class="string">": "</span> + a);</div><div class="line">                        next.app.thread.scheduleSendResult(next.appToken, a);</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) {</div><div class="line">                    next.app.thread.scheduleNewIntent(next.newIntents, next.appToken);</div><div class="line">                }</div><div class="line"></div><div class="line">                EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,</div><div class="line">                        next.userId, System.identityHashCode(next),</div><div class="line">                        next.task.taskId, next.shortComponentName);</div><div class="line"></div><div class="line">                next.sleeping = <span class="keyword">false</span>;</div><div class="line">                showAskCompatModeDialogLocked(next);</div><div class="line">                next.app.pendingUiClean = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 执行 activity 的 Resume 生命周期</span></div><div class="line">                next.app.thread.scheduleResumeActivity(next.appToken,</div><div class="line">                        mService.isNextTransitionForward());</div><div class="line"></div><div class="line">                checkReadyForSleepLocked();</div><div class="line"></div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// Whoops, need to restart this activity!</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Resume failed; resetting state to "</span></div><div class="line">                        + lastState + <span class="string">": "</span> + next);</div><div class="line">                next.state = lastState;</div><div class="line">                mResumedActivity = lastResumedActivity;</div><div class="line">                Slog.i(TAG, <span class="string">"Restarting because process died: "</span> + next);</div><div class="line">                <span class="keyword">if</span> (!next.hasBeenLaunched) {</div><div class="line">                    next.hasBeenLaunched = <span class="keyword">true</span>;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW && mMainStack) {</div><div class="line">                        mService.mWindowManager.setAppStartingWindow(</div><div class="line">                                next.appToken, next.packageName, next.theme,</div><div class="line">                                mService.compatibilityInfoForPackageLocked(</div><div class="line">                                        next.info.applicationInfo),</div><div class="line">                                next.nonLocalizedLabel,</div><div class="line">                                next.labelRes, next.icon, next.windowFlags,</div><div class="line">                                <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="comment">// 如果执行 activity Resume 生命周期出现错误的话（IPC 通信错误之类的）</span></div><div class="line">                <span class="comment">// 调用 startSpecificActivityLocked 重新启动这个 activity </span></div><div class="line">                <span class="comment">// 然后里面会调用 realStartActivityLocked 就和分支1后面一样了</span></div><div class="line">                startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// From this point on, if something goes wrong there is no way</span></div><div class="line">            <span class="comment">// to recover the activity.</span></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                next.visible = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 如果执行 activity Resume 生命周期没有错误的话就调用 completeResumeLocked</span></div><div class="line">                <span class="comment">// 之后的流程和分支1一样的</span></div><div class="line">                completeResumeLocked(next);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// If any exception gets thrown, toss away this</span></div><div class="line">                <span class="comment">// activity and try the next one.</span></div><div class="line">                Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</div><div class="line">                requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</div><div class="line">                        <span class="string">"resume-exception"</span>, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            next.stopped = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// Whoops, need to restart this activity!</span></div><div class="line">            <span class="keyword">if</span> (!next.hasBeenLaunched) {</div><div class="line">                next.hasBeenLaunched = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) {</div><div class="line">                    mService.mWindowManager.setAppStartingWindow(</div><div class="line">                            next.appToken, next.packageName, next.theme,</div><div class="line">                            mService.compatibilityInfoForPackageLocked(</div><div class="line">                                    next.info.applicationInfo),</div><div class="line">                            next.nonLocalizedLabel,</div><div class="line">                            next.labelRes, next.icon, next.windowFlags,</div><div class="line">                            <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG, <span class="string">"Restarting: "</span> + next);</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果要 resume 的 activity 的进程不在了，也需要重新启动</span></div><div class="line">            startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>分支2从各种情况调用到 AS 的 resumeTopActivityLocked，然后最后辗转几次还是到了 resume 的埋点函数 completeResumeLocked 这里。然后最后调用 USS 的接口，收集数据。</p>
<h4 id="notePauseComponent">notePauseComponent</h4>
<p>接下来是调用通知 Pause 的接口，也是先上图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/notePauseComponent.png" alt=""></p>
<p>首先从图上看，埋点函数是 AS 的 startPausingLocked:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startPausingLocked</span>(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping) {</div><div class="line">        <span class="comment">// 检测下当前是不是有 AR 正处于 Pause 的处理中，有的话就打印一个错误信息</span></div><div class="line">        <span class="comment">// 因为一次只能有一个 AR 处于 Pause 的处理中</span></div><div class="line">        <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) {</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException();</div><div class="line">            Slog.e(TAG, <span class="string">"Trying to pause when pause is already pending for "</span></div><div class="line">                  + mPausingActivity, e);</div><div class="line">        }</div><div class="line">        <span class="comment">// 要 Pause 是当前 Resume 的 AR，所以说 Resume 和 Pause 是成对的</span></div><div class="line">        ActivityRecord prev = mResumedActivity;</div><div class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 如果当前 Resume 的 AR 是 null 的话，说明有点问题，</span></div><div class="line">            <span class="comment">// 调用 resumeTopActivityLocked 去让一个 AR 处于 Resume 状态</span></div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException();</div><div class="line">            Slog.e(TAG, <span class="string">"Trying to pause when nothing is resumed"</span>, e);</div><div class="line">            resumeTopActivityLocked(<span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to PAUSING: "</span> + prev);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Start pausing: "</span> + prev);</div><div class="line">        <span class="comment">// 把 mResumedActivity 设置为 null，</span></div><div class="line">        <span class="comment">// 之前那个 Resume 的 AR 保存为 mPausingActivity，顺带更新下 AR 的状态</span></div><div class="line">        <span class="comment">// mResumedActivity 的话在前面 resumeTopActivityLocked 和 realStartActivityLocked 有设置，</span></div><div class="line">        <span class="comment">// 可以倒回去看一下，所以说只有保证 activity 的 Resume 在 Pause 前面才真正常运作</span></div><div class="line">        mResumedActivity = <span class="keyword">null</span>;</div><div class="line">        mPausingActivity = prev;</div><div class="line">        mLastPausedActivity = prev;</div><div class="line">        prev.state = ActivityState.PAUSING;</div><div class="line">        prev.task.touchActiveTime();</div><div class="line">        prev.updateThumbnail(screenshotActivities(prev), <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        mService.updateCpuStats();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (prev.app != <span class="keyword">null</span> && prev.app.thread != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Enqueueing pending pause: "</span> + prev);</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</div><div class="line">                        prev.userId, System.identityHashCode(prev),</div><div class="line">                        prev.shortComponentName);</div><div class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</div><div class="line">                        userLeaving, prev.configChangeFlags);</div><div class="line">                <span class="keyword">if</span> (mMainStack) {</div><div class="line">                    <span class="comment">// 调用 AMS 的 updateUsageStats 接口，传递 Pause 的 AR，第二参数 resumed 为 false</span></div><div class="line">                    <span class="comment">// resumed 为 false 的话会调用 USS 的 notePauseComponent 接口，这里不贴代码了</span></div><div class="line">                    mService.updateUsageStats(prev, <span class="keyword">false</span>);</div><div class="line">                }</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// Ignore exception, if process died other code will cleanup.</span></div><div class="line">                Slog.w(TAG, <span class="string">"Exception thrown during pause"</span>, e);</div><div class="line">                mPausingActivity = <span class="keyword">null</span>;</div><div class="line">                mLastPausedActivity = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mPausingActivity = <span class="keyword">null</span>;</div><div class="line">            mLastPausedActivity = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后调用 AS 埋点函数的大致分为3个分支。每个分支也是 AMS 里面有很多有种情况会调用，照样省略：</p>
<ul>
<li><strong>branch1:</strong></li>
</ul>
<p>分支1 AMS 里面会有很多种情况调用 AS 的 finishActivityLocked，最常见的就是按 back 键或是调用 finishActivity 结束 activity，那按生命周期首先得进入 Pause 状态处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @return Returns true if this activity has been removed from the history</span></div><div class="line"><span class="comment">     * list, or false if it is still in the list and will be removed later.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> finishActivityLocked(ActivityRecord r, <span class="keyword">int</span> index,</div><div class="line">            <span class="keyword">int</span> resultCode, Intent resultData, String reason, <span class="keyword">boolean</span> oomAdj) {</div><div class="line">        <span class="keyword">return</span> finishActivityLocked(r, index, resultCode, resultData, reason, <span class="keyword">false</span>, oomAdj);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @return Returns true if this activity has been removed from the history</span></div><div class="line"><span class="comment">     * list, or false if it is still in the list and will be removed later.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> finishActivityLocked(ActivityRecord r, <span class="keyword">int</span> index, <span class="keyword">int</span> resultCode,</div><div class="line">            Intent resultData, String reason, <span class="keyword">boolean</span> immediate, <span class="keyword">boolean</span> oomAdj) {</div><div class="line">        <span class="keyword">if</span> (r.finishing) {</div><div class="line">            Slog.w(TAG, <span class="string">"Duplicate finish request for "</span> + r);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (immediate) {</div><div class="line">            <span class="keyword">return</span> finishCurrentActivityLocked(r, index,</div><div class="line">                    FINISH_IMMEDIATELY, oomAdj) == <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == r) {</div><div class="line">            <span class="keyword">boolean</span> endTask = index &lt;= <span class="number">0</span>   </div><div class="line">                    || (mHistory.get(index-<span class="number">1</span>)).task != r.task;</div><div class="line">            <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG, </div><div class="line">                    <span class="string">"Prepare close transition: finishing "</span> + r);</div><div class="line">            mService.mWindowManager.prepareAppTransition(endTask</div><div class="line">                    ? WindowManagerPolicy.TRANSIT_TASK_CLOSE</div><div class="line">                    : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE, <span class="keyword">false</span>);</div><div class="line">       </div><div class="line">            <span class="comment">// Tell window manager to prepare for this one to be removed.</span></div><div class="line">            mService.mWindowManager.setAppVisibility(r.appToken, <span class="keyword">false</span>);</div><div class="line">            </div><div class="line">            <span class="comment">// 如果没有 AR 正在处于 Pause 状态，调用 startPausingLocked 开始 Pause 状态处理 </span></div><div class="line">            <span class="keyword">if</span> (mPausingActivity == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Finish needs to pause: "</span> + r);</div><div class="line">                <span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG, <span class="string">"finish() =&gt; pause with userLeaving=false"</span>);</div><div class="line">                startPausingLocked(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (r.state != ActivityState.PAUSING) {</div><div class="line">            <span class="comment">// If the activity is PAUSING, we will complete the finish once</span></div><div class="line">            <span class="comment">// it is done pausing; else we can just directly finish it here.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Finish not pausing: "</span> + r);</div><div class="line">            <span class="keyword">return</span> finishCurrentActivityLocked(r, index,</div><div class="line">                    FINISH_AFTER_PAUSE, oomAdj) == <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Finish waiting for pause of: "</span> + r);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li><strong>branch2:</strong></li>
</ul>
<p>分支2的话是前面说过的很多种情况会调用的 AS 的 resumeTopActivityLocked，例如启动一个新的 activity（前面说了会调用 resumeTopActivityLocked 的），就会先让当前处于前台的 activity 进入 Pause 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> resumeTopActivityLocked(ActivityRecord prev, Bundle options) {</div><div class="line">        <span class="comment">// Find the first activity that is not finishing.</span></div><div class="line">        ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 如果当前有正处于 Resume 的 AR，调用 startPausingLocked 把当前 Resume 的 AR</span></div><div class="line">        <span class="comment">// 变成 Pause 状态</span></div><div class="line">        <span class="comment">// We need to start pausing the current activity so the top one</span></div><div class="line">        <span class="comment">// can be resumed...</span></div><div class="line">        <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG, <span class="string">"Skip resume: need to start pausing"</span>);</div><div class="line">            <span class="comment">// At this point we want to put the upcoming activity's process</span></div><div class="line">            <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></div><div class="line">            <span class="comment">// very soon and it would be a waste to let it get killed if it</span></div><div class="line">            <span class="comment">// happens to be sitting towards the end.</span></div><div class="line">            <span class="keyword">if</span> (next.app != <span class="keyword">null</span> && next.app.thread != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// No reason to do full oom adj update here; we'll let that</span></div><div class="line">                <span class="comment">// happen whenever it needs to later.</span></div><div class="line">                mService.updateLruProcessLocked(next.app, <span class="keyword">false</span>);</div><div class="line">            }               </div><div class="line">            startPausingLocked(userLeaving, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li><strong>branch3:</strong></li>
</ul>
<p>分支3是很多种情况会调用的 AS 的 checkReadyForSleepLocked，好像是用处理休眠的。例如说放一段时间，设备会进入休眠状态，当然得把前台正在运行的 activity 变成 Pause 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">void</span> checkReadyForSleepLocked() {</div><div class="line">        <span class="keyword">if</span> (!mService.isSleeping()) {</div><div class="line">            <span class="comment">// Do not care.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!mSleepTimeout) {</div><div class="line">            <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// Still have something resumed; can't sleep until it is paused.</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Sleep needs to pause "</span> + mResumedActivity);</div><div class="line">                <span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG, <span class="string">"Sleep =&gt; pause with userLeaving=false"</span>);</div><div class="line">                <span class="comment">// 休眠没超时的会把当前处于前台的 activity 变成 Pause 状态</span></div><div class="line">                startPausingLocked(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// Still waiting for something to pause; can't sleep yet.</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Sleep still waiting to pause "</span> + mPausingActivity);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">        mHandler.removeMessages(SLEEP_TIMEOUT_MSG);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mGoingToSleep.isHeld()) {</div><div class="line">            mGoingToSleep.release();</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (mService.mShuttingDown) {</div><div class="line">            mService.notifyAll();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<h4 id="addLaunchTime">addLaunchTime</h4>
<p>最后是记录启动时长的接口，也先上图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/addLaunchTime.png" alt=""></p>
<p>启动所需时长的埋点函数是 AR 中的 windowsDraw：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// stack(AS), service(AMS), realActivity(ComponentName) 都在 AS 的 startActivityLocked 的时候</span></div><div class="line"><span class="comment">// new AR 传过去的，代码前面有，可以倒回去看一下</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowsDrawn</span>() {</div><div class="line">    <span class="keyword">synchronized</span>(service) {</div><div class="line">        <span class="keyword">if</span> (launchTime != <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 取当前的时间</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> curTime = SystemClock.uptimeMillis();</div><div class="line">            <span class="comment">// 拿当前时间减启动时候的时间</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> thisTime = curTime - launchTime;</div><div class="line">            <span class="comment">// 看下 AS 的 mInitialStartTime 是不是 0，如果不是的话拿 AS 的 mInitialStartTime 来计算，</span></div><div class="line">            <span class="comment">// 如果 mInitialStartTime 是 0，那么当 launchTime 来计算</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> totalTime = stack.mInitialStartTime != <span class="number">0</span></div><div class="line">                    ? (curTime - stack.mInitialStartTime) : thisTime;</div><div class="line">            <span class="keyword">if</span> (ActivityManagerService.SHOW_ACTIVITY_START_TIME) {</div><div class="line">                EventLog.writeEvent(EventLogTags.AM_ACTIVITY_LAUNCH_TIME,</div><div class="line">                        userId, System.identityHashCode(<span class="keyword">this</span>), shortComponentName,</div><div class="line">                        thisTime, totalTime);</div><div class="line">                StringBuilder sb = service.mStringBuilder;</div><div class="line">                sb.setLength(<span class="number">0</span>);</div><div class="line">                sb.append(<span class="string">"Displayed "</span>);</div><div class="line">                sb.append(shortComponentName);</div><div class="line">                sb.append(<span class="string">": "</span>);</div><div class="line">                TimeUtils.formatDuration(thisTime, sb);</div><div class="line">                <span class="keyword">if</span> (thisTime != totalTime) {</div><div class="line">                    sb.append(<span class="string">" (total "</span>);</div><div class="line">                    TimeUtils.formatDuration(totalTime, sb);</div><div class="line">                    sb.append(<span class="string">")"</span>);</div><div class="line">                }   </div><div class="line">                Log.i(ActivityManagerService.TAG, sb.toString());</div><div class="line">            }   </div><div class="line">            stack.reportActivityLaunchedLocked(<span class="keyword">false</span>, <span class="keyword">this</span>, thisTime, totalTime);</div><div class="line">            <span class="comment">// 通过前面计算得到的时间，传给 USS 保存</span></div><div class="line">            <span class="keyword">if</span> (totalTime &gt; <span class="number">0</span>) {</div><div class="line">                service.mUsageStatsService.noteLaunchTime(realActivity, (<span class="keyword">int</span>)totalTime);</div><div class="line">            }   </div><div class="line">            launchTime = <span class="number">0</span>;</div><div class="line">            stack.mInitialStartTime = <span class="number">0</span>;</div><div class="line">        }   </div><div class="line">        startTime = <span class="number">0</span>;</div><div class="line">        finishLaunchTickingLocked();</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 AR 的 launchTime 和对应的 AS（mMainStack） 的 mInitialStartTime 是在 AS 的 startSpecificActivityLocked 中设置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span>(ActivityRecord r,</div><div class="line">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig) {</div><div class="line">        <span class="comment">// Is this activity's application already running?</span></div><div class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</div><div class="line">                r.info.applicationInfo.uid);</div><div class="line">        </div><div class="line">        <span class="comment">// 如果要启动的 activity 对应的 AR 的 launchTime 为 0，取当前时间</span></div><div class="line">        <span class="keyword">if</span> (r.launchTime == <span class="number">0</span>) {     </div><div class="line">            r.launchTime = SystemClock.uptimeMillis();</div><div class="line">            <span class="keyword">if</span> (mInitialStartTime == <span class="number">0</span>) {</div><div class="line">                mInitialStartTime = r.launchTime;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mInitialStartTime == <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 或者如果 mInitialStartTime 为 0，也取当前时间</span></div><div class="line">            mInitialStartTime = SystemClock.uptimeMillis();</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们来看下在哪里调用了 startSpecificActivityLocked 这个函数。从 AMS 的 startActivity 开始，如果是第一次启动 activity，AS 中的 startActivityLocked 会创建新的 AR，然后转几下（什么 startActivityUncheckedLocked 什么之类的，中间很麻烦的，以后分析 AMS 的时候再具体说），最后到 resumeTopActivityLocked，由于这个时候 AR 的 app 信息是 null （第一次，进程还没跑）的就会调用到 startSpecificActivityLocked，然后由于 app 信息为 null，最后再调用到 AMS 的 startProcessLocked 去让 Zygote 去 fork 进程，然后就是前面 noteResumeComponent 的分支1流程了。如果不是第一次启动，然后进程信息还在（也就是 noteResumeComponent 的分支2），那么也会跑 startSpecificActivityLocked 的。</p>
<p>所以不管时候需要启动进程，startActivity 都要跑 startSpecificActivityLocked 这个函数，然后开始启动 activity 的计时（从这里可以看得出如果需要启动进程的话，计时肯定会很长的）。</p>
<p>弄清楚了从那开始计算时间，那么我看看在那结束计时的。从上面图来看，是在 WMS 中结束统计时长的，WMS 每一个 window 都有一个 AppWindowToken（AWT） 的结构，这个结构里面有一个 updateReportedVisibilityLocked 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> updateReportedVisibilityLocked() {</div><div class="line">    <span class="keyword">if</span> (appToken == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span>; </div><div class="line">    }       </div><div class="line"></div><div class="line">    <span class="keyword">int</span> numInteresting = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> numVisible = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> numDrawn = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> nowGone = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) Slog.v(WindowManagerService.TAG,</div><div class="line">            <span class="string">"Update reported visibility: "</span> + <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = allAppWindows.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">        WindowState win = allAppWindows.get(i);</div><div class="line">        <span class="keyword">if</span> (win == startingWindow || win.mAppFreezing</div><div class="line">                || win.mViewVisibility != View.VISIBLE</div><div class="line">                || win.mAttrs.type == TYPE_APPLICATION_STARTING</div><div class="line">                || win.mDestroying) {</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) {</div><div class="line">            Slog.v(WindowManagerService.TAG, <span class="string">"Win "</span> + win + <span class="string">": isDrawn="</span></div><div class="line">                    + win.isDrawnLw()</div><div class="line">                    + <span class="string">", isAnimating="</span> + win.mWinAnimator.isAnimating());</div><div class="line">            <span class="keyword">if</span> (!win.isDrawnLw()) {</div><div class="line">                Slog.v(WindowManagerService.TAG, <span class="string">"Not displayed: s="</span> + win.mWinAnimator.mSurface</div><div class="line">                        + <span class="string">" pv="</span> + win.mPolicyVisibility</div><div class="line">                        + <span class="string">" mDrawState="</span> + win.mWinAnimator.mDrawState</div><div class="line">                        + <span class="string">" ah="</span> + win.mAttachedHidden</div><div class="line">                        + <span class="string">" th="</span></div><div class="line">                        + (win.mAppToken != <span class="keyword">null</span></div><div class="line">                                ? win.mAppToken.hiddenRequested : <span class="keyword">false</span>)</div><div class="line">                        + <span class="string">" a="</span> + win.mWinAnimator.mAnimating);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        numInteresting++;</div><div class="line">        <span class="keyword">if</span> (win.isDrawnLw()) {</div><div class="line">            numDrawn++;</div><div class="line">            <span class="keyword">if</span> (!win.mWinAnimator.isAnimating()) {</div><div class="line">                numVisible++;</div><div class="line">            }</div><div class="line">            nowGone = <span class="keyword">false</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (win.mWinAnimator.isAnimating()) {</div><div class="line">            nowGone = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> nowDrawn = numInteresting &gt; <span class="number">0</span> && numDrawn &gt;= numInteresting;</div><div class="line">    <span class="keyword">boolean</span> nowVisible = numInteresting &gt; <span class="number">0</span> && numVisible &gt;= numInteresting;</div><div class="line">    <span class="keyword">if</span> (!nowGone) {</div><div class="line">        <span class="comment">// If the app is not yet gone, then it can only become visible/drawn.</span></div><div class="line">        <span class="keyword">if</span> (!nowDrawn) {</div><div class="line">            nowDrawn = reportedDrawn;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (!nowVisible) {</div><div class="line">            nowVisible = reportedVisible;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) Slog.v(WindowManagerService.TAG, <span class="string">"VIS "</span> + <span class="keyword">this</span> + <span class="string">": interesting="</span></div><div class="line">            + numInteresting + <span class="string">" visible="</span> + numVisible);</div><div class="line">    <span class="comment">// 前面那一堆 nowDrawn, reportedDrawn 有空再理会它们，</span></div><div class="line">    <span class="comment">// 反正这个 REPORT_APPLICATION_TOKEN_DRAWN 肯定能发出去的</span></div><div class="line">    <span class="keyword">if</span> (nowDrawn != reportedDrawn) {</div><div class="line">        <span class="keyword">if</span> (nowDrawn) {</div><div class="line">            Message m = service.mH.obtainMessage(</div><div class="line">                    H.REPORT_APPLICATION_TOKEN_DRAWN, <span class="keyword">this</span>);</div><div class="line">            service.mH.sendMessage(m);</div><div class="line">        }</div><div class="line">        reportedDrawn = nowDrawn;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (nowVisible != reportedVisible) {</div><div class="line">        <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) Slog.v(</div><div class="line">                WindowManagerService.TAG, <span class="string">"Visibility changed in "</span> + <span class="keyword">this</span></div><div class="line">                + <span class="string">": vis="</span> + nowVisible);</div><div class="line">        reportedVisible = nowVisible;</div><div class="line">        Message m = service.mH.obtainMessage(</div><div class="line">                H.REPORT_APPLICATION_TOKEN_WINDOWS,</div><div class="line">                nowVisible ? <span class="number">1</span> : <span class="number">0</span>,</div><div class="line">                nowGone ? <span class="number">1</span> : <span class="number">0</span>,</div><div class="line">                <span class="keyword">this</span>);</div><div class="line">        service.mH.sendMessage(m);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 WMS 里面的 Handler 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> REPORT_APPLICATION_TOKEN_DRAWN: {</div><div class="line">    <span class="keyword">final</span> AppWindowToken wtoken = (AppWindowToken)msg.obj;</div><div class="line">               </div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (DEBUG_VISIBILITY) Slog.v(</div><div class="line">                TAG, <span class="string">"Reporting drawn in "</span> + wtoken);</div><div class="line">        <span class="comment">// 这个 appToken 是 AR 那里实现的一个 Binder 对象</span></div><div class="line">        wtoken.appToken.windowsDrawn();</div><div class="line">    } <span class="keyword">catch</span> (RemoteException ex) { </div><div class="line">    } </div><div class="line">} <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>懒得说 Binder 那些东西了，忘了的自觉去 Binder 篇相关的东西，直接上 AR 中相关的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> class Token extends IApplicationToken.Stub {</div><div class="line">        <span class="keyword">final</span> WeakReference&lt;ActivityRecord&gt; weakActivity;</div><div class="line"></div><div class="line">        Token(ActivityRecord activity) {</div><div class="line">            weakActivity = <span class="keyword">new</span> WeakReference&lt;ActivityRecord&gt;(activity);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowsDrawn</span>() <span class="keyword">throws</span> RemoteException {</div><div class="line">            <span class="comment">// 最后还是调用 AR 中的 windowsDrawn 了</span></div><div class="line">            ActivityRecord activity = weakActivity.get(); </div><div class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {        </div><div class="line">                activity.windowsDrawn();       </div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面 AWP 的 updateReportedVisibilityLocked 在 WMS 中也是有很多地方会调用的，例如 relayoutWindow、开始窗口变化动画等等地方。从这里可以看得出，USS 中统计 activity 启动需要的时间，是从发起 startActivity 请求（startSpecificActivityLocked）开始，直到对应 activity 的窗口开始绘制（窗口可见）这段时间。</p>
<h4 id="AMS_小分析">AMS 小分析</h4>
<p>这里算是把3个接口的埋点分析完了。本来说 AMS 和 WMS 太复杂了，留给以后再慢慢来看，但是没忍住还是稍微把 startActivity 的一般流程分析了一下，来一张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/startActivity.png" alt=""></p>
<p>这里就不上代码解说了，这篇已经够长了，看看图差不多大概明白流程是怎么回事了。图中我画了比较常见的3种情况（所有情况没画全，太多分支了）：</p>
<ul>
<li><p><strong>branch1:</strong><br>要 launch 的 activity 进程不存在。其中 mResumedActivity 代表之前有没有处于 Resume 状态的 activity，有的话要先那个变成 Pause 状态（一般都有，没有的情况就是刚开机 launch 桌面的时候，排除第一次开机那个 Provision，桌面是第一 launch 的 activity）。这种情况需要先让 Zygote fork 出对应的进程，然后等待进程启动后，调用 AMS 的 attachApplication 接口继续跑后面的流程（前面的 Service、Broadcast 都有类似的过程了）。</p>
</li>
<li><p><strong>branch2:</strong><br>要 launch 的 activity 进程已经存在，但是不存在对应的 TaskRecord(ActivityRecord)，launch 了 activity 在 AMS 中对应就有保存有 ActivityRecord（AR），但是如果调用 finishActivity（onDestroy）会销毁 ActivityRecord，典型的情况按 back 键返回。这种情况和 branch1 AMS attchApplication 接口后面的流程是一样的，就是不需要等待 Zygote fork 进程而已。</p>
</li>
<li><p><strong>branch3:</strong><br>要 launch 的 activity 进程已经，并且存在对应的 TaskRecord(ActivityRecord)，最典型的情况就是按 home 键回桌面。这种情况先把对应的 Task 移动到前台，然后让 activity 走下 Resume 流程就行了。</p>
</li>
</ul>
<p>上面我把我们开发应用熟悉的 activity 的那几个生命周期回调用红色标了出来，上面的埋点函数用紫色的标了一下，大家可以对比前面的解说再好好看看。最后上一个官方 sdk doc 上的 activity 的生命周期图，对 android activity 生命周期实现、管理有更加深入的理解：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/activity_lifecycle.png" alt=""></p>
<p>然后再附上一段官方的说明：</p>
<ul>
<li><p><font color="#ff0000">The entire lifetime</font> of an activity happens between the first call to <strong>onCreate(Bundle)</strong> through to a single final call to onDestroy(). An activity will do all setup of “global” state in onCreate(), and release all remaining resources in <strong>onDestroy()</strong>. For example, if it has a thread running in the background to download data from the network, it may create that thread in onCreate() and then stop the thread in onDestroy().</p>
</li>
<li><p><font color="#ff0000">The visible lifetime</font> of an activity happens between a call to <strong>onStart()</strong> until a corresponding call to <strong>onStop()</strong>. During this time the user can see the activity on-screen, though it may not be in the foreground and interacting with the user. Between these two methods you can maintain resources that are needed to show the activity to the user. For example, you can register a BroadcastReceiver in onStart() to monitor for changes that impact your UI, and unregister it in onStop() when the user no longer sees what you are displaying. The onStart() and onStop() methods can be called multiple times, as the activity becomes visible and hidden to the user.</p>
</li>
<li><p><font color="#ff0000">The foreground lifetime</font> of an activity happens between a call to <strong>onResume()</strong> until a corresponding call to <strong>onPause()</strong>. During this time the activity is in front of all other activities and interacting with the user. An activity can frequently go between the resumed and paused states — for example when the device goes to sleep, when an activity result is delivered, when a new intent is delivered — so the code in these methods should be fairly lightweight. </p>
</li>
</ul>
<p>从 onCreate 到 onDestroy 算是 activity 的存在时间，从 onStart 到 onStop 算是 activity 处于可见的时间，从 onResume 到 onPause 算是 activity 的处于前台的时间。这里比较迷惑的是可见时间和处于前台的时候。这里稍微说明下，所谓处于前台是处于当前 activity 堆栈（AS）的最顶部，能够接收输入焦点，例如说正在交互的 activity。那所谓的可见时间呢，其实有些时候就算 activity 不在 AS 的最顶部，也是可见的，最典型的情况上当前正在交互的 activity 是个半透明的，所以它下面那个 activity 是可见的，但是不处于前台（处于 onPause 状态，但是没还到 onStop 状态）。所以上面的图，可见时间比前台时间要长就是这个原因。从这个来看 USS 统计的启动时长，感觉像是从 onCreate 到 onStart 那段时间。我本来还以为 onStart 要涉及 WMS，等待窗口开始绘制才会调用的，但是好像并不是我想的那样，就是在 onCreate 后几句就调用 onRestart，不过在 onStop 后还是有区别的，在 activity 的存在周期，onCreate 只会调用一次，但是 onStart 可能会有多次。</p>
<p>还有上面 onStop 这个回调的时间很有意思，官方的解说是： activity no longer visible。怎么才算 no longer visible ？？ 看上面的流程图会发现，当 activity 开始 Pasuing 流程的时候，AR 会保存到一个叫 mStopActivites 的列表中（进行 Resume 的时候会从里面删掉自己）。然后当一个 activity 的主线程（UI 线程）的 Handler 的消息队列（MessageQueue）为空的时候会激发一个 IdlerHandler 的回调（每个程序的 ActivityThread 会设置这个回调），它会向 AMS 报告 activity idle 消息，在 idle 消息处理中会查看 mStopActivites 中哪里 AR 可以进入 Stop 状态（进入之后会从 mStopActivites 中删除，AMS 的 idle 处理还有别的工作要做，这里只说 stop 处理）。其实激发 AMS activity idle 的地方还有别的地方，但是 Handler idle 是一个比较典型的地方。我说之前看到 Handler 的 MessageQueue 那有个啥 idle handler 的处理，不知道干什么，现在知道了。</p>
<p>所以这里可以知道一个比较好玩的东西，就是 android 认为 UI 线程的消息队列为空，就代表这个 activity 空闲了。其实这个设定也是合理的因为上层的应用交互都是基于消息队列驱动的。然后也明白了 no longer 是要等 activity 的 UI 线程的消息队列为空。以后有空把 Handler、Looper、MessageQueue 也好好整理分析下。</p>
<h3 id="保存数据">保存数据</h3>
<p>上面扯了一下 AMS 相关的流程（因为 USS 埋点要在 AMS 里面埋），现在回来把数据保存说一下。前面在说数据结构那，把 USS 保存过的数据 dump 出来了，然后它的结构就是一个 Map，以 pkg 为 key，一个 pkg 一条。然后每条里面有一个 TimeStats 的东西，又包含了一个 HashMap 以 ComponentName 为 key，一个 component 一条，所以从逻辑上来说内存结构应该是这样的（前面 dump 出来的数据也很直观了）：</p>
<p>pkg1:<br>  component1: xx xx xx xx<br>  component2: xx xx xx xx<br>  component3: xx xx xx xx<br>pkg2:<br>  component1: xx xx xx xx<br>pkg3:<br>  component1: xx xx xx xx<br>  component2: xx xx xx xx<br>… …</p>
<p>这里的保存，就是要把内存中的这些数据写到文件中。看到这个，在 android 中你就要想到 Parcel 要出场了。其实前面说数据结构的时候，就看到 PkgUsageStatsExtended 和 TimeStats 都有对应的 Parcelable 的函数（倒回去看一下）。先把这些说清楚，后面看起保存数据的代码就简单了。在上面埋点统计那，notePauseComponent 和 noteLaunchTime 会调用有一个函数 writeStatsToFile（代码不算太长，一次性贴完了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ======================== UsageStatsService.java =========================</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_PREFIX = <span class="string">"usage-"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FILE_WRITE_INTERVAL = <span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Calendar mCal; <span class="comment">// guarded by itself</span></div><div class="line"></div><div class="line">    <span class="comment">// java 的 Atomic 系列，能够保证访问、修改的原子性，也后可以也学学该怎么用这些东西</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mLastWriteDay = <span class="keyword">new</span> AtomicInteger(-<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong mLastWriteElapsedTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mUnforcedDiskWriteRunning = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 这个函数就是把 USS 统计数据写入文件保存的函数</span></div><div class="line">    <span class="comment">// 2个 boolean 参数，是否强制写入。虽然上面埋点那会调用这个函数，但是不是每次调用都会写文件，</span></div><div class="line">    <span class="comment">// USS 有一个保存策略的，代码看代码再具体说这个策略。当然可以传 true 无视这个策略。</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Conditionally start up a disk write if it's been awhile, or the</span></div><div class="line"><span class="comment">     * day has rolled over.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This is called indirectly from user-facing actions (when</span></div><div class="line"><span class="comment">     * 'force' is false) so it tries to be quick, without writing to</span></div><div class="line"><span class="comment">     * disk directly or acquiring heavy locks.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @params force  do an unconditional, synchronous stats flush</span></div><div class="line"><span class="comment">     *                to disk on the current thread.</span></div><div class="line"><span class="comment">     * @params forceWriteHistoryStats Force writing of historical stats.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeStatsToFile</span>(<span class="keyword">final</span> <span class="keyword">boolean</span> force, <span class="keyword">final</span> <span class="keyword">boolean</span> forceWriteHistoryStats) {</div><div class="line">        <span class="keyword">int</span> curDay;</div><div class="line">        <span class="comment">// 前面注释也有说用的时候要自己注意同步锁</span></div><div class="line">        <span class="keyword">synchronized</span> (mCal) {</div><div class="line">            mCal.setTimeInMillis(System.currentTimeMillis());</div><div class="line">            curDay = mCal.get(Calendar.DAY_OF_YEAR);</div><div class="line">        }    </div><div class="line">        <span class="comment">// 取当前的时候和最后一次保存的时间对比，看看是不是同一天</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> dayChanged = curDay != mLastWriteDay.get();</div><div class="line"></div><div class="line">        <span class="comment">// Determine if the day changed...  note that this will be wrong</span></div><div class="line">        <span class="comment">// if the year has changed but we are in the same day of year...</span></div><div class="line">        <span class="comment">// we can probably live with this.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currElapsedTime = SystemClock.elapsedRealtime();</div><div class="line"></div><div class="line">        <span class="comment">// 如果没有强制保存的话，这里就会应用一个保存策略：</span></div><div class="line">        <span class="comment">// 一天保存一次（dayChanged），并且本次保存要和上一次保存的间隔超过 FILE_WRITE_INTERVAL（30分钟）</span></div><div class="line">        <span class="comment">// 不满足的话直接返回，满足的话开一个线程来写（线程里面调用自己是强制写的）。</span></div><div class="line">        <span class="comment">// 不过我太不喜欢 java 这样随手匿名 new 一个线程就 run。</span></div><div class="line">        <span class="comment">// Fast common path, without taking the often-contentious</span></div><div class="line">        <span class="comment">// mFileLock.</span></div><div class="line">        <span class="keyword">if</span> (!force) {</div><div class="line">            <span class="keyword">if</span> (!dayChanged &&</div><div class="line">                (currElapsedTime - mLastWriteElapsedTime.get()) &lt; FILE_WRITE_INTERVAL) {</div><div class="line">                <span class="comment">// wait till the next update</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mUnforcedDiskWriteRunning.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</div><div class="line">                <span class="keyword">new</span> Thread(<span class="string">"UsageStatsService_DiskWriter"</span>) {</div><div class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="keyword">if</span> (localLOGV) Slog.d(TAG, <span class="string">"Disk writer thread starting."</span>);</div><div class="line">                            writeStatsToFile(<span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">                        } <span class="keyword">finally</span> {</div><div class="line">                            mUnforcedDiskWriteRunning.set(<span class="keyword">false</span>);</div><div class="line">                            <span class="keyword">if</span> (localLOGV) Slog.d(TAG, <span class="string">"Disk writer thread ending."</span>);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }.start();</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 满足上面的策略判断后就开始写文件。</span></div><div class="line">        <span class="comment">// 这里用的锁是专门用来锁读、写文件的，前面访问数据的用的是另外一个。</span></div><div class="line">        <span class="comment">// 访问内存数据和读写文件分开锁，能提供并发能力</span></div><div class="line">        <span class="keyword">synchronized</span> (mFileLock) {</div><div class="line">            <span class="comment">// 这里是获取最近保存一次的文件名，其实就是： FILE_PREFIX+当前的日期，</span></div><div class="line">            <span class="comment">// 类似这样的： usage-2015-03-06，具体代码不贴了</span></div><div class="line">            <span class="comment">// Get the most recent file</span></div><div class="line">            mFileLeaf = getCurrentDateStr(FILE_PREFIX);</div><div class="line">            <span class="comment">// Copy current file to back up</span></div><div class="line">            File backupFile = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 如果上一次保存过的文件在，那么先把上次的文件重命名为 xx.bak</span></div><div class="line">            <span class="comment">// 后面如果写文件失败，会再把原文件改个名字还远回去，这种做法值得学习</span></div><div class="line">            <span class="keyword">if</span> (mFile != <span class="keyword">null</span> && mFile.exists()) {</div><div class="line">                backupFile = <span class="keyword">new</span> File(mFile.getPath() + <span class="string">".bak"</span>);</div><div class="line">                <span class="keyword">if</span> (!backupFile.exists()) {</div><div class="line">                    <span class="keyword">if</span> (!mFile.renameTo(backupFile)) {</div><div class="line">                        Slog.w(TAG, <span class="string">"Failed to persist new stats"</span>);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    mFile.delete();</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 具体写的内容在下面这个函数中</span></div><div class="line">                <span class="comment">// Write mStats to file</span></div><div class="line">                writeStatsFLOCK(mFile);</div><div class="line">                <span class="comment">// 保存最后一次写文件的时间</span></div><div class="line">                mLastWriteElapsedTime.set(currElapsedTime);</div><div class="line">                <span class="comment">// 如果日期变更的话，成功把当前数据写入文件后，会清除当前的数据</span></div><div class="line">                <span class="comment">// 也就是说文件中保存的数据就是一天的统计情况（怪不得以一天的日期来命名）</span></div><div class="line">                <span class="keyword">if</span> (dayChanged) {</div><div class="line">                    mLastWriteDay.set(curDay);</div><div class="line">                    <span class="comment">// clear stats</span></div><div class="line">                    <span class="keyword">synchronized</span> (mStats) {</div><div class="line">                        mStats.clear();</div><div class="line">                    }</div><div class="line">                    <span class="comment">// 这个 mDir USS 初始化的时候 AMS 传递进来过的，</span></div><div class="line">                    <span class="comment">// 保存数据的路径是： /data/system/usagestats</span></div><div class="line">                    mFile = <span class="keyword">new</span> File(mDir, mFileLeaf);</div><div class="line">                    <span class="comment">// 检测下保存的文件数量（默认的 USS 只保存最近5天的文件）</span></div><div class="line">                    checkFileLimitFLOCK();</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 那个历史记录的这里不管先</span></div><div class="line">                <span class="keyword">if</span> (dayChanged || forceWriteHistoryStats) {</div><div class="line">                    <span class="comment">// Write history stats daily, or when forced (due to shutdown).</span></div><div class="line">                    writeHistoryStatsFLOCK(mHistoryFile);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 文件成功写入后，把之前的 .bak 文件删掉</span></div><div class="line">                <span class="comment">// Delete the backup file</span></div><div class="line">                <span class="keyword">if</span> (backupFile != <span class="keyword">null</span>) {</div><div class="line">                    backupFile.delete();</div><div class="line">                }</div><div class="line">            } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                Slog.w(TAG, <span class="string">"Failed writing stats to file:"</span> + mFile);</div><div class="line">                <span class="comment">// 如果写入文件失败，把 .bak 改个名字还远回去</span></div><div class="line">                <span class="keyword">if</span> (backupFile != <span class="keyword">null</span>) {</div><div class="line">                    mFile.delete();</div><div class="line">                    backupFile.renameTo(mFile);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.d(TAG, <span class="string">"Dumped usage stats."</span>);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeStatsFLOCK</span>(File file) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="comment">// 这里的流程是这样的，可以学习在 android 上怎么比较好的保存文件：</span></div><div class="line">        <span class="comment">// 1. 从一个存储介质路径创建一个 File 对象</span></div><div class="line">        <span class="comment">// 2. 从 File 文件中创建 java 输出流对象（FOS）</span></div><div class="line">        <span class="comment">// 3. new 一个 Parcel（下面的 Parcel.obtain 会有缓存效果）</span></div><div class="line">        <span class="comment">// 4. 拿 Parcel 给实现了 Parcelable 接口的对象打包数据到 Parcel 内存中</span></div><div class="line">        <span class="comment">// 5. 调用 Parcel 的 marshall 获取之前打包的内存字节流</span></div><div class="line">        <span class="comment">// 6. 把获取的内存字节流写入 FOS 中(flush FOS)</span></div><div class="line">        <span class="comment">// 7. 最后调用下 FOS 的文件描述 sync，然 FOS 的内存数据同步到存储介质（文件）上去</span></div><div class="line">        <span class="comment">// 8. 释放数据：回收 Parcel 数据，关闭输出流</span></div><div class="line">        FileOutputStream stream = <span class="keyword">new</span> FileOutputStream(file);                                  </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Parcel out = Parcel.obtain();  </div><div class="line">            writeStatsToParcelFLOCK(out);  </div><div class="line">            stream.write(out.marshall());</div><div class="line">            <span class="comment">// 用完了 Parcel 回收一下数据  </span></div><div class="line">            out.recycle();</div><div class="line">            stream.flush();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            FileUtils.sync(stream); </div><div class="line">            <span class="comment">// 关闭文件流       </span></div><div class="line">            stream.close();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeStatsToParcelFLOCK</span>(Parcel out) {</div><div class="line">        <span class="comment">// 这里要访问数据了，加数据同步锁</span></div><div class="line">        <span class="keyword">synchronized</span> (mStatsLock) {  </div><div class="line">            <span class="comment">// 先写入版本号（检测数据有效性用的）      </span></div><div class="line">            out.writeInt(VERSION);         </div><div class="line">            Set&lt;String&gt; keys = mStats.keySet();</div><div class="line">            <span class="comment">// 再写入有几条 PkgUsageStatsExtended 数据</span></div><div class="line">            out.writeInt(keys.size());</div><div class="line">            <span class="comment">// 后面就循环的把每一条 PkgUsageStatsExtended 写入</span></div><div class="line">            <span class="keyword">for</span> (String key : keys) {          </div><div class="line">                PkgUsageStatsExtended pus = mStats.get(key);</div><div class="line">                <span class="comment">// 先写 pkg name</span></div><div class="line">                out.writeString(key);</div><div class="line">                <span class="comment">// 然后调用 PkgUsageStatsExtended 的 Parcel 写入接口写数据</span></div><div class="line">                <span class="comment">// PkgUsageStatsExtended 的写入接口倒回去看数据结构那的代码</span></div><div class="line">                pus.writeToParcel(out);    </div><div class="line">            }                 </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ======================== FileUtils.java =========================</span></div><div class="line"></div><div class="line">    <span class="comment">// 这里就获取了下 FOS 的文件描述符，然后调用对应的文件描述符接口</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform an fsync on the given FileOutputStream.  The stream at this</span></div><div class="line"><span class="comment">     * point must be flushed but not yet closed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sync</span>(FileOutputStream stream) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (stream != <span class="keyword">null</span>) {          </div><div class="line">                stream.getFD().sync();         </div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {      </div><div class="line">        }                     </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面是从文件中读数据的接口： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readStatsFromFile</span>() {</div><div class="line">    File newFile = mFile;</div><div class="line">    <span class="comment">// 读写文件锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mFileLock) {     </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (newFile.exists()) { </div><div class="line">                <span class="comment">// 真正的读数据在下面这个函数中       </span></div><div class="line">                readStatsFLOCK(newFile);       </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 文件不存在就创建一个新的</span></div><div class="line">                <span class="comment">// Check for file limit before creating a new file</span></div><div class="line">                <span class="comment">// 检测下文件个数限制</span></div><div class="line">                checkFileLimitFLOCK();         </div><div class="line">                newFile.createNewFile();       </div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {      </div><div class="line">            Slog.w(TAG,<span class="string">"Error : "</span> + e + <span class="string">" reading data from file:"</span> + newFile);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">   </div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readStatsFLOCK</span>(File file) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="comment">// 从保存数据的文件中转载 Parcel 数据</span></div><div class="line">    Parcel in = getParcelForFile(file);</div><div class="line">    <span class="comment">// 先读版本号（顺序要和前面写的一致）</span></div><div class="line">    <span class="keyword">int</span> vers = in.readInt();       </div><div class="line">    <span class="comment">// 如果数据版本号和当前的不一样的，认为该数据无效</span></div><div class="line">    <span class="keyword">if</span> (vers != VERSION) {</div><div class="line">        Slog.w(TAG, <span class="string">"Usage stats version changed; dropping"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 读取 PkgUsageStatsExtended 的数量 </span></div><div class="line">    <span class="keyword">int</span> N = in.readInt();</div><div class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) {</div><div class="line">        N--;</div><div class="line">        <span class="comment">// 读每一条 PkgUsageStatsExtended 的 pkg name</span></div><div class="line">        String pkgName = in.readString();</div><div class="line">        <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Reading package #"</span> + N + <span class="string">": "</span> + pkgName);</div><div class="line">        <span class="comment">// 调用 PkgUsageStatsExtended 的 Parcelable 读接口填充数据</span></div><div class="line">        PkgUsageStatsExtended pus = <span class="keyword">new</span> PkgUsageStatsExtended(in);</div><div class="line">        <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">            <span class="comment">// 将填充好的 PkgUsageStatsExtended 保存到 USS 数据列表中</span></div><div class="line">            mStats.put(pkgName, pus);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> Parcel <span class="title">getParcelForFile</span>(File file) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="comment">// 这里可以和上面写对应可以学习怎么从文件中利用 Parcel 读数据：</span></div><div class="line">    <span class="comment">// 1. 打开 File 对象</span></div><div class="line">    <span class="comment">// 2. 从 File 中创建 java 输入流对象（FIS）</span></div><div class="line">    <span class="comment">// 3. 从 FIS 中读出直接流到内存中（数据不多的可以一次性读完）</span></div><div class="line">    <span class="comment">// 4. new Parcel 对象（同样利用 Parcel.obtain 会有缓存效果）</span></div><div class="line">    <span class="comment">// 5. 把内存字节流传给 Parcel unmarshall 转载到 Parcel 中</span></div><div class="line">    <span class="comment">// 6. 关闭 FIS</span></div><div class="line">    <span class="comment">// 7. 把转载好数据的 Parcel 给 Parcelable 对象读数据</span></div><div class="line">    <span class="comment">// 8. 释放数据：关闭输入流，回收 Parcel 数据</span></div><div class="line">    <span class="comment">// 读这里好像没 recycle obtain 的 parcel，我觉得应该要 recycle 一下的，</span></div><div class="line">    <span class="comment">// 虽然说 recycle 会把 parcel 的内存释放掉，但是读的时候应该都 copy 到对象自己</span></div><div class="line">    <span class="comment">// 的数据里面来了吧，改天有空自己试一下这个东西</span></div><div class="line">    FileInputStream stream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">    <span class="keyword">byte</span>[] raw = readFully(stream);</div><div class="line">    Parcel in = Parcel.obtain();   </div><div class="line">    in.unmarshall(raw, <span class="number">0</span>, raw.length);</div><div class="line">    <span class="comment">// 注意下把数据指针移到初始位置</span></div><div class="line">    in.setDataPosition(<span class="number">0</span>);</div><div class="line">    stream.close();</div><div class="line">    <span class="keyword">return</span> in;</div><div class="line">}</div><div class="line">   </div><div class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] readFully(FileInputStream stream) <span class="keyword">throws</span> java.io.IOException {</div><div class="line">    <span class="comment">// java 的 I/O 操作，没啥好讲的，自己看看就行</span></div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> avail = stream.available();</div><div class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[avail]; </div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">        <span class="keyword">int</span> amt = stream.read(data, pos, data.length-pos);</div><div class="line">        <span class="keyword">if</span> (amt &lt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">return</span> data;</div><div class="line">        }</div><div class="line">        pos += amt;</div><div class="line">        avail = stream.available();    </div><div class="line">        <span class="keyword">if</span> (avail &gt; data.length-pos) { </div><div class="line">            <span class="keyword">byte</span>[] newData = <span class="keyword">new</span> <span class="keyword">byte</span>[pos+avail]; </div><div class="line">            System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, pos);</div><div class="line">            data = newData;                </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们看下文件数量的限制方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line">         </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM_FILES = <span class="number">5</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getUsageStatsFileListFLOCK</span>() {</div><div class="line">        <span class="comment">// 首先列出 /data/system/usagestats 目录下的所有文件列表</span></div><div class="line">        <span class="comment">// Check if there are too many files in the system and delete older files</span></div><div class="line">        String fList[] = mDir.list();</div><div class="line">        <span class="keyword">if</span> (fList == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        ArrayList&lt;String&gt; fileList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String file : fList) {</div><div class="line">            <span class="comment">// 不是 usage- 开头的文件忽略</span></div><div class="line">            <span class="keyword">if</span> (!file.startsWith(FILE_PREFIX)) {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            } </div><div class="line">            <span class="comment">// 把一些遗留的备份文件删掉  </span></div><div class="line">            <span class="keyword">if</span> (file.endsWith(<span class="string">".bak"</span>)) {</div><div class="line">                (<span class="keyword">new</span> File(mDir, file)).delete();</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line">            <span class="comment">// 添加到文件列表</span></div><div class="line">            fileList.add(file); </div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> fileList;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkFileLimitFLOCK</span>() {</div><div class="line">        <span class="comment">// 收集 /data/system/usagestats 目录下的所有数据文件</span></div><div class="line">        <span class="comment">// Get all usage stats output files</span></div><div class="line">        ArrayList&lt;String&gt; fileList = getUsageStatsFileListFLOCK();</div><div class="line">        <span class="keyword">if</span> (fileList == <span class="keyword">null</span>) {        </div><div class="line">            <span class="comment">// Strange but we dont have to delete any thing</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">int</span> count = fileList.size(); </div><div class="line">        <span class="comment">// 没超过限制个数返回  </span></div><div class="line">        <span class="keyword">if</span> (count &lt;= MAX_NUM_FILES) {  </div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 按照最近日期排个序列</span></div><div class="line">        <span class="comment">// Sort files</span></div><div class="line">        Collections.sort(fileList);    </div><div class="line">        count -= MAX_NUM_FILES;</div><div class="line">        <span class="comment">// 把超出限制范围的文件删掉        </span></div><div class="line">        <span class="comment">// Delete older files</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            String fileName = fileList.get(i);</div><div class="line">            File file = <span class="keyword">new</span> File(mDir, fileName);</div><div class="line">            Slog.i(TAG, <span class="string">"Deleting usage file : "</span> + fileName);</div><div class="line">            file.delete();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看完上面的了保存和读取接口，然后我们最后把 USS 调用到的地方看一下（这里不贴代码了，直接说那几个地方调用到了，用 grep 很容易找的）：</p>
<p>调用写（writeStatsToFile）的地方有：(调试的地方不算, true 代表强制写，false 使用保存策略)</p>
<ol>
<li>shutdown: true</li>
<li>notePauseComponent: false</li>
<li>noteLaunchTime: false</li>
</ol>
<p>调用读（readStatsFromFile）的地方有：</p>
<ol>
<li>UsageStatsService</li>
</ol>
<p>总结一下就能发现 USS 特性： 在收到 notePauseComponent 和 noteLaunchTime 的时候会激发保存动作，策略基本上是一天保存一次，一次保存为一个文件（以日期命名）。成功保存完之后，会把内存中的数据清零，所以一个文件中的数据差不多是一天统计的数据。但是上面在 USS 关闭（重启、关机 SystemServce 会调用各个 SS 的 shutdown 函数）的时候会强制写数据，然后在初始化的时候（构造函数）取当前日期的文件，如果有就去把这个文件中的数据转载到 mStats 中去（相当于读档）。这个操作能保证设备在还没用满一天的情况下重启、关机数据也能保存（正常的是要过了一天才会激发写文件操作的）。然后默认只会保留最近5天的数据，超过了就会删掉之前的。</p>
<p>搞清楚了 USS 的保存数据的方法和策略，我们最后来看实际数据的情况，加深一下理解。下面这张图就是 USS 一天的数据（拿 xxd 转化为 16进制，用 vi 打开），然后对应下 dump 的数据：</p>
<pre>
Date: 20150306
  com.android.systemui: 1 times, 30961918 ms
    com.android.systemui.usb.UsbStorageActivity: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 2 times, 8282 ms
    com.bbk.studyos.launcher.activity.Launcher: 2 starts, 2000-3000ms=1
</pre>

<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/usage-data.png" alt=""></p>
<p>Binder 系列 Parcel 篇我们分析过 Parcel 就是一块内存自己来写，我们对着内存中的数据一个一个对照看一下。最开始写入的是版本号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Current on-disk Parcel version</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION = <span class="number">1007</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>0x0000 03ef（注意一下，我手上机子的 cpu 是小端格式的）正好是 1007，writeInt 前面说过是 4byte 的（绿色部分）。然后接下来是 PkgUsageStatsExtended 的个数，0x0000 0002 是2个，看 dump 的输出，果然是2个，同样是 WriteInt 4byte（深蓝色部分）。接下来就是第一个 PkgUsageStatsExtended 的 pkg name，是用 writeString 写的（红色的部分）。这里我们补充下 Parcel 的一些知识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ======================== Parcel.java =========================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Write a string value into the parcel at the current dataPosition(),</span></div><div class="line"><span class="comment">     * growing dataCapacity() if needed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeString</span>(String val) {</div><div class="line">        nativeWriteString(mNativePtr, val);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ======================== android_os_Parcel.cpp =========================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Parcel_writeString(JNIEnv* env, jclass clazz, jint nativePtr, jstring val)</div><div class="line">{</div><div class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) {</div><div class="line">        status_t err = NO_MEMORY;</div><div class="line">        <span class="keyword">if</span> (val) {</div><div class="line">            <span class="keyword">const</span> jchar* str = env-&gt;GetStringCritical(val, <span class="number">0</span>); </div><div class="line">            <span class="keyword">if</span> (str) {</div><div class="line">                err = parcel-&gt;writeString16(str, env-&gt;GetStringLength(val));</div><div class="line">                env-&gt;ReleaseStringCritical(val, str);</div><div class="line">            }   </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            err = parcel-&gt;writeString16(NULL, <span class="number">0</span>); </div><div class="line">        }   </div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">            signalExceptionForError(env, clazz, err);</div><div class="line">        }   </div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ======================== Parcel.cpp ========================= </span></div><div class="line"></div><div class="line"><span class="comment">// 这里调用的是 writeString16 我之前分析的是 writeString8</span></div><div class="line">status_t Parcel::writeString16(<span class="keyword">const</span> char16_t* str, size_t len) </div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (str == NULL) <span class="keyword">return</span> writeInt32(-<span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 和之前的 writeString8 一样，第一个位置是写字符串的长度</span></div><div class="line">    status_t err = writeInt32(len);</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        <span class="comment">// 字符长度 x 一个字符所占的大小</span></div><div class="line">        <span class="comment">// char16_t 看下面的定义是 2byte</span></div><div class="line">        len *= sizeof(char16_t);</div><div class="line">        <span class="comment">// 注意看这里， len 还多加了一个字符的</span></div><div class="line">        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));</div><div class="line">        <span class="keyword">if</span> (data) {</div><div class="line">            memcpy(data, str, len);</div><div class="line">            <span class="comment">// 原来是拿来写 '/0' 结束符用的</span></div><div class="line">            *reinterpret_cast&lt;char16_t*&gt;(data+len) = <span class="number">0</span>; </div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line">        }</div><div class="line">        err = mError;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> err; </div><div class="line">}</div><div class="line"></div><div class="line">String16 Parcel::readString16() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    size_t len;</div><div class="line">    <span class="keyword">const</span> char16_t* str = readString16Inplace(&len);</div><div class="line">    <span class="keyword">if</span> (str) <span class="keyword">return</span> String16(str, len);</div><div class="line">    ALOGE(<span class="string">"Reading a NULL string not supported here."</span>);</div><div class="line">    <span class="keyword">return</span> String16();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> char16_t* Parcel::readString16Inplace(size_t* outLen) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    int32_t size = readInt32();</div><div class="line">    <span class="comment">// watch for potential int overflow from size+1</span></div><div class="line">    <span class="keyword">if</span> (size &gt;= <span class="number">0</span> && size &lt; INT32_MAX) {</div><div class="line">        *outLen = size;</div><div class="line">        <span class="comment">// 果然读的地方也要多加1个字符</span></div><div class="line">        <span class="keyword">const</span> char16_t* str = (<span class="keyword">const</span> char16_t*)readInplace((size+<span class="number">1</span>)*sizeof(char16_t));</div><div class="line">        <span class="keyword">if</span> (str != NULL) {</div><div class="line">            <span class="keyword">return</span> str;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    *outLen = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ======================== Unicode.h ========================= </span></div><div class="line"></div><div class="line">typedef uint32_t char32_t;</div><div class="line">typedef uint16_t char16_t;</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到上面 WriteString16 和 定义头文件的 Unicode 就能猜到 java 里面的 String 用的是 UCS-2（2byte 的unicode 编码，忘记了的去 <a href="http://light3moon.com/2015/01/31/[转] unicode 编码表" title="unicode 编码表" target="_blank" rel="external">unicode 编码表</a> 看看）。</p>
<p>好补充了上面的知识我们再接着看 pkg name。一开始长度： 0x0000 0014，20个字符，从 0x0063（”c” 的 UCS-2 码） 到红色最后一排那个 0x0069（”i” 的 UCS-2 码） 正好是 20 个（2byte x 20 = 40byte, 0x000000ch ~ 0x0000033h）。UCS-2 使用2个byte来代码一个码，如果是字母的就是 ACSII 的值，从右侧的显示也能看出是： com.android.systemui。但是这里稍微注意下，红色的部分，多个了2个 0x0000，第一个从前面 Parcel 的代码我们知道是 ‘/0’ 字符串结束符。但是怎么还多了一个出来？还记得 Parcel 篇说过 Parcel 数据都会 4byte 对齐的么，如果不算后面那个 0x0000 的话，我们算算看原来的数据是多少： 4byte(1个 32bit int len) + 40byte(20个 16bit UCS-2 字符) + 2byte（1个 16bit UCS-2 结束符）= 46byte，46 % 4 = 2，所以最后还要补上 2byte 作为 4byte 对齐用的。这里结合实际终能稍微能明白点字节对齐了。</p>
<p>补充完 Parcel 知识，继续往下看。倒回去看下 PkgUsageStatsExtended 的 writeToParcel 接口：</p>
<p>黄色部分，  4byte（writeInt）， mLaunchTime（启动次数），0x0000 0001，1次<br>淡蓝色部分，8byte（writeLong），mUsageTime（使用时长），0x0000 0000 01d8 70ef，30961918ms<br>紫色部分，  4byte（writeInt）， TimeStats 的个数，0x0000 0001，1个</p>
<p>然后后面就是循环写 TimeStats 了，和 PkgUsageStatsExtended 差不多一开始是 component name：红色部分，前面详细说了 pkg name 这里不多说了，照着前面的方法自己对照一下吧。然后就要看 TimeStats 的 writeToParcel 接口了：</p>
<p>紫色部分，4byte（writeInt），count 总共启动次数，0x0000 0001，1次。然后后面红色的部分是 TimeStats 的那个 int[] times 的数组的数值，全都是 4byte（writeInt），一共10个：正好从 0x00000a8h ~ 0x00000cfh 40byte。然后第2个为1，去翻下前面那个数组的定义：第二时间段正好是 250-500ms的（第一个是 &lt;250ms）。</p>
<p>然后剩下的就是循环重复了的，有兴趣的自己往下读一下了。从我们自己分析文件中的二进制数据发现，是和 USS 中的数据对得上的。</p>
<p>最后再说下前面说到 Parcel.obtain 带缓存效果是怎么回事，我们直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line">                 </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">6</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sOwnedPool = <span class="keyword">new</span> Parcel[POOL_SIZE];</div><div class="line">    <span class="comment">// pool 是 static 变量，每个进程中 Pacel 都有一个（6个元素的数组）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sHolderPool = <span class="keyword">new</span> Parcel[POOL_SIZE];</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">protected</span> <span class="keyword">final</span> Parcel <span class="title">obtain</span>(<span class="keyword">int</span> obj) { </div><div class="line">        <span class="keyword">final</span> Parcel[] pool = sHolderPool;</div><div class="line">        <span class="keyword">synchronized</span> (pool) { </div><div class="line">            Parcel p;</div><div class="line">            <span class="comment">// 会在 pool 中找到一个不为 null 的元素，取出来，</span></div><div class="line">            <span class="comment">// 然后先初始化一下大小，再把这个位置的元素设置为 null，表示已经被取走了</span></div><div class="line">            <span class="comment">// 最后返回取出来的元素给调用者使用</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) {</div><div class="line">                p = pool[i];</div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) {               </div><div class="line">                    pool[i] = <span class="keyword">null</span>;                </div><div class="line">                    <span class="keyword">if</span> (DEBUG_RECYCLE) {           </div><div class="line">                        p.mStack = <span class="keyword">new</span> RuntimeException();</div><div class="line">                    }</div><div class="line">                    p.init(obj);                   </div><div class="line">                    <span class="keyword">return</span> p;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// 如果 pool 中都是空的，只好重新 new 一个出来了</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parcel(obj);        </div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 结合上面的 obtain 来看，这个 recycle 就是先把自己的内存释放掉，</span></div><div class="line">    <span class="comment">// 然后在 pool 中找一个空位置，把自己放进去，如果 pool 满了的话（没人用）就不管了</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Put a Parcel object back into the pool.  You must not touch</span></div><div class="line"><span class="comment">     * the object after this call.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recycle</span>() {</div><div class="line">        <span class="keyword">if</span> (DEBUG_RECYCLE) mStack = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 释放自己占用的内存</span></div><div class="line">        freeBuffer();</div><div class="line">    </div><div class="line">        <span class="comment">// 看样子 obtain 取不到 mOwnsNativeParcelObject 的 Parcel 的</span></div><div class="line">        <span class="keyword">final</span> Parcel[] pool; </div><div class="line">        <span class="keyword">if</span> (mOwnsNativeParcelObject) {</div><div class="line">            pool = sOwnedPool;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mNativePtr = <span class="number">0</span>;</div><div class="line">            pool = sHolderPool;</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="keyword">synchronized</span> (pool) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) {</div><div class="line">                <span class="keyword">if</span> (pool[i] == <span class="keyword">null</span>) {</div><div class="line">                    pool[i] = <span class="keyword">this</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>从这里我们可以看出，在使用 Parcel 的时候，尽量调用 Parcel.obtain 来获取 Parcel 来使用，使用完之后要调用 recycle 把不用的 Parcel 还到缓存池中去，以便下次使用。这样能减少 GC 的概率。对了前面 Parcel 还有2个函数没说（java 中的直接挂 jni 的马甲，直接上 jni 代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ======================== android_os_Parcel.cpp ========================= </span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jbyteArray android_os_Parcel_marshall(JNIEnv* env, jclass clazz, jint nativePtr)</div><div class="line">{</div><div class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel == NULL) {</div><div class="line">       <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// do not marshall if there are binder objects in the parcel</span></div><div class="line">    <span class="keyword">if</span> (parcel-&gt;objectsCount())</div><div class="line">    {</div><div class="line">        jniThrowException(env, <span class="string">"java/lang/RuntimeException"</span>, <span class="string">"Tried to marshall a Parcel that contained Binder objects."</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// new 了一个 parcel 数据大小的 java byte 数组</span></div><div class="line">    jbyteArray ret = env-&gt;NewByteArray(parcel-&gt;dataSize());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ret != NULL)</div><div class="line">    {</div><div class="line">        jbyte* <span class="built_in">array</span> = (jbyte*)env-&gt;GetPrimitiveArrayCritical(ret, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">array</span> != NULL)</div><div class="line">        {</div><div class="line">            <span class="comment">// 把 parcel 中的内存 copy 到刚刚 new 出来的 byte 数组中</span></div><div class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>, parcel-&gt;data(), parcel-&gt;dataSize());</div><div class="line">            env-&gt;ReleasePrimitiveArrayCritical(ret, <span class="built_in">array</span>, <span class="number">0</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Parcel_unmarshall(JNIEnv* env, jclass clazz, jint nativePtr,</div><div class="line">                                         jbyteArray data, jint offset, jint length)</div><div class="line">{</div><div class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel == NULL || length &lt; <span class="number">0</span>) {</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 从 java byte 数组中获取指针</span></div><div class="line">    jbyte* <span class="built_in">array</span> = (jbyte*)env-&gt;GetPrimitiveArrayCritical(data, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>)</div><div class="line">    {</div><div class="line">        parcel-&gt;setDataSize(length);   </div><div class="line">        parcel-&gt;setDataPosition(<span class="number">0</span>);    </div><div class="line"></div><div class="line">        <span class="comment">// 让 parcel 分配指定的内存空间</span></div><div class="line">        <span class="keyword">void</span>* raw = parcel-&gt;writeInplace(length);</div><div class="line">        <span class="comment">// 把 java byte 数组 copy 到 parcel 的内存中</span></div><div class="line">        <span class="built_in">memcpy</span>(raw, (<span class="built_in">array</span> + offset), length);</div><div class="line"></div><div class="line">        env-&gt;ReleasePrimitiveArrayCritical(data, <span class="built_in">array</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>marshall 是从 Parcel 中获取打包好的直接流数据；unmarshall 正好反过来，把指定的字节流写入到 Parcel 中。</p>
<h2 id="改造">改造</h2>
<h3 id="方案">方案</h3>
<p>前面说了那么多，大概弄清楚 USS 统计了什么数据，如果保存的。从上面来看，如果要利用 USS 来进行应用时长统计，只要做一点点修改就行了。首先 USS 只会保存最近5天的数据，可以自己在 framework 中写一个 Provider 把 USS 的数据全部存到数据库中。我是在只建了一张表，就2个字段，一个是 long 时间，一个是 blob USS 每一个保存文件的对应的二进制数据（也就是 Parcel 中的内存结构）。这样做出于下面的的考虑：</p>
<ol>
<li>数据量不会太大，一天一个文件，也就是说一天一条记录，1000 条够3年多了。一般设备上安装的应用也不会特别多，所以对应每一条的 blob 数据也不会太大。</li>
<li>使用数据库方便查询，对于生成一些指定范围时间范围内的数据报表很有帮助，例如说最近一个星期、最近1个月的使用情况。</li>
<li>保存的是 USS 的原始数据，如果需要 USS 增加什么新数据的话，数据库不需要升级表字段。</li>
<li>Provider 接口方便多个进程调用。</li>
<li>因为相当于是把 USS 生成的文件保存到数据库中了，所以解析速度会稍微慢一点，但是对于查看统计应用时长的需要，转个圈圈加载一下下也没啥关系。</li>
</ol>
<p>但是需要注意一点：从上面的分析知道 USS 保存到文件中的数据并不是当前的实时数据，所以保存在数据库中的也不是实时数据，也就说从 Provider 读到的也不是实时数据。实时数据在 USS 的内存中（mStats），所以如果要判断当前某些应用使用多长时间（应用监控功能），需要在 USS 拉接口，去取 mStats 的数据。</p>
<h3 id="实现">实现</h3>
<p>上面把方案说了一下，实现的话这里简单说一下就行了，不贴代码了（这篇已经够长了，而且改造挺简单的）。新加一个 Provider 的话，可以在 packages/providers 下面新建一个 UsageStatsProvider 的模块，Android.mk 和 ContentProvider 的写法，可以照着同目录的几个 providers 抄一下。然后如果要随系统发布的话，记得把你新加的模块加到编译脚本中。然后去 frameworks/base/core/java/android/provider 下面加一个 UsageStats.java 的文件，把数据库的表字段、对外的 Provider URL 定义好（拉接口）。然后数据保存就弄得差不多了。</p>
<p>最后就是要让 USS 保存文件的时候调用下你写的 Provider 的接口，把文件顺带写到数据中。通过上面的分析，就在 writeToFileParcel 成功写入那加就行了，还有现成的 blob 数据（Parcel 的打包数据）。</p>
<p>然后 USS 拉接口的就要具体业务了，这里不多说了。</p>
<h2 id="总结">总结</h2>
<p>终于说完了。其实 USS 还有一些东西我没管（例如那个 resume 的历史记录 xml 文件），以后用到再说。还有顺带分析的 AMS 那里也是还有很多种情况没分析到的。还有这里只说了 startActivity，对应的 finishActivity 还没说，以后再说了。还有以后顺带把 Handler、Looper、MessageQueue 也整理一篇。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86/</loc>
    <lastmod>2015-03-31T06:36:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——原理</title>
        <pubTime>2015-01-28T12:17:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>分析之前说一下原理。为要 android 要搞这么复杂的一个东西。那是因为 android 是个多进程的系统，进程间的数据交换、相互调用（某几个程序配合完成某些业务）就涉及跨进程通信。2个进程不能直接访问数据的原因：</p>
<ol>
<li>每个进程的地址空间的独立的，所以进程A中某个数据的地址在进程B中不确定是什么东西。</li>
<li>安全性，如果能随便访问其它进程空间的数据，那么是非常危险的事情（想想看你再用支付宝输支付密码的时候，其它随便一个程序就能轻轻松松读取你输入的密码是多么恐怖）。</li>
</ol>
<p>所以 android 就整一套进程通信框架——binder</p>
<h2 id="原理">原理</h2>
<p>首先 binder 在最底层有 kernel 的驱动支持。/dev/binder 是 binder 的设备文件。然后 android 通过这个驱动在 native 层整了一套 C/S 架构的框架出来，最后在 java 对应也封装了一层（可以理解为 native 的马甲）。这些东西后面再慢慢分析。</p>
<h2 id="应用">应用</h2>
<p>基于 binder android 弄了很多 manager services，不过我觉得倒是因为需要存在这些 maanger services 才需要 binder 进程间通信。这里说说为什么需要这些 manager services（我后面把这些称为：那一票 services）。因为设备的上的有些硬件（例如相机、传感器）一般一次只能一个访问，有些需要把一些数据混合在一起输出（SurfaceFlinger、AudioFlinger），这就需要一些管理，但是应用是不同的程序，它们并不知道其它人的情况，所以就需要一个 manager，而且这个 manager 是要能接受不同进程的。这就引出了 android binder 的最经典的场景—— android 那一票 services。</p>
<p>同时由于有这一票 services 的 存在，那么又要有人来管它们，所以就有一个东西叫： ServiceManager 。这个东西本身也是基于 binder 通信的。</p>
<h2 id="框架设计——native">框架设计——native</h2>
<p>binder 主要的实现在 native 层。先来张图，整体对框架有个概括（图中我省略了 binder 进程 death 之后的通知机制，这个可以后面单独分析，这里只是画出了刚开始比较关键的通信的那部分）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-base/1.png" alt=""></p>
<p>这里先啰嗦下 binder native 层的代码位置（这个是个模块，相关的都里面，没几个文件，自己找吧）： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 头文件：</span></div><div class="line">frameworks/native/include/binder</div><div class="line"><span class="comment"># 实现：</span></div><div class="line">frameworks/native/libs/binder</div><div class="line"></div></pre></td></tr></table></figure>

<p>图中分为2个部分：一个是实现部分（BBinder、Bpinder 那部分），一个是接口部分（IInterface 那部分）。先来看下实体部分：</p>
<p>前面说了 binder 是 C/S 架构的，那当然得有 server 和 client。BBinder 代表 server，Bpinder 代表 client，然后在这个基础上抽象出 IBinder 这个基类。IBinder 中比较重要的抽象方法有4个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Check if this IBinder implements the interface named by</span></div><div class="line"><span class="comment"> * @a descriptor.  If it does, the base pointer to it is returned,</span></div><div class="line"><span class="comment"> * which you can safely static_cast&lt;&gt; to the concrete C++ interface.</span></div><div class="line"><span class="comment"> */</span> </div><div class="line"><span class="keyword">virtual</span> sp&lt;IInterface&gt;  queryLocalInterface(<span class="keyword">const</span> String16& descriptor);</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> status_t        transact(   uint32_t code,</div><div class="line">                                    <span class="keyword">const</span> Parcel& data,</div><div class="line">                                    Parcel* reply,</div><div class="line">                                    uint32_t flags = <span class="number">0</span>) = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> BBinder*        localBinder();</div><div class="line"><span class="keyword">virtual</span> BpBinder*       remoteBinder();</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后在基类有默认实现的是3个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sp&lt;IInterface&gt;  IBinder::queryLocalInterface(<span class="keyword">const</span> String16& descriptor)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line">BBinder* IBinder::localBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line">BpBinder* IBinder::remoteBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>基类的实现还真全是马甲，但是这样也有个好出，就是之类可以只覆盖自己感兴趣的方法就可以了（否则子类就必须全部实现，不然编译会报错的）。</p>
<p>先来看看 localBinder 和 remoteBinder 这2个，这2个看定义就十分明显了，一个是返回 BBinder 的指针（服务器的），一个是返回 BpBinder 的指针（客户端的），而且在 BBinder 和 BpBinder 分别只实现了一个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># 简单干脆，都直接返回自己</span></div><div class="line">BBinder* BBinder::localBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div><div class="line">BpBinder* BpBinder::remoteBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 queryLocalInterface 这个，这个返回的是 IInterface 的指针（sp android 搞的啥智能指针，可以参看我前面一篇相关的备忘，挺烦的）。BBinder 和 BpBinder 都没有实现，这个放到后面暴露的接口去实现了（后面再说）。</p>
<p>最后来看下： transact，这个看名字，和参数就知道这个就是通信用的方法。这个在基类中也没实现，但是在 BBinder 和 BpBinder 有实现，并且不一样（当然得不一样，服务器能和客户端一样么）。BBinder 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">status_t BBinder::transact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    data.setDataPosition(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    status_t err = NO_ERROR;</div><div class="line">    <span class="keyword">switch</span> (code) {</div><div class="line">        <span class="keyword">case</span> PING_TRANSACTION:</div><div class="line">            reply-&gt;writeInt32(pingBinder());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = onTransact(code, data, reply, flags);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (reply != NULL) {</div><div class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> err; </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个 <code>PING_TRANSACTION</code> 估计是测试用的，先不理它，它主要就是调用了 onTransact 这个回调。这个回调是在 BBinder 中定义的，是个虚函数，主要留给它的子类来实现。可以想象得到服务器端在等待客户端的请求，当有请求来的时候，就会出发 onTransact 然后由具体的服务（子类）来实现这个回调，处理不同的逻辑。 </p>
<p>而在 BpBinder 中是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">status_t BpBinder::transact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></div><div class="line">    <span class="keyword">if</span> (mAlive) {</div><div class="line">        status_t status = IPCThreadState::self()-&gt;transact(</div><div class="line">            mHandle, code, data, reply, flags);</div><div class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    }</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> DEAD_OBJECT;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>又是马甲，这个IPCThreadState 是线程剧本变量，就是一个线程存一个，不同线程不一样，binder 的 C/S 架构采用了多线程来处理请求，这个也是后面再分析，先来看看实现再说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::transact(int32_t handle,</div><div class="line">                                  uint32_t code, <span class="keyword">const</span> Parcel& data,</div><div class="line">                                  Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    status_t err = data.errorCheck();</div><div class="line"></div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line"></div><div class="line">    IF_LOG_TRANSACTIONS() {</div><div class="line">        TextOutput::Bundle _b(alog);</div><div class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span> </div><div class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</div><div class="line">            (flags & TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</div><div class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        <span class="keyword">return</span> (mLastError = err);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((flags & TF_ONE_WAY) == <span class="number">0</span>) { </div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (reply) {</div><div class="line">            err = waitForResponse(reply);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Parcel fakeReply;</div><div class="line">            err = waitForResponse(&fakeReply);</div><div class="line">        }    </div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        IF_LOG_TRANSACTIONS() {</div><div class="line">            TextOutput::Bundle _b(alog);</div><div class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</div><div class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        err = waitForResponse(NULL, NULL);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数中关键点是 writeTransactionData 和  waitForResponse，这2个函数分别是对 binder 驱动写请求（数据已经通过 Parcel 打包好，这个也是后面再分析），然后等待 binder 驱动的返回的数据结果（服务器那端写的）。驱动相关的也是后面再说，先在继续往下走。这里可以看得出客户端是将请求写入驱动，发送给服务器，然后等待服务器返回的结果。</p>
<p>然后就是接口了，接口基类是 IInterface，这个基类很简单，就定义2个有用的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> IInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">            IInterface();</div><div class="line">            sp&lt;IBinder&gt;         asBinder();</div><div class="line">            sp&lt;<span class="keyword">const</span> IBinder&gt;   asBinder() <span class="keyword">const</span>;</div><div class="line">            </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span>                     ~IInterface();</div><div class="line">    <span class="keyword">virtual</span> IBinder*            onAsBinder() = <span class="number">0</span>;</div><div class="line">};</div><div class="line"></div><div class="line">sp&lt;IBinder&gt; IInterface::asBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> ? onAsBinder() : NULL;</div><div class="line">}</div><div class="line"></div><div class="line">sp&lt;<span class="keyword">const</span> IBinder&gt; IInterface::asBinder() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> ? <span class="keyword">const_cast</span>&lt;IInterface*&gt;(<span class="keyword">this</span>)-&gt;onAsBinder() : NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实它留给子类的就 onAsBinder 这个回调，用来获取 IBinder 的指针。IInterface 的子类是 BnInterface<interface> 和 BpInterface<interface> 分别对应 BBinder（服务器） 和 BpBinder（客户端）的接口。在这之前得先看看 INTERFACE 这个东西，android 在这里弄了一个模版类，BnXx 和 BpXx 都是。</interface></interface></p>
<p>在 IInterface.h 中有这2个宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ----------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                          \</div><div class="line">    <span class="keyword">static</span> android::sp&lt;I<span class="preprocessor">##INTERFACE&gt; asInterface(                       \</span></div><div class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;& obj);                  \</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::String16& getInterfaceDescriptor() <span class="keyword">const</span>;    \</div><div class="line">    I<span class="preprocessor">##INTERFACE();                                                     \</span></div><div class="line">    <span class="keyword">virtual</span> ~I<span class="preprocessor">##INTERFACE();                                            \</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></div><div class="line">    <span class="keyword">const</span> android::String16 I<span class="preprocessor">##INTERFACE::descriptor(NAME);             \</span></div><div class="line">    <span class="keyword">const</span> android::String16&                                            \</div><div class="line">            I<span class="preprocessor">##INTERFACE::getInterfaceDescriptor() const {              \</span></div><div class="line">        <span class="keyword">return</span> I<span class="preprocessor">##INTERFACE::descriptor;                                \</span></div><div class="line">    }                                                                   \</div><div class="line">    android::sp&lt;I<span class="preprocessor">##INTERFACE&gt; I##INTERFACE::asInterface(                \</span></div><div class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;& obj)                   \</div><div class="line">    {                                                                   \</div><div class="line">        android::sp&lt;I<span class="preprocessor">##INTERFACE&gt; intr;                                 \</span></div><div class="line">        <span class="keyword">if</span> (obj != NULL) {                                              \</div><div class="line">            intr = <span class="keyword">static_cast</span>&lt;I<span class="preprocessor">##INTERFACE*&gt;(                          \</span></div><div class="line">                obj-&gt;queryLocalInterface(                               \</div><div class="line">                        I<span class="preprocessor">##INTERFACE::descriptor).get());               \</span></div><div class="line">            <span class="keyword">if</span> (intr == NULL) {                                         \</div><div class="line">                intr = <span class="keyword">new</span> Bp<span class="preprocessor">##INTERFACE(obj);                          \</span></div><div class="line">            }                                                           \</div><div class="line">        }                                                               \</div><div class="line">        <span class="keyword">return</span> intr;                                                    \</div><div class="line">    }                                                                   \</div><div class="line">    I<span class="preprocessor">##INTERFACE::I##INTERFACE() { }                                    \</span></div><div class="line">    I<span class="preprocessor">##INTERFACE::~I##INTERFACE() { }                                   \</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> CHECK_INTERFACE(interface, data, reply)                         \</span></div><div class="line">    <span class="keyword">if</span> (!data.checkInterface(<span class="keyword">this</span>)) { <span class="keyword">return</span> PERMISSION_DENIED; }       \</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ----------------------------------------------------------------------</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>如果在 .h 中的 class 定义中调用 <code>DECLARE_META_INTERFACE(&quot;Xx&quot;)</code> 在 .cpp 中的实现中调用 <code>IMPLEMENT_META_INTERFACE(&quot;Xx&quot;, &quot;Xx&quot;)</code> 那么就想当于声明和实现了：</p>
<ol>
<li>默认构造函数</li>
<li>析构函数</li>
<li>定义了并以 Xx 初始化 String16 descriptor 这个变量</li>
<li>asInterface： 返回 IXx 的指针</li>
<li>getInterfaceDescriptor： 返回 descriptor 字符串</li>
</ol>
<p>实际上不是如果，后面的具体的 native 的 service 的接口就是这么写的（后面会有具体的实例分析）。</p>
<p>接下来就看真正的接口基类： BnInterface<xx>:</xx></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">class</span> BnInterface : <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16& _descriptor);</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> String16&     getInterfaceDescriptor() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> IBinder*            onAsBinder();</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>哎呦咧，C++ 的多重继承，分别继续了 BBinder（binder 的服务器） 和 INTERFACE 这个其实就是上面的 IInterface，在具体的 services 中会通过 IInterface 中的那2个宏弄一个 IXx 出来，然后 BnInterface 这里的 INTERFACE 就是 IXx（这个后面到了实例分析，就会很清楚了）。这里实现上面 BBinder 那没实现的几个接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> sp&lt;IInterface&gt; BnInterface&lt;INTERFACE&gt;::queryLocalInterface(</div><div class="line">        <span class="keyword">const</span> String16& _descriptor)   </div><div class="line">{</div><div class="line">    <span class="comment">// 对比下是不是自己的标示，是的话直接返回自己</span></div><div class="line">    <span class="keyword">if</span> (_descriptor == INTERFACE::descriptor) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> String16& BnInterface&lt;INTERFACE&gt;::getInterfaceDescriptor() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="comment">// 这 ... 有必要重写一下么？？</span></div><div class="line">    <span class="keyword">return</span> INTERFACE::getInterfaceDescriptor();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line">IBinder* BnInterface&lt;INTERFACE&gt;::onAsBinder()</div><div class="line">{</div><div class="line">    <span class="comment">// 这里抛弃 BBinder 的 localBinder 了，直接返回自己了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>queryLocalInterface 这个是只有 BBinder 才有的（对比 IBinder 的接口），然后根据在这个函数的实现：对比 descriptor 是不是自己定义的（通过 <code>DECLARE_META_INTERFACE</code> 这个宏定义的），然后是否返回自己，可以猜得到：1、这个函数是用来判断请求是不是处于本进程内，如果是的话，应该就不需要跨进程调用，直接可以调用本进程的方法。这样对于上层应用来说，暴露的是 IBinder 接口，上层应用不需要关心调用是本地的还是远程的。2：descriptor 这个是用来区别 binder 的服务器的，binder 通过这个来判断请求是不是发给自己的，如果 descriptor 不匹配，则拒绝处理。（这些猜测后面再慢慢说）</p>
<p>然后是 BpInterface 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">class</span> BpInterface : <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;& remote);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> IBinder*            onAsBinder();</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>比 Bn 相比，没了判断是不是本地的接口了，客户端当然不需要有啦。然后应该是继续 BpBinder 的，变成了 BpRefBase ，看到这个名字我又想到了 android 那蛋疼的智能指针和引用计数，我真的很烦这个东西，就不能好好的自己管好内存么？？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BpRefBase : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">                            BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;& o); </div><div class="line">    <span class="keyword">virtual</span>                 ~BpRefBase();</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>            onFirstRef();</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>            onLastStrongRef(<span class="keyword">const</span> <span class="keyword">void</span>* id);</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span>            onIncStrongAttempted(uint32_t flags, <span class="keyword">const</span> <span class="keyword">void</span>* id);</div><div class="line"></div><div class="line">    <span class="comment">// 最重要的一个函数，返回 mRemote IBinder 指针</span></div><div class="line">    <span class="keyword">inline</span>  IBinder*        remote()                { <span class="keyword">return</span> mRemote; }</div><div class="line">    <span class="keyword">inline</span>  IBinder*        remote() <span class="keyword">const</span>          { <span class="keyword">return</span> mRemote; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">                            BpRefBase(<span class="keyword">const</span> BpRefBase& o); </div><div class="line">    BpRefBase&              <span class="keyword">operator</span>=(<span class="keyword">const</span> BpRefBase& o); </div><div class="line"></div><div class="line">    IBinder* <span class="keyword">const</span>          mRemote;</div><div class="line">    RefBase::weakref_type*  mRefs;</div><div class="line">    <span class="keyword">volatile</span> int32_t        mState;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面这个东西，其它的不看，就看一个函数 remote() 返回 mRemote 这个 IBinder 指针。然后来看下 BpInterface 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> BpInterface&lt;INTERFACE&gt;::BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;& remote)</div><div class="line">    : BpRefBase(remote)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> IBinder* BpInterface&lt;INTERFACE&gt;::onAsBinder()</div><div class="line">{</div><div class="line">    <span class="comment">// 调用 BpRefBase 的 remote() 返回 BpBinder 的远程 binder 指针</span></div><div class="line">    <span class="keyword">return</span> remote();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>BpInterface 的 sp<ibinder> 参数的构造函数，把 sp<ibinder> 传给 BpRefBase 了，这个 IBinder 其实就是 BpBinder （通过后面的分析可以看得出的）。结合上面 Bn 的 onAsBinder 是返回 this 自己（BBinder），Bp 的是返回 BpBinder 。</ibinder></ibinder></p>
<p>再下面，就是具体业务相关的了，IXx 继承自 IInterface，主要是使用 IInterface 提供的那个 <code>DECLARE_META_INTERFACE(Xx)</code> 这个宏声明一些接口（上面有分析的），Xx 就是接口的名字了，例如 ServerManager、SurfaceComposer 之类的（这个后面会有具体的实例分析的）。然后这个 IXx 还得定义这个 service 对外（客户端）提供的接口，例如 CaptureScreen 之类的，这个就和具体的 service 相关了。 </p>
<p>BnXx 继承 BnInterface（同时继承 IXx），使用 IInterface 提供的 <code>IMPLEMENT_META_INTERFACE(Xx, Xx)</code> 来实现上面说的那些接口。注意这里的 Xx 要和 <code>DECLARE_META_INTERFACE</code> 那里的一样，例如都叫 SurfaceComposer， 然后后面那个是标示（descriptor），例如 “android.ui.ISurfaceComposer”（用包名来标示一般不会重复）。</p>
<p>然后剩下的主要是实现 onTransact 就是响应客户端的请求。其实通过后面的分析 BnXx 中也并不是真正实现请求的地方，这个只是一个中转站而已，真正的实现在 service 模块里面，一个一个业务函数实现的，这里的 onTransact 只是区分客户端发过来的请求命令，然后去调用 service 里面的函数，实现这些的文件都叫 I<br>Xx.h, IXx.cpp 看上去也不像实现的样子。然后真正的 service 就要继承 BnXx 去实现 onTransact。但是你也发现了，onTransact 已经在 BnXx 里实现了，所以你在 services 看到的 onTransact 都是马甲（有些做了一些拦截，例如权限检测，没权限的请求直接拦截下来），基本上都是调用： super.onTransact 的 -_-|| 。</p>
<p>BpXx 继承 BpInterface。 BpInterface 并没强制要求 BpXx 实现啥东西，但是作用客户端（Java 层那一堆 XxManager 给其它 apk 调用的），暴露给第三方引用使用的，必须要实现服务器提供的方法对应的接口：例如说 service 那边有一个方法是： captureScreen 用来实现截屏用的，那么客户端也必须有响应的方法： captureScreen，然后客户端调用 remote()（IBinder） 的 transact 发送请求到服务器。当然其实函数名字也可以不一一对应，你只要在服务器 onTransact 里调用正确就行了。但是后面你会发现如果这些东西一一对应的话，代码是很机械的，后面 android 就搞了个代码自动生成的工具出来（aidl）。</p>
<p>这里 native 层的框架就说完了。接下来看下 java 层的。</p>
<h2 id="框架设计——java">框架设计——java</h2>
<p>照例来先张图先：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-base/2.png" alt=""></p>
<p>图中我把相关的 jni 里面类也画了出来，这样就能更加明显的看到 java 层和 native 层的对应关系。</p>
<p>代码位置也先说下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java：</span></div><div class="line">frameworks/base/core/java/android/os/Binder.java</div><div class="line">frameworks/base/core/java/android/os/Parcel.java</div><div class="line">frameworks/base/core/java/com/android/internal/os/BinderInternal.java</div><div class="line"></div><div class="line"><span class="comment"># jni：</span></div><div class="line">frameworks/base/core/jni/android_util_Binder.h</div><div class="line">frameworks/base/core/jni/android_util_Binder.cpp</div><div class="line">frameworks/base/core/jni/android_os_Parcel.h</div><div class="line">frameworks/base/core/jni/android_os_Parcel.cpp</div><div class="line"></div></pre></td></tr></table></figure>

<p>从图可得到，java 层的架构和 native 的很像。也是分为2个部分：实现部分和接口部分（几乎连名字都和 native 的一样）。</p>
<p>实现部分的话，也是一个 IBinder 的基类，额，不对 java 的叫 interface ，这个比 c++ 更加注重抽象。然后实现这个接口的分别是 Binder（Binder.java） 和 BinderProxy（Binder.java），分别对应 native 的 BBinder 和 BpBinder ，同时也分别代表 java 层的服务端和客户端。</p>
<p>Binder 这边的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Convenience method for associating a specific interface with the Binder.</span></div><div class="line"><span class="comment"> * After calling, queryLocalInterface() will be implemented for you</span></div><div class="line"><span class="comment"> * to return the given owner IInterface when the corresponding</span></div><div class="line"><span class="comment"> * descriptor is requested.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachInterface</span>(IInterface owner, String descriptor) {</div><div class="line">    mOwner = owner;</div><div class="line">    mDescriptor = descriptor;      </div><div class="line">}</div><div class="line">   </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Default implementation returns an empty interface name.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> String <span class="title">getInterfaceDescriptor</span>() {</div><div class="line">    <span class="keyword">return</span> mDescriptor;   </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Use information supplied to attachInterface() to return the</span></div><div class="line"><span class="comment"> * associated IInterface if it matches the requested</span></div><div class="line"><span class="comment"> * descriptor.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span>(String descriptor) {</div><div class="line">    <span class="keyword">if</span> (mDescriptor.equals(descriptor)) {</div><div class="line">        <span class="keyword">return</span> mOwner;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Default implementation is a stub that returns false.  You will want</span></div><div class="line"><span class="comment"> * to override this to do the appropriate unmarshalling of transactions.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * &lt;p&gt;If you want to call this, call transact().</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply,</div><div class="line">        <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (code == INTERFACE_TRANSACTION) {</div><div class="line">        reply.writeString(getInterfaceDescriptor());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (code == DUMP_TRANSACTION) {</div><div class="line">        ParcelFileDescriptor fd = data.readFileDescriptor();</div><div class="line">        String[] args = data.readStringArray(); </div><div class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                dump(fd.getFileDescriptor(), args);</div><div class="line">            } <span class="keyword">finally</span> {   </div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    fd.close();                    </div><div class="line">                } <span class="keyword">catch</span> (IOException e) {      </div><div class="line">                    <span class="comment">// swallowed, not propagated back to the caller</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// Write the StrictMode header.</span></div><div class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span>) {           </div><div class="line">            reply.writeNoException();      </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            StrictMode.clearGatheredViolations();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Default implementation rewinds the parcels and calls onTransact.  On</span></div><div class="line"><span class="comment"> * the remote side, transact calls into the binder to do the IPC.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply,</div><div class="line">        <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"Binder"</span>, <span class="string">"Transact: "</span> + code + <span class="string">" to "</span> + <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) {</div><div class="line">        data.setDataPosition(<span class="number">0</span>);       </div><div class="line">    }</div><div class="line">    <span class="keyword">boolean</span> r = onTransact(code, data, reply, flags);</div><div class="line">    <span class="keyword">if</span> (reply != <span class="keyword">null</span>) {  </div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面几个函数都挺简单的，就是返回 descriptor ，要不返回 IInterface，要不设置下 IInterface 和 desriptor 。transact 这个函数看注释说是啥默认实现，别看它调用了 onTransact （native Bn 端的实现主要在这里）其实就是个摆设，没用的，因为要实现 IBinder 的接口，才必须要有一个实现而已（到后面就就知道了）。然后 onTransact 这个和 native 对应了，不过这里其实也没干声明正事，功能主要是留在service 的接口里实现的。</p>
<p>java 的 Binder 最主要要看的是它有个叫 mObject 的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* mObject is used by native code, do not remove or rename */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mObject;</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释说是 native 层要使用，其实是 jni 要使用。来看看这个 mObject 是怎么使用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> native final <span class="keyword">void</span> init();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Default constructor initializes the object.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> Binder() {</div><div class="line">    init();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) {    </div><div class="line">        final Class&lt;? extends Binder&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&</div><div class="line">                (klass.getModifiers() & Modifier.STATIC) == <span class="number">0</span>) {</div><div class="line">            Log.w(TAG, <span class="string">"The following Binder class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());     </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在 Binder 的构造函数中会调用一个 init 的 native 方法，这个方法在 jni <code>android_util_Binder.cpp</code> 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Binder_init(JNIEnv* env, jobject obj) </div><div class="line">{</div><div class="line">    JavaBBinderHolder* jbh = <span class="keyword">new</span> JavaBBinderHolder();</div><div class="line">    <span class="keyword">if</span> (jbh == NULL) {</div><div class="line">        jniThrowException(env, <span class="string">"java/lang/OutOfMemoryError"</span>, NULL);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    ALOGV(<span class="string">"Java Binder %p: acquiring first ref on holder %p"</span>, obj, jbh);</div><div class="line">    jbh-&gt;incStrong((<span class="keyword">void</span>*)android_os_Binder_init);</div><div class="line">    env-&gt;SetIntField(obj, gBinderOffsets.mObject, (<span class="keyword">int</span>)jbh);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里创建了一个 JavaBBinderHolder （这个是 c++ 的类）的类，然后把这个指针保存在了 mObject 这个变量里面。int 类型是 32bit 的，指针（地址）在 32bit 系统上也是 32bit 的。这里再先看看 gBinderOffsets 这个东西，其实还有一个叫 gBinderProxyOffsets 的。这2个是 jni 里面 java 的类信息变量，弄成全局变量，如果访问频繁的话，能提高速度，因为每次都要去查 java 的类表很慢的，加载的代码在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderPathName = <span class="string">"android/os/Binder"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> int_register_android_os_Binder(JNIEnv* env)</div><div class="line">{</div><div class="line">    jclass clazz;</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(kBinderPathName);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class android.os.Binder"</span>);</div><div class="line"></div><div class="line">    gBinderOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gBinderOffsets.mExecTransact</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"execTransact"</span>, <span class="string">"(IIII)Z"</span>);</div><div class="line">    assert(gBinderOffsets.mExecTransact);</div><div class="line"></div><div class="line">    gBinderOffsets.mObject</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</div><div class="line">    assert(gBinderOffsets.mObject);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(</div><div class="line">        env, kBinderPathName,</div><div class="line">        gBinderMethods, NELEM(gBinderMethods));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> int_register_android_os_BinderProxy(JNIEnv* env)</div><div class="line">{</div><div class="line">    jclass clazz;</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/ref/WeakReference"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class java.lang.ref.WeakReference"</span>);</div><div class="line">    gWeakReferenceOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gWeakReferenceOffsets.mGet</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"get"</span>, <span class="string">"()Ljava/lang/Object;"</span>);</div><div class="line">    assert(gWeakReferenceOffsets.mGet);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Error"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class java.lang.Error"</span>);</div><div class="line">    gErrorOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(kBinderProxyPathName);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class android.os.BinderProxy"</span>);</div><div class="line"></div><div class="line">    gBinderProxyOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gBinderProxyOffsets.mConstructor</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mConstructor);</div><div class="line">    gBinderProxyOffsets.mSendDeathNotice</div><div class="line">        = env-&gt;GetStaticMethodID(clazz, <span class="string">"sendDeathNotice"</span>, <span class="string">"(Landroid/os/IBinder$DeathRecipient;)V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mSendDeathNotice);</div><div class="line"></div><div class="line">    gBinderProxyOffsets.mObject</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mObject);</div><div class="line">    gBinderProxyOffsets.mSelf</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mSelf"</span>, <span class="string">"Ljava/lang/ref/WeakReference;"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mSelf);</div><div class="line">    gBinderProxyOffsets.mOrgue</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mOrgue);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Class"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find java.lang.Class"</span>);</div><div class="line">    gClassOffsets.mGetName = env-&gt;GetMethodID(clazz, <span class="string">"getName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</div><div class="line">    assert(gClassOffsets.mGetName);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(</div><div class="line">        env, kBinderProxyPathName,</div><div class="line">        gBinderProxyMethods, NELEM(gBinderProxyMethods));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> register_android_os_Binder(JNIEnv* env)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (int_register_android_os_Binder(env) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (int_register_android_os_BinderInternal(env) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (int_register_android_os_BinderProxy(env) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    ... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 <code>register_android_os_Binder</code> 会在 android 的 java 初始化的时候调用，这个时候需要的类信息就加载好了。gBinderOffsets 对应的是 Binder， gBinderProxyOffsets 对应的是 BinderProxy 。gBinderOffsets 的 mObject 就是 Binder 的 mObject 变量，所以那个注释说不要乱改这个变量的名字，不然这里就找不到了。gBinderOffsets 还有一个保存了 execTransact 的变量，这个注意一下，后面会说到的。</p>
<p>回过来看下 JavaBBinderHolder 这个东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> JavaBBinderHolder : <span class="keyword">public</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)</div><div class="line">    {</div><div class="line">        AutoMutex _l(mLock);  </div><div class="line">        sp&lt;JavaBBinder&gt; b = mBinder.promote();</div><div class="line">        <span class="keyword">if</span> (b == NULL) {</div><div class="line">            b = <span class="keyword">new</span> JavaBBinder(env, obj); </div><div class="line">            mBinder = b;      </div><div class="line">            ALOGV(<span class="string">"Creating JavaBinder %p (refs %p) for Object %p, weakCount=%d\n"</span>,</div><div class="line">                 b.get(), b-&gt;getWeakRefs(), obj, b-&gt;getWeakRefs()-&gt;getWeakCount());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    }</div><div class="line"></div><div class="line">    sp&lt;JavaBBinder&gt; getExisting()</div><div class="line">    {</div><div class="line">        AutoMutex _l(mLock);  </div><div class="line">        <span class="keyword">return</span> mBinder.promote();      </div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Mutex           mLock;</div><div class="line">    wp&lt;JavaBBinder&gt; mBinder;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个东西继承自 native 的 RefBase，然后在看它的 get 方法的返回值，可以理解为这个东西就是在 java 里面放了一个 natvie 的 sp<ibinder> 一样。它持有的是 JavaBBinder 对象，这个才是重点：</ibinder></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">class JavaBBinder : <span class="keyword">public</span> BBinder</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="title">JavaBBinder</span>(JNIEnv* env, jobject object)</div><div class="line">        : <span class="title">mVM</span>(<span class="title">jnienv_to_javavm</span>(env)), <span class="title">mObject</span>(env-&gt;<span class="title">NewGlobalRef</span>(object))</div><div class="line">    {</div><div class="line">        ALOGV(<span class="string">"Creating JavaBBinder %p\n"</span>, <span class="keyword">this</span>);</div><div class="line">        android_atomic_inc(&gNumLocalRefs);</div><div class="line">        incRefsCreated(env);</div><div class="line">    }</div><div class="line"></div><div class="line">    bool    checkSubclass(<span class="keyword">const</span> <span class="keyword">void</span>* subclassID) <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> subclassID == &gBinderOffsets;</div><div class="line">    }</div><div class="line"></div><div class="line">    jobject object() <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> mObject;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    virtual ~<span class="title">JavaBBinder</span>()</div><div class="line">    {</div><div class="line">        ALOGV(<span class="string">"Destroying JavaBBinder %p\n"</span>, <span class="keyword">this</span>);</div><div class="line">        android_atomic_dec(&gNumLocalRefs);</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line">        env-&gt;DeleteGlobalRef(mObject);</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual status_t onTransact(</div><div class="line">        uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags = <span class="number">0</span>)</div><div class="line">    {</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line"></div><div class="line">        ALOGV(<span class="string">"onTransact() on %p calling object %p in env %p vm %p\n"</span>, <span class="keyword">this</span>, mObject, env, mVM);</div><div class="line"></div><div class="line">        IPCThreadState* thread_state = IPCThreadState::self();</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> strict_policy_before = thread_state-&gt;getStrictModePolicy();</div><div class="line">        thread_state-&gt;setLastTransactionBinderFlags(flags);</div><div class="line"></div><div class="line">        <span class="comment">//printf("Transact from %p to Java code sending: ", this);</span></div><div class="line">        <span class="comment">//data.print();</span></div><div class="line">        <span class="comment">//printf("\n");</span></div><div class="line">        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</div><div class="line">            code, (int32_t)&data, (int32_t)reply, flags);</div><div class="line">        jthrowable excep = env-&gt;ExceptionOccurred();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (excep) {</div><div class="line">            report_exception(env, excep,</div><div class="line">                <span class="string">"*** Uncaught remote exception!  "</span></div><div class="line">                <span class="string">"(Exceptions are not yet supported across processes.)"</span>);</div><div class="line">            res = JNI_FALSE;</div><div class="line"></div><div class="line">            <span class="comment">/* clean up JNI local ref -- we don't return to Java code */</span></div><div class="line">            env-&gt;DeleteLocalRef(excep);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Restore the Java binder thread's state if it changed while</span></div><div class="line">        <span class="comment">// processing a call (as it would if the Parcel's header had a</span></div><div class="line">        <span class="comment">// new policy mask and Parcel.enforceInterface() changed</span></div><div class="line">        <span class="comment">// it...)</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> strict_policy_after = thread_state-&gt;getStrictModePolicy();</div><div class="line">        <span class="keyword">if</span> (strict_policy_after != strict_policy_before) {</div><div class="line">            <span class="comment">// Our thread-local...</span></div><div class="line">            thread_state-&gt;setStrictModePolicy(strict_policy_before);</div><div class="line">            <span class="comment">// And the Java-level thread-local...</span></div><div class="line">            set_dalvik_blockguard_policy(env, strict_policy_before);</div><div class="line">        }</div><div class="line"></div><div class="line">        jthrowable excep2 = env-&gt;ExceptionOccurred();</div><div class="line">        <span class="keyword">if</span> (excep2) {</div><div class="line">            report_exception(env, excep2,</div><div class="line">                <span class="string">"*** Uncaught exception in onBinderStrictModePolicyChange"</span>);</div><div class="line">            <span class="comment">/* clean up JNI local ref -- we don't return to Java code */</span></div><div class="line">            env-&gt;DeleteLocalRef(excep2);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Need to always call through the native implementation of</span></div><div class="line">        <span class="comment">// SYSPROPS_TRANSACTION.</span></div><div class="line">        <span class="keyword">if</span> (code == SYSPROPS_TRANSACTION) {</div><div class="line">            BBinder::onTransact(code, data, reply, flags);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">//aout &lt;&lt; "onTransact to Java code; result=" &lt;&lt; res &lt;&lt; endl</span></div><div class="line">        <span class="comment">//    &lt;&lt; "Transact from " &lt;&lt; this &lt;&lt; " to Java code returning "</span></div><div class="line">        <span class="comment">//    &lt;&lt; reply &lt;&lt; ": " &lt;&lt; *reply &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual status_t dump(<span class="keyword">int</span> fd, <span class="keyword">const</span> Vector&lt;String16&gt;& args)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    JavaVM* <span class="keyword">const</span>   mVM;</div><div class="line">    jobject <span class="keyword">const</span>   mObject;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>JavaBBinder 继承自 native 的 BBinder，这下清楚了，java 层最重要还是持有了 native 的 binder 对象。同时这个东西还保存了 java Binder 的对象（相互保存 -_-||），那个 jobject mObject 就是，构造函数传进来的，然后在 JavaBBinderHolder 的 get 那里第一次会触发 new JavaBBinder，参数就是 java 的 Binder，这里后面再说。然后这个类重载了 BBinder 的 onTransact ，前面 native 说过了， Bn 端的实现主要是要重写 onTransact。然后在 onTransact 通过 java 对象 mObject 调用了 java Binder 的 gBinderOffsets 的 mExecTransact 。还记得前面加载 Binder 类信息的时候，说要注意这个 mExecTransact 的么，就是这里用啦，对应 Binder 的 execTransact 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Entry point from android_util_Binder.cpp's onTransact</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span>(<span class="keyword">int</span> code, <span class="keyword">int</span> dataObj, <span class="keyword">int</span> replyObj,</div><div class="line">        <span class="keyword">int</span> flags) {</div><div class="line">    Parcel data = Parcel.obtain(dataObj); </div><div class="line">    Parcel reply = Parcel.obtain(replyObj);</div><div class="line">    <span class="comment">// theoretically, we should call transact, which will call onTransact,</span></div><div class="line">    <span class="comment">// but all that does is rewind it, and we just got these from an IPC,</span></div><div class="line">    <span class="comment">// so we'll just call it directly.</span></div><div class="line">    <span class="keyword">boolean</span> res;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        res = onTransact(code, data, reply, flags);</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">        reply.writeException(e);       </div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException e) { </div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">        reply.writeException(e);       </div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">catch</span> (OutOfMemoryError e) { </div><div class="line">        RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">        reply.writeException(re);      </div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    reply.recycle();</div><div class="line">    data.recycle();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后是调用了 Binder 的 onTransact 函数，所以还是和 native 的一样，Bn 靠重载 onTransact。所以前面说 Binder 实现 IBinder 的 transact 接口是摆设，因为这个不像 native 层 BBinder 的 transact，java 层的压根就没调用到。总结下，java 的 Bn 是通过 native 的 BBinder 的 transact 被调用，然后 natvie BBinder 的 onTransact（JavaBBinder 重载） 的被调用，然后在 jni 中调用 java 的 Binder 的 onTransact 。</p>
<p>然后是 BinderProxy:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> class BinderProxy implements IBinder {</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getInterfaceDescriptor</span>() <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply,</div><div class="line">            <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException; </div><div class="line"></div><div class="line">    <span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span>(String descriptor) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>BinderProxy 很多都直接是 native 方法。queryLocalInterface 直接放回 null，和 native 层的一样， Bp 端不实现 Bn 端的方法。它和 Binder 一样有一个 int mObject 的变量，同样这个也是保存 native 对象指针的，这个其实是 sp<bpbinder>，这个后面再分析了。所以 java 的 BinderProxy transact 方法就直接调用 native BpBinder 的 transact 。</bpbinder></p>
<p>接下来就是接口部分了。IInterface :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Base class for Binder interfaces.  When defining a new interface,</span></div><div class="line"><span class="comment"> * you must derive it from IInterface.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IInterface</span></span></div><div class="line"><span class="class"></span>{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Retrieve the Binder object associated with this interface.</span></div><div class="line"><span class="comment">     * You must use this instead of a plain cast, so that proxy objects</span></div><div class="line"><span class="comment">     * can return the correct result.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> IBinder <span class="title">asBinder</span>();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>和 native 层的很像，但是这个和 Binder 和 BinderProxy 不一样，java 的 IInterface 和 native 层的没啥关系（Binder 和 BinderProxy 可是保存了 native 层对象的指针的），只是为单纯为了对应而已。</p>
<p>然后同样，java 层的 service 需要继续这个接口，自己写一个 IXxManager 定义自己的服务提供的业务逻辑接口（那个 Manager 的后缀不是必须的，但是 android 系统的 service 都很统一，接口都叫 XxManager，服务都叫 XxManagerServices）。然后 Bn 这边的话，实现接口一般都叫 XxManagerNative 去实现这个 IXxManager 的接口，相当于 native 的 BnXx 实现 BnInterface 一样。然后服务模块继承这个 XxManagerNative，真正实现业务逻辑功能，XxManagerNative 里面的 onTransact 负责接受客户端发送过来的请求，并且调用正确的 service 的业务函数完成功能（和 native 流程一样）。</p>
<p>Bp 这边呢，一般由一个叫 XxProxy 的类实现 IXxManager 的接口，然后它有一个 mRemote 的 IBinder 变量，其实就是 BinderProxy （这个后面实例慢慢分析）。然后接口是通过 Parcel 把请求打包好，通过的 mRemote（BinderProxy，BinderProxy 直接调用 native BpBinder 的 transact） 的 transact 发送给 binder 驱动，最后再转给 Bn 端接收。流程也和 native 的是一样的。最后暴露给应用使用的 XxManager 其实一般都保存了一个 XxProxy 对象，然后 XxManager 的接口，基本上都是马甲，直接调用 XxProxy 对应的方法的（同样后面对照实例慢慢分析）。</p>
<p>前面 uml 中我在 XxManagerNative 和 XxProxy 中还有个括号，我前面说了 android 在 java 搞了个代码自动生成的东西——aidl，那个括号里面的类名是工具生成出来的，括号外面是手动写的。android 那一票 services 绝大部分接口的代码是用工具生成的，但是有几个是手写的，原因么，估计刚开始还没这个工具吧。 </p>
<p>android 故意在 java 层上 binder 的框架结构和 native 层保持一致，这是个不错的设计，然后 java 层 binder 通信其实就是 native 的调用而已。上面简单把 binder 的框架梳理了一下，有很多地方后面再慢慢分析，因为 binder 涉及的东西太多了（横跨 java、native 和 kernel），而且进程间通信本来就是比较麻烦的东西，我认为多进程这个是现代智能操作系统的必不可少的基本功能之一。</p>
<p>把基本的东西先弄清楚，后面分析会方便很多。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B/</loc>
    <lastmod>2015-03-31T06:35:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——通信模型</title>
        <pubTime>2015-01-28T12:29:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>通信就要搞一些协议，binder 的比较简单，但是也有一个基本的模型，这里以最基本的一次 IPC 调用来说明一下。然后涉及的代码主要在（这里不列 java 层的代码了，java 层的代码前面原理篇分析过了，主要是挂马甲调用 native 的方法的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># native binder 头文件</span></div><div class="line">frameworks/native/include/binder</div><div class="line"><span class="comment"># native binder 实现</span></div><div class="line">frameworks/native/libs/binder</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="流程">流程</h2>
<p>先上张图先，图我尽量简化，只画了 IPC 调用相关的东西（是 4.4 来分析的，之前的版本有点点小区别）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-transaction/1.png" alt=""></p>
<h2 id="1、服务端等待请求">1、服务端等待请求</h2>
<p>首先看图上右边的服务（service）部分。service 进程运行起来，然后通过调用 IPCThreadState 的 joinThreadLoop 在本线程中开始等待客户端请求的到来。这里有2个问题：第一个，system service 必须向 service manager 注册自己；第二个，服务端的多线程支持问题。这里都后面再说。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</div><div class="line">{</div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n"</span>, (<span class="keyword">void</span>*)pthread_self(), getpid());</div><div class="line"></div><div class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line">    </div><div class="line">    <span class="comment">// This thread may have been spawned by a thread that was in the background</span></div><div class="line">    <span class="comment">// scheduling group, so first we will make sure it is in the foreground</span></div><div class="line">    <span class="comment">// one to avoid performing an initial transaction in the background.</span></div><div class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">             </div><div class="line">    status_t result;</div><div class="line">    <span class="keyword">do</span> { </div><div class="line">        processPendingDerefs();</div><div class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></div><div class="line">        result = getAndExecuteCommand();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR && result != TIMED_OUT && result != -ECONNREFUSED && result != -EBADF) {</div><div class="line">            ALOGE(<span class="string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,</div><div class="line">                  mProcess-&gt;mDriverFD, result);</div><div class="line">            <span class="built_in">abort</span>();</div><div class="line">        }    </div><div class="line">             </div><div class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></div><div class="line">        <span class="comment">// needed and it is not the main process thread.</span></div><div class="line">        <span class="keyword">if</span>(result == TIMED_OUT && !isMain) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }    </div><div class="line">    } <span class="keyword">while</span> (result != -ECONNREFUSED && result != -EBADF);</div><div class="line"></div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%p\n"</span>,</div><div class="line">        (<span class="keyword">void</span>*)pthread_self(), getpid(), (<span class="keyword">void</span>*)result);</div><div class="line">    </div><div class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</div><div class="line">    talkWithDriver(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里看得出，这个函数是个循环（等待——处理——等待 … … 一般服务器的模型都是这样），参数 isMain 表示这个 service thread 是不是主线程，这个东西后面再说。循环里面主要是调用 getAndExecuteCommand 来处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::getAndExecuteCommand()</div><div class="line">{</div><div class="line">    status_t result;</div><div class="line">    int32_t cmd;</div><div class="line">        </div><div class="line">    result = talkWithDriver();</div><div class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">        size_t IN = mIn.dataAvail();</div><div class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        result = executeCommand(cmd);</div><div class="line">    </div><div class="line">        <span class="comment">// After executing the command, ensure that the thread is returned to the</span></div><div class="line">        <span class="comment">// foreground cgroup before rejoining the pool.  The driver takes care of</span></div><div class="line">        <span class="comment">// restoring the priority, but doesn't do anything with cgroups so we</span></div><div class="line">        <span class="comment">// need to take care of that here in userspace.  Note that we do make</span></div><div class="line">        <span class="comment">// sure to go in the foreground after executing a transaction, but</span></div><div class="line">        <span class="comment">// there are other callbacks into user code that could have changed</span></div><div class="line">        <span class="comment">// our group so we want to make absolutely sure it is put back.</span></div><div class="line">        set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>getAndExecuteCommand 这个名字就可以看得出这个函数主要干2个事情，一个取请求数据、一个就是处理请求数据：正好又分了2个函数： talkWithDriver 和 executeCommand（下面那个好像是设置线程优先级，先不理这些东西先）。</p>
<p>先来看下 talkWithDriver：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> -EBADF;</div><div class="line">    }</div><div class="line"> </div><div class="line">    binder_write_read bwr;</div><div class="line">        </div><div class="line">    <span class="comment">// Is the read buffer empty?</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</div><div class="line">    </div><div class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></div><div class="line">    <span class="comment">// from data left in the input buffer and the caller</span></div><div class="line">    <span class="comment">// has requested to read the next data.</span></div><div class="line">    <span class="keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line">    </div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</div><div class="line">        </div><div class="line">    <span class="comment">// This is what we'll read.</span></div><div class="line">    <span class="keyword">if</span> (doReceive && needRead) {</div><div class="line">        bwr.read_size = mIn.dataCapacity();</div><div class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        TextOutput::Bundle _b(alog);</div><div class="line">        <span class="keyword">if</span> (outAvail != <span class="number">0</span>) {</div><div class="line">            alog &lt;&lt; <span class="string">"Sending commands to driver: "</span> &lt;&lt; indent;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* cmds = (<span class="keyword">const</span> <span class="keyword">void</span>*)bwr.write_buffer;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* end = ((<span class="keyword">const</span> uint8_t*)cmds)+bwr.write_size;</div><div class="line">            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;</div><div class="line">            <span class="keyword">while</span> (cmds &lt; end) cmds = printCommand(alog, cmds);</div><div class="line">            alog &lt;&lt; dedent;</div><div class="line">        }</div><div class="line">        alog &lt;&lt; <span class="string">"Size of receive buffer: "</span> &lt;&lt; bwr.read_size</div><div class="line">            &lt;&lt; <span class="string">", needRead: "</span> &lt;&lt; needRead &lt;&lt; <span class="string">", doReceive: "</span> &lt;&lt; doReceive &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></div><div class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) && (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    status_t err;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"About to read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; endl;</div><div class="line">        }</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_ANDROID_OS)</span></div><div class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &bwr) &gt;= <span class="number">0</span>)</div><div class="line">            err = NO_ERROR;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            err = -errno;</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">        err = INVALID_OPERATION;</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) {</div><div class="line">            err = -EBADF;</div><div class="line">        }</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Finished read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    } <span class="keyword">while</span> (err == -EINTR);</div><div class="line"></div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        alog &lt;&lt; <span class="string">"Our err: "</span> &lt;&lt; (<span class="keyword">void</span>*)err &lt;&lt; <span class="string">", write consumed: "</span></div><div class="line">            &lt;&lt; bwr.write_consumed &lt;&lt; <span class="string">" (of "</span> &lt;&lt; mOut.dataSize()</div><div class="line">                        &lt;&lt; <span class="string">"), read consumed: "</span> &lt;&lt; bwr.read_consumed &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())</div><div class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                mOut.setDataSize(<span class="number">0</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) {</div><div class="line">            mIn.setDataSize(bwr.read_consumed);</div><div class="line">            mIn.setDataPosition(<span class="number">0</span>);</div><div class="line">        }</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            TextOutput::Bundle _b(alog);</div><div class="line">            alog &lt;&lt; <span class="string">"Remaining data size: "</span> &lt;&lt; mOut.dataSize() &lt;&lt; endl;</div><div class="line">            alog &lt;&lt; <span class="string">"Received commands from driver: "</span> &lt;&lt; indent;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* cmds = mIn.data();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* end = mIn.data() + mIn.dataSize();</div><div class="line">            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;</div><div class="line">            <span class="keyword">while</span> (cmds &lt; end) cmds = printReturnCommand(alog, cmds);</div><div class="line">            alog &lt;&lt; dedent;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>talkWithDriver 主要是调用 ioctl 去 kernel 的 binder 设备那里读数据。这里的 mDriverFD 是打开 binder 设备的文件描述符。在 ProcessState 的构造函数中会打开 binder 设备（一个进程只会开打一次，然后所有线程共用一个 fd）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ProcessState::ProcessState()</div><div class="line">    : mDriverFD(open_driver())</div><div class="line">... ...</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> open_driver()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</div><div class="line">        <span class="keyword">int</span> vers;</div><div class="line">        status_t result = ioctl(fd, BINDER_VERSION, &vers);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) {</div><div class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        size_t maxThreads = <span class="number">15</span>;</div><div class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &maxThreads);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</div><div class="line">    } </div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>回到 talkWithDriver，ioctl 调用的命令是 <code>BINDER_WRITE_READ</code>，参数是 <code>binder_write_read</code> 这个结构。这里每个 IPCThreadState（service 的线程）都还有2个 Parcel 变量：mIn、mOut 分别用于打包发送和接收读取的数据。这些后面再分析 binder 的数据包的时候再说。这里只说前面要向 binder 发命令，就调用 mOut 写命令，要接收数据的话，talkWithDriver 的参数 doRevice 默认是 true，ioctl 能一次性完成读、写操作。</p>
<p>这里第一次 service 写是 0btye，读是 256btye（初始化的 mIn 的 Capacity 是 256，但是 service 开始并没有写入命令）。</p>
<p>然后 ioctl 就到了 kernel 的 binder 驱动里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line">    <span class="comment">/*printk(KERN_INFO "binder_ioctl: %d:%d %x %lx\n", proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></div><div class="line"></div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret; </div><div class="line"></div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    <span class="keyword">if</span> (thread == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err; </div><div class="line">    }</div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: {</div><div class="line">        <span class="keyword">struct</span> binder_write_read bwr; </div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) {</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (copy_from_user(&bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">        binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">                 <span class="string">"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</div><div class="line">                 bwr.read_size, bwr.read_buffer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) {</div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</div><div class="line">                bwr.read_consumed = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) {</div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &bwr.read_consumed, filp-&gt;f_flags & O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">                 <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</div><div class="line">                 bwr.read_consumed, bwr.read_size);</div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>关于 ioctl 的一些基本知识可以参看下我的这篇文章：<br><a href="http://light3moon.com/2015/01/19/[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" title="[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" target="_blank" rel="external">[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</a> </p>
<p>这里稍微注意下，ioctl 里面 proc 表示本次调用的进程，thread 表示调用本次调用的线程（这2个主要是记录了进程号 pid 和线程号 tid）。然后第一次 write 的 size 是 0，所以没有处理 <code>binder_thread_write</code>。接下来是取数据： <code>binder_thread_read</code>（这里可以看到出，kernel 是先处理 write 再处理 read 的，原因到后面就知道了）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                  <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</div><div class="line">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">    }</div><div class="line"></div><div class="line">retry:</div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == NULL &&</div><div class="line">                list_empty(&thread-&gt;todo);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (thread-&gt;return_error != BR_OK && ptr &lt; end) {</div><div class="line">        <span class="keyword">if</span> (thread-&gt;return_error2 != BR_OK) {</div><div class="line">            <span class="keyword">if</span> (put_user(thread-&gt;return_error2, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="keyword">if</span> (ptr == end)</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            thread-&gt;return_error2 = BR_OK;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (put_user(thread-&gt;return_error, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        thread-&gt;return_error = BR_OK;</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads++;</div><div class="line">    mutex_unlock(&binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) {</div><div class="line">        <span class="keyword">if</span> (!(thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">                    BINDER_LOOPER_STATE_ENTERED))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></div><div class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></div><div class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</div><div class="line">            wait_event_interruptible(binder_user_error_wait,</div><div class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">        }</div><div class="line">        binder_set_nice(proc-&gt;default_priority);</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</div><div class="line">    }</div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads--;</div><div class="line">    thread-&gt;looper &= ~BINDER_LOOPER_STATE_WAITING;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>来看下 <code>binder_thread_read</code> 的前面部分。这里 service 的 <code>wait_for_proc_work</code> 的值为 1，也是 true 的意思。一开始的 <code>thread-&gt;transaction_stack</code> 是 NULL 的，这个是表示这个线程的传递堆栈，类似于函数调用堆栈的东西，一开始没传递，这个堆栈肯定是空的（这个也后面再具体分析）。然后一开始 thread-&gt;todo 这链表也是空的，这个是表示这个线程上需要完成的工作，这个后面会知道是什么东西。</p>
<p>那根据上面的条件，这里 service 的 ioctl 调用就会跑到这里：</p>
<p><code>wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</code></p>
<p>wait event 是 kernel 里面的等待队列，在前面那篇 ioctl 的文章里有详细说明，它现在阻塞于 proc-&gt;wait 这个变量，如果唤醒 proc-&gt;wait 阻塞会结束。还有如果后面那个 <code>binder_has_proc_work</code> 返回值为 1（条件为 true） 阻塞也会结束。但是这里 <code>binder_has_proc_work</code> 不为 true：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个其实就是判断 proc 有没有需要完成的工作（前面那个是判断是 thread 的）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_has_proc_work(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                <span class="keyword">struct</span> binder_thread *thread)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> !list_empty(&proc-&gt;todo) ||</div><div class="line">        (thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>所以这里 <code>binder_thread_read</code> 要不阻塞，要么跑进来的时候 proc-&gt;todo 不为空（就是该进程有需要处理的工作），要么就只能等待有人唤醒 proc-&gt;wait 。这里对应图中 service 在等待客户端请求的到来，这个是在 kernel 中使用 wait queue（等待队列）实现的。</p>
<p>所以为什么先处理 <code>binder_thread_write</code> ，因为 <code>binder_thread_read</code> 会阻塞。</p>
<h2 id="2-_客户端发起_IPC_请求">2. 客户端发起 IPC 请求</h2>
<p>服务端已经在阻塞等待了，现在来看看客户端（client）这边（图中的左边部分）。client 调用一个 IPC 接口函数（例如调用 ActivityManager 的 startActivity 之类的），发起 IPC 调用，IPC 接口函数调用 Bp 的 transaction 函数，这些在前面的原理篇里有说过，获取 Bp 是通过 service manager 获取的（前面说 service 要在 service manager 注册就是为了 client 能通过 service manager 获取自己的 Bp），这里细节后面再说。</p>
<p>Bp 的 transaction 直接调用 IPCThreadState 的 transaction 函数（注意别头晕，servie、client 是共用一份代码的，加上前面 ioctl 读、写一个命令 -_-||）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::transact(int32_t handle,</div><div class="line">                                  uint32_t code, <span class="keyword">const</span> Parcel& data,</div><div class="line">                                  Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    status_t err = data.errorCheck();</div><div class="line"></div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line"></div><div class="line">    IF_LOG_TRANSACTIONS() {</div><div class="line">        TextOutput::Bundle _b(alog);   </div><div class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span></div><div class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</div><div class="line">            (flags & TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>); </div><div class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        <span class="keyword">return</span> (mLastError = err);     </div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> ((flags & TF_ONE_WAY) == <span class="number">0</span>) {</div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (reply) {</div><div class="line">            err = waitForResponse(reply);  </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Parcel fakeReply;</div><div class="line">            err = waitForResponse(&fakeReply); </div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        </div><div class="line">        IF_LOG_TRANSACTIONS() {        </div><div class="line">            TextOutput::Bundle _b(alog);   </div><div class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</div><div class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        err = waitForResponse(NULL, NULL);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里也是分为2个部分：第一部分： writeTransactionData 向 service 写请求数据，第二部分： waitForResponse，等待 service 返回请求结果。不难理解，一个函数调用，一般都有返回值（就算是 void 的也需要等待 service 返回结果），所以要发起请求后，要等待 service 返回结果。</p>
<p>先来看下写请求数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel& data, status_t* statusBuffer)</div><div class="line">{</div><div class="line">    binder_transaction_data tr;</div><div class="line">        </div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    tr.flags = binderFlags;</div><div class="line">    tr.cookie = <span class="number">0</span>;</div><div class="line">    tr.sender_pid = <span class="number">0</span>;</div><div class="line">    tr.sender_euid = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> status_t err = data.errorCheck();</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        tr.data_size = data.ipcDataSize();</div><div class="line">        tr.data.ptr.buffer = data.ipcData();</div><div class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(size_t);</div><div class="line">        tr.data.ptr.offsets = data.ipcObjects();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) {</div><div class="line">        tr.flags |= TF_STATUS_CODE;</div><div class="line">        *statusBuffer = err;</div><div class="line">        tr.data_size = <span class="keyword">sizeof</span>(status_t);</div><div class="line">        tr.data.ptr.buffer = statusBuffer;</div><div class="line">        tr.offsets_size = <span class="number">0</span>;</div><div class="line">        tr.data.ptr.offsets = NULL;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> (mLastError = err);</div><div class="line">    }</div><div class="line"></div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>传过去的 cmd（命令）是 <code>BC_TRANSACTION</code> 这个要记住。这里把上层 app 传递过来的数据（Pacrel 封装的，主要是 IPC 的参数），打包到 <code>binder_transaction_data</code> 这个数据结构中，这个是 kernel binder 驱动 ioctl 参数里带的数据（后面再说）。这里都是通过 mOut Pacrel 打包的（后面再说）。注意这里只是把数据包打好，还没发送。</p>
<p>然后到 IPCThreadState transaction 的第二部分：waitForResponse 等待 service 返回处理结果。这里注意一下 transaction 有个判断：</p>
<p><code>if ((flags &amp; TF_ONE_WAY) == 0)</code></p>
<p>这个是表示 IPC 调用需要不需要返回，一般都是需要的，所以这里 waitForResponese 的参数 reply 不是 NULL，这个 reply 会返回给 IPC 的调用者，里来带有返回的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</div><div class="line">{</div><div class="line">    int32_t cmd;</div><div class="line">    int32_t err;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里看到有一个循环，至于为什么，到后面会知道的。循环开始调用 talkWithDriver，这个函数前面在 service 那里看过了，是调用 ioctl 去 bidner 那里写数据和读数据。service 那里只是读了，但是没写。client 不一样了，前面 writeTransactionData 把 <code>BC_TRANSACTION</code> 命令和参数全都打包好了，就通过 ioctl 发到 kernel 的 binder 那去了。</p>
<p>这里 <code>binder_ioctl</code> 那会跑 <code>binder_thread_write</code> 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;   </div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) { </div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        }</div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BC_TRANSACTION:</div><div class="line">        <span class="keyword">case</span> BC_REPLY: {</div><div class="line">            <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (copy_from_user(&tr, ptr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line">            binder_transaction(proc, thread, &tr, cmd == BC_REPLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>write 这里是一个 while 循环 ptr 是前面用户空间（client）打包传进入来的数据，end 是数据结束的地址。这么搞这一个循环，其实是因为这个数据是支持打包多条命令的，虽然这里没体现出来，但是后面有些地方能体现出来，例如说释放内存的命令有些时候就是和其其它命令打包在一起传进来的。取完数据，数据指针会移动，移动到 end 地址了，就结束处处理了，所以可以处理多条命令。感觉 binder 这里经常一次搞多种东西，让代码上让人感觉怪怪的。主要看用的人了，因为是支持打包多条命令的。</p>
<p>不过这里先关心我们之前 client 写入的 <code>BC_TRANSACTION</code> 命令。看下面的处理的处理。传输命令交由 <code>binder_transaction</code> 函数处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete;</div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list;</div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">    e = binder_transaction_log_add(&binder_transaction_log);</div><div class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags & TF_ONE_WAY);</div><div class="line">    e-&gt;from_proc = proc-&gt;pid;</div><div class="line">    e-&gt;from_thread = thread-&gt;pid;</div><div class="line">    e-&gt;target_handle = tr-&gt;target.handle;</div><div class="line">    e-&gt;data_size = tr-&gt;data_size;</div><div class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got "</span></div><div class="line">                    <span class="string">"transaction to invalid handle\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_invalid_target_handle;</div><div class="line">            }</div><div class="line">            target_node = ref-&gt;node;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">            <span class="keyword">if</span> (target_node == NULL) {</div><div class="line">                return_error = BR_DEAD_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_no_context_mgr_node;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        e-&gt;to_node = target_node-&gt;debug_id;</div><div class="line">        target_proc = target_node-&gt;proc;</div><div class="line">        <span class="keyword">if</span> (target_proc == NULL) {</div><div class="line">            return_error = BR_DEAD_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_dead_binder;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (!(tr-&gt;flags & TF_ONE_WAY) && thread-&gt;transaction_stack) {</div><div class="line">            <span class="keyword">struct</span> binder_transaction *tmp;</div><div class="line">            tmp = thread-&gt;transaction_stack;</div><div class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got new "</span></div><div class="line">                    <span class="string">"transaction with bad transaction stack"</span></div><div class="line">                    <span class="string">", transaction %d has target %d:%d\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</div><div class="line">                    tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="number">0</span>,</div><div class="line">                    tmp-&gt;to_thread ?</div><div class="line">                    tmp-&gt;to_thread-&gt;pid : <span class="number">0</span>);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_bad_call_stack;</div><div class="line">            }</div><div class="line">            <span class="keyword">while</span> (tmp) {</div><div class="line">                <span class="keyword">if</span> (tmp-&gt;from && tmp-&gt;from-&gt;proc == target_proc)</div><div class="line">                    target_thread = tmp-&gt;from;</div><div class="line">                tmp = tmp-&gt;from_parent;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (target_thread) {</div><div class="line">        e-&gt;to_thread = target_thread-&gt;pid;</div><div class="line">        target_list = &target_thread-&gt;todo;</div><div class="line">        target_wait = &target_thread-&gt;wait;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        target_list = &target_proc-&gt;todo;</div><div class="line">        target_wait = &target_proc-&gt;wait;</div><div class="line">    }</div><div class="line">    e-&gt;to_proc = target_proc-&gt;pid;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>先来看看这个函数前面一段，前面有一个是否是 reply 的判断，前面 <code>BC_TRANSACTION</code> 命令传过来的是 true，所以走的下面分支。其实这段是查找服务端进程的。tr-&gt;target.handle 这个由最开始 client 所持有的 Bp 传进来的，通过这个 kernel binder 驱动可以找对应的 service 的 proc。这里具体后面再说，这里就简单知道通过 handle 找到远程目标 service 的 proc，还有这里走的是下面 target_proc 的分支，<code>target_thread</code> 是后面 service 写返回值用的。还有注意，这里通过找到 <code>target_proc</code> 确定了 <code>target_wait</code>，回想下前面 service 在 <code>binder_thread_read</code> 那里 wait，就是 wait 这个变量。</p>
<p>接下去继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/* TODO: reuse incoming transaction for reply */</span></div><div class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (t == NULL) {</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</div><div class="line">    }</div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</div><div class="line"></div><div class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (tcomplete == NULL) {</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</div><div class="line">    }</div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line"></div><div class="line">    t-&gt;debug_id = ++binder_last_id;</div><div class="line">    e-&gt;debug_id = t-&gt;debug_id;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> tmp_pid = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (target_thread) {</div><div class="line">        tmp_pid = target_thread-&gt;pid;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!reply && !(tr-&gt;flags & TF_ONE_WAY))</div><div class="line">        t-&gt;from = thread;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t-&gt;from = NULL;</div><div class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</div><div class="line">    t-&gt;to_proc = target_proc;</div><div class="line">    t-&gt;to_thread = target_thread;</div><div class="line">    t-&gt;code = tr-&gt;code;</div><div class="line">    t-&gt;flags = tr-&gt;flags;</div><div class="line">    t-&gt;priority = task_nice(current);</div><div class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</div><div class="line">        tr-&gt;offsets_size, !reply && (t-&gt;flags & TF_ONE_WAY));</div><div class="line">    <span class="keyword">if</span> (t-&gt;buffer == NULL) {</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</div><div class="line">    }</div><div class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</div><div class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</div><div class="line">    t-&gt;buffer-&gt;transaction = t;</div><div class="line">    t-&gt;buffer-&gt;target_node = target_node;</div><div class="line">    <span class="keyword">if</span> (target_node)</div><div class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, NULL);</div><div class="line"></div><div class="line">    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(size_t))) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">            <span class="string">"invalid offsets size, %zd\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    }</div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</div><div class="line">        binder_pop_transaction(target_thread, in_reply_to);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags & TF_ONE_WAY)) {</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</div><div class="line">        t-&gt;need_reply = <span class="number">1</span>;</div><div class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</div><div class="line">        thread-&gt;transaction_stack = t;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        BUG_ON(target_node == NULL);</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) {</div><div class="line">            target_list = &target_node-&gt;async_todo;</div><div class="line">            target_wait = NULL;</div><div class="line">        } <span class="keyword">else</span>  </div><div class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</div><div class="line">    }</div><div class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    list_add_tail(&t-&gt;work.entry, target_list);</div><div class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    list_add_tail(&tcomplete-&gt;entry, &thread-&gt;todo);</div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里创建了2个对象：<code>binder_transaction</code> 和 <code>binder_work</code>，后面的代码就是填充这2个结构。<code>binder_transaction</code> 主要是把目标（<code>target_proc</code> 或是 <code>traget_thread</code>）和数据填写好。数据从用户层 ioctl 传过来的 <code>binder_transaction_data</code>（前面 client writeTransactionData 那里），把 IPC 的参数打包封装起来了，这里通过 <code>copy_from_user</code> 把这里数据再填写到 <code>binder_transaction</code> 带的数据结构的指针中。<br>下面又有一个 for 循环，这个循环是处理 Parcel 保存的 object 的数据的，其实就是 Bp 或是 Bn，这个是和 service manager 通信用的，这里先暂时不管。</p>
<p>这里还有一点，保存了传递堆栈，<code>!(t-&gt;flags &amp; TF_ONE_WAY)</code> 这里一般 IPC 都是需要返回的，所以把当前的 <code>binder_transaction</code> 保存到 <code>transaction_stack</code> 中去了。后面 service 写返回值的时候回通过这个找到要返回的目标进程的。</p>
<p>最后， <code>binder_transaction</code> 的 work type 设置为 <code>BINDER_WORK_TRANSACTION 然后 binder_work 设置为 BINDER_WORK_TRANSACTION_COMPLETE</code> ，分别加入到了 <code>target_list</code> 中（这个这里是 <code>target_proc</code> 的 todo list，也就是 service 的进程工作列表）和 thread 的 todo list（也就是 client 发起 IPC 调用的线程的 todo list）。然后，如果目标 service 进程在等待中（前面第一部分确实在等待），就唤醒它。（回去看看最开始的图稍微好理解些）</p>
<p>其实到这里，client 已经把 IPC 请求发出去了，而 service 那把阻塞在 <code>binder_thread_read</code> 那里的也应该唤醒了，开始执行后面的处理了。不过这里还是继续看 client 这边。</p>
<p>client 这边 <code>binder_thread_write</code> 处理完了，就到 <code>binder_thread_read</code> 了。前面 service 那里分析过阻塞的情况（前面说过了 service、client 代码都是共用的）。这里因为前面 <code>binder_thread_write</code> 那里把一个 <code>binder_work</code> 插入到 thread-&gt;todo 中，所以这里是不会阻塞的。这里会不会觉得有点奇怪，应该正常的模型应该是要阻塞等待 service 那边返回结果才对，不过先别着急。慢慢看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        uint32_t cmd;</div><div class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line">        <span class="keyword">struct</span> binder_work *w;</div><div class="line">        <span class="keyword">struct</span> binder_transaction *t = NULL;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!list_empty(&thread-&gt;todo))</div><div class="line">            w = list_first_entry(&thread-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&proc-&gt;todo) && wait_for_proc_work)</div><div class="line">            w = list_first_entry(&proc-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> && !(thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></div><div class="line">                <span class="keyword">goto</span> retry;   </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (w-&gt;type) {</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: {</div><div class="line">            t = container_of(w, <span class="keyword">struct</span> binder_transaction, work);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: {</div><div class="line">            cmd = BR_TRANSACTION_COMPLETE; </div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;                </div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line"></div><div class="line">            binder_stat_br(proc, thread, cmd);</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION_COMPLETE,</div><div class="line">                     <span class="string">"binder: %d:%d BR_TRANSACTION_COMPLETE\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);       </div><div class="line"></div><div class="line">            list_del(&w-&gt;entry);           </div><div class="line">            kfree(w);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">... ...</div><div class="line">        }   </div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!t) </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line">    </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>有是一个 while 循环，前面已经有好多了，见怪不怪。前面把一个 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 的 <code>binder_work</code> 插入到了 thread-&gt;todo 中，所以这里的分支是 switch 那里的 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 。这里只是把一个 <code>BR_TRANSACTION_COMPLETE</code> 返回给用户了（<code>put_user</code> 是 kernel 向用户空间写单个变量，<code>copy_user</code> 是传递一片数据）。然后就把这个 work 从 todo list 中删掉了。</p>
<p>然后走到下面，t 是 NULL 所以又回到循环开始地方，由于处理完了 work 就删掉了，所以这里取不到任何 todo work 了，就会走最后没那个 else 分支，然后这个<br><code>(ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))</code></p>
<p>这个判断是没有任何读数据的时候，就是没做任何处理。前面最开始有向用户空间写入 <code>BR_NOOP</code> 的操作（可以回到 service 那里仔细看一下），所以如果没做任何处理， ptr 应该被移动了4个字节。但是前面处理了 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 有移动了4个字节，所以这里条件不满足。然后就 break 跳出循环了。然后 <code>binder_thread_read</code> 就结束了。这次 ioctl 也就结束了，然后又回到用户空间 client 那里。</p>
<p>这里会到前面 client waitForResponse 那里，从 talkWithDrvier 返回了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        err = mIn.errorCheck();</div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        cmd = mIn.readInt32();</div><div class="line"></div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></div><div class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</div><div class="line">            <span class="keyword">if</span> (!reply && !acquireResult) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }  <span class="comment">// end while(1)</span></div><div class="line"></div><div class="line">finish:</div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        mLastError = err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 kernel <code>binder_thread_read</code> 返回的 cmd 是 <code>BR_TRANSACTION_COMPLETE</code> ，这边分支除了一个判断，要跳转到 finish 以外其它什么处理都没了。前面 client waitForResponse 是有传入参数 reply 的（这个是拿来存 IPC 函数的返回值的），所以这里只是 break 而已，没跳转去 finish（跳转到 finish 这个函数就结束了）。如果是不需要返回的，reply 传入 NULL 的话，接收到 kernel 的返回值，就直接退出了。</p>
<p>从这个含义来看， <code>BR_TRANSACTION_COMPLETE</code> 是 kernel binder 告诉调用者，命令发送已经处理完毕（前面 client 有对 kernel 发送 <code>BC_TRANSACTION</code> 命令）。所以 kernel 会把 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 的 work 插入到本线程的 todo list 中，为了就是告诉调用者，发送已经完成而已。而看样子，现阶段这个返回值好像没啥用，因为调用者没做啥处理。这个理解下设计者的意图，后面 service 还会有。</p>
<p>然后继续循环，然后调用 talkWithDriver，这里和前面第一部分 service 那里很像，因为前面把 mOut 中数据已经写完了，所以这里写入就是 0byte，读入 256btye，然后就和前面 service 一样了，阻塞在 <code>binder_thread_read</code> 那里等待 service 返回的值。这里才是符合前面所的模型，client 发送了请求后，就要等待 service 的返回。这里是通过 client 那里 waitForResponse 的 while 来实现的，因为这个函数需要处理多个命令（kernel 的返回值），这里知道为什么这里要用循环了吧。</p>
<h2 id="3-_服务端处理请求，并返回结果">3. 服务端处理请求，并返回结果</h2>
<p>client 在等待 service 的处理，我们回到 service 这边。之前 service 阻塞在 <code>binder_thread_read</code> 的 ioctl 调用那（回到图中右边部分），后面 client 发送了一个 IPC 请求，然后把一个 work 插入到了 service proc（<code>target_proc</code>） 的 todo lsit 上，service 的阻塞就被唤醒了。我们接着看后面的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">  </div><div class="line">... ...</div><div class="line"></div><div class="line">        BUG_ON(t-&gt;buffer == NULL);</div><div class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) {</div><div class="line">            <span class="keyword">struct</span> binder_node *target_node = t-&gt;buffer-&gt;target_node;</div><div class="line">            tr.target.ptr = target_node-&gt;ptr;</div><div class="line">            tr.cookie =  target_node-&gt;cookie;</div><div class="line">            t-&gt;saved_priority = task_nice(current);</div><div class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &&</div><div class="line">                !(t-&gt;flags & TF_ONE_WAY))</div><div class="line">                binder_set_nice(t-&gt;priority);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags & TF_ONE_WAY) ||</div><div class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</div><div class="line">                binder_set_nice(target_node-&gt;min_priority);</div><div class="line">            cmd = BR_TRANSACTION;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            tr.target.ptr = NULL;</div><div class="line">            tr.cookie = NULL;</div><div class="line">            cmd = BR_REPLY;</div><div class="line">        }</div><div class="line">        tr.code = t-&gt;code;</div><div class="line">        tr.flags = t-&gt;flags;</div><div class="line">        tr.sender_euid = t-&gt;sender_euid;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (t-&gt;from) {</div><div class="line">            <span class="keyword">struct</span> task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;</div><div class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</div><div class="line">                            current-&gt;nsproxy-&gt;pid_ns);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            tr.sender_pid = <span class="number">0</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</div><div class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</div><div class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</div><div class="line">                    proc-&gt;user_buffer_offset;</div><div class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</div><div class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</div><div class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &tr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line"></div><div class="line">        binder_stat_br(proc, thread, cmd);</div><div class="line">        binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                 <span class="string">"binder: %d:%d %s %d %d:%d, cmd %d"</span></div><div class="line">                 <span class="string">"size %zd-%zd ptr %p-%p\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid,</div><div class="line">                 (cmd == BR_TRANSACTION) ? <span class="string">"BR_TRANSACTION"</span> :</div><div class="line">                 <span class="string">"BR_REPLY"</span>,</div><div class="line">                 t-&gt;debug_id, t-&gt;from ? t-&gt;from-&gt;proc-&gt;pid : <span class="number">0</span>,</div><div class="line">                 t-&gt;from ? t-&gt;from-&gt;pid : <span class="number">0</span>, cmd,</div><div class="line">                 t-&gt;buffer-&gt;data_size, t-&gt;buffer-&gt;offsets_size,</div><div class="line">                 tr.data.ptr.buffer, tr.data.ptr.offsets);</div><div class="line"></div><div class="line">        list_del(&t-&gt;work.entry);</div><div class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION && !(t-&gt;flags & TF_ONE_WAY)) {</div><div class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</div><div class="line">            t-&gt;to_thread = thread;</div><div class="line">            thread-&gt;transaction_stack = t;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            t-&gt;buffer-&gt;transaction = NULL;</div><div class="line">            kfree(t);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION);</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>由于 client 把一个 work 插入到 service proc 中的 todo list 中， work type 是 <code>BINDER_WORK_TRANSACTION</code>，这个处理就自己把前面写入的 <code>binder_transaction</code> 这个数据结构给取出来了，所以 t 那个判断 t != NULL 就会继续走下面的处理（看前面 client 的代码分析）。</p>
<p>这里有个分支判断： t-&gt;buffer-&gt;target_node 是否为 NULL，前面 client <code>binder_transaction</code> 那里通过 Bp 的 handle 找到了目标（service）的 target node 了的（每个 Bn 都是一个 binder node，这个后面再说），然后把 <code>target_node</code> 写入了 <code>binder_transaction</code> 中，所以这里走 <code>BR_TRANSACTION</code> 命令这个分支。这个分支把 <code>target_node</code> 的 ptr 和 cookie 写了返回给 service 的数据中，这个东西就是 Bn 的地址指针（这个后面 service manager 那再具体说）。</p>
<p>然后下面，就是把 <code>binder_transaction</code> 中的数据地址 copy 到准备返回给 service 的 <code>binder_transaction_data</code> 中。然后先是一个 <code>put_user</code> 把 <code>BR_TRANSACTION</code> 命令写给用户空间，后面 <code>copy_to_user</code> 把数据给写给用户空间。最后分支是 <code>BR_TRANSACTION</code> 然后也需要返回，保存下传送堆栈。</p>
<p>之后 service 在 kernel 中的 ioctl 阻塞结束，返回到用户空间。之前在 getAndExecuteCommand 的 talkWithDriver 阻塞，现在继续往下执行，在 ioctl 读取到数据后，读取 kernel 返回的命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">    size_t IN = mIn.dataAvail();   </div><div class="line">    <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">    cmd = mIn.readInt32();</div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">             &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    result = executeCommand(cmd);  </div><div class="line"></div><div class="line">    <span class="comment">// After executing the command, ensure that the thread is returned to the</span></div><div class="line">    <span class="comment">// foreground cgroup before rejoining the pool.  The driver takes care of</span></div><div class="line">    <span class="comment">// restoring the priority, but doesn't do anything with cgroups so we</span></div><div class="line">    <span class="comment">// need to take care of that here in userspace.  Note that we do make</span></div><div class="line">    <span class="comment">// sure to go in the foreground after executing a transaction, but</span></div><div class="line">    <span class="comment">// there are other callbacks into user code that could have changed</span></div><div class="line">    <span class="comment">// our group so we want to make absolutely sure it is put back.</span></div><div class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>之前 kernel 返回的是 <code>BR_TRANSACTION</code>，然后到 executeCommand 处理命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">       </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        {</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ALOG_ASSERT(result == NO_ERROR,</div><div class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> pid_t origPid = mCallingPid;</div><div class="line">            <span class="keyword">const</span> uid_t origUid = mCallingUid;</div><div class="line"></div><div class="line">            mCallingPid = tr.sender_pid;</div><div class="line">            mCallingUid = tr.sender_euid;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> curPrio = getpriority(PRIO_PROCESS, mMyThreadId);</div><div class="line">            <span class="keyword">if</span> (gDisableBackgroundScheduling) {</div><div class="line">                <span class="keyword">if</span> (curPrio &gt; ANDROID_PRIORITY_NORMAL) {</div><div class="line">                    <span class="comment">// We have inherited a reduced priority from the caller, but do not</span></div><div class="line">                    <span class="comment">// want to run in that state in this process.  The driver set our</span></div><div class="line">                    <span class="comment">// priority already (though not our scheduling class), so bounce</span></div><div class="line">                    <span class="comment">// it back to the default before invoking the transaction.</span></div><div class="line">                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (curPrio &gt;= ANDROID_PRIORITY_BACKGROUND) {</div><div class="line">                    <span class="comment">// We want to use the inherited priority from the caller.</span></div><div class="line">                    <span class="comment">// Ensure this thread is in the background scheduling class,</span></div><div class="line">                    <span class="comment">// since the driver won't modify scheduling classes for us.</span></div><div class="line">                    <span class="comment">// The scheduling group is reset to default by the caller</span></div><div class="line">                    <span class="comment">// once this method returns after the transaction is complete.</span></div><div class="line">                    set_sched_policy(mMyThreadId, SP_BACKGROUND);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">//ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);</span></div><div class="line"></div><div class="line">            Parcel reply;</div><div class="line">            IF_LOG_TRANSACTIONS() {</div><div class="line">                TextOutput::Bundle _b(alog);</div><div class="line">                alog &lt;&lt; <span class="string">"BR_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self()</div><div class="line">                    &lt;&lt; <span class="string">" / obj "</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">" / code "</span></div><div class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; buffer</div><div class="line">                    &lt;&lt; dedent &lt;&lt; endl</div><div class="line">                    &lt;&lt; <span class="string">"Data addr = "</span></div><div class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer)</div><div class="line">                    &lt;&lt; <span class="string">", offsets addr="</span></div><div class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) {</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                <span class="keyword">const</span> status_t error = b-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">const</span> status_t error = the_context_object-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">//ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",</span></div><div class="line">            <span class="comment">//     mCallingPid, origPid, origUid);</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((tr.flags & TF_ONE_WAY) == <span class="number">0</span>) {</div><div class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</div><div class="line">                sendReply(reply, <span class="number">0</span>);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</div><div class="line">            }</div><div class="line"></div><div class="line">            mCallingPid = origPid;</div><div class="line">            mCallingUid = origUid;</div><div class="line"></div><div class="line">            IF_LOG_TRANSACTIONS() {</div><div class="line">                TextOutput::Bundle _b(alog);</div><div class="line">                alog &lt;&lt; <span class="string">"BC_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / obj "</span></div><div class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">            }</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续从 mIn 中把前面 kernel 写入的 <code>binder_transaction_data</code> 数据取出来，然后把 buffer 数据地址写入到 Parcel 中，这个相当于把 client 传入的 IPC 参数取出来了。</p>
<p>然后关键的来了， 判断 tr.target.ptr 是否为 NULL，前面 kernel 把 service Bn 的指针地址写进去了，后面直接转化为 BBinder* ，然后调用 transaction 方法。这个就想当于调用 serivce Bn 的 transaction 方法，最后参数调用到 service 中真正实现的函数，具体的看前一篇原理的分析（这里实现 IPC 调用，前面图中有一个流程 impl IPC API）。</p>
<p>在调用 transaction 的时候，有个引用参数 reply，service 的业务函数会把返回值通过 Parcel 打包好，然后后面那个判断前面见过很多次，是需要返回值的，所以调用 sendReply 把返回值，通过 kernel binder 发送给 client：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::sendReply(<span class="keyword">const</span> Parcel& reply, uint32_t flags) </div><div class="line">{</div><div class="line">    status_t err;</div><div class="line">    status_t statusBuffer;</div><div class="line">    err = writeTransactionData(BC_REPLY, flags, -<span class="number">1</span>, <span class="number">0</span>, reply, &statusBuffer);</div><div class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</div><div class="line">       </div><div class="line">    <span class="keyword">return</span> waitForResponse(NULL, NULL);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数十分简洁，调用的2个函数前面（client 发命令那里）也都见过，而且顺序都一样，只不过参数不一样而已。writeTransactionData 打包的命令是 <code>BC_REPLY</code>，而 waitForReponse 参数是 NULL，根据前面的分析，参数是 NULL 的话，那么得到 kernel 返回 <code>BR_TRANSACTION_COMPLETE</code> 函数就结束了（前面的图中是 no reply）。</p>
<p>这里就不贴代码了，和前面是一样的，writeTransactionData 把数据打好包后，waitForReponse 通过 talkWithDriver 的 ioctl 就到 kernel 里面了，这次 <code>binder_thread_write</code> 调用 <code>binder_transaction</code> 的参数 reply 是 true，来看看有什么不一样（前面 client 是 false）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">        in_reply_to = thread-&gt;transaction_stack;</div><div class="line">        <span class="keyword">if</span> (in_reply_to == NULL) {     </div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got reply transaction "</span></div><div class="line">                      <span class="string">"with no transaction stack\n"</span>, </div><div class="line">                      proc-&gt;pid, thread-&gt;pid);       </div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_empty_call_stack;     </div><div class="line">        }</div><div class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</div><div class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got reply transaction "</span></div><div class="line">                <span class="string">"with bad transaction stack,"</span>  </div><div class="line">                <span class="string">" transaction %d has target %d:%d\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,</div><div class="line">                in_reply_to-&gt;to_proc ?         </div><div class="line">                in_reply_to-&gt;to_proc-&gt;pid : <span class="number">0</span>, </div><div class="line">                in_reply_to-&gt;to_thread ?       </div><div class="line">                in_reply_to-&gt;to_thread-&gt;pid : <span class="number">0</span>);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            in_reply_to = NULL;            </div><div class="line">            <span class="keyword">goto</span> err_bad_call_stack;       </div><div class="line">        }</div><div class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</div><div class="line">        target_thread = in_reply_to-&gt;from;</div><div class="line">        <span class="keyword">if</span> (target_thread == NULL) {   </div><div class="line">            return_error = BR_DEAD_REPLY;  </div><div class="line">            <span class="keyword">goto</span> err_dead_binder;          </div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got reply transaction "</span></div><div class="line">                <span class="string">"with bad target transaction stack %d, "</span></div><div class="line">                <span class="string">"expected %d\n"</span>,               </div><div class="line">                proc-&gt;pid, thread-&gt;pid,        </div><div class="line">                target_thread-&gt;transaction_stack ?</div><div class="line">                target_thread-&gt;transaction_stack-&gt;debug_id : <span class="number">0</span>,</div><div class="line">                in_reply_to-&gt;debug_id);        </div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            in_reply_to = NULL;            </div><div class="line">            target_thread = NULL;          </div><div class="line">            <span class="keyword">goto</span> err_dead_binder;          </div><div class="line">        }</div><div class="line">        target_proc = target_thread-&gt;proc;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">... ... </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里主要的不同是寻找目标进程（线程）的不同，前面 client 那里寻找目标 service proc 是通过从 service manager 取到的 service Bp 的 handle 取到 service Bn 的 node，进而找到 service proc 的。这里却是通过前面 client 保存的 <code>transaction_stack</code>（传送堆栈）取到要返回的 client 的 thread 的。而且还根据这个校验这次的传送是否是有效的，就是保存的堆栈中的 <code>in_reply_to</code> 必须是本线程（就是前面 client 发送到的目标线程序必须是自己），否则就认为是一次无效的调用，就不处理（这个可能对某些恶意注入、拦截有用吧）。 </p>
<p>然后后面就和 client 那里一样了，创建 <code>binder_transaction</code> 和 <code>binder_work</code> 把数据和 work type 写到里面去。有一点，后面如果是 reply 则调用 <code>binder_pop_transaction</code> 把之前 client 保存堆栈出栈（因为这里是返回到 client，所以要出栈，之前 client 到 service 是入栈）。</p>
<p>然后也和前面 client 一样，插入了2个 work，一个插到 client 的 thread todo （这里是 thread 的 todo list，因为前面找到的 <code>target_thread</code> != NULL）里面，一个插到自己 thread 的 todo 里面，并唤醒在等待的 client 线程。</p>
<p>这里和前面一样，先不管 client 那边先，先继续看 service 这边。这边从 <code>binder_thread_write</code> 写完后，就到 <code>binder_thread_read</code> 了。和前面 client 一样，由于插入了 <code>BINDER_WORK_COMPLETE</code> 的 work 到 thread-&gt;todo list 所以这里不会阻塞。然后和 client 一样了，返回 <code>BR_TRANSACTION_COMPLETE</code> 给用户空间，然后退出循环，结束 ioctl 调用。</p>
<p>到用户空间， waitForReponse 前面说了，参数为 NULL，直接跳到 finish，结束，然后 sendReply 执行结束， exectueCommand 执行结束，然后 getAndExecuteCommand 执行结束。这里本次 IPC 调用， service 端的工作就算是结束了。然后进入下一个 joinThreadLoop 循环，等待下一次 client 请求的到来。</p>
<h2 id="4-_客户端接收到服务端返回的数据">4. 客户端接收到服务端返回的数据</h2>
<p>service 端结束了，回到 client 这边（继续图的左边部分）。前面 client 为等待 service 返回的结果，阻塞在 <code>binder_thread_read</code> 那里。上一个部分， service 把返回数据用 <code>BC_REPLY</code> 写入 kernel 后，client 就被唤醒了，然后继续往下走：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">        BUG_ON(t-&gt;buffer == NULL);</div><div class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) {</div><div class="line">... ...</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            tr.target.ptr = NULL;</div><div class="line">            tr.cookie = NULL;</div><div class="line">            cmd = BR_REPLY;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面取数据都一样了，然后主要是这里不一样，前面 service 那 <code>t-&gt;buffer-&gt;target_node</code> 是为 NULL 的，但是这里是 NULL（上面一部 service 是通过 <code>transaction_stack</code> 取的 target thread，所以没有 <code>target_node</code>），所以走下面。Bn 的地址直接设置为 NULL（client 那当然没 Bn，那里的是 Bp），返回的命令的是 <code>BR_REPLY</code> 。后面的处理就和前面差不多了，方法就返回到用户空间了。</p>
<p>这里就从 talkWithDriver 回到了 waitForReponse ，继续下面的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        err = mIn.errorCheck();</div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        cmd = mIn.readInt32();</div><div class="line"></div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></div><div class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BR_REPLY:</div><div class="line">            {</div><div class="line">                binder_transaction_data tr;    </div><div class="line">                err = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</div><div class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (reply) {</div><div class="line">                    <span class="keyword">if</span> ((tr.flags & TF_STATUS_CODE) == <span class="number">0</span>) {</div><div class="line">                        reply-&gt;ipcSetDataReference(    </div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                            tr.data_size,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(size_t),</div><div class="line">                            freeBuffer, <span class="keyword">this</span>);</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        err = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> status_t*&gt;(tr.data.ptr.buffer);</div><div class="line">                        freeBuffer(NULL,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                            tr.data_size,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    freeBuffer(NULL,</div><div class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                        tr.data_size,</div><div class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">goto</span> finish;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">finish:</div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        mLastError = err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里从 kernel 返回的命令是 <code>BR_REPLY</code>，处理也比较简单，就是把 service 写给 kernel 的数据指针设置给了 reply （Parcel）而已。然后就跳出循环 finish 了。然后后面就是通过 Parcel 从 reply 中读出 service 打包的数据，作为函数的返回值。</p>
<p>到这里 client 发起的一次 IPC 调用就结束了。</p>
<h2 id="总结">总结</h2>
<p>前面写了很多，稍微简化一下流程是：</p>
<ol>
<li>service 运行，阻塞于 ioctl，等待 client 发起请求</li>
<li>client 通过 ioctl 发起 IPC 请求，等待 service 结果<br> 2.1. client send <strong><code>BC_TRANSACTION</code></strong> —&gt; kernel<br> 2.2. kernel return <strong><code>BR_TRANSACTION_COMPLETE</code></strong> —&gt; client<br> 2.3. client 阻塞于 ioctl，等待 service 返回结果</li>
<li>service 被唤醒，完成业务，返回结果<br> 3.1. kernel return <strong><code>BR_TRANSACTION</code></strong> —&gt; service<br> 3.2. service impl IPC call<br> 3.3. service send <strong><code>BC_REPLY</code></strong> —&gt; kernel<br> 3.4. kernel return <strong><code>BR_TRANSACTION_COMPLETE</code></strong> —&gt; service</li>
<li>client 被唤醒，读取 service 返回结果， IPC 结束<br> 4.1. kernel return <strong><code>BR_REPLY</code></strong> —&gt; client<br> 4.2. IPC call end</li>
</ol>
<p>可以看到 BC 开头的协议都是用户空间对 kernel 发送的， BR 开头的协议都是 kernel 返回给用户空间的。所以应用程序是通过 kernel 的 binder 驱动进行通信的（之前我搞混过，一开始我以为这些 <code>BC_XX</code>, <code>BR_XX</code> 是 client 发往 service，其实不是它们都只与 kernel 通信而已，不知道对方彼此的存在）。向 kernel 发送传送请求的命令（<code>BC_TRANSACTION</code>, <code>BC_REPLY</code>），kernel 会返回 <code>BR_TRANSACTION_COMPLETE</code> 告诉发送者，传送完成。</p>
<p>kernel binder 驱动 binder.h 中定义2个 enum ，分别是： BinderDriverReturnProtocol 和 BinderDriverCommandProtocol 。里面除了上面提到的 <code>BC_TRANSACTION</code>, <code>BC_REPLY</code>, <code>BR_TRANSACTION_COMPLETE</code>, <code>BR_TRANSACTION</code>, <code>BR_REPLY</code> 还有很多别的命令，而且有一些还是没实现的（看注释有写）。其它一些用处，后面一些篇章会说到。其实名字还是挺形象的（BC、BR），只不过我一开始理解错了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%80%85%5BParcel%5D/</loc>
    <lastmod>2015-03-31T06:34:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——数据传递者（Parcel）</title>
        <pubTime>2015-01-28T12:41:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>前面 binder 原理和通信模型中在接口实现部分（Bp 和 Bn）中应该看到很多地方都有使用 parcel。这个 android 专门设计用来跨进程传递数据的，实现在 native，java 层有接口（基本上是 jni 马甲）。照例先说下源代码位置（4.4 的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java parcel （MemoryFile 是封装好的匿名共享内存的接口）</span></div><div class="line">frameworks/base/core/java/os/Parcel.java</div><div class="line">frameworks/base/core/java/os/Parcelable.java</div><div class="line">frameworks/base/core/java/os/ParcelFileDescriptor.java</div><div class="line">frameworks/base/core/java/os/MemoryFile.java</div><div class="line"></div><div class="line"><span class="comment"># parcel jni 相关</span></div><div class="line">frameworks/base/core/jni/android_os_Parcel.h</div><div class="line">frameworks/base/core/jni/android_os_MemoryFile.h</div><div class="line">frameworks/base/core/jni/android_os_Parcel.cpp</div><div class="line"></div><div class="line"><span class="comment"># native parcel 实现（Memory 相关的是封装好的匿名共享内存实现）</span></div><div class="line">frameworks/native/include/binder/Parcel.h</div><div class="line">frameworks/native/include/binder/IMemory.h</div><div class="line">frameworks/native/include/binder/MemoryHeapBase.h</div><div class="line">frameworks/native/include/binder/MemoryBase.h</div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line">frameworks/native/libs/binder/Memory.cpp</div><div class="line">frameworks/native/libs/binder/MemoryHeapBase.cpp</div><div class="line">frameworks/native/libs/binder/MemoryBase.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"><span class="comment"># kernel ahsmem 驱动</span></div><div class="line">kernel/include/linux/ashmem.h</div><div class="line">kernel/mm/ashmem.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="原理">原理</h2>
<p>在 java 层 parcel 有个接口叫 Parcelable，和 java 的 Serializable 很像，刚开始我还没搞明白这2个有什么区别（以前对 java 也不太熟）。这里简单说一下， Serializable 是 java 的接口，翻译过来是序列化的意思，就是通过实现这个接口能够让 java 的对象序列化能够永久保存在的存储介质上，然后反序列化就能从存储介质上实列化出 java 对象（通俗点，就是一个 save/load 的功能）。因为保存到了存储介质上，所以是可以跨进程的（一个进程把数据写入文件，另外一个去读）。但是为什么 android 还要搞一个 parcel 出来，是因为 java 的 Serializable 是通过存储介质的，所以速度慢。parcel 是基于内存传递的，比磁盘I/O要块，而且更加轻量级（这个我是从网上看到的，我没研究过 java 的 Serializable 代码）。</p>
<p>parcel 在内存中的结构是一块连续的内存，会动根据需要自动扩展大小（这个设计比较赞，一些对性能要求不是太高、或是小数据的地方，可以不用废脑想分配多大空间）。parcel 传递数据，可以分为3种，传递方式也不一样：</p>
<ul>
<li><strong>小型数据</strong>： 从用户空间（源进程）copy 到 kernel 空间（binder 驱动中）再写回用户空间（目标进程，binder 驱动负责寻找目标进程）。</li>
<li><strong>大型数据</strong>： 使用 android 的匿名共享内存（Ashmem）传递</li>
<li><strong>binder 对象</strong>： kernel binder 驱动专门处理</li>
</ul>
<p>下面逐一分析。这里我打算从 natvie 到 kernel 再到 java 的顺序进行，因为接着前面通信原型那里，所以从 natvie 开始会比较好，而且实现的地方也在 native。</p>
<h2 id="小型数据">小型数据</h2>
<p>先来看看 Parcel.h 中几个比较关键的几个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">uint8_t*            mData;</div><div class="line">size_t              mDataSize;</div><div class="line">size_t              mDataCapacity;</div><div class="line"><span class="keyword">mutable</span> size_t      mDataPos;</div><div class="line">size_t*             mObjects;</div><div class="line">size_t              mObjectsSize;</div><div class="line">size_t              mObjectsCapacity;</div><div class="line"><span class="keyword">mutable</span> size_t      mNextObjectHint;</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>mData： 数据指针，也是数据在本进程空间内的内存地址</li>
<li>mDataSize： 存储的数据大小（使用的空间大小）</li>
<li>mDataCapacity： 数据空间大小，如果不够的话，可以动态增长</li>
<li>mDataPos： 数据游标，当前数据的位置，和读文件的游标类似，可以手动设置。声明了 mutbale 属性，可以学习下这个属性应该用在声明地方 ^_^。</li>
<li>mObjects： <code>flat_binder_object</code> 对象的位置数据，注意这个是个指针（其实就是个数组），里面保存的不是数据，而且地址的偏移（后面再具体说）。</li>
<li>mObjectsSize： 这个简单来说其实就是上面那个 objects 数组的大小。</li>
<li>mObjectsCapacity： objects 偏移地址（再次强调一次是地址）的空间大小，同样可以动态增长</li>
<li>mNextObjectHint： 可以理解为 objects 的 dataPos 。</li>
</ul>
<p>还记得通信模型 IPCThreadState 中有2个 Parcel 变量： mIn、mOut，前面分析这2个东西是 binder 通信的时候打包数据用的。我们通过结合前面的例子来分析。</p>
<p>首先是初始化，IPCThreadState 是直接使用变量的（栈内存），使用默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Parcel::Parcel()</div><div class="line">{</div><div class="line">    initState();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::initState()</div><div class="line">{</div><div class="line">    mError = NO_ERROR;</div><div class="line">    mData = <span class="number">0</span>;</div><div class="line">    mDataSize = <span class="number">0</span>;</div><div class="line">    mDataCapacity = <span class="number">0</span>;</div><div class="line">    mDataPos = <span class="number">0</span>;</div><div class="line">    ALOGV(<span class="string">"initState Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">    ALOGV(<span class="string">"initState Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">    mObjects = NULL;</div><div class="line">    mObjectsSize = <span class="number">0</span>;</div><div class="line">    mObjectsCapacity = <span class="number">0</span>;</div><div class="line">    mNextObjectHint = <span class="number">0</span>;</div><div class="line">    mHasFds = <span class="keyword">false</span>;</div><div class="line">    mFdsKnown = <span class="keyword">true</span>;</div><div class="line">    mAllowFds = <span class="keyword">true</span>;</div><div class="line">    mOwner = NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>初始话很简单，几乎都是初始化为 0（NULL） 的。然后看看 IPCThreadState 使用的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">IPCThreadState::IPCThreadState()</div><div class="line">    : mProcess(ProcessState::self()),</div><div class="line">      mMyThreadId(androidGetTid()),</div><div class="line">      mStrictModePolicy(<span class="number">0</span>),</div><div class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</div><div class="line">{</div><div class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</div><div class="line">    clearCaller();</div><div class="line">    mIn.setDataCapacity(<span class="number">256</span>);</div><div class="line">    mOut.setDataCapacity(<span class="number">256</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>首先调用 setDataCapacity 来初始化 parcel 的数据空间大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::setDataCapacity(size_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (size &gt; mDataCapacity) <span class="keyword">return</span> continueWrite(size);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::continueWrite(size_t desired)</div><div class="line">{</div><div class="line">... ...</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mData) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// This is the first data.  Easy!</span></div><div class="line">        uint8_t* data = (uint8_t*)<span class="built_in">malloc</span>(desired);</div><div class="line">        <span class="keyword">if</span> (!data) {</div><div class="line">            mError = NO_MEMORY;</div><div class="line">            <span class="keyword">return</span> NO_MEMORY;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!(mDataCapacity == <span class="number">0</span> && mObjects == NULL</div><div class="line">             && mObjectsCapacity == <span class="number">0</span>)) {</div><div class="line">            ALOGE(<span class="string">"continueWrite: %d/%p/%d/%d"</span>, mDataCapacity, mObjects, mObjectsCapacity, desired);</div><div class="line">        }</div><div class="line"></div><div class="line">        mData = data;</div><div class="line">        mDataSize = mDataPos = <span class="number">0</span>;</div><div class="line">        ALOGV(<span class="string">"continueWrite Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">        ALOGV(<span class="string">"continueWrite Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">        mDataCapacity = desired;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>设置空间大小的，其实主要是调用到了 contiueWrite 函数。前面那个 size &gt; mDataCapacity 判断意思是如果设置的大小比原来的要大，则需要调整申请的内存的大小，如果小的话，就直接使用原来的大小。</p>
<p>接下来看 contiueWrite，前面有个 object 的判断先不管。然后下面主要是分开3个分支，分别是：</p>
<ul>
<li>分支一： 如果设置了 release 函数指针（mOwner是个函数指针），调用 release 函数进行处理。</li>
<li>分支二： 没有设置 release 函数指针，但是 mData 中存在数据，需要在原来的数据的基础上扩展存储空间。</li>
<li>分支三： 没有设置 release 函数指针，并且 mData 中不存在数据（就是注释中说的第一次使用， Easy -_-||），调用 malloc 申请内存块，保存在 mData。设置相应的设置 capacity、size、pos、object 的值。</li>
</ul>
<p>这里先贴出分支三的代码，第一次使用，是走分支三的，其它2个后面再说。这里注意一点，这里只 malloc 了一个块内存，就是 mData 的，前面说 parcel 存储结构是一块连续的内存，mObjects 只是保存的只是地址的偏移，这里可以看到一些端倪（后面就能清楚）。</p>
<p>初始化了之后，我们看看怎么使用的，在通信模型中我们说道 Bp 端发起 IPC 调用，通过 IPCThreadState 对 binder 驱动写入请求数据发送到 Bn 端，我们回想下 Bp 端写数据的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel& data, status_t* statusBuffer)</div><div class="line">{</div><div class="line">    binder_transaction_data tr;</div><div class="line"></div><div class="line">... ...</div><div class="line">       </div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">                              </div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>先看前面 writeInt32 这个，对 parcel 写入一个 32bit 的 int 型数据。parcel 接口中有一类是专门针对基本类型（int、float、double、int数组），writeInt32、writeInt64、writeFloat、writeDouble、writeIntArray 这些（对应有 read 接口）。然后他们都是另一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">status_t Parcel::writeAligned(T val) {</div><div class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) {</div><div class="line">restart_write:</div><div class="line">        *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;</div><div class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));</div><div class="line">    }</div><div class="line"></div><div class="line">    status_t err = growData(<span class="keyword">sizeof</span>(val));</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::finishWrite(size_t len)</div><div class="line">{</div><div class="line">    <span class="comment">//printf("Finish write of %d\n", len);</span></div><div class="line">    mDataPos += len;</div><div class="line">    ALOGV(<span class="string">"finishWrite Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">    <span class="keyword">if</span> (mDataPos &gt; mDataSize) {</div><div class="line">        mDataSize = mDataPos;</div><div class="line">        ALOGV(<span class="string">"finishWrite Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">    }</div><div class="line">    <span class="comment">//printf("New pos=%d, size=%d\n", mDataPos, mDataSize);</span></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>writeAligned 看名字就知道要内存对齐，第一句好像就是验证下是否内存对齐的，好像能够根据编译选项判断，应该是如果打开某个编译选项，如果传过来的 size 没内存对齐直接报错吧，内存对齐的算法都是搞一些位运算（这里好像是4字节对齐吧）：</p>
<pre>
#define PAD_SIZE(s) (((s)+3)&~3)
</pre>

<p>int32、int64、float、double 都是4字节对齐的。接着往下看，有个判断当前 pos + 要写入的数据的所占用的空间是否比 capacity 大，就是看空间是不是够大。前面所了 parcel 能够根据需求自动增长空间，这里我们先看空间够的情况，就是走 if 里面：</p>
<pre>
*reinterpret_cast<t*>(mData+mDataPos) = val;
</t*></pre>

<p>直接取当前地址强制转化指针类型，然后赋值（c/c++语言就是舒服）。然后调用 finishWrite 完成写入。finishWrite 就是把 mDataPos 和 mDataSize 值改了一下（加上刚刚写入数据的大小），从这里可以看得出，对于 write 来说，mDataPos = mDataSize。</p>
<p>然后我们看看当空间不够的情况，就是走 if 后面，有一个 growData 的函数，这个是用来调整内存空间的，然后一个 goto 跳转回 if 里面重写写入（parcel 的实现很多地方有 goto，其实 goto 在本函数里面用还好）。我们来看看 growData：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::growData(size_t len)</div><div class="line">{</div><div class="line">    size_t newSize = ((mDataSize+len)*<span class="number">3</span>)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> (newSize &lt;= mDataSize)</div><div class="line">            ? (status_t) NO_MEMORY         </div><div class="line">            : continueWrite(newSize);      </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 parcel 的增长算法： ((mDataSize+len)*3)/2， 带一定预测性的增长，避免频繁的空间调整（每次调整需要重新 malloc 内存的，频繁的话会影响效率的）。然后这里有个判断 newSize &lt; mDataSize 就认为 NO_MEMORY。这是所如果如果溢出了（是负数），就认为申请不到内存了。然后调用的函数是 continueWrite ，和前面 setCapacity 调用的是同一个。前面说这个函数有3个分支，这里我们就可以来看第2个分支了（mData 有数据的情况）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::continueWrite(size_t desired)</div><div class="line">{</div><div class="line">    <span class="comment">// If shrinking, first adjust for any objects that appear</span></div><div class="line">    <span class="comment">// after the new data size.</span></div><div class="line">    size_t objectsSize = mObjectsSize;</div><div class="line">    <span class="keyword">if</span> (desired &lt; mDataSize) {</div><div class="line">        <span class="keyword">if</span> (desired == <span class="number">0</span>) {</div><div class="line">            objectsSize = <span class="number">0</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">while</span> (objectsSize &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (mObjects[objectsSize-<span class="number">1</span>] &lt; desired)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                objectsSize--;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mData) {</div><div class="line">        <span class="keyword">if</span> (objectsSize &lt; mObjectsSize) {</div><div class="line">            <span class="comment">// Need to release refs on any objects we are dropping.</span></div><div class="line">            <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">            <span class="keyword">for</span> (size_t i=objectsSize; i&lt;mObjectsSize; i++) {</div><div class="line">                <span class="keyword">const</span> flat_binder_object* flat</div><div class="line">                    = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(mData+mObjects[i]);</div><div class="line">                <span class="keyword">if</span> (flat-&gt;type == BINDER_TYPE_FD) {</div><div class="line">                    <span class="comment">// will need to rescan because we may have lopped off the only FDs</span></div><div class="line">                    mFdsKnown = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">                release_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">            }</div><div class="line">            size_t* objects =</div><div class="line">                (size_t*)realloc(mObjects, objectsSize*<span class="keyword">sizeof</span>(size_t));</div><div class="line">            <span class="keyword">if</span> (objects) {</div><div class="line">                mObjects = objects;</div><div class="line">            }</div><div class="line">            mObjectsSize = objectsSize;</div><div class="line">            mNextObjectHint = <span class="number">0</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// We own the data, so we can just do a realloc().</span></div><div class="line">        <span class="keyword">if</span> (desired &gt; mDataCapacity) {</div><div class="line">            uint8_t* data = (uint8_t*)realloc(mData, desired);</div><div class="line">            <span class="keyword">if</span> (data) {</div><div class="line">                mData = data;</div><div class="line">                mDataCapacity = desired;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (desired &gt; mDataCapacity) {</div><div class="line">                mError = NO_MEMORY;</div><div class="line">                <span class="keyword">return</span> NO_MEMORY;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (mDataSize &gt; desired) {</div><div class="line">                mDataSize = desired;</div><div class="line">                ALOGV(<span class="string">"continueWrite Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mDataPos &gt; desired) {</div><div class="line">                mDataPos = desired;</div><div class="line">                ALOGV(<span class="string">"continueWrite Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有关 object 的处理也是先放放，后面再一起说。看后面的，如果需要的空间比原来的大，那么调用 realloc 把空间调整一下。realloc 可以看 man，是说保留原来的内存空间，然后尝试在原来的空间后面扩展需要的内存空间。然后就是把 mDataPos 和 mDataSize 设置一下。如果是要的空间比原来的小，那就什么都不干，就是说用就当成小的用，内存还是以前那么大。</p>
<p>然后回到 IPCThreadState::writeTransactionData 我们看看后面那个 mOut.write： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::write(<span class="keyword">const</span> <span class="keyword">void</span>* data, size_t len)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> d = writeInplace(len);</div><div class="line">    <span class="keyword">if</span> (d) {</div><div class="line">        <span class="built_in">memcpy</span>(d, data, len);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> mError;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span>* Parcel::writeInplace(size_t len)</div><div class="line">{</div><div class="line">    <span class="comment">// 4字节对齐，看样子字节对齐对效率还是有影响的</span></div><div class="line">    <span class="keyword">const</span> size_t padded = PAD_SIZE(len); </div><div class="line"></div><div class="line">    <span class="comment">// sanity check for integer overflow</span></div><div class="line">    <span class="keyword">if</span> (mDataPos+padded &lt; mDataPos) { </div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mDataPos+padded) &lt;= mDataCapacity) {</div><div class="line">restart_write:</div><div class="line">        <span class="comment">//printf("Writing %ld bytes, padded to %ld\n", len, padded);</span></div><div class="line">        uint8_t* <span class="keyword">const</span> data = mData+mDataPos;</div><div class="line"></div><div class="line">        <span class="comment">// Need to pad at end?</span></div><div class="line">        <span class="keyword">if</span> (padded != len) {</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> BYTE_ORDER == BIG_ENDIAN</span></div><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> uint32_t mask[<span class="number">4</span>] = {</div><div class="line">                <span class="number">0x00000000</span>, <span class="number">0xffffff00</span>, <span class="number">0xffff0000</span>, <span class="number">0xff000000</span></div><div class="line">            };</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></div><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> uint32_t mask[<span class="number">4</span>] = {</div><div class="line">                <span class="number">0x00000000</span>, <span class="number">0x00ffffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span></div><div class="line">            };</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">            <span class="comment">//printf("Applying pad mask: %p to %p\n", (void*)mask[padded-len],</span></div><div class="line">            <span class="comment">//    *reinterpret_cast&lt;void**&gt;(data+padded-4));</span></div><div class="line">            *<span class="keyword">reinterpret_cast</span>&lt;uint32_t*&gt;(data+padded-<span class="number">4</span>) &= mask[padded-len];</div><div class="line">        }</div><div class="line"></div><div class="line">        finishWrite(padded);</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    }</div><div class="line"></div><div class="line">    status_t err = growData(padded);</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数首先调用 writeInplace。来看下 writeInplace，这个函数参数是一个大小，返回是一个地址。进去里面看下，除去字节对齐的部分，就是把 mDataPos 和 mDataSize 的值加上了传过去的 len 大小，然后返回 mData + len 的地址。注意这里也有空间不够的情况，和前面的处理一样，调用 growData 去调整空间（parcel 写的接口基本上都有这个 growData 的处理）。这个函数相当于是帮你把内存分配好，然后返回计算好的起始地址给你。然后回到 write 下面直接 memcpy，把传过来的地址中的数据复制过来。</p>
<p>这2个接口的示例很经典，一个是写基本类型，一个是写对象类型的。基本类型可以说是值类型，直接把值写入内存中；对象类型，是把对象的内存数据写进来，这个相当于 c++ 里面的深拷贝，复制数据。上面 IPCThreadState 写入的是 <code>binder_transaction_data</code> 这个结构体，后面具体说说 binder 通信之间的数据格式。现在再来看看 writeString8 这个接口，加深下理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeString8(<span class="keyword">const</span> String8& str)</div><div class="line">{</div><div class="line">    status_t err = writeInt32(str.bytes()); </div><div class="line">    <span class="comment">// only write string if its length is more than zero characters,</span></div><div class="line">    <span class="comment">// as readString8 will only read if the length field is non-zero.</span></div><div class="line">    <span class="comment">// this is slightly different from how writeString16 works.</span></div><div class="line">    <span class="keyword">if</span> (str.bytes() &gt; <span class="number">0</span> && err == NO_ERROR) {</div><div class="line">        err = write(str.<span class="built_in">string</span>(), str.bytes()+<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>String8 是 android 在 native 对 <code>char*</code> 封装了一下，有点像 java 的 String方便字符串操作的。这个也是对象类型，看到 parcel 先是把 String8 的 size 写进去，然后 write 把 <code>char*</code> 数据写在 size 后面的内存中。我们再来看看对应的 readString8：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">String8 Parcel::readString8() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    int32_t size = readInt32();</div><div class="line">    <span class="comment">// watch for potential int overflow adding 1 for trailing NUL</span></div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> && size &lt; INT32_MAX) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* str = (<span class="keyword">const</span> <span class="keyword">char</span>*)readInplace(size+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (str) <span class="keyword">return</span> String8(str, size);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> String8();</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::readInt32(int32_t *pArg) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> readAligned(pArg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">status_t Parcel::readAligned(T *pArg) <span class="keyword">const</span> {</div><div class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(T)) &lt;= mDataSize) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = mData+mDataPos;</div><div class="line">        mDataPos += <span class="keyword">sizeof</span>(T);</div><div class="line">        *pArg =  *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(data);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> NOT_ENOUGH_DATA;        </div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span>* Parcel::readInplace(size_t len) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> ((mDataPos+PAD_SIZE(len)) &gt;= mDataPos && (mDataPos+PAD_SIZE(len)) &lt;= mDataSize) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = mData+mDataPos;</div><div class="line">        mDataPos += PAD_SIZE(len);     </div><div class="line">        ALOGV(<span class="string">"readInplace Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>读是先 readInt32 把 write 写入的 size 取出来，readInt32 是调用 readAligned 的。和前面 writeAligned 对应，先是判断下字节对齐，然后直接取 mData + mDataPos 地址的数据，转化成模版类型（再次感叹一次 c、c++ 爽）。注意一下这个函数最后移动了 mDataPos 的位置（对应 read 的数据的大小）。</p>
<p>然后是调用 readInplace ，有了前面的说明，你也应该知道这个是去返回对应的 writeInplace 的地址。里面果然是，同样注意最后移动了 mDataPos 的位置。然后去返回的地址取之前写入的 <code>char*</code> 数据，基于上面的数据重新构造出新的 String8 对象。这里你看出 pacrel 和 Serializable 很像，只不过 parcel 是在内存中捣腾，还有后面你会发现 parcel 还为 binder 做了一些别的事情。</p>
<p>还有前面说的 read 的接口回自动移动 mDataPos 的位置（parcel 所有 read 的接口都会自动移动 mDataPos），然后看前面的代码，你会发现，write 之后，到 read 的时候，能否取得到正确的数据，依赖于 mDataPos 的位置。这里就要求 binder 通信的时候，双方在用 parcel 读写数据的时候顺序一定要一致。例如说一个 IPC 调用，传递一个函数的参数： int、float、object，用 parcel 写顺序是： writeInt32、writeFloat、write，那么对方接到传过来的 parcel read 的顺序也必须为： readInt32、readFloat、read。就算其中某些参数你不用，你也要 read 一下，主要是要把 mDataPos 的位置移动对。</p>
<p>这里可以看得出 parcel 只是提供的是一块连续的内存块，至于往里面写什么东西，格式是怎么样的，取决于使用的人，所以使用人要要保证自己读得正确（要和写对应），例如前面说的 String8，前面一个 int32 是大小，后面这个大小的是 <code>char*</code> 数据，这个读的人必须按这个格式才重新创建出 String8。这个我们后面看 binder 中的使用能够看得出来。</p>
<p>接下来我们看看 binder 怎么把 parcel 打包的数据传递给另外一个进程的。这里我们结合下通信模型那分析的东西。首先 Bp 端调用 writeTransationData 把 IPC 请求打包发送到 binder 驱动。前面看到打包的是一个 cmd 和一个 <code>binder_transaction_data</code> 结构。先来看看这个结构（在 kernel binder.h 中）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction_data {</div><div class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></div><div class="line"><span class="comment">     * identifying the target and contents of the transaction.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        size_t  handle; <span class="comment">/* target descriptor of command transaction */</span></div><div class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></div><div class="line">    } target;</div><div class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></div><div class="line"></div><div class="line">    <span class="comment">/* General information about the transaction. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    pid_t       sender_pid;</div><div class="line">    uid_t       sender_euid;</div><div class="line">    size_t      data_size;  <span class="comment">/* number of bytes of data */</span></div><div class="line">    size_t      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></div><div class="line"></div><div class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></div><div class="line"><span class="comment">     * follows here; otherwise, it ends with a pointer to</span></div><div class="line"><span class="comment">     * the data buffer.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        <span class="keyword">struct</span> {</div><div class="line">            <span class="comment">/* transaction data */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</div><div class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</div><div class="line">        } ptr;</div><div class="line">        uint8_t buf[<span class="number">8</span>];</div><div class="line">    } data;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们看看 Bp 端对这个结构体填充了什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel& data, status_t* statusBuffer)</div><div class="line">{</div><div class="line">    binder_transaction_data tr;</div><div class="line"></div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    tr.flags = binderFlags;</div><div class="line">    tr.cookie = <span class="number">0</span>;</div><div class="line">    tr.sender_pid = <span class="number">0</span>;</div><div class="line">    tr.sender_euid = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> status_t err = data.errorCheck();</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        tr.data_size = data.ipcDataSize();</div><div class="line">        tr.data.ptr.buffer = data.ipcData();</div><div class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(size_t);</div><div class="line">        tr.data.ptr.offsets = data.ipcObjects();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) {</div><div class="line">        tr.flags |= TF_STATUS_CODE;</div><div class="line">        *statusBuffer = err;</div><div class="line">        tr.data_size = <span class="keyword">sizeof</span>(status_t);</div><div class="line">        tr.data.ptr.buffer = statusBuffer;</div><div class="line">        tr.offsets_size = <span class="number">0</span>;</div><div class="line">        tr.data.ptr.offsets = NULL;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> (mLastError = err);</div><div class="line">    }</div><div class="line"></div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_transatcion_data</code> target 这个 union 先看注释的说明， target.handle 是说是 IPC 目标的标示，这个 handle 这个东西后面再细说。code 是 IPC 接口定义的接口的标示（例如 <code>START_ACTIVITY</code>, <code>GET_TASK</code> 之类的玩意）。然后是检查下 parcel 的错误状态，一般是没啥错误的。然后后面几个赋值，来看看从 parcel 取出的是什么东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> uint8_t* Parcel::ipcData() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> mData;</div><div class="line">}</div><div class="line"></div><div class="line">size_t Parcel::ipcDataSize() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> (mDataSize &gt; mDataPos ? mDataSize : mDataPos);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> size_t* Parcel::ipcObjects() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> mObjects;</div><div class="line">}</div><div class="line"></div><div class="line">size_t Parcel::ipcObjectsCount() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> mObjectsSize;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释 <code>binder_transatcion_data</code> 的 data 这个变量是个 union，远程传输的时候用的是 ptr 这个结构，里面保存的是数据的地址。ptr.buffer 是 parcel 的 ipcData() ，这个函数返回的是 mData 就是数据地址。注意一下这里 data.ptr 保存的是 IPC Bp 传入的那个 parcel，不是 IPCThreadState mOut 这个用来打包 binder 数据的 parcel（都是用 parcel 容易搞混）。这里 data 这个 parcel 是将 IPC 的接口函数的参数数据打包起来的，例如 int、string 之类的参数。Bn 端返回的数据也是通过 parcel 打包的。而 IPCThreadState 的 mOut 只是写入了 cmd 和 <code>binder_transatcion_data</code> 而已，而 <code>binder_transation_data</code> 保存了 IPC 中传递的真正数据的地址（从参数 parcel 或取的），仅仅是地址而已。所以开头为什么 mOut 和 mIn 只把空间大小设置为 256，刚开始以为是因为 parcel 可以动态增长空间，先在看来，其实根本用不了到 256，因为数据大小只有一个 int32 的 cmd 和 <code>binder_transation_data</code> 这个结构而已。算一下 int32 4字节，<code>binder_transation_data</code> 第一个 target union 2个都是4字节的地址，所以就是4字节，除去后面 data 的 union 其余的7个都是4字节的地址，后面那个 data union 算最大的数据，是 4字节x2，所以 <code>binder_transation_data</code> 结构占 40字节，加上 cmd 就是 44字节。回去通信模型那看看图，是不是 Bp 端发 <code>BC_TRANSACTION</code> write_size 是不是 44。mIn 从 Bn 那读回来的数据也是差不多的，所以 256 足够了，基本上不需要动态调整空间的。</p>
<p>好，回到赋值那，看看后面几个，<code>data_size</code> 是取 mDataSize, mDataPos 比较大的那个（估计是为了保险吧，对于写 mDataSize 应该等于 mDataPos），然后看看后面的把 parcel 的 mObjectsSize 和 mObjects 分别给了 <code>offset_size</code> 和 ptr.offsets，<code>offset_size</code> 还乘了个地址的大小。前面说过了 parcel 的 mObjects 保存的是偏移地址，parcel 的名字很奇怪，kernel 里面的数据结构用名字再次告诉了我们这个是偏移地址。这个到后面就清楚了。</p>
<p>好 mOut 把数据打包好了，到了 waitForResponse 循环调用 talkWithDriver 向 binder 驱动写数据，以及等待 Bn 端返回数据（忘记了的回通信模型看看流程图）。我们先来看第一次写通信命令写了什么东西进去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> -EBADF; </div><div class="line">    }</div><div class="line">        </div><div class="line">    binder_write_read bwr;</div><div class="line">            </div><div class="line">    <span class="comment">// Is the read buffer empty?</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</div><div class="line">        </div><div class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></div><div class="line">    <span class="comment">// from data left in the input buffer and the caller</span></div><div class="line">    <span class="comment">// has requested to read the next data.</span></div><div class="line">    <span class="keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line">            </div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</div><div class="line">                </div><div class="line">    <span class="comment">// This is what we'll read.</span></div><div class="line">    <span class="keyword">if</span> (doReceive && needRead) {</div><div class="line">        bwr.read_size = mIn.dataCapacity();</div><div class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</div><div class="line">    } <span class="keyword">else</span> { </div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    }</div><div class="line">   </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></div><div class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) && (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    status_t err;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        ... ...</div><div class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &bwr) &gt;= <span class="number">0</span>)</div><div class="line">            err = NO_ERROR;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            err = -errno;</div><div class="line">        ... ...</div><div class="line">    } <span class="keyword">while</span> (err == -EINTR);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们在 kernel 的 binder.h 看到 <code>BINDER_WRITE_READ</code> 的参数是 <code>binder_write_read</code> 这个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BINDER_WRITE_READ           _IOWR('b', 1, struct binder_write_read)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * On 64-bit platforms where user code may run in 32-bits the driver must</span></div><div class="line"><span class="comment"> * translate the buffer (and local binder) addresses apropriately.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_write_read {</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span> </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span> </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_write_read</code> 的结构并不复杂，就是一个数据地址，一个数据大小，一个数据确认处理的大小，分为2部分，write 和 read（看注释后面要支持 64bit binder 数据传输这里要改不少东西吧）。回来看下赋值。前面那个那个判断 mIn 中的是否有读的数据，是通过 mDataPos 的位置来判断的，就是说如果 mDataPos 的位置比 mDataSize 小，说明还有数据还没读完，前面说了 parcel 每调用一次 read 接口就会自动移动 mDataPos，如果正好把 read 次数（Bp 端读）对应上 write 次数（Bn 端写），那么 mDataPos 是正好等于 mDataSize 的。后面根据 (!doReceive || needRead) 决定 <code>write_size</code> 的大小，这个后面到 kernel 里可以知道 size 的大小是否为 0 决定了是否调用 binder 驱动的读写处理函数。如果 mIn 中还有数据还没读取完，needRead 为 true， doReceive 默认是 true（默认要接收 Bn 端返回的数据），所以如果还有 Bn 端发过来的数据还没读完，本次循环在 binder 驱动中是发不出数据的。这里开始是能没有读数据的，所以能发得出来，<code>write_size</code> 大小是 mOut parcel 的 mDataSize，<code>write_buffer</code> 是 mOut 的 mData 地址。读的部分相应的取 mIn 的，这里给接收的大小也是 256，后面可以看到 Bn 端发过来也是也是 <code>binder_transatcion_data</code> 结构，所以 256 也够了。然后在 ioctl 前把 consumed 都设置成0。</p>
<p>然后就 ioctl 到 kernel 的 binder 驱动里面去了，我在 binder 驱动中看看，parcel 是怎么从 Bp 端传递到 Bn 端（或者从 Bn 返回到 Bp）的。首先是上面的 Bp 向 binder 发送 <code>BC_TRANSACTION</code> 把 <code>binder_transtion_data</code> 的地址保存到 ioctl 的参数 <code>binder_write_read</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg) </div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line">... ...</div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: {</div><div class="line">        <span class="keyword">struct</span> binder_write_read bwr; </div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) {</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (copy_from_user(&bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }  </div><div class="line">... ...</div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) { </div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) { </div><div class="line">                bwr.read_consumed = <span class="number">0</span>; </div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err; </div><div class="line">            }    </div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) { </div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &bwr.read_consumed, filp-&gt;f_flags & O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            }</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">... ...</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        ret = -EINVAL;</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    }</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有个 kernel 函数调用： <code>copy_from_user</code>，是从用户空间 copy 指定的一段内存数据到 kernel 空间（用户态（空间），kernel态（空间）有啥区别网上查吧，我也不是很清除），这样 IPCThreadState talkWithDriver 那些填写的那个 <code>binder_write_read</code> 就传递到 kernel binder 驱动中了。这里可以看得到，如果 IPCThreadState 把 wirte 或是 read 的 size 设置为 0 的话就不会处理（前面也说过）。我们先看 write， <code>write_buffer</code> 里面的数据是 IPCThreadState 用 mOut 打包的内存数据块。根据前面的分析，应该是这样的格式:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-parcel/1.png" alt=""></p>
<p>然后去 <code>binder_thread_write</code> 里面去看看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;   </div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t); </div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BC_TRANSACTION:</div><div class="line">        <span class="keyword">case</span> BC_REPLY: {</div><div class="line">            <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (copy_from_user(&tr, ptr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line">            binder_transaction(proc, thread, &tr, cmd == BC_REPLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有个 while 循环，结束条件是 ptr 指针移动 end 处，就是处理完 IPCThreadState write 进来的数据为止。循环一开始就用 <code>get_user</code> 从 ptr 指向的用户空间出一个 int32 的数据到 kernel 空间（<code>get_user</code> 和 <code>copy_from_user</code> 的区别是，一个是 copy 一个简单的变量，一个是 copy 一块内存块）。然后接着把 ptr 指针移动一个 int32 大小。这里注意下，前面 ioctl 那 <code>copy_from_user</code> 是从用户空间得到 <code>binder_write_read</code> 结构（地址在 ioctl 的参数里面），而这里从用户空间 copy 的是保存在 <code>binder_write_read</code> <code>write_buffer</code> 中的地址，也就是前面 mOut 的 mData 的地址。所以要根据前面打包的格式来读（看上面的图）。前面说了 parcel 的读和写对应。所以这里先取 cmd（是  <code>BC_TRANSACTION</code>），然后 parcel 调用 read 接口会自动移动 mDataPos ，binder 驱动里面要自己手动移动指针位置（这里再次看出，parcel 提供简单的内存读写，很灵活，也比较简单，但是同时也比较容易出错）。然后后面继续 <code>copy_from_user</code> 从用户态的 mOut 地址把 <code>binder_transation_data</code> copy 过来（顺带移动指针），然后交由 <code>binder_transation</code> 函数处理（这篇的流程其实和前面通信模型是一样的，但是本篇主要讲数据的流动）。这里先看到后面，<code>binder_transation</code> 处理完后， consumed 就被设置为相应读取的数据大小（这个 consumed 是个指针，其实就设置 <code>binder_write_read</code> 这个结构 <code>write_consumed</code> 这个变量的， <code>binder_write_read</code> 这个结构最后又会被传回用户空间去的，后面能看到）。</p>
<p>至于 <code>binder_transation</code> 中怎么传递到另一个进程中的去，去看我下一篇 binder 的内存管理篇吧，那里有详细的说明，这里不多说这些。反正最后通过 <code>binder_thread_read</code> 传递用 Bn 端的用户空间，然后借着上一篇 Bn 端的 getAndExecuteCommand 从 talkWithDriver 那的 ioctl 返回得到 Bp 端通过 kernel 发送的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::getAndExecuteCommand()</div><div class="line">{</div><div class="line">    status_t result;</div><div class="line">    int32_t cmd; </div><div class="line"></div><div class="line">    result = talkWithDriver();</div><div class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">        size_t IN = mIn.dataAvail();</div><div class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">        <span class="comment">// 这里先读 cmd</span></div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }    </div><div class="line"></div><div class="line">        result = executeCommand(cmd);</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Bn 端等待 Bp 端的时候，把自己 mIn 的 parcel 的 buffer 传递到 kernel 里面去了，所以 Bp 端发送过来的 parcel 通过 kernel 传递到 Bn 端的 mIn 中去了。<br>内存管理篇那里 <code>binder_thread_read</code> 会把 cmd 写入 mIn buffer 的第一个 int32 的地址，所以这里先读 int32 的 cmd，然后送给 executeCommand 处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        {</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ALOG_ASSERT(result == NO_ERROR,</div><div class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line">... ...</div><div class="line"></div><div class="line">            Parcel reply;</div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) {</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                <span class="keyword">const</span> status_t error = b-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">const</span> status_t error = the_context_object-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((tr.flags & TF_ONE_WAY) == <span class="number">0</span>) {</div><div class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</div><div class="line">                sendReply(reply, <span class="number">0</span>);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</div><div class="line">            }</div><div class="line"></div><div class="line">            mCallingPid = origPid;</div><div class="line">            mCallingUid = origUid;</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//======================================</span></div><div class="line"></div><div class="line">status_t Parcel::read(<span class="keyword">void</span>* outData, size_t len) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> ((mDataPos+PAD_SIZE(len)) &gt;= mDataPos && (mDataPos+PAD_SIZE(len)) &lt;= mDataSize) {</div><div class="line">        <span class="built_in">memcpy</span>(outData, mData+mDataPos, len);</div><div class="line">        mDataPos += PAD_SIZE(len);     </div><div class="line">        ALOGV(<span class="string">"read Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NOT_ENOUGH_DATA;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续看前一篇的那张通信模型的图， Bn 这里是接到的 cmd 是 kernel 发过来的 <code>BR_TRANSACTION</code>， 然后前面 Bp 把 <code>binder_transaction_data</code> 通过 Parcel 写入，这里就要通过 read 来读出来了。内存流的，直接一个强制转化就行了，read 也很简单，就是 memcpy （可以好好看看内存管理篇，kernel 里面传递 parcel data 的 buffer 的技巧很牛x）。然后这里的 Parcel buffer 是临时变量， ipcSetDataReference 设置 freeBuffer 函数怎么回事，内存管理篇都有讲，这里就不多说了。然后最后 </p>
<pre config="brush:bash;toolbar:false;">
b->transact(tr.code, buffer, &reply, tr.flags)
</pre>

<p>就把 Bp 传递过来的 parcel 传递子类实现 binder 业务的 transact 函数去处理的，顺带，把放返回值的 reply 给传过去了。</p>
<p>我们拿 AM 中的一个简单的接口来看一下（frameworks/base/core/java/android/app/ActivityManagerNative.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// ActivityManagerNativeProxy: Bp 端</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishActivity</span>(IBinder token, <span class="keyword">int</span> resultCode, Intent resultData)</div><div class="line">            <span class="keyword">throws</span> RemoteException {</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        <span class="comment">// 写入本服务接口的标志，一个字符串，一般是完整的类名 android.xx.xx</span></div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        <span class="comment">// 参数1： flat_binder_object 特殊类型</span></div><div class="line">        data.writeStrongBinder(token);</div><div class="line">        <span class="comment">// 参数2: int 类型的</span></div><div class="line">        data.writeInt(resultCode);</div><div class="line">        <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 参数3： 一个自定义类型的对象，支持 Parcelable 的</span></div><div class="line">            <span class="comment">// 在开始写一个 1，标记一下</span></div><div class="line">            data.writeInt(<span class="number">1</span>);</div><div class="line">            resultData.writeToParcel(data, <span class="number">0</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 如果传递的参数非法，标记写0</span></div><div class="line">            data.writeInt(<span class="number">0</span>);</div><div class="line">        }    </div><div class="line">        mRemote.transact(FINISH_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        <span class="keyword">boolean</span> res = reply.readInt() != <span class="number">0</span>;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> res; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//============================================</span></div><div class="line"></div><div class="line">    <span class="comment">// ActivityManagerNative： Bn 端</span></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags) </div><div class="line">            <span class="keyword">throws</span> RemoteException {       </div><div class="line">        <span class="keyword">switch</span> (code) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> FINISH_ACTIVITY_TRANSACTION: {</div><div class="line">            <span class="comment">// 先读接口标志，对比下是不是本服务的 Bp 端发过来的请求</span></div><div class="line">            data.enforceInterface(IActivityManager.descriptor);</div><div class="line">            <span class="comment">// 参数1： 特殊 flat_binder_object</span></div><div class="line">            IBinder token = data.readStrongBinder();</div><div class="line">            Intent resultData = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 参数2： int 类型</span></div><div class="line">            <span class="keyword">int</span> resultCode = data.readInt();</div><div class="line">            <span class="comment">// 参数3： Parcelable 类型自定义对象</span></div><div class="line">            <span class="comment">// 前面如果传递的参数2合法，这里读出的就是 1</span></div><div class="line">            <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) {</div><div class="line">                <span class="comment">// 把内存流的 parcel 传递给实现了 Parcelable 结构的自定义类</span></div><div class="line">                <span class="comment">// 通过数据在 Bn 端重新创建一个对象</span></div><div class="line">                resultData = Intent.CREATOR.createFromParcel(data);</div><div class="line">            }</div><div class="line">            <span class="comment">// 参数解析完毕，调用真正的业务函数实现功能</span></div><div class="line">            <span class="keyword">boolean</span> res = finishActivity(token, resultCode, resultData);</div><div class="line">            reply.writeNoException();</div><div class="line">            reply.writeInt(res ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面看代码中的注释就差不多了，顺序都是一一对应的。然后说说那个 Parcelable 这个接口。这个接口最主要就是2个函数：writeToParcel、createFromParcel 这2个，一个相当于是序列化，一个是反序列化。就是自己类自己实现了的，再复杂的对象都可以通过 Parcel 前面的那些基本类型来存储。</p>
<h2 id="大型数据">大型数据</h2>
<p>大型数据主要是通过 Parcel 的匿名共享内存（Ashmem）接口来使用的（writeBlob、readBlob），当然你也可以使用 writeInPlace 使用普通内存来传递，效率么，呵呵（还有不能超过 binder 的 1MB 大小的限制哦）。 这个话去看我的那篇专门说 ashmem 的吧。</p>
<h2 id="binder_对象">binder 对象</h2>
<p>Parcel 有一个特殊的结构叫 <code>flat_binder_object</code>。这个是专门用来传递 binder 对象的（其实这个在 ashmem 篇里发现这个还可以传递文件描述 fd，咋这只说 binder 句柄）。</p>
<p>这里我略过 Parcel 的 java 接口 和 jni 的马甲了，直接拿 native 的代码说，稍微简洁一些。</p>
<p>我还是以上面 AM 里面那个例子说。里面在 IPC 有个要传递的对象是 IBinder 类型的，通过原型篇的分析，这个就是 binder 对象了，这里说的 binder 句柄传递，就是针对这一类型的数据。这里就是调用了 Parcel 的2个接口，我们先来看看写的那个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;& val)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line">status_t flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;& binder, Parcel* out)</div><div class="line">{</div><div class="line">    flat_binder_object obj;</div><div class="line"></div><div class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    <span class="keyword">if</span> (binder != NULL) {</div><div class="line">        <span class="comment">// 区分是 Bn（localBinder） 还是 Bp（remoteBinder）</span></div><div class="line">        IBinder *local = binder-&gt;localBinder();</div><div class="line">        <span class="keyword">if</span> (!local) {</div><div class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</div><div class="line">            <span class="keyword">if</span> (proxy == NULL) {</div><div class="line">                ALOGE(<span class="string">"null proxy"</span>);</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果是 Bp 的话，则保存 Bp 的 handle 值</span></div><div class="line">            <span class="comment">// Bp 的 type 是 BINDER_TYPE_HANDLE</span></div><div class="line">            <span class="keyword">const</span> int32_t handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</div><div class="line">            obj.type = BINDER_TYPE_HANDLE;</div><div class="line">            obj.handle = handle;</div><div class="line">            obj.cookie = NULL;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 如果是 Bn 的话，直接保存 binder 对象本身</span></div><div class="line">            <span class="comment">// Bn 的 type 是 BINDER_TYPE_BINDER</span></div><div class="line">            obj.type = BINDER_TYPE_BINDER;</div><div class="line">            obj.binder = local-&gt;getWeakRefs();</div><div class="line">            obj.cookie = local;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        obj.type = BINDER_TYPE_BINDER;</div><div class="line">        obj.binder = NULL;</div><div class="line">        obj.cookie = NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 前面只是设置 flat_binder_object，这个函数才是真正写入 parcel 数据</span></div><div class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Parcel 其实还有 writeWeakBinder，但是这里只管 writeStrongBinder，而且一般也是 strong 用的多。先说说 <code>flat_binder_object</code> 这个东西，它是 kernel binder 驱动里面的一个结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This is the flattened representation of a Binder object for transfer</span></div><div class="line"><span class="comment"> * between processes.  The 'offsets' supplied as part of a binder transaction</span></div><div class="line"><span class="comment"> * contains offsets into the data where these structures occur.  The Binder</span></div><div class="line"><span class="comment"> * driver takes care of re-writing the structure type and data as it moves</span></div><div class="line"><span class="comment"> * between processes.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> flat_binder_object {</div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</div><div class="line"></div><div class="line">    <span class="comment">/* 8 bytes of data. */</span></div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* extra data associated with local object */</span></div><div class="line">    <span class="keyword">void</span>            *cookie;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个注释就已经真相了，这个玩意就是专门拿来传 binder 对象的（前面说了还有 fd），而且 offsets 就是这个东西的在传递数据中的位置，就是前面说的 parcel 中那个 mObjects 其实是个偏移来的啦。然后 binder 和 handle 是一个 union，就是说这个 binder 对象要么是 Bn（local），要么是 Bp（remote）。</p>
<p>那么我接下去看 <code>finish_flatten_binder</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内联函数 -_-||</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">static</span> status_t finish_flatten_binder(</div><div class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;& binder, <span class="keyword">const</span> flat_binder_object& flat, Parcel* out)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::writeObject(<span class="keyword">const</span> flat_binder_object& val, <span class="keyword">bool</span> nullMetaData)</div><div class="line">{</div><div class="line">    <span class="comment">// 这里得同时判断 mData 和 mObjects 够不够咧</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> enoughData = (mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> enoughObjects = mObjectsSize &lt; mObjectsCapacity;</div><div class="line">    <span class="comment">// 空间够，就可以写</span></div><div class="line">    <span class="keyword">if</span> (enoughData && enoughObjects) {</div><div class="line">restart_write:</div><div class="line">        <span class="comment">// 注意这里，flat_binder_object 是保存在 mData 里的</span></div><div class="line">        *<span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(mData+mDataPos) = val;</div><div class="line">        </div><div class="line">        <span class="comment">// Need to write meta-data?    </span></div><div class="line">        <span class="keyword">if</span> (nullMetaData || val.binder != NULL) {</div><div class="line">            <span class="comment">// 再注意这里，保存刚刚写 flat_binder_object 的开始的地址</span></div><div class="line">            <span class="comment">// 这里就能说明 mObjects 保存的是偏移了。</span></div><div class="line">            mObjects[mObjectsSize] = mDataPos;</div><div class="line">            <span class="comment">// 给 flat_binder_object 保存的 binder 对象增加引用计数</span></div><div class="line">            acquire_object(ProcessState::self(), val, <span class="keyword">this</span>);</div><div class="line">            <span class="comment">// 数据中保存的 object 数量 +1</span></div><div class="line">            mObjectsSize++;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// remember if it's a file descriptor</span></div><div class="line">        <span class="keyword">if</span> (val.type == BINDER_TYPE_FD) { </div><div class="line">            <span class="keyword">if</span> (!mAllowFds) {</div><div class="line">                <span class="keyword">return</span> FDS_NOT_ALLOWED;        </div><div class="line">            }</div><div class="line">            mHasFds = mFdsKnown = <span class="keyword">true</span>;    </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(flat_binder_object));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 空间不够就和前面一样，调整内存大小</span></div><div class="line">    <span class="keyword">if</span> (!enoughData) {</div><div class="line">        <span class="keyword">const</span> status_t err = growData(<span class="keyword">sizeof</span>(val));</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">return</span> err;</div><div class="line">    }</div><div class="line">    <span class="comment">// 这里还有可能保存 offset 的空间不够了</span></div><div class="line">    <span class="keyword">if</span> (!enoughObjects) {</div><div class="line">        size_t newSize = ((mObjectsSize+<span class="number">2</span>)*<span class="number">3</span>)/<span class="number">2</span>;</div><div class="line">        size_t* objects = (size_t*)realloc(mObjects, newSize*<span class="keyword">sizeof</span>(size_t));</div><div class="line">        <span class="keyword">if</span> (objects == NULL) <span class="keyword">return</span> NO_MEMORY;</div><div class="line">        mObjects = objects;</div><div class="line">        mObjectsCapacity = newSize;    </div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="comment">// 调整完内存后，重新回去写</span></div><div class="line">    <span class="keyword">goto</span> restart_write;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后是调用 writeObject（object 只能是 <code>flat_binder_object</code>） 来写到 parcel 中去。这里和前面的差不多，都得先判断空间够不够，但是这里还得多判断一个 mObjects 的空间够不够。不够的和前面一样调用 growData 去调整大小。这里同样多处理一个 mObjects 空间调整，这里很简单了就是 realloc 一下就行了。这里看代码就知道 <code>flat_binder_object</code> 是保存在 mData 的区域的，而且后面几句代码彻底说明了 mObjects 保存的是偏移地址。最后 finishWrite 和前面一样，把 mDataPos 移动一下。</p>
<p>这里多嘴说下 <code>acquire_object</code>，我就说我烦 android 的那个啥智能指针，也不是太智能的样子，这里还得显示的增加下引用计数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parcel::acquireObjects()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    size_t i = mObjectsSize;</div><div class="line">    uint8_t* <span class="keyword">const</span> data = mData;</div><div class="line">    size_t* <span class="keyword">const</span> objects = mObjects;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</div><div class="line">        i--;</div><div class="line">        <span class="comment">// 看到 flat_binder_object 怎么取了的没，首地址 + 偏移地址</span></div><div class="line">        <span class="keyword">const</span> flat_binder_object* flat </div><div class="line">            = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);</div><div class="line">        acquire_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> acquire_object(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> flat_binder_object& obj, <span class="keyword">const</span> <span class="keyword">void</span>* who)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (obj.type) {</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p acquiring reference on local %p"</span>, who, obj.cookie);</div><div class="line">                <span class="keyword">static_cast</span>&lt;IBinder*&gt;(obj.cookie)-&gt;incStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder)</div><div class="line">                <span class="keyword">static_cast</span>&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;incWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE: {</div><div class="line">            <span class="keyword">const</span> sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p acquiring reference on remote %p"</span>, who, b.get());</div><div class="line">                b-&gt;incStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="keyword">const</span> wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) b.get_refs()-&gt;incWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="comment">// intentionally blank -- nothing to do to acquire this, but we do</span></div><div class="line">            <span class="comment">// recognize it as a legitimate object type.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGD(<span class="string">"Invalid object type 0x%08lx"</span>, obj.type);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 parcel 中内存分配应该是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-parcel/2.png" alt=""></p>
<p>然后打包了 <code>flat_binder_object</code> 的 parcel 就传到 kernel 的 binder 驱动里面去了。驱动里面有做特殊处理的，驱动里的处理放到后面一篇说 ServiceManager 那里细说，这里只要知道驱动里面倒腾了一下就到目标进程了，然后目标进程可以使用 parcel 的读接口读到之前写的 binder 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    sp&lt;IBinder&gt; val;</div><div class="line">    unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, &val);</div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个 inline 函数是耍存在感的么 -_-||</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">static</span> status_t finish_unflatten_binder(</div><div class="line">    BpBinder* proxy, <span class="keyword">const</span> flat_binder_object& flat, <span class="keyword">const</span> Parcel& in)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line">    </div><div class="line">status_t unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> Parcel& in, sp&lt;IBinder&gt;* out)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="keyword">false</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (flat) {</div><div class="line">        <span class="keyword">switch</span> (flat-&gt;type) {</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">                <span class="comment">// Bn 本地的直接强转一下</span></div><div class="line">                *out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</div><div class="line">                <span class="keyword">return</span> finish_unflatten_binder(NULL, *flat, in);</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">                <span class="comment">// Bp 的话要通过 handle 构造一个远程的代理对象（Bp 对象）</span></div><div class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</div><div class="line">                <span class="keyword">return</span> finish_unflatten_binder(</div><div class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</div><div class="line">        }        </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> BAD_TYPE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>readStrongBinder 其实挺简单的，是本地的可以直接用，远程的那个 getStrongProxyForHandle 也是放到后面 ServiceManager 再细说。到这里目标进程就收到原始进程传递过来的 binder 对象了，然后可以转化为 binder 的 interface 调用对应的 IPC 接口。</p>
<p>然后最后看下清理的情况，由于 binder 实现的接口中，Parcel 基本都是局部变量，所以 IPC 调用一结束，就会调用析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">Parcel::~Parcel()</div><div class="line">{</div><div class="line">    freeDataNoInit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::freeDataNoInit()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">        <span class="comment">//ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());</span></div><div class="line">        mOwner(<span class="keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这里看下面这个分支，mOwner 是 IPC 传递参数的 parcel 专用的</span></div><div class="line">        <span class="comment">// 减少引用计数，还得手动减少 -_-||</span></div><div class="line">        releaseObjects();</div><div class="line">        <span class="comment">// 直接 free mData 和 mObjects </span></div><div class="line">        <span class="comment">// 申请的是 malloc，释放就是 free 咯</span></div><div class="line">        <span class="keyword">if</span> (mData) <span class="built_in">free</span>(mData);</div><div class="line">        <span class="keyword">if</span> (mObjects) <span class="built_in">free</span>(mObjects);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::releaseObjects()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    size_t i = mObjectsSize;</div><div class="line">    uint8_t* <span class="keyword">const</span> data = mData;</div><div class="line">    size_t* <span class="keyword">const</span> objects = mObjects;</div><div class="line">    <span class="comment">// 这里和 acquireObjects 很像呐</span></div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</div><div class="line">        i--;</div><div class="line">        <span class="keyword">const</span> flat_binder_object* flat</div><div class="line">            = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);</div><div class="line">        release_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> release_object(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> flat_binder_object& obj, <span class="keyword">const</span> <span class="keyword">void</span>* who)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (obj.type) {</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p releasing reference on local %p"</span>, who, obj.cookie);</div><div class="line">                <span class="keyword">static_cast</span>&lt;IBinder*&gt;(obj.cookie)-&gt;decStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder)</div><div class="line">                <span class="keyword">static_cast</span>&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;decWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE: {</div><div class="line">            <span class="keyword">const</span> sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p releasing reference on remote %p"</span>, who, b.get());</div><div class="line">                b-&gt;decStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="keyword">const</span> wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) b.get_refs()-&gt;decWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="keyword">if</span> (obj.cookie != (<span class="keyword">void</span>*)<span class="number">0</span>) close(obj.handle);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGE(<span class="string">"Invalid object type 0x%08lx"</span>, obj.type);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里的函数都不复杂，我直接贴到底了。其实就是 free 掉之前 malloc 的 mData 和 mObjects，还有就是前面手动增加了的引用计数，这里得再手动减少（这玩意就是麻烦）。</p>
<p>其实传递 binder 对象，最关键的地方其实在 kernel 的 binder 驱动里面，但是鉴于这篇已经够长了，而且这个和 ServiceManager 关系也挺密切的，所以决定把这块地方放到 ServiceManager 那篇去。</p>
<p>Parcel 是 android binder 通信中扮演着数据打包、解包的角色，是比较重要的一个东西。它的内存结构其实很简单，以后自己用的时候要注意下遵守规则（读、写顺序一致）。然后它可以传递一些小数据、也还可以传一些二进制流，对于大型数据提供匿名共享内存（Ashmem）的支持，它还有一个很特殊的功能，就是传递 binder 对象，保证了 binder IPC 通信的正常使用。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%5BAshmem%5D/</loc>
    <lastmod>2015-03-31T06:33:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——匿名共享内存（Ashmem）</title>
        <pubTime>2015-01-28T13:00:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>前面分析了 binder 中用来打包、传递数据的 Parcel，一般用来传递 IPC 中的小型参数和返回值。binder 目前每个进程 mmap 接收数据的内存是 1M，所以就算你不考虑效率问题用 Parcel 来传，也无法传过去。只要超过 1M 就会报错（binder 无法分配接收空间）。所以 android 里面有一个专门用来在 IPC 中传递大型数据的东西—— Ashmem（Anonymous Shared Memroy）。照例把相关代码的位置说一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># MemroyFile 是 ashmem java 层接口</span></div><div class="line">frameworks/base/core/java/os/Parcel.java</div><div class="line">frameworks/base/core/java/os/Parcelable.java</div><div class="line">frameworks/base/core/java/os/ParcelFileDescriptor.java</div><div class="line">frameworks/base/core/java/os/MemoryFile.java</div><div class="line"></div><div class="line"><span class="comment"># jni 相关</span></div><div class="line">frameworks/base/core/jni/android_os_Parcel.h</div><div class="line">frameworks/base/core/jni/android_os_MemoryFile.cpp</div><div class="line">frameworks/base/core/jni/android_os_Parcel.cpp</div><div class="line">libnativehelper/JNIHelp.cpp</div><div class="line"></div><div class="line"><span class="comment"># 封装了 ashmem 驱动的 c 接口</span></div><div class="line">system/core/include/cutils/ashmem.h</div><div class="line">system/core/libcutils/ashmem-dev.c</div><div class="line"></div><div class="line"><span class="comment"># MemoryXx 是 ashmem 的 native 接口</span></div><div class="line">frameworks/native/include/binder/Parcel.h</div><div class="line">frameworks/native/include/binder/IMemory.h</div><div class="line">frameworks/native/include/binder/MemoryHeapBase.h</div><div class="line">frameworks/native/include/binder/MemoryBase.h</div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line">frameworks/native/libs/binder/Memory.cpp</div><div class="line">frameworks/native/libs/binder/MemoryHeapBase.cpp</div><div class="line">frameworks/native/libs/binder/MemoryBase.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"><span class="comment"># kernel ashmem 驱动</span></div><div class="line">kernel/include/linux/ashmem.h</div><div class="line">kernel/mm/ashmem.c</div><div class="line"></div></pre></td></tr></table></figure>

<p>（这和 Parcel 篇的基本一样么 -_-||）</p>
<h2 id="原理概述">原理概述</h2>
<p>ashmem 并像 binder 是 android 重新自己搞的一套东西，而是利用了 linux 的 tmpfs 文件系统。关于 tmpfs 我目前还不算很了解，可以先看下这里的2篇，有个基本的了解：</p>
<p><a href="http://blog.chinaunix.net/uid-20779720-id-3078267.html" title="Linux tmpfs " target="_blank" rel="external">Linux tmpfs </a><br><a href="http://blog.csdn.net/dog250/article/details/5303709" title="linux共享内存的设计" target="_blank" rel="external">linux共享内存的设计</a></p>
<p>那么大致能够知道，tmpfs 是一种可以基于 ram 或是 swap 的高速文件系统，然后可以拿它来实现不同进程间的内存共享。</p>
<p>然后大致思路和流程是：</p>
<ul>
<li>Proc A 通过 tmpfs 创建一块共享区域，得到这块区域的 fd（文件描述符）</li>
<li>Proc A 在 fd 上 mmap 一片内存区域到本进程用于共享数据</li>
<li>Proc A 通过某种方法把 fd 倒腾给 Proc B</li>
<li>Proc B 在接到的 fd 上同样 mmap 相同的区域到本进程</li>
<li>然后 A、B 在 mmap 到本进程中的内存中读、写，对方都能看到了</li>
</ul>
<p>其实核心点就是创建一块共享区域，然后2个进程同时把这片区域 mmap 到本进程，然后读写就像本进程的内存一样。这里要解释下第3步，为什么要倒腾 fd，因为在 linux 中 fd 只是对本进程是唯一的，在 Proc A 中打开一个文件得到一个 fd，但是把这个打开的 fd 直接放到 Proc B 中，Proc B 是无法直接使用的。但是文件是唯一的，就是说一个文件（file）可以被打开多次，每打开一次就有一个 fd（文件描述符），所以对于同一个文件来说，需要某种转化，把 Proc A 中的 fd 转化成 Proc B 中的 fd。这样 Proc B 才能通过 fd mmap 同样的共享内存文件（额，其实这里相关知识我也还没了解，瞎扯一下）。 </p>
<h2 id="java_层接口">java 层接口</h2>
<p>java 层的接口要拿 2.3 的来说，因为从 4.1（具体哪个版本我不好说，反正我手上只有 4.1 之后的）之后 java 层的 MemroyFile 应该就无法正常使用了，搜索代码发现，除了 test 有 MemroyFile 其它地方就去掉了。具体原因后面分析代码就知道了。</p>
<p>咋先来点感性的认识（MemroyFile.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> FileDescriptor mFD;        <span class="comment">// ashmem file descriptor</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mAddress;   <span class="comment">// address of ashmem memory</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLength;    <span class="comment">// total length of our ashmem region</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mAllowPurging = <span class="keyword">false</span>;  <span class="comment">// true if our ashmem region is unpinned</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mOwnsRegion;  <span class="comment">// false if this is a ref to an existing ashmem region</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Allocates a new ashmem region. The region is initially not purgable.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param name optional name for the file (can be null).</span></div><div class="line"><span class="comment"> * @param length of the memory file in bytes.</span></div><div class="line"><span class="comment"> * @throws IOException if the memory file could not be created.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="title">MemoryFile</span>(String name, <span class="keyword">int</span> length) <span class="keyword">throws</span> IOException {</div><div class="line">    mLength = length;</div><div class="line">    mFD = native_open(name, length);</div><div class="line">    mAddress = native_mmap(mFD, length, PROT_READ | PROT_WRITE);</div><div class="line">    mOwnsRegion = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>MemroyFile 还是比较简单的，成员变量也比较少，上面基本上就是所有的变量了。FileDescriptor 这个是 java 本身的对象，应该是 natvie fd 的封装吧。后面的地址、长度不说了。后面2个 boolean， mAllowPurging 表示这块 ashmem 是否允许被回收。 ashmem 在驱动那向 kernel 注册了一个内存回收算法，当 kernel 进行内存扫描的时候会调用这个回收算法，当标记了可以回收的时候，会把标记的内存给回收掉。这个设计的目的估计是想更高效的使用内存（能够标记一段共享内存不用了），但是后面你会发现这个东西目前还是个摆设。mOwnsRegion 表示只有创建者才能标记这块共享内存被回收。</p>
<p>MemroyFile 的使用方法，就只有构造函数一个。而且默认 mAllowPurging 是 false。这个构造函数是创建共享内存的，所以 mOwnsRegion 是 true。回想下前面原理，说的 Proc A 首先要创建一块共享内存，然后再 mmap 到本进程。这里正好2个 jni：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jobject android_os_MemoryFile_open(JNIEnv* env, jobject clazz, jstring name, jint length)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* namestr = (name ? env-&gt;GetStringUTFChars(name, NULL) : NULL);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> result = ashmem_create_region(namestr, length);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name)</div><div class="line">        env-&gt;ReleaseStringUTFChars(name, namestr);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem_create_region failed"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> jniCreateFileDescriptor(env, result);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 jni 很简单了，前面的 MemroyFile 传了要创建的共享内存的名字以及大小。这里主要是调用 libcutils 里面的 ashmem-dev.c 的接口去创建共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ASHMEM_DEVICE   "/dev/ashmem"</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * ashmem_create_region - creates a new ashmem region and returns the file</span></div><div class="line"><span class="comment"> * descriptor, or &lt;0 on error</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * `name' is an optional label to give the region (visible in /proc/pid/maps)</span></div><div class="line"><span class="comment"> * `size' is the size of the region, in page-aligned bytes</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> ashmem_create_region(<span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd, ret;</div><div class="line"></div><div class="line">    fd = open(ASHMEM_DEVICE, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> fd;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name) {</div><div class="line">        <span class="keyword">char</span> buf[ASHMEM_NAME_LEN];</div><div class="line"></div><div class="line">        strlcpy(buf, name, <span class="keyword">sizeof</span>(buf));</div><div class="line">        ret = ioctl(fd, ASHMEM_SET_NAME, buf);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> error;</div><div class="line">    }</div><div class="line"></div><div class="line">    ret = ioctl(fd, ASHMEM_SET_SIZE, size);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> error;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line"></div><div class="line">error:</div><div class="line">    close(fd);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>熟悉 linux 环境编程的也没啥要说的， open 打开设备。/dev/ashmem 在前面有篇文章说到，在 init.rc 里面和 /dev/binder 是系统 init 进程创建好的设备节点（虚拟机设备）。然后 ioctl 去设置名字和大小。这里就要走到 kernel 的驱动里面去了，这些后面再说。然后返回 fd。然后回到 jni 里面，通过 fd 构造出 java 的 FileDescriptor（JNIHelp.cpp）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">jobject jniCreateFileDescriptor(C_JNIEnv* env, <span class="keyword">int</span> fd) {</div><div class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</div><div class="line">    <span class="keyword">static</span> jmethodID ctor = e-&gt;GetMethodID(JniConstants::fileDescriptorClass, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</div><div class="line">    jobject fileDescriptor = (*env)-&gt;NewObject(e, JniConstants::fileDescriptorClass, ctor);</div><div class="line">    jniSetFileDescriptorOfFD(env, fileDescriptor, fd);</div><div class="line">    <span class="keyword">return</span> fileDescriptor;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> jniGetFDFromFileDescriptor(C_JNIEnv* env, jobject fileDescriptor) {</div><div class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</div><div class="line">    <span class="keyword">static</span> jfieldID fid = e-&gt;GetFieldID(JniConstants::fileDescriptorClass, <span class="string">"descriptor"</span>, <span class="string">"I"</span>);</div><div class="line">    <span class="keyword">return</span> (*env)-&gt;GetIntField(e, fileDescriptor, fid);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> jniSetFileDescriptorOfFD(C_JNIEnv* env, jobject fileDescriptor, <span class="keyword">int</span> value) {</div><div class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</div><div class="line">    <span class="keyword">static</span> jfieldID fid = e-&gt;GetFieldID(JniConstants::fileDescriptorClass, <span class="string">"descriptor"</span>, <span class="string">"I"</span>);</div><div class="line">    (*env)-&gt;SetIntField(e, fileDescriptor, fid, value);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就能看得出，FileDescriptor 就是把 fd 封装了一下，核心还是这个 int 值啊（通过反射，用 fd 设置了一下 FileDescriptor 的 fileDescriptor 这个变量）。然后看下 mmap：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_mmap(JNIEnv* env, jobject clazz, jobject fileDescriptor,</div><div class="line">        jint length, jint prot)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    jint result = (jint)mmap(NULL, length, prot, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!result)</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"mmap failed"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个更简单，通过 FileDescriptor 得到 fd，直接系统 mmap 。这里 mmap 也是要进到 kernel 的驱动里面的。稍微注意下， port 是 <code>PORT_READ | PORT_WRITE</code> 读写， flag 是 <code>MAP_SHARED</code>，就说明这是专为共享设置的。</p>
<p>Proc A 算是把共享内存创建好了也 mmap 到本进程，现在就要把 fd 倒腾给 Proc B。现在我们假设 Proc A 是 Bn 端，Proc B 是 Bp 端。然后来看看 MemroyFile 的一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Gets a ParcelFileDescriptor for the memory file. See {@link #getFileDescriptor()}</span></div><div class="line"><span class="comment"> * for caveats. This must be here to allow classes outside &lt;code&gt;android.os&lt;/code&lt; to</span></div><div class="line"><span class="comment"> * make ParcelFileDescriptors from MemoryFiles, as</span></div><div class="line"><span class="comment"> * {@link ParcelFileDescriptor#ParcelFileDescriptor(FileDescriptor)} is package private.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @return The file descriptor owned by this memory file object.</span></div><div class="line"><span class="comment"> *         The file descriptor is not duplicated.</span></div><div class="line"><span class="comment"> * @throws IOException If the memory file has been closed.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @hide</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> ParcelFileDescriptor <span class="title">getParcelFileDescriptor</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    FileDescriptor fd = getFileDescriptor();</div><div class="line">    <span class="keyword">return</span> fd != <span class="keyword">null</span> ? <span class="keyword">new</span> ParcelFileDescriptor(fd) : <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ParcelFileDescriptor，看名字你是不是明白了什么咧，能够 Parcelable 的 fd，这个就是让你拿来用 binder 传给 Proc B 的啊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*package */</span>ParcelFileDescriptor(FileDescriptor descriptor) {</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">if</span> (descriptor == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"descriptor must not be null"</span>);</div><div class="line">    }</div><div class="line">    mFileDescriptor = descriptor;</div><div class="line">    mParcelDescriptor = <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * {@inheritDoc}</span></div><div class="line"><span class="comment"> * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,</span></div><div class="line"><span class="comment"> * the file descriptor will be closed after a copy is written to the Parcel.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span>(Parcel out, <span class="keyword">int</span> flags) {</div><div class="line">    out.writeFileDescriptor(mFileDescriptor);</div><div class="line">    <span class="keyword">if</span> ((flags&PARCELABLE_WRITE_RETURN_VALUE) != <span class="number">0</span> && !mClosed) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            close();</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            <span class="comment">// Empty</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;ParcelFileDescriptor&gt; CREATOR</div><div class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;ParcelFileDescriptor&gt;() {</div><div class="line">    <span class="keyword">public</span> ParcelFileDescriptor <span class="title">createFromParcel</span>(Parcel in) {</div><div class="line">        <span class="keyword">return</span> in.readFileDescriptor();</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> ParcelFileDescriptor[] <span class="title">newArray</span>(<span class="keyword">int</span> size) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelFileDescriptor[size];</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>ParcelFileDescriptor 其实挺简单，主要是看它的 Paracelable 接口。又是调用 Parcel 的对应接口（java jni native 放一起了，麻烦，而且下面是 2.3 的代码，4.4 的不一样了，基本上好像太能配合 MemroyFile 使用了）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java ================================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Write a FileDescriptor into the parcel at the current dataPosition(),</span></div><div class="line"><span class="comment">     * growing dataCapacity() if needed.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * &lt;p class="caution"&gt;The file descriptor will not be closed, which may</span></div><div class="line"><span class="comment">     * result in file descriptor leaks when objects are returned from Binder</span></div><div class="line"><span class="comment">     * calls.  Use {@link ParcelFileDescriptor#writeToParcel} instead, which</span></div><div class="line"><span class="comment">     * accepts contextual flags and will close the original file descriptor</span></div><div class="line"><span class="comment">     * if {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set.&lt;/p&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> final native <span class="keyword">void</span> writeFileDescriptor(FileDescriptor val);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Read a FileDescriptor from the parcel at the current dataPosition().</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> final ParcelFileDescriptor readFileDescriptor() {</div><div class="line">        FileDescriptor fd = internalReadFileDescriptor();</div><div class="line">        <span class="keyword">return</span> fd != null ? <span class="keyword">new</span> ParcelFileDescriptor(fd) : null;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// jni ================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Parcel_writeFileDescriptor(JNIEnv* env, jobject clazz, jobject object)</div><div class="line">{</div><div class="line">    Parcel* parcel = parcelForJavaObject(env, clazz);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) {</div><div class="line">        <span class="keyword">const</span> status_t err = parcel-&gt;writeDupFileDescriptor(</div><div class="line">                env-&gt;GetIntField(object, gFileDescriptorOffsets.mDescriptor));</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">            jniThrowException(env, <span class="string">"java/lang/OutOfMemoryError"</span>, NULL);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个在 jni 注册那里是叫 internalReadFileDescriptor -_-||</span></div><div class="line"><span class="keyword">static</span> jobject android_os_Parcel_readFileDescriptor(JNIEnv* env, jobject clazz)</div><div class="line">{</div><div class="line">    Parcel* parcel = parcelForJavaObject(env, clazz);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) {</div><div class="line">        <span class="keyword">int</span> fd = parcel-&gt;readFileDescriptor();</div><div class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> NULL;</div><div class="line">        fd = dup(fd);</div><div class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> NULL;</div><div class="line">        jobject object = env-&gt;NewObject(</div><div class="line">                gFileDescriptorOffsets.mClass, gFileDescriptorOffsets.mConstructor);</div><div class="line">        <span class="keyword">if</span> (object != NULL) {</div><div class="line">            <span class="comment">//LOGI("Created new FileDescriptor %p with fd %d\n", object, fd);</span></div><div class="line">            env-&gt;SetIntField(object, gFileDescriptorOffsets.mDescriptor, fd);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> object;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// native ================================</span></div><div class="line"></div><div class="line">status_t Parcel::writeDupFileDescriptor(<span class="keyword">int</span> fd)</div><div class="line">{</div><div class="line">    flat_binder_object obj;</div><div class="line">    obj.type = BINDER_TYPE_FD;</div><div class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    obj.handle = dup(fd);</div><div class="line">    obj.cookie = (<span class="keyword">void</span>*)<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> writeObject(obj, <span class="keyword">true</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> Parcel::readFileDescriptor() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">const</span> flat_binder_object* flat = readObject(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">if</span> (flat) {</div><div class="line">        <span class="keyword">switch</span> (flat-&gt;type) {</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_FD:           </div><div class="line">                <span class="comment">//LOGI("Returning file descriptor %ld from parcel %p\n", flat-&gt;handle, this);</span></div><div class="line">                <span class="keyword">return</span> flat-&gt;handle;</div><div class="line">        }        </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> BAD_TYPE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后，是到 Parcel ，通过 <code>flat_binder_object</code> 来传递的。回想下前面几篇的内容，Parcel 传递 <code>flat_binder_object</code> 到 binder 驱动的时候，有好几种类型，当时是不是有一种 <code>BINDER_TYPE_FD</code> 类型被选择性的无视了，现在知道这个 FD 是专门拿来倒腾 fd 用的了吧。这里 writeDupFileDescriptor 用 dup 复制了一个 fd 封装在 <code>flat_binder_object</code> 里面，然后 kernel 那里倒腾后面再说。反正 binder 传到 Proc B 那边，通过 Parcelable 的 CREATEOR 调用到 readFileDescriptor 会把 <code>flat_binder_object</code> 读出来，然后这里的 fd 就是经过倒腾的，是 Proc B 进程能够用的了。</p>
<p>Proc B 拿到 fd 后就可以 mmap Proc A 创建的共享内存了（还是创建 MemroyFile）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Creates a reference to an existing memory file. Changes to the original file</span></div><div class="line"><span class="comment"> * will be available through this reference.</span></div><div class="line"><span class="comment"> * Calls to {@link #allowPurging(boolean)} on the returned MemoryFile will fail.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param fd File descriptor for an existing memory file, as returned by</span></div><div class="line"><span class="comment"> *        {@link #getFileDescriptor()}. This file descriptor will be closed</span></div><div class="line"><span class="comment"> *        by {@link #close()}.</span></div><div class="line"><span class="comment"> * @param length Length of the memory file in bytes.</span></div><div class="line"><span class="comment"> * @param mode File mode. Currently only "r" for read-only access is supported.</span></div><div class="line"><span class="comment"> * @throws NullPointerException if &lt;code&gt;fd&lt;/code&gt; is null.</span></div><div class="line"><span class="comment"> * @throws IOException If &lt;code&gt;fd&lt;/code&gt; does not refer to an existing memory file,</span></div><div class="line"><span class="comment"> *         or if the file mode of the existing memory file is more restrictive</span></div><div class="line"><span class="comment"> *         than &lt;code&gt;mode&lt;/code&gt;.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @hide</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="title">MemoryFile</span>(FileDescriptor fd, <span class="keyword">int</span> length, String mode) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"File descriptor is null."</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!isMemoryFile(fd)) {       </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not a memory file."</span>);</div><div class="line">    }</div><div class="line">    mLength = length;</div><div class="line">    mFD = fd;</div><div class="line">    mAddress = native_mmap(mFD, length, modeToProt(mode));</div><div class="line">    mOwnsRegion = <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个就是 Proc A 那里省去了 open 的操作（当然，因为有现成的 fd 了）。Proc B 也把共享内存文件 mmap 到本进程后，A、B 就可以通过 MemroyFile 的 read、write 接口读写了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java ================================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Reads bytes from the memory file.</span></div><div class="line"><span class="comment">     * Will throw an IOException if the file has been purged.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param buffer byte array to read bytes into.</span></div><div class="line"><span class="comment">     * @param srcOffset offset into the memory file to read from.</span></div><div class="line"><span class="comment">     * @param destOffset offset into the byte array buffer to read into.</span></div><div class="line"><span class="comment">     * @param count number of bytes to read.</span></div><div class="line"><span class="comment">     * @return number of bytes read.</span></div><div class="line"><span class="comment">     * @throws IOException if the memory file has been purged or deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> readBytes(byte[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count) </div><div class="line">            throws IOException {           </div><div class="line">        <span class="keyword">if</span> (isDeactivated()) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can't read from deactivated memory file."</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (destOffset &lt; <span class="number">0</span> || destOffset &gt; buffer.length || count &lt; <span class="number">0</span></div><div class="line">                || count &gt; buffer.length - destOffset</div><div class="line">                || srcOffset &lt; <span class="number">0</span> || srcOffset &gt; mLength</div><div class="line">                || count &gt; mLength - srcOffset) { </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> native_read(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Write bytes to the memory file.</span></div><div class="line"><span class="comment">     * Will throw an IOException if the file has been purged.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param buffer byte array to write bytes from.</span></div><div class="line"><span class="comment">     * @param srcOffset offset into the byte array buffer to write from.</span></div><div class="line"><span class="comment">     * @param destOffset offset  into the memory file to write to.</span></div><div class="line"><span class="comment">     * @param count number of bytes to write.</span></div><div class="line"><span class="comment">     * @throws IOException if the memory file has been purged or deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> writeBytes(byte[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count)</div><div class="line">            throws IOException {           </div><div class="line">        <span class="keyword">if</span> (isDeactivated()) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can't write to deactivated memory file."</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (srcOffset &lt; <span class="number">0</span> || srcOffset &gt; buffer.length || count &lt; <span class="number">0</span></div><div class="line">                || count &gt; buffer.length - srcOffset</div><div class="line">                || destOffset &lt; <span class="number">0</span> || destOffset &gt; mLength</div><div class="line">                || count &gt; mLength - destOffset) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">        }</div><div class="line">        native_write(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// jni ================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_read(JNIEnv* env, jobject clazz,</div><div class="line">        jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset,</div><div class="line">        jint count, jboolean unpinned)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    <span class="keyword">if</span> (unpinned && ashmem_pin_region(fd, <span class="number">0</span>, <span class="number">0</span>) == ASHMEM_WAS_PURGED) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem region was purged"</span>);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    env-&gt;SetByteArrayRegion(buffer, destOffset, count, (<span class="keyword">const</span> jbyte *)address + srcOffset);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (unpinned) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_write(JNIEnv* env, jobject clazz,</div><div class="line">        jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset,</div><div class="line">        jint count, jboolean unpinned)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    <span class="keyword">if</span> (unpinned && ashmem_pin_region(fd, <span class="number">0</span>, <span class="number">0</span>) == ASHMEM_WAS_PURGED) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem region was purged"</span>);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    env-&gt;GetByteArrayRegion(buffer, srcOffset, count, (jbyte *)address + destOffset);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (unpinned) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>jni 里面，除去那个 unpinned 不看（mAllowPurging 默认是 false），read 和 write 很简单，就是单纯的从 mAddress（mmap 到本进程的地址）读或写数据（数据都是二进制的，至于怎么用，那是上层业务的事情了）。就算手动设置了 mAllowPurging（2.3 的源码系统里面也没主动设置的地方），<code>ashmem_pin_region</code> 的范围都是 0，在 kernel 驱动中， 0 代表整块区域，所以就算设置了，也暂时没起到分块使用的作用。所以这些就忽略这些东西（主要是我也不太懂 -_-||）。</p>
<p>是用完之后就可以调用 close 接口，先 munmap 内存映射，然后再关掉共享内存文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java ================================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Closes the memory file. If there are no other open references to the memory</span></div><div class="line"><span class="comment">     * file, it will be deleted.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> close() {</div><div class="line">        deactivate();</div><div class="line">        <span class="keyword">if</span> (!isClosed()) {</div><div class="line">            native_close(mFD);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Unmaps the memory file from the process's memory space, but does not close it.</span></div><div class="line"><span class="comment">     * After this method has been called, read and write operations through this object</span></div><div class="line"><span class="comment">     * will fail, but {@link #getFileDescriptor()} will still return a valid file descriptor.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @hide</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> deactivate() {</div><div class="line">        <span class="keyword">if</span> (!isDeactivated()) {        </div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                native_munmap(mAddress, mLength);</div><div class="line">                mAddress = <span class="number">0</span>;</div><div class="line">            } <span class="keyword">catch</span> (IOException ex) {     </div><div class="line">                Log.e(TAG, ex.toString());     </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Checks whether the memory file has been deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> boolean isDeactivated() {</div><div class="line">        <span class="keyword">return</span> mAddress == <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Checks whether the memory file has been closed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> boolean isClosed() {</div><div class="line">        <span class="keyword">return</span> !mFD.valid();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// jni ================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_mmap(JNIEnv* env, jobject clazz, jobject fileDescriptor,</div><div class="line">        jint length, jint prot)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    jint result = (jint)mmap(NULL, length, prot, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!result)</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"mmap failed"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line">    </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_MemoryFile_munmap(JNIEnv* env, jobject clazz, jint addr, jint length)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> result = munmap((<span class="keyword">void</span> *)addr, length);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"munmap failed"</span>);</div><div class="line">}</div><div class="line">            </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_MemoryFile_close(JNIEnv* env, jobject clazz, jobject fileDescriptor)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        jniSetFileDescriptorOfFD(env, fileDescriptor, -<span class="number">1</span>);</div><div class="line">        close(fd);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>jni 里面直接就是系统调用了。open 了就要 close，mmap 了就要 munmap， 没啥好说的。前面说为什么 4.1 之后 java 的 MemroyFile 应该就没法用了呢。仔细看下上面，我贴的几个接口，是 hide 的有：</p>
<pre config="brush:bash;toolbar:false;">
public MemoryFile(FileDescriptor fd, int length, String mode) 
public ParcelFileDescriptor getParcelFileDescriptor()
</pre>

<p>这普通应用正常情况下，根本就没办法用 MemroyFile。所以后面直接把这几个 hide 接口给干掉了。所以我感觉 android 在 java 上不想普通应用直接使用 ashmem，因为很多东西是系统帮你使用了 ashmem，例如传递稍微大一点的 Bitmap。可能 android 觉得在该使用 ashmem 的地方，系统帮你弄好了，你就不要瞎操心了。</p>
<h2 id="native_层接口">native 层接口</h2>
<p>java 层的 MemroyFile 基本是残废的，但是 native 层的接口可是齐全的。native 层的 android 搞了2个：</p>
<ul>
<li><strong>MemroyHeapBase</strong>： 这个类代表一块共享内存区域。</li>
<li><strong>MemroyBase</strong>： 这个是上面一块共享内存区域中的一段，就是说 native 层中是支持一段、一段的使用的（不过大多时候是把上面一块就当成一块用 -_-||）。</li>
<li><strong>IMemory</strong>： binder 接口。</li>
</ul>
<p>流程也是和原理一样的，先是 Proc A 创建一块共享内存区域（创建一个 MemroyHeapBase 对象）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, <span class="keyword">char</span> <span class="keyword">const</span> * name)</div><div class="line">    : mFD(-<span class="number">1</span>), mSize(<span class="number">0</span>), mBase(MAP_FAILED), mFlags(flags),</div><div class="line">      mDevice(<span class="number">0</span>), mNeedUnmap(<span class="keyword">false</span>), mOffset(<span class="number">0</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> size_t pagesize = getpagesize();</div><div class="line">    <span class="comment">// 页面字节对齐，native 层的就是讲究效率</span></div><div class="line">    size = ((size + pagesize-<span class="number">1</span>) & ~(pagesize-<span class="number">1</span>));</div><div class="line">    <span class="keyword">int</span> fd = ashmem_create_region(name == NULL ? <span class="string">"MemoryHeapBase"</span> : name, size);</div><div class="line">    ALOGE_IF(fd&lt;<span class="number">0</span>, <span class="string">"error creating ashmem region: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (mapfd(fd, size) == NO_ERROR) {</div><div class="line">            <span class="keyword">if</span> (flags & READ_ONLY) {       </div><div class="line">                ashmem_set_prot_region(fd, PROT_READ);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>底层的接口和 jni 的的一样的，创建也是调用 libcutils 的 ashmem-dev.c 相关接口。然后 mapfd 是 mmap 内存到本进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">status_t MemoryHeapBase::mapfd(<span class="keyword">int</span> fd, size_t size, uint32_t offset)</div><div class="line">{</div><div class="line">    <span class="comment">// 如果不指定大小，则尝试自动分配，不过一般使用者都会指定大小的</span></div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</div><div class="line">        <span class="comment">// try to figure out the size automatically</span></div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS</span></div><div class="line">        <span class="comment">// first try the PMEM ioctl    </span></div><div class="line">        pmem_region reg;</div><div class="line">        <span class="keyword">int</span> err = ioctl(fd, PMEM_GET_TOTAL_SIZE, ®);</div><div class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">            size = reg.len;</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) { <span class="comment">// try fstat  </span></div><div class="line">            <span class="keyword">struct</span> stat sb;</div><div class="line">            <span class="keyword">if</span> (fstat(fd, &sb) == <span class="number">0</span>)       </div><div class="line">                size = sb.st_size;             </div><div class="line">        }</div><div class="line">        <span class="comment">// if it didn't work, let mmap() fail.</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 一般也不会指定 DONT_MAP_LOCALLY 这个标志，这个标志就不会 mmap 内存了</span></div><div class="line">    <span class="keyword">if</span> ((mFlags & DONT_MAP_LOCALLY) == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">void</span>* base = (uint8_t*)mmap(<span class="number">0</span>, size, </div><div class="line">                PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);</div><div class="line">        <span class="keyword">if</span> (base == MAP_FAILED) {      </div><div class="line">            ALOGE(<span class="string">"mmap(fd=%d, size=%u) failed (%s)"</span>,</div><div class="line">                    fd, uint32_t(size), strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            <span class="keyword">return</span> -errno;</div><div class="line">        }</div><div class="line">        <span class="comment">//ALOGD("mmap(fd=%d, base=%p, size=%lu)", fd, base, size);</span></div><div class="line">        mBase = base;</div><div class="line">        mNeedUnmap = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span>  {</div><div class="line">        mBase = <span class="number">0</span>; <span class="comment">// not MAP_FAILED</span></div><div class="line">        mNeedUnmap = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    mFD = fd;</div><div class="line">    mSize = size;</div><div class="line">    mOffset = offset;</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数正常情况下，排除那几个特殊标志，就是调用了系统接口 mmap，然后把 fd，映射得到的地址，大小，偏移保存了一下。这下 Proc A 的共享内存区域就创建好了。不过前面说了， native 层的接口，真正使用的是 MemroyBase，这个可以从 MemroyHeapBase 中指定一段区域来使用，这里我们考虑把 MemroyHeapBase 当成一整块来使用。MemroyXx 都实现了 binder 相关的接口（忘记了的，回去看第一篇原理，其实封装搞多了我也是醉了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我把相关代码贴全点，帮大家回想起 binder 相关的接口</span></div><div class="line"><span class="comment">// IMemroy ================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> BnMemoryHeap : <span class="keyword">public</span> BnInterface&lt;IMemoryHeap&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact( </div><div class="line">            uint32_t code,</div><div class="line">            <span class="keyword">const</span> Parcel& data,</div><div class="line">            Parcel* reply,</div><div class="line">            uint32_t flags = <span class="number">0</span>); </div><div class="line">        </div><div class="line">    BnMemoryHeap();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~BnMemoryHeap();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// MemroyHeapBase =========================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> MemoryHeapBase : <span class="keyword">public</span> <span class="keyword">virtual</span> BnMemoryHeap</div><div class="line">{</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// MemroyBase =============================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> MemoryBase : <span class="keyword">public</span> BnMemory </div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MemoryBase(<span class="keyword">const</span> sp&lt;IMemoryHeap&gt;& heap, ssize_t offset, size_t size);</div><div class="line">    <span class="keyword">virtual</span> ~MemoryBase();</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(ssize_t* offset, size_t* size) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    size_t getSize() <span class="keyword">const</span> { <span class="keyword">return</span> mSize; }</div><div class="line">    ssize_t getOffset() <span class="keyword">const</span> { <span class="keyword">return</span> mOffset; }</div><div class="line">    <span class="keyword">const</span> sp&lt;IMemoryHeap&gt;& getHeap() <span class="keyword">const</span> { <span class="keyword">return</span> mHeap; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    size_t          mSize;</div><div class="line">    ssize_t         mOffset;</div><div class="line">    sp&lt;IMemoryHeap&gt; mHeap;</div><div class="line">};</div><div class="line"></div><div class="line">MemoryBase::MemoryBase(<span class="keyword">const</span> sp&lt;IMemoryHeap&gt;& heap,</div><div class="line">        ssize_t offset, size_t size)</div><div class="line">    : mSize(size), mOffset(offset), mHeap(heap)</div><div class="line">{</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以说，举个例子说，Proc A 中创建了一个 2048 byte 的 MemroyHeapBase，要整块一起使用，应该是下面这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ProcA : <span class="keyword">public</span> BinderService&lt;ProcA&gt;, </div><div class="line">                    <span class="keyword">public</span> BnProcA</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="keyword">const</span>* getServiceName() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"ProcA"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    ProcA();</div><div class="line">    ~ProcA();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact(uint32_t code, <span class="keyword">const</span> Parcel& data,</div><div class="line">        Parcel* reply, uint32_t flags);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemory&gt; getMemory();</div><div class="line"></div><div class="line">    sp&lt;MemoryBase&gt; mMemory;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line">ProcA::K7Service()</div><div class="line">    :   BnK7() {</div><div class="line">    sp&lt;MemoryHeapBase&gt; heap = <span class="keyword">new</span> MemoryHeapBase(<span class="number">2048</span>, <span class="number">0</span>, <span class="string">"K7Service"</span>);</div><div class="line">    mMemory = <span class="keyword">new</span> MemoryBase(heap, <span class="number">0</span>, <span class="number">2048</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那么接下来 Proc A 只要把 fd 倒腾给 Proc B 就行了。不过这里 fd 是封装在 MemroyHeapBase 里面的，真正使用的又是 MemroyBase，而且又实现了 binder 接口，当然得一层层转。首先得把 MemroyBase 传给 Proc B，MemroyBase 的 binder 接口是 IMemroy（IBinder），把这个通过 binder 扔给 Proc B 先。我们假设在 Proc A 的 binder 接口中有一个教 getMemroy 的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IProcA =================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> BpProcA : <span class="keyword">public</span> BpInterface&lt;IProcA&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemory&gt; getMemory() {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IProcA::getInterfaceDescriptor());</div><div class="line">        remote()-&gt;transact(BnProcA::GET_MEMORY, data, &reply);</div><div class="line">        sp&lt;IMemory&gt; memory = interface_cast&lt;IMemory&gt;(reply.readStrongBinder());</div><div class="line">        <span class="keyword">return</span> memory;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">status_t BnProcA::onTransact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span>(code) {</div><div class="line">        <span class="keyword">case</span> GET_MEMORY: {</div><div class="line">            CHECK_INTERFACE(IProcA, data, reply);</div><div class="line">            sp&lt;IMemory&gt; memory = getMemory();</div><div class="line">            reply-&gt;writeStrongBinder(memory-&gt;asBinder());</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ProcA ==================================</span></div><div class="line"></div><div class="line">sp&lt;IMemory&gt; K7Service::getMemory() { </div><div class="line">    <span class="keyword">return</span> mMemory;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Parcel 的 readStrongBinder 和 writeStrongBinder 前面说过了，Parcel 的 <code>flat_binder_object</code> 专门用来传递 binder 对象的。IMemroy 传到 Proc B 后，来看看 IMemroy 有哪些接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IMemroy.h ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> IMemory : <span class="keyword">public</span> IInterface</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DECLARE_META_INTERFACE(Memory);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(ssize_t* offset=<span class="number">0</span>, size_t* size=<span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// helpers</span></div><div class="line">    <span class="keyword">void</span>* fastPointer(<span class="keyword">const</span> sp&lt;IBinder&gt;& heap, ssize_t offset) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">void</span>* pointer() <span class="keyword">const</span>;</div><div class="line">    size_t size() <span class="keyword">const</span>;</div><div class="line">    ssize_t offset() <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> BnMemory : <span class="keyword">public</span> BnInterface&lt;IMemory&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact(</div><div class="line">            uint32_t code,</div><div class="line">            <span class="keyword">const</span> Parcel& data,            </div><div class="line">            Parcel* reply,</div><div class="line">            uint32_t flags = <span class="number">0</span>);</div><div class="line"></div><div class="line">    BnMemory();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~BnMemory();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IMemroy.cpp ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">void</span>* IMemory::pointer() <span class="keyword">const</span> {</div><div class="line">    ssize_t offset;</div><div class="line">    sp&lt;IMemoryHeap&gt; heap = getMemory(&offset);</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> base = heap!=<span class="number">0</span> ? heap-&gt;base() : MAP_FAILED;</div><div class="line">    <span class="keyword">if</span> (base == MAP_FAILED)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(base) + offset;</div><div class="line">}</div><div class="line"></div><div class="line">size_t IMemory::size() <span class="keyword">const</span> {</div><div class="line">    size_t size;</div><div class="line">    getMemory(NULL, &size);</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">}</div><div class="line"></div><div class="line">ssize_t IMemory::offset() <span class="keyword">const</span> {</div><div class="line">    ssize_t offset;</div><div class="line">    getMemory(&offset);</div><div class="line">    <span class="keyword">return</span> offset;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>基本上可以看得出， pointer() 是返回共享内存的地址，这个地址是已经映射到 Proc B 中了的，就是可以直接读、写了的。然后 size() 和 offset() 分别是返回大小和偏移（例子中是 2048 和 0）。</p>
<p>然后，它们都调用了一个比较关键的函数叫 getMemroy：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MemroyBase ===============================</span></div><div class="line"></div><div class="line">sp&lt;IMemoryHeap&gt; MemoryBase::getMemory(ssize_t* offset, size_t* size) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset;</div><div class="line">    <span class="keyword">if</span> (size)   *size = mSize;</div><div class="line">    <span class="keyword">return</span> mHeap;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// IMemroy ==================================</span></div><div class="line"></div><div class="line">sp&lt;IMemoryHeap&gt; BpMemory::getMemory(ssize_t* offset, size_t* size) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mHeap == <span class="number">0</span>) {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());</div><div class="line">        <span class="keyword">if</span> (remote()-&gt;transact(GET_MEMORY, data, &reply) == NO_ERROR) {</div><div class="line">            sp&lt;IBinder&gt; heap = reply.readStrongBinder();</div><div class="line">            ssize_t o = reply.readInt32(); </div><div class="line">            size_t s = reply.readInt32();  </div><div class="line">            <span class="keyword">if</span> (heap != <span class="number">0</span>) {</div><div class="line">                mHeap = interface_cast&lt;IMemoryHeap&gt;(heap);</div><div class="line">                <span class="keyword">if</span> (mHeap != <span class="number">0</span>) {              </div><div class="line">                    mOffset = o;                   </div><div class="line">                    mSize = s;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset; </div><div class="line">    <span class="keyword">if</span> (size) *size = mSize;</div><div class="line">    <span class="keyword">return</span> mHeap;</div><div class="line">}</div><div class="line"></div><div class="line">status_t BnMemory::onTransact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    <span class="keyword">switch</span>(code) {</div><div class="line">        <span class="keyword">case</span> GET_MEMORY: {</div><div class="line">            CHECK_INTERFACE(IMemory, data, reply);</div><div class="line">            ssize_t offset;</div><div class="line">            size_t size;</div><div class="line">            reply-&gt;writeStrongBinder( getMemory(&offset, &size)-&gt;asBinder() );</div><div class="line">            reply-&gt;writeInt32(offset);     </div><div class="line">            reply-&gt;writeInt32(size);       </div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个叫 getMemroy 的最后其实是把 MemoryBase 用的 MemoryHeapBase 的 binder 接口（IMemroyHeap）传了过来（前面说了要一层层转的吧）。然后我们就得来看看 IMemroyHeap 的接口了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MemroyHeapBase ============================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> MemoryHeapBase::getHeapID() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">return</span> mFD;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// IMemroy.h ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> IMemoryHeap : <span class="keyword">public</span> IInterface</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DECLARE_META_INTERFACE(MemoryHeap);</div><div class="line"></div><div class="line">    <span class="comment">// flags returned by getFlags()</span></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        READ_ONLY   = <span class="number">0x00000001</span>       </div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">int</span>         getHeapID() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>*       getBase() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> size_t      getSize() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> uint32_t    getFlags() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> uint32_t    getOffset() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// these are there just for backward source compatibility</span></div><div class="line">    int32_t heapID() <span class="keyword">const</span> { <span class="keyword">return</span> getHeapID(); }</div><div class="line">    <span class="keyword">void</span>*   base() <span class="keyword">const</span>  { <span class="keyword">return</span> getBase(); }</div><div class="line">    size_t  virtualSize() <span class="keyword">const</span> { <span class="keyword">return</span> getSize(); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> BnMemoryHeap : <span class="keyword">public</span> BnInterface&lt;IMemoryHeap&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact(</div><div class="line">            uint32_t code,</div><div class="line">            <span class="keyword">const</span> Parcel& data,            </div><div class="line">            Parcel* reply,</div><div class="line">            uint32_t flags = <span class="number">0</span>);           </div><div class="line">    </div><div class="line">    BnMemoryHeap();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~BnMemoryHeap();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IMemroy.cpp ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> BpMemoryHeap::getHeapID() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mHeapId;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span>* BpMemoryHeap::getBase() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mBase;</div><div class="line">}</div><div class="line"></div><div class="line">size_t BpMemoryHeap::getSize() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mSize;</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t BpMemoryHeap::getFlags() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mFlags;</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t BpMemoryHeap::getOffset() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mOffset;</div><div class="line">}</div><div class="line"></div><div class="line">status_t BnMemoryHeap::onTransact(</div><div class="line">        uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    <span class="keyword">switch</span>(code) {</div><div class="line">       <span class="keyword">case</span> HEAP_ID: {</div><div class="line">            CHECK_INTERFACE(IMemoryHeap, data, reply);</div><div class="line">            reply-&gt;writeFileDescriptor(getHeapID());</div><div class="line">            reply-&gt;writeInt32(getSize());  </div><div class="line">            reply-&gt;writeInt32(getFlags()); </div><div class="line">            reply-&gt;writeInt32(getOffset());</div><div class="line">            <span class="keyword">return</span> NO_ERROR;  </div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>上面 IMemory 那里获取到 IMemroyHeap 后，调用的是 base(), 这个最后是调用 getBaes() 的。但是这几个 Bp 端的接口实现，无一例外，全都调用了另一个关键的函数（又是关键的 -_-||）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertMapped() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {</div><div class="line">        sp&lt;IBinder&gt; binder(<span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)-&gt;asBinder());</div><div class="line">        sp&lt;BpMemoryHeap&gt; heap(<span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(find_heap(binder).get()));</div><div class="line">        heap-&gt;assertReallyMapped();    </div><div class="line">        <span class="keyword">if</span> (heap-&gt;mBase != MAP_FAILED) {</div><div class="line">            Mutex::Autolock _l(mLock);     </div><div class="line">            <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {           </div><div class="line">                mBase   = heap-&gt;mBase;         </div><div class="line">                mSize   = heap-&gt;mSize;         </div><div class="line">                mOffset = heap-&gt;mOffset;       </div><div class="line">                android_atomic_write( dup( heap-&gt;mHeapId ), &mHeapId );</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// something went wrong        </span></div><div class="line">            free_heap(binder);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertReallyMapped() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {</div><div class="line"></div><div class="line">        <span class="comment">// 注释好像是说为了性能，不在 transact 远程调用加锁，只在后面 mmap 那里加锁</span></div><div class="line">        <span class="comment">// remote call without mLock held, worse case scenario, we end up</span></div><div class="line">        <span class="comment">// calling transact() from multiple threads, but that's not a problem,</span></div><div class="line">        <span class="comment">// only mmap below must be in the critical section.</span></div><div class="line"></div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemoryHeap::getInterfaceDescriptor());</div><div class="line">        status_t err = remote()-&gt;transact(HEAP_ID, data, &reply);</div><div class="line">        <span class="keyword">int</span> parcel_fd = reply.readFileDescriptor();</div><div class="line">        ssize_t size = reply.readInt32();</div><div class="line">        uint32_t flags = reply.readInt32();</div><div class="line">        uint32_t offset = reply.readInt32();</div><div class="line"></div><div class="line">        ALOGE_IF(err, <span class="string">"binder=%p transaction failed fd=%d, size=%ld, err=%d (%s)"</span>,</div><div class="line">                asBinder().get(), parcel_fd, size, err, strerror(-err));</div><div class="line"></div><div class="line">        <span class="keyword">int</span> fd = dup( parcel_fd );</div><div class="line">        ALOGE_IF(fd==-<span class="number">1</span>, <span class="string">"cannot dup fd=%d, size=%ld, err=%d (%s)"</span>,</div><div class="line">                parcel_fd, size, err, strerror(errno));</div><div class="line"></div><div class="line">        <span class="keyword">int</span> access = PROT_READ;</div><div class="line">        <span class="keyword">if</span> (!(flags & READ_ONLY)) {</div><div class="line">            access |= PROT_WRITE;</div><div class="line">        }</div><div class="line"></div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {</div><div class="line">            mRealHeap = <span class="keyword">true</span>;</div><div class="line">            mBase = mmap(<span class="number">0</span>, size, access, MAP_SHARED, fd, offset);</div><div class="line">            <span class="keyword">if</span> (mBase == MAP_FAILED) {</div><div class="line">                ALOGE(<span class="string">"cannot map BpMemoryHeap (binder=%p), size=%ld, fd=%d (%s)"</span>,</div><div class="line">                        asBinder().get(), size, fd, strerror(errno));</div><div class="line">                close(fd);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mSize = size;</div><div class="line">                mFlags = flags;</div><div class="line">                mOffset = offset;</div><div class="line">                <span class="comment">// mHeapId 就是 fd 啊</span></div><div class="line">                android_atomic_write(fd, &mHeapId);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 Proc B 是要用到共享内存才会去 mmap 的。assertMapped()、assertReallyMapped() 这2个名字还真直白。 mHeapId 就是 Proc A 倒腾给 Proc B 的 fd，如果为 -1 表示 Proc B 还没 mmap 过，所以进入 assert(Really)Mapped() 进行 mmap 。assertMapped() 那里有个 <code>find_heap</code> 的东西，看起来挺多余的，直接调用自己的函数有那么费劲么，后面看了下注释好像是拿来调试用的，那就不用管它了。然后 assertReallyMapped 就和 java 层的差不多了，先是发一个 <code>HEAP_ID</code> 给 MemoryHeapBase 的 Bn 让它把 Proc A 那边的 fd 通过 Parcel 的 writeFileDescriptor 倒腾<br>过来。注意这里调用的是 native Parcel 的 writeFileDescriptor，而上面 java 的是 writeDupFileDescriptor，所以 Proc B Bp 这边接到后，要自己手动 dup(fd) 一次 -_-||。然后就 mmap 了，报得到的地址、大小、偏移保存一下，Proc B 就能读写了。</p>
<p>native 层的接口返回的直接是地址，读写比 java 层的灵活很多。然后 native 的 close、munmap 都是在析够函数中进行的，可以说配合 android 的智能指针（其实我挺讨厌这玩意），可以说使用无脑（用 sp<imemory>，初始化的时候 new 出来，在析构函数里置为 NULL 就行了）。</imemory></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 因为主要 open、mmap 都是 MemoryHeapBase 做的，MemoryBase 只是把地址、偏移设置了下，</span></div><div class="line"><span class="comment">// 所以 close、munmap 都只要 MemoryHeapBase 来做就行了，MemoryBase 不用做什么清理的。</span></div><div class="line"></div><div class="line"><span class="comment">// Bn 端（Proc A）的关闭</span></div><div class="line"><span class="comment">// MemroyHeapBase ==================================</span></div><div class="line"></div><div class="line">MemoryHeapBase::~MemoryHeapBase()</div><div class="line">{</div><div class="line">    dispose();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> MemoryHeapBase::dispose()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = android_atomic_or(-<span class="number">1</span>, &mFD); </div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (mNeedUnmap) {</div><div class="line">            <span class="comment">//ALOGD("munmap(fd=%d, base=%p, size=%lu)", fd, mBase, mSize);</span></div><div class="line">            munmap(mBase, mSize);          </div><div class="line">        }</div><div class="line">        mBase = <span class="number">0</span>;</div><div class="line">        mSize = <span class="number">0</span>;</div><div class="line">        close(fd);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Bp 端（Proc B）的关闭 </span></div><div class="line"><span class="comment">// IMemroy ==================================</span></div><div class="line"></div><div class="line">BpMemoryHeap::~BpMemoryHeap() {</div><div class="line">    <span class="keyword">if</span> (mHeapId != -<span class="number">1</span>) {</div><div class="line">        close(mHeapId);</div><div class="line">        <span class="keyword">if</span> (mRealHeap) {</div><div class="line">            <span class="comment">// by construction we're the last one</span></div><div class="line">            <span class="keyword">if</span> (mBase != MAP_FAILED) {</div><div class="line">                sp&lt;IBinder&gt; binder = <span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)-&gt;asBinder();</div><div class="line">    </div><div class="line">                <span class="keyword">if</span> (VERBOSE) {</div><div class="line">                    ALOGD(<span class="string">"UNMAPPING binder=%p, heap=%p, size=%d, fd=%d"</span>,</div><div class="line">                            binder.get(), <span class="keyword">this</span>, mSize, mHeapId);</div><div class="line">                    CallStack <span class="built_in">stack</span>(LOG_TAG);</div><div class="line">                }</div><div class="line">    </div><div class="line">                munmap(mBase, mSize);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// remove from list only if it was mapped before</span></div><div class="line">            sp&lt;IBinder&gt; binder = <span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)-&gt;asBinder();</div><div class="line">            free_heap(binder);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>又是 MemoryHeapBase、MemoryBase、IMemoryBase、IMemory 是不是有点头晕咧，主要是 android 在 native 层搞了2个东西，加那一堆 binder 接口，这还没 java 层简洁（虽然 java 层的被废掉了 -_-||）。最后来张图吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-ashmem/1.png" alt=""></p>
<h2 id="kernel_驱动">kernel 驱动</h2>
<p>上面把应用层的接口说往了，下面就要讲 kernel 里面的驱动了。最开始的时候说了， ashmem 是基于 linux 的 tmpfs 实现的，所以最好要有点这方面的知识，不过目前我还是不太清楚 tmpfs 相关的接口用法 -_-||，等以后找点书来看补补吧。</p>
<p>前面那些接口最后面就是调用到 libcutils 的 ashmem-dev.c 中的那些接口，那些接口最后都是 open 或是 ioctl 的系统调用，这些最后都是进入到 kernel 的 ashmem 驱动当中。</p>
<p>我们先来看下 ashmem 驱动加载初始化的时候：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * ashmem_area - anonymous shared memory area</span></div><div class="line"><span class="comment"> * Lifecycle: From our parent file's open() until its release()</span></div><div class="line"><span class="comment"> * Locking: Protected by `ashmem_mutex'</span></div><div class="line"><span class="comment"> * Big Note: Mappings do NOT pin this structure; it dies on close()</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> ashmem_area {</div><div class="line">    <span class="keyword">char</span> name[ASHMEM_FULL_NAME_LEN];<span class="comment">/* optional name for /proc/pid/maps */</span></div><div class="line">    <span class="keyword">struct</span> list_head unpinned_list; <span class="comment">/* list of all ashmem areas */</span> </div><div class="line">    <span class="keyword">struct</span> file *file;      <span class="comment">/* the shmem-based backing file */</span></div><div class="line">    size_t size;            <span class="comment">/* size of the mapping, in bytes */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prot_mask;    <span class="comment">/* allowed prot bits, as vm_flags */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kmem_cache *ashmem_area_cachep __read_mostly;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kmem_cache *ashmem_range_cachep __read_mostly;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init ashmem_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">// 为 ashmem 驱动的数据结构创建一块后备高速缓存</span></div><div class="line">    ashmem_area_cachep = kmem_cache_create(<span class="string">"ashmem_area_cache"</span>,</div><div class="line">                      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_area),</div><div class="line">                      <span class="number">0</span>, <span class="number">0</span>, NULL);</div><div class="line">    <span class="keyword">if</span> (unlikely(!ashmem_area_cachep)) {</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to create slab cache\n"</span>);</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这块数据结构是 pin/unpin 相关的，无视 ... ...</span></div><div class="line">    ashmem_range_cachep = kmem_cache_create(<span class="string">"ashmem_range_cache"</span>,</div><div class="line">                      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_range),</div><div class="line">                      <span class="number">0</span>, <span class="number">0</span>, NULL);</div><div class="line">    <span class="keyword">if</span> (unlikely(!ashmem_range_cachep)) {</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to create slab cache\n"</span>);</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 注册驱动操作相关函数</span></div><div class="line">    ret = misc_register(&ashmem_misc);</div><div class="line">    <span class="keyword">if</span> (unlikely(ret)) {</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to register misc device!\n"</span>);</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 注册内存回收扫描算法，继续无视 ... ...</span></div><div class="line">    register_shrinker(&ashmem_shrinker);</div><div class="line"></div><div class="line">    printk(KERN_INFO <span class="string">"ashmem: initialized\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// exit 函数很多对应上面 init 的注销、销毁操作</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit ashmem_exit(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    unregister_shrinker(&ashmem_shrinker);</div><div class="line"></div><div class="line">    ret = misc_deregister(&ashmem_misc);</div><div class="line">    <span class="keyword">if</span> (unlikely(ret))</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to unregister misc device!\n"</span>);</div><div class="line"></div><div class="line">    kmem_cache_destroy(ashmem_range_cachep);</div><div class="line">    kmem_cache_destroy(ashmem_area_cachep);</div><div class="line"></div><div class="line">    printk(KERN_INFO <span class="string">"ashmem: unloaded\n"</span>);</div><div class="line">}</div><div class="line"></div><div class="line">module_init(ashmem_init);</div><div class="line">module_exit(ashmem_exit);</div><div class="line"></div></pre></td></tr></table></figure>

<p>init 和 exit 函数是 kernel 第一次加载 ashmem 模块的时候调用的，一般做一些驱动初始化或是申请资源相关的操作。这里首先在 kernel 的后备高速缓存区开辟的一段空间，用来申请 <code>struct ashmem_area</code> 这个驱动相关的结构体的存储空间。这个后备高速缓存据说是应用于反复的多次分配的情况，因为 ashmem 本身就是出于性能考虑设计的，所以选择使用这个吧，能够加快分配内存的速度（注意这里只是分配驱动保存一些状态的数据结构，不是共享内存本身）。这个后备高速缓存好像又叫 slab 分配器，好像是 kernel 里面挺快的一个东西 -_-|| 。</p>
<p>然后后面那个和 pin/unpin 还有内存回收算法相关的，我现在不打算去分析，因为第一，这个东西前面说过了，现在基本上没用；第二，最主要的是我也不是很清楚这些玩意 -_-||。再后注册驱动操作相关函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations ashmem_fops = {</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .open = ashmem_open,</div><div class="line">    .release = ashmem_release,</div><div class="line">        .read = ashmem_read,  </div><div class="line">        .llseek = ashmem_llseek,       </div><div class="line">    .mmap = ashmem_mmap,</div><div class="line">    .unlocked_ioctl = ashmem_ioctl,</div><div class="line">    .compat_ioctl = ashmem_ioctl,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice ashmem_misc = {</div><div class="line">    .minor = MISC_DYNAMIC_MINOR,</div><div class="line">    .name = <span class="string">"ashmem"</span>,</div><div class="line">    .fops = &ashmem_fops,</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>稍微接触过点 linux 驱动的都应该知道，这个 <code>file_operations</code> 就是 linux 文件设备驱动（linux 上所有设置都是文件）的操作函数。例如说上层应用对本设备调用 open 对应的驱动函数就是 .open 对应的，然后依此类推：</p>
<pre>
mmap  --> .mmap(ashmem_mapp)
ioctl --> .unlocked_ioctl(ashmem_ioctl)
          .compat_ioctl(ashmem_ioctl)
close --> .release(ashmem_release)
read  --> .read(ashmem_read)
seek  --> llseek(ashmem_llseek)
</pre>

<p><code>file_operations</code> 的操作函数不止这几个，没实现的就不支持对应的操作，上层调用接口，会返回错误值。以前 2.3 的 ashmem 不支持 read 和 seek 的，4.x 的开始支持啦，不过这里只关注另外几个重要的。</p>
<p>首先是 Proc A 调用 open 创建共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">// 调用系统方法打开文件</span></div><div class="line">    ret = generic_file_open(inode, file);</div><div class="line">    <span class="keyword">if</span> (unlikely(ret))</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">// 在 init 创建的高速缓存区，申请 struct ashmem_area 变量</span></div><div class="line">    asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (unlikely(!asma))</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&asma-&gt;unpinned_list);</div><div class="line">    <span class="comment">// 保持打开的文件的名字</span></div><div class="line">    <span class="built_in">memcpy</span>(asma-&gt;name, ASHMEM_NAME_PREFIX, ASHMEM_NAME_PREFIX_LEN);</div><div class="line">    asma-&gt;prot_mask = PROT_MASK;</div><div class="line">    <span class="comment">// 保持驱动私有变量</span></div><div class="line">    file-&gt;private_data = asma;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数 kernel 传递过来2个参数，第一个 inode 是文件设备节点，前面说了一个真实的文件只有一个设备节点。后面那个是文件指针，但是一个文件可以打开多次，每打开一次就有一个文件指针对应。那个 <code>generic_file_open</code> kernel 的接口，具体目前我也不是很清楚，反正就理解为调用 kernel 接口打开指定的文件设备吧 -_-||。然后利用 init 中开辟的高速缓存创建驱动的私有驱动数据，看上面， ashmem 的私有结构挺简单的，基本上就是名字、大小、打开的文件指针和端口标志（那个 unpin 的 list 咱们无视）。然后这里强制把名字的前缀设置为： </p>
<pre config="brush:bash;toolbar:false;">
#define ASHMEM_NAME_PREFIX "dev/ashmem/"
</pre>

<p>注意这里只是设置前缀而已，后面有 <code>set_name</code> 的 ioctl 接口的，这个接口是把用户设置的名字加在后面而已，基本上名字就是： “dev/shmem/xx”，这个名字感觉除了在 cat /proc/pid/maps 的时候显示一下以外就没啥别的用处了（而且好多应用还不设置）。</p>
<p>然后就是把在高速缓存区创建的 <code>ashmem_area</code> 保持在 file-&gt;private_data 这个字段中。这是很多驱动的通用做法，把私有的数据结构保持在这个字段，在后面的 ioctl 里面能取出来用。</p>
<p>然后 Proc A 就该调用 mmap 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_mmap(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">    mutex_lock(&ashmem_mutex);</div><div class="line"></div><div class="line">    <span class="comment">// 在调用 mmap 之前必须调用 ioctl SET_SIZE -_-||</span></div><div class="line">    <span class="comment">/* user needs to SET_SIZE before mapping */</span></div><div class="line">    <span class="keyword">if</span> (unlikely(!asma-&gt;size)) {</div><div class="line">        ret = -EINVAL;        </div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* requested protection bits must match our allowed protection mask */</span></div><div class="line">    <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags & ~calc_vm_prot_bits(asma-&gt;prot_mask)) &</div><div class="line">                        calc_vm_prot_bits(PROT_MASK))) {</div><div class="line">        ret = -EPERM;         </div><div class="line">        <span class="keyword">goto</span> out;             </div><div class="line">    }</div><div class="line">    vma-&gt;vm_flags &= ~calc_vm_may_flags(~asma-&gt;prot_mask);</div><div class="line"></div><div class="line">    <span class="comment">// 还没创建共享内存文件，则创建</span></div><div class="line">    <span class="keyword">if</span> (!asma-&gt;file) {</div><div class="line">        <span class="keyword">char</span> *name = ASHMEM_NAME_DEF;  </div><div class="line">        <span class="keyword">struct</span> file *vmfile;  </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (asma-&gt;name[ASHMEM_NAME_PREFIX_LEN] != <span class="string">'\0'</span>)</div><div class="line">            name = asma-&gt;name;</div><div class="line"></div><div class="line">        <span class="comment">// 在 tmpfs 文件系统上创建共享内存文件</span></div><div class="line">        <span class="comment">/* ... and allocate the backing shmem file */</span></div><div class="line">        vmfile = shmem_file_setup(name, asma-&gt;size, vma-&gt;vm_flags);</div><div class="line">        <span class="keyword">if</span> (unlikely(IS_ERR(vmfile))) {</div><div class="line">            ret = PTR_ERR(vmfile);</div><div class="line">            <span class="keyword">goto</span> out;</div><div class="line">        }</div><div class="line">        asma-&gt;file = vmfile;</div><div class="line">    }</div><div class="line">    get_file(asma-&gt;file);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags & VM_SHARED)</div><div class="line">        shmem_set_file(vma, asma-&gt;file);</div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (vma-&gt;vm_file)</div><div class="line">            fput(vma-&gt;vm_file);</div><div class="line">        vma-&gt;vm_file = asma-&gt;file;</div><div class="line">    }</div><div class="line">    vma-&gt;vm_flags |= VM_CAN_NONLINEAR;</div><div class="line"></div><div class="line">out:</div><div class="line">    mutex_unlock(&ashmem_mutex);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> ashmem_ioctl(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</div><div class="line">    <span class="keyword">long</span> ret = -ENOTTY;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    <span class="keyword">case</span> ASHMEM_SET_NAME:</div><div class="line">        ret = set_name(asma, (<span class="keyword">void</span> __user *) arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_NAME:</div><div class="line">        ret = get_name(asma, (<span class="keyword">void</span> __user *) arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_SET_SIZE:</div><div class="line">        ret = -EINVAL;</div><div class="line">        <span class="keyword">if</span> (!asma-&gt;file) {</div><div class="line">            ret = <span class="number">0</span>;</div><div class="line">            asma-&gt;size = (size_t) arg;     </div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_SIZE:</div><div class="line">        ret = asma-&gt;size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_SET_PROT_MASK:</div><div class="line">        ret = set_prot_mask(asma, arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_PROT_MASK:</div><div class="line">        ret = asma-&gt;prot_mask;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_PIN:</div><div class="line">    <span class="keyword">case</span> ASHMEM_UNPIN:</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_PIN_STATUS:</div><div class="line">        ret = ashmem_pin_unpin(asma, cmd, (<span class="keyword">void</span> __user *) arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_PURGE_ALL_CACHES:</div><div class="line">        ret = -EPERM;</div><div class="line">        <span class="keyword">if</span> (capable(CAP_SYS_ADMIN)) {</div><div class="line">            <span class="keyword">struct</span> shrink_control sc = {</div><div class="line">                .gfp_mask = GFP_KERNEL,</div><div class="line">                .nr_to_scan = <span class="number">0</span>,</div><div class="line">            };</div><div class="line">            ret = ashmem_shrink(&ashmem_shrinker, &sc);</div><div class="line">            sc.nr_to_scan = ret;</div><div class="line">            ashmem_shrink(&ashmem_shrinker, &sc);</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>mmap 一开始要在调用前需要调用 ioctl <code>SET_SIZE</code> 设置这片共享内存区域的大小。回去前面看下 <code>ashmem_create_region</code> 是不是在 open 之后，调用了 ioctl 去设置大小。所以我把 ioctl 那部分也贴出来了，<code>SET_SIZE</code> 其实很简单，就是把 asm-&gt;size 设置了一下。但是我觉得有点奇怪，上层调用 mmap 的时候也传了 size 了（size 和 调用 ioctl 的一样），那为什么不像 binder 的那样使用 vma 中的 size 。这点我就暂时无法理解了（对 kernel 相关的知识不太了解）。</p>
<p>然后后面的就能更难理解了，调用 <code>shmem_file_setup</code> 据说好像是 kernel 的 tmpfs 的接口，然后从参数看，姑且就认为在 tmpfs 上创建了一个名字为 name，大小为 asm-&gt;size 的文件，用于共享内存。后面那个 <code>get_file</code> 也不知道用处是什么（主要是没百度到）。然后 flags，前面 mmap 的时候，都设置了 <code>MAP_SHARED</code>，这里 <code>shmem_set_file</code> 就说是 android 在 kernel 中自己加的接口，我就更不知道是干啥用的了。不过看名字，加上参数，好像是激活刚刚创建的文件吧。然后就完了 -_-||。</p>
<p>其实 ashmem 的 kernel 驱动，这里就只能大致讲个原理，具体的因为不太懂 kernel 文件系统、I/O 相关的东西，没办法继续分析下去了，等以后再说吧。</p>
<p>然后就应该到 Proc A 把 fd 倒腾给 Proc B 了，这里倒腾要借助 binder 的驱动。还记得 Parcel 的 <code>flat_binder_object</code> 么，binder 的驱动专门处理这个东西的，那么就要去看 Parcel 的 <code>flat_binder_object</code> 在 binder 里面怎么倒腾的了。前面说 <code>BINDER_TYPE_FD</code> 这个类型就是专门到来倒腾 fd 的，这个在 <code>binder_transaction</code> 中（忘记流程了的，回去复习下前面几篇）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete;</div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list;</div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(size_t))) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">            <span class="string">"invalid offsets size, %zd\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    }</div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line">        <span class="keyword">struct</span> flat_binder_object *fp;</div><div class="line">        <span class="keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            t-&gt;buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">                <span class="string">"invalid offset, %zd\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, *offp);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_offset;</div><div class="line">        }</div><div class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) {</div><div class="line">        ... ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="keyword">int</span> target_fd;</div><div class="line">            <span class="keyword">struct</span> file *file;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (reply) {</div><div class="line">                <span class="comment">// 如果目标对象不接受 fd 的话则报错，前面 Parcel 调用那个相关接口的时候设置了这个标志的</span></div><div class="line">                <span class="keyword">if</span> (!(in_reply_to-&gt;flags & TF_ACCEPT_FDS)) {</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%d got reply with fd, %ld, but target does not allow fds\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_fd_not_allowed;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (!target_node-&gt;accept_fds) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got transaction with fd, %ld, but target does not allow fds\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_fd_not_allowed;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 这个 fp-&gt;handle 就是前面的 fd</span></div><div class="line">            <span class="comment">// 通过 fd 取得 file 文件指针</span></div><div class="line">            file = fget(fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (file == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid fd, %ld\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_fget_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 寻找目标进程（target_proc: Proc B）中空闲的 fd</span></div><div class="line">            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);</div><div class="line">            <span class="keyword">if</span> (target_fd &lt; <span class="number">0</span>) {</div><div class="line">                fput(file);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_get_unused_fd_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 在目标进程空闲的 fd 中安装 file 文件指针</span></div><div class="line">            task_fd_install(target_proc, target_fd, file);</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        fd %ld -&gt; %d\n"</span>, fp-&gt;handle, target_fd);</div><div class="line">            <span class="comment">// 把转化好的目标进程的 fd 设回 flat_binder_object 传递给上层应用</span></div><div class="line">            <span class="comment">/* TODO: fput? */</span></div><div class="line">            fp-&gt;handle = target_fd;</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transactio"</span></div><div class="line">                <span class="string">"n with invalid object type, %lx\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, fp-&gt;type);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_object_type;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里倒腾的主要是另外2个函数： </p>
<p><code>task_get_unused_fd_flags</code>： 在目标进程中找到空闲的 fd<br><code>task_fd_install</code>： 在目标进程空闲的 fd 中安装 Proc A 中打开的文件指针</p>
<p>我看来看下这2个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * copied from get_unused_fd_flags</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> task_get_unused_fd_flags(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> flags)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> files_struct *files = proc-&gt;files;</div><div class="line">    <span class="keyword">int</span> fd, error;</div><div class="line">    <span class="keyword">struct</span> fdtable *fdt;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rlim_cur;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> irqs;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (files == NULL)</div><div class="line">        <span class="keyword">return</span> -ESRCH;</div><div class="line"></div><div class="line">    error = -EMFILE;</div><div class="line">    spin_lock(&files-&gt;file_lock);</div><div class="line"></div><div class="line">repeat:</div><div class="line">    fdt = files_fdtable(files);</div><div class="line">    fd = find_next_zero_bit(fdt-&gt;open_fds-&gt;fds_bits, fdt-&gt;max_fds,</div><div class="line">                files-&gt;next_fd);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * N.B. For clone tasks sharing a files structure, this test</span></div><div class="line"><span class="comment">     * will limit the total number of files that can be opened.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    rlim_cur = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (lock_task_sighand(proc-&gt;tsk, &irqs)) {</div><div class="line">        rlim_cur = proc-&gt;tsk-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur;</div><div class="line">        unlock_task_sighand(proc-&gt;tsk, &irqs);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (fd &gt;= rlim_cur)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">    <span class="comment">/* Do we need to expand the fd array or fd set?  */</span></div><div class="line">    error = expand_files(files, fd);</div><div class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) {</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * If we needed to expand the fs array we</span></div><div class="line"><span class="comment">         * might have blocked - try again.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        error = -EMFILE;</div><div class="line">        <span class="keyword">goto</span> repeat;</div><div class="line">    }</div><div class="line"></div><div class="line">    FD_SET(fd, fdt-&gt;open_fds);</div><div class="line">    <span class="keyword">if</span> (flags & O_CLOEXEC)</div><div class="line">        FD_SET(fd, fdt-&gt;close_on_exec);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        FD_CLR(fd, fdt-&gt;close_on_exec);</div><div class="line">    files-&gt;next_fd = fd + <span class="number">1</span>;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> 1</span></div><div class="line">    <span class="comment">/* Sanity check */</span></div><div class="line">    <span class="keyword">if</span> (fdt-&gt;fd[fd] != NULL) {</div><div class="line">        printk(KERN_WARNING <span class="string">"get_unused_fd: slot %d not NULL!\n"</span>, fd);</div><div class="line">        fdt-&gt;fd[fd] = NULL;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    error = fd;</div><div class="line"></div><div class="line">out:</div><div class="line">    spin_unlock(&files-&gt;file_lock);</div><div class="line">    <span class="keyword">return</span> error;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * copied from fd_install</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> task_fd_install(</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc, <span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">struct</span> file *file)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> files_struct *files = proc-&gt;files;</div><div class="line">    <span class="keyword">struct</span> fdtable *fdt;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (files == NULL)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    spin_lock(&files-&gt;file_lock);</div><div class="line">    fdt = files_fdtable(files);</div><div class="line">    BUG_ON(fdt-&gt;fd[fd] != NULL);</div><div class="line">    rcu_assign_pointer(fdt-&gt;fd[fd], file);</div><div class="line">    spin_unlock(&files-&gt;file_lock);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这2个函数现在的我完全无法解释啥，看注释好像是从 kernel 的文件 I/O 中抄过来的，我又醉了 -_-|| 。反正就知道经过这2个函数的倒腾后，Proc A 的 fd 就能扔给 Proc B 用了。然后 Proc B 就能那这个 fd 去 mmap Proc A 在 tmpfs 上创建的共享内存文件了。然后 mmap 到地址后，就能读、写了。</p>
<p>呃，最后看看 close 的操作吧（这个相对能理解点）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_release(<span class="keyword">struct</span> inode *ignored, <span class="keyword">struct</span> file *file)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> ashmem_range *range, *next;</div><div class="line"></div><div class="line">    mutex_lock(&ashmem_mutex);</div><div class="line">    list_for_each_entry_safe(range, next, &asma-&gt;unpinned_list, unpinned)</div><div class="line">        range_del(range);</div><div class="line">    mutex_unlock(&ashmem_mutex);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (asma-&gt;file)</div><div class="line">        fput(asma-&gt;file);</div><div class="line">    kmem_cache_free(ashmem_area_cachep, asma);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>抛去 pin/unping 的不看，这里就是把 open 里面从高速缓存中申请的 <code>ashmem_area</code> 给释放掉了。</p>
<h2 id="例子">例子</h2>
<p>上面说了那么多，咋来点例子来看下 framework 中是怎么使用 ashmem 的。前面说 java 层 android 不希望开发者自己倒腾 ashmem，这里我们拿用 Parcel 传递 Bitmap 为例子。图片算是比较大型的资源了，大的图片也很占内存，当你使用 Parcel 传递 Bitmap android 自动帮我们使用 ashmem 了，因为 Bitmap 是 Parcelable 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Bitmap&gt; CREATOR</div><div class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;Bitmap&gt;() {</div><div class="line">    <span class="javadoc">/**  </span></div><div class="line"><span class="javadoc">     * Rebuilds a bitmap previously stored with writeToParcel().</span></div><div class="line"><span class="javadoc">     *</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @param</span> p    Parcel object to read the bitmap from</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @return</span> a new bitmap created from the data in the parcel</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">public</span> Bitmap <span class="title">createFromParcel</span>(Parcel p) { </div><div class="line">        Bitmap bm = nativeCreateFromParcel(p);</div><div class="line">        <span class="keyword">if</span> (bm == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to unparcel Bitmap"</span>);</div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span> bm;</div><div class="line">    }    </div><div class="line">    <span class="keyword">public</span> Bitmap[] <span class="title">newArray</span>(<span class="keyword">int</span> size) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bitmap[size];</div><div class="line">    }    </div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * No special parcel contents.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span>() {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Write the bitmap and its pixels to the parcel. The bitmap can be</span></div><div class="line"><span class="comment"> * rebuilt from the parcel by calling CREATOR.createFromParcel().</span></div><div class="line"><span class="comment"> * @param p    Parcel object to write the bitmap data into</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span>(Parcel p, <span class="keyword">int</span> flags) {</div><div class="line">    checkRecycled(<span class="string">"Can't parcel a recycled bitmap"</span>);</div><div class="line">    <span class="keyword">if</span> (!nativeWriteToParcel(mNativeBitmap, mIsMutable, mDensity, p)) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"native writeToParcel failed"</span>);</div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>挂 jni 的马甲咧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,</div><div class="line">                                     <span class="keyword">const</span> SkBitmap* bitmap,</div><div class="line">                                     jboolean isMutable, jint density,</div><div class="line">                                     jobject parcel) {</div><div class="line">    <span class="keyword">if</span> (parcel == NULL) {</div><div class="line">        SkDebugf(<span class="string">"------- writeToParcel null parcel\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 通过 java 的 Parcel 对象获取 native 层的 parcel 对象</span></div><div class="line">    android::Parcel* p = android::parcelForJavaObject(env, parcel);</div><div class="line"></div><div class="line">    <span class="comment">// 把 bitmap 的一些配置信息写进去</span></div><div class="line">    p-&gt;writeInt32(isMutable);</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;config());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;width());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;height());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;rowBytes());</div><div class="line">    p-&gt;writeInt32(density);</div><div class="line"></div><div class="line">    <span class="comment">// 如果是 index 格式，不使用 ashmem，直接拿 Parcel 申请普通内存传递</span></div><div class="line">    <span class="comment">// 颜色索引格式的图片占用资源一般都不大</span></div><div class="line">    <span class="keyword">if</span> (bitmap-&gt;getConfig() == SkBitmap::kIndex8_Config) {</div><div class="line">        SkColorTable* ctable = bitmap-&gt;getColorTable();</div><div class="line">        <span class="keyword">if</span> (ctable != NULL) {</div><div class="line">            <span class="keyword">int</span> count = ctable-&gt;count();</div><div class="line">            p-&gt;writeInt32(count);</div><div class="line">            <span class="built_in">memcpy</span>(p-&gt;writeInplace(count * <span class="keyword">sizeof</span>(SkPMColor)),</div><div class="line">                   ctable-&gt;lockColors(), count * <span class="keyword">sizeof</span>(SkPMColor));</div><div class="line">            ctable-&gt;unlockColors(<span class="keyword">false</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p-&gt;writeInt32(<span class="number">0</span>);   <span class="comment">// indicate no ctable</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    size_t size = bitmap-&gt;getSize();</div><div class="line"></div><div class="line">    <span class="comment">// 其它格式（最常见的 ARGB）是用 ashmem</span></div><div class="line">    <span class="comment">// 这个 Blob 是 Parcel 的一个简单的封装类</span></div><div class="line">    android::Parcel::WritableBlob blob;</div><div class="line">    <span class="comment">// writeBlob 就是创建 size 大小的 ashmem</span></div><div class="line">    android::status_t status = p-&gt;writeBlob(size, &blob);</div><div class="line">    <span class="keyword">if</span> (status) {</div><div class="line">        doThrowRE(env, <span class="string">"Could not write bitmap to parcel blob."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    bitmap-&gt;lockPixels();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* pSrc =  bitmap-&gt;getPixels();</div><div class="line">    <span class="keyword">if</span> (pSrc == NULL) {</div><div class="line">        <span class="built_in">memset</span>(blob.data(), <span class="number">0</span>, size);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// memcpy， 这里需要 copy 一次</span></div><div class="line">        <span class="built_in">memcpy</span>(blob.data(), pSrc, size);</div><div class="line">    }</div><div class="line">    bitmap-&gt;unlockPixels();</div><div class="line"></div><div class="line">    <span class="comment">// 图片 pixels 复制完了可以 munmap 了</span></div><div class="line">    blob.release();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数主要是调用 Parcel 的 writeBlob 创建 ashmem，并初始化 Blob。然后把 bitmap 的 pixels 数据 copy 到 ashmem 中，注意 copy 完之后 Proc A 就不再需要对 ashmem 进行操作了，所以后面就 munmap（下面 Blob 的代码可以看到 release 只是 munmap 而已，没 close，这里还不能 close 要等 Proc B 读完才能 close）。<br>然后我们看下 Parcel 的 Blob 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Parcel.h ==================================</span></div><div class="line"></div><div class="line">    <span class="keyword">class</span> Blob {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Blob();</div><div class="line">        ~Blob();</div><div class="line"></div><div class="line">        <span class="keyword">void</span> release();</div><div class="line">        <span class="keyword">inline</span> size_t size() <span class="keyword">const</span> { <span class="keyword">return</span> mSize; } </div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="keyword">void</span> init(<span class="keyword">bool</span> mapped, <span class="keyword">void</span>* data, size_t size);</div><div class="line">        <span class="keyword">void</span> clear();</div><div class="line"></div><div class="line">        <span class="comment">// true 表示 mmap 过，release 的时候需要 munmap</span></div><div class="line">        <span class="keyword">bool</span> mMapped;</div><div class="line">        <span class="comment">// mmap 的内存地址</span></div><div class="line">        <span class="keyword">void</span>* mData;    </div><div class="line">        <span class="comment">// mmap 的内存大小      </span></div><div class="line">        size_t mSize;</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="comment">// Parcel.cpp ==================================</span></div><div class="line"></div><div class="line">Parcel::Blob::Blob() :</div><div class="line">        mMapped(<span class="keyword">false</span>), mData(NULL), mSize(<span class="number">0</span>) {</div><div class="line">}</div><div class="line"></div><div class="line">Parcel::Blob::~Blob() {</div><div class="line">    release();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::Blob::release() {</div><div class="line">    <span class="keyword">if</span> (mMapped && mData) {</div><div class="line">        ::munmap(mData, mSize);        </div><div class="line">    }</div><div class="line">    clear();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::Blob::init(<span class="keyword">bool</span> mapped, <span class="keyword">void</span>* data, size_t size) {</div><div class="line">    mMapped = mapped;</div><div class="line">    mData = data;</div><div class="line">    mSize = size;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::Blob::clear() {</div><div class="line">    mMapped = <span class="keyword">false</span>;</div><div class="line">    mData = NULL;</div><div class="line">    mSize = <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>十分简单，然后再来看 Parcel Blob 相关操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)</div><div class="line">{</div><div class="line">    status_t status;</div><div class="line"></div><div class="line">    <span class="comment">// 这里判断下，如果禁用 ashmem 或是要创建的 ashmem 不够大，不让使用</span></div><div class="line">    <span class="comment">// 直接用普通内存代替，果然前面 bitmap 判断小空间不用是正确的</span></div><div class="line">    <span class="keyword">if</span> (!mAllowFds || len &lt;= IN_PLACE_BLOB_LIMIT) {</div><div class="line">        ALOGV(<span class="string">"writeBlob: write in place"</span>);</div><div class="line">        status = writeInt32(<span class="number">0</span>);        </div><div class="line">        <span class="keyword">if</span> (status) <span class="keyword">return</span> status;     </div><div class="line"></div><div class="line">        <span class="keyword">void</span>* ptr = writeInplace(len); </div><div class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> NO_MEMORY;    </div><div class="line"></div><div class="line">        outBlob-&gt;init(<span class="keyword">false</span> <span class="comment">/*mapped*/</span>, ptr, len);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 调用 libcutils 的接口创建 ashmem</span></div><div class="line">    ALOGV(<span class="string">"writeBlob: write to ashmem"</span>);</div><div class="line">    <span class="keyword">int</span> fd = ashmem_create_region(<span class="string">"Parcel Blob"</span>, len);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> NO_MEMORY;</div><div class="line"></div><div class="line">    <span class="comment">// 设置下 ashmem 的读、写权限</span></div><div class="line">    <span class="keyword">int</span> result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">        status = result;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 记起我们的例子：创建完之后，Proc A mmap 内存到本进程空间</span></div><div class="line">        <span class="keyword">void</span>* ptr = ::mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (ptr == MAP_FAILED) {       </div><div class="line">            status = -errno;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 这里这么又把端口设成只读的啦？？</span></div><div class="line">            result = ashmem_set_prot_region(fd, PROT_READ);</div><div class="line">            <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">                status = result;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 1 标志是用 ashmem 的</span></div><div class="line">                status = writeInt32(<span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (!status) {</div><div class="line">                    <span class="comment">// 前面分析的，用 flat_binder_object` 传 fd</span></div><div class="line">                    <span class="comment">// 注意下后面的 takeOwnership 是 true</span></div><div class="line">                    status = writeFileDescriptor(fd, <span class="keyword">true</span> <span class="comment">/*takeOwnership*/</span>);</div><div class="line">                    <span class="keyword">if</span> (!status) {</div><div class="line">                        <span class="comment">// 不错误的把地址保存在 Blob 中</span></div><div class="line">                        outBlob-&gt;init(<span class="keyword">true</span> <span class="comment">/*mapped*/</span>, ptr, len);</div><div class="line">                        <span class="keyword">return</span> NO_ERROR;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        ::munmap(ptr, len);</div><div class="line">    }</div><div class="line">    ::close(fd);</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后回去看 Bitmap createFromParcel 接口的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {</div><div class="line">    <span class="keyword">if</span> (parcel == NULL) {</div><div class="line">        SkDebugf(<span class="string">"-------- unparcel parcel is NULL\n"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 继续先获取 native Parcel 对象</span></div><div class="line">    android::Parcel* p = android::parcelForJavaObject(env, parcel);</div><div class="line"></div><div class="line">    <span class="comment">// 把之前写的配置读出来</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span>              isMutable = p-&gt;readInt32() != <span class="number">0</span>;</div><div class="line">    <span class="keyword">const</span> SkBitmap::Config  config = (SkBitmap::Config)p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               width = p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               height = p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               rowBytes = p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               density = p-&gt;readInt32();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (SkBitmap::kARGB_8888_Config != config && </div><div class="line">            SkBitmap::kRGB_565_Config != config &&</div><div class="line">            SkBitmap::kARGB_4444_Config != config &&</div><div class="line">            SkBitmap::kIndex8_Config != config &&</div><div class="line">            SkBitmap::kA8_Config != config) {</div><div class="line">        SkDebugf(<span class="string">"Bitmap_createFromParcel unknown config: %d\n"</span>, config);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    SkBitmap* bitmap = <span class="keyword">new</span> SkBitmap;</div><div class="line"></div><div class="line">    bitmap-&gt;setConfig(config, width, height, rowBytes);</div><div class="line"></div><div class="line">    <span class="comment">// 索引格式直接使用普通内存</span></div><div class="line">    SkColorTable* ctable = NULL;</div><div class="line">    <span class="keyword">if</span> (config == SkBitmap::kIndex8_Config) {</div><div class="line">        <span class="keyword">int</span> count = p-&gt;readInt32();</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</div><div class="line">            size_t size = count * <span class="keyword">sizeof</span>(SkPMColor);</div><div class="line">            <span class="keyword">const</span> SkPMColor* src = (<span class="keyword">const</span> SkPMColor*)p-&gt;readInplace(size);</div><div class="line">            ctable = <span class="keyword">new</span> SkColorTable(src, count);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 根据图片的大小申请内存空间</span></div><div class="line">    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);</div><div class="line">    <span class="keyword">if</span> (NULL == buffer) {</div><div class="line">        SkSafeUnref(ctable);</div><div class="line">        <span class="keyword">delete</span> bitmap;</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    SkSafeUnref(ctable);</div><div class="line"></div><div class="line">    size_t size = bitmap-&gt;getSize();</div><div class="line"></div><div class="line">    <span class="comment">// 在传过来的 Parcel 中通过 Blob 读取 ashmem 的内容</span></div><div class="line">    android::Parcel::ReadableBlob blob;</div><div class="line">    android::status_t status = p-&gt;readBlob(size, &blob);</div><div class="line">    <span class="keyword">if</span> (status) {</div><div class="line">        doThrowRE(env, <span class="string">"Could not read bitmap from parcel blob."</span>);</div><div class="line">        <span class="keyword">delete</span> bitmap;</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    bitmap-&gt;lockPixels();</div><div class="line">    <span class="comment">// 把 Proc A ashmem 里的内容（bitmap 的 pixels 数据）</span></div><div class="line">    <span class="comment">// copy 到刚刚申请的内存中，这里算第二次了吧</span></div><div class="line">    <span class="built_in">memcpy</span>(bitmap-&gt;getPixels(), blob.data(), size);</div><div class="line">    bitmap-&gt;unlockPixels();</div><div class="line"></div><div class="line">    <span class="comment">// 用完了释放下</span></div><div class="line">    blob.release();</div><div class="line"></div><div class="line">    <span class="comment">// 拿之前申请的内存（已经 copy 了 Proc A 的pixels）创建一个 Bitmap 对象</span></div><div class="line">    <span class="keyword">return</span> GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),</div><div class="line">            NULL, NULL, density);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 Parcel 的 readBlob：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="comment">// 前面 writeBlob 的时候，第一个 int 是 1 来着</span></div><div class="line">    int32_t useAshmem;</div><div class="line">    status_t status = readInt32(&useAshmem);</div><div class="line">    <span class="keyword">if</span> (status) <span class="keyword">return</span> status;</div><div class="line"></div><div class="line">    <span class="comment">// 第一个 int 不是 1 就表示是普通的内存</span></div><div class="line">    <span class="keyword">if</span> (!useAshmem) {</div><div class="line">        ALOGV(<span class="string">"readBlob: read in place"</span>);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* ptr = readInplace(len);</div><div class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> BAD_VALUE;    </div><div class="line"></div><div class="line">        outBlob-&gt;init(<span class="keyword">false</span> <span class="comment">/*mapped*/</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">void</span>*&gt;(ptr), len);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// readFileDescriptor 和 writeFileDescriptor 对应</span></div><div class="line">    <span class="comment">// Proc B 得到经过倒腾的 fd</span></div><div class="line">    ALOGV(<span class="string">"readBlob: read from ashmem"</span>);</div><div class="line">    <span class="keyword">int</span> fd = readFileDescriptor(); </div><div class="line">    <span class="keyword">if</span> (fd == <span class="keyword">int</span>(BAD_TYPE)) <span class="keyword">return</span> BAD_VALUE;</div><div class="line"></div><div class="line">    <span class="comment">// Proc B mmap 内存到本进程</span></div><div class="line">    <span class="keyword">void</span>* ptr = ::mmap(NULL, len, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>); </div><div class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> NO_MEMORY;</div><div class="line"></div><div class="line">    <span class="comment">// 把 mmap 到的地址、大小保存在 Blob 中</span></div><div class="line">    outBlob-&gt;init(<span class="keyword">true</span> <span class="comment">/*mapped*/</span>, ptr, len);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后最后是释放共享内存。前面 Proc A 写完后，Blob 的 release 只是 munmap 了而已，Proc B 也是读完，重新创建完 Bitmap 后，也是 release 只是 munmap。我们来看看是在哪里关闭 fd 的。本着谁 open、谁 close 的原则，应该是 Proc A 这边关闭的。后面有篇内存管理篇的， Parcel 的析构函数会调用 freeDataNoInit：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parcel::freeDataNoInit()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">        <span class="comment">//ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());</span></div><div class="line">        mOwner(<span class="keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        releaseObjects();</div><div class="line">        <span class="keyword">if</span> (mData) <span class="built_in">free</span>(mData);        </div><div class="line">        <span class="keyword">if</span> (mObjects) <span class="built_in">free</span>(mObjects);  </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>内存管理那里是设置了 mOwner 了的，所以跑的是自己的 freeBuffer 回调，这里走的是下面，那主要是看 releaseObjects：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parcel::releaseObjects() </div><div class="line">{</div><div class="line">    <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    size_t i = mObjectsSize;</div><div class="line">    uint8_t* <span class="keyword">const</span> data = mData;</div><div class="line">    size_t* <span class="keyword">const</span> objects = mObjects;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</div><div class="line">        i--;</div><div class="line">        <span class="keyword">const</span> flat_binder_object* flat </div><div class="line">            = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);</div><div class="line">        release_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> release_object(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> flat_binder_object& obj, <span class="keyword">const</span> <span class="keyword">void</span>* who)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (obj.type) {</div><div class="line">        ... ...</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="comment">// 前面设置了 takeOwnership 是 true 的话，cookie 就是 1</span></div><div class="line">            <span class="keyword">if</span> (obj.cookie != (<span class="keyword">void</span>*)<span class="number">0</span>) close(obj.handle);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGE(<span class="string">"Invalid object type 0x%08lx"</span>, obj.type);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然是在 Proc A 关闭 fd 的咧，前面 writeFileDescriptor 那里设置的 takeOwnership 是 true，所以 <code>flat_binder_object</code> 的 cookie 是 1 。Parcel 析构的时候，正好可以 close 掉 fd。一般 IPC 通信，Proc A 传过去的 Parcel 都是局部变量，等 IPC 通信完成，就析构了（Proc B 那边也用完了，所以这个时候 close 是安全的）。</p>
<p>所以从上面来看，java 层的 MemroyFile 确实没啥用，不过感觉可以用 Parcel 来代替咧，Parcel 的 Blob 就是封装好的 ashmem，也有 read、write 接口。然后如果在 binder 中传递 Bitmap 的话，使用 ashmem 需要 copy 2次 bitmap 的 pixels 数据，这个 android 应该是出于安全性考虑，把原始的 bitmap copy 了一份出来，扔 ashmem 里面，然后对方再申请一片空间把 ashmem 里的内容 copy 过去。这样话，Proc A 后面怎么折腾原始的 bitmap 都不会对 Proc B 的 bitmap有影响（包括 recycle）。</p>
<p>当然这样在高性能的环境下是不行的，可以自己通过 Parcel 的接口改造一下： Proc A 创建 ashmem，拿 ashmem 的 buffer 解码 bitmap，然后传 ashmem 给 Proc B，Proc B 直接在 ashmem 的 buffer 上再创建出 Bitmap。不过这样带来的风险就是你自己要管理好 ashmem 的 buffer，确保 Proc B 不用了，才能 munmap、close 。好像 SurfacFlinger 用的就是类似这样的方案，这个后面有时间再慢慢说。所以说不要有事没事跨进程传图片，还是大图片。</p>
<p>最后来个对比，如果 bitmap 不用 ashmem 传递，把 binder mmap 的内存改大，那么使用普通内存传递，需要 3次 copy（Proc A、Proc B 各自一次，Proc A —&gt; kernel 一次）。如果使用普通的 IPC 那么需要 4次 copy（Proc A、Proc B 各自一次，Proc A —&gt; kernel, kernel —&gt; Proc B）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</loc>
    <lastmod>2015-03-31T06:32:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——内存管理</title>
        <pubTime>2015-01-28T13:14:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 为了高效的 IPC 通信做了很多工作，内存管理就属于其中之一。传统的 IPC 传递数据，至少需要2次拷贝，一次为进程1到内核，一次为内核到进程2，但是得益 android binder 的内存管理，数据拷贝只有1次，就从这里速度比传统的要快1倍。这里慢慢分析。还是先说下相关代码的位置（其实还有很多 linux 编程的相关基础知识）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># native binder 头文件</span></div><div class="line">frameworks/native/include/binder</div><div class="line"><span class="comment"># native binder 实现</span></div><div class="line">frameworks/native/libs/binder</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="基础知识">基础知识</h2>
<p>首先得说下一些相关的基础知识。这里很多我都是找网上现成的，因为这方面的基础知识我几乎为0 -_-||。先说下，为什么 linux 要使用虚拟地址映射物理地址，内存为什么要分页：<br><a href="http://blog.chinaunix.net/uid-26611383-id-3761754.html" title="Linux中的内存管理" target="_blank" rel="external">Linux中的内存管理</a></p>
<p>然后还有这篇有介绍 linux 用户空间和内核空间的：<br><a href="http://blog.csdn.net/f22jay/article/details/7925531" title="Linux用户空间与内核空间" target="_blank" rel="external">Linux用户空间与内核空间</a></p>
<p>然后 linux 中的内存是分页的，也就是说要按照页大小对齐。这个在后面内存分配那里能够体现出来，这里先提前说一下。</p>
<h2 id="原理">原理</h2>
<p>前面几篇也说过了，IPC 中最基本的问题在于进程间使用的虚拟地址空间是相互独立的，不能直接访问，所以要相互访问，就要借助 kernel ，就是要让数据用用户空间进入到内核空间，然后再去到另一个进程的用户空间。传统的 IPC 是这样的，其实 binder 也是这样的，不过它把内核空间的地址和用户空间的虚拟地址映射到了同一段物理地址上，所以就只需要把数据从原始用户空间复制到内核空间，把目标进程用户空间和内核空间映射到同一段物理地址，这样第一次复制到内核空间，其实目标的用户空间上也有这段数据了。这就是 binder 比传统 IPC 高效的一个原因。</p>
<p>这么抽象的文字，不太好理解吧，下面从代码慢慢看吧：</p>
<h2 id="只复制一次的实现">只复制一次的实现</h2>
<p>首先 ProcessState 初始化的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ProcessState::ProcessState()</div><div class="line">    : mDriverFD(open_driver())</div><div class="line">    , mVMStart(MAP_FAILED)</div><div class="line">    , mManagesContexts(<span class="keyword">false</span>)</div><div class="line">    , mBinderContextCheckFunc(NULL)</div><div class="line">    , mBinderContextUserData(NULL)</div><div class="line">    , mThreadPoolStarted(<span class="keyword">false</span>)</div><div class="line">    , mThreadPoolSeq(<span class="number">1</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) {</div><div class="line">        <span class="comment">// XXX Ideally, there should be a specific define for whether we</span></div><div class="line">        <span class="comment">// have mmap (or whether we could possibly have the kernel module</span></div><div class="line">        <span class="comment">// availabla).</span></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> !defined(HAVE_WIN32_IPC)</span></div><div class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></div><div class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>); </div><div class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) {</div><div class="line">            <span class="comment">// *sigh*</span></div><div class="line">            ALOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</div><div class="line">            close(mDriverFD);</div><div class="line">            mDriverFD = -<span class="number">1</span>; </div><div class="line">        }   </div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">        mDriverFD = -<span class="number">1</span>; </div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    } </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个 <code>open_driver()</code> 是打开 /dev/binder 这个设备节点。额，这里多扯下这个设备节点相关的知识。这个是 android 为 binder 驱动创建的虚拟设备节点。什么叫虚拟的咧，像触摸屏、传感器这些设备节点是有真实的物理设备的，但是 binder 确没有，只是为 IPC 创建的驱动而已，所以是虚拟的。android 上 linux 不支持动态创建设备节点，所有的设备节点都是通过 system/core/init 这个 init 程序创建的。这个东西有个配置文件，可以配置要创建哪里设备节点，默认的在 system/core/rootdir/ueventd.rc 这个文件中：</p>
<pre config="brush:bash;toolbar:false;">
/dev/null                 0666   root       root
/dev/zero                 0666   root       root
/dev/full                 0666   root       root
/dev/ptmx                 0666   root       root
/dev/tty                  0666   root       root
/dev/random               0666   root       root
/dev/urandom              0666   root       root
/dev/ashmem               0666   root       root
/dev/binder               0666   root       root
</pre>

<p>可以在 devices 下面 ueventd.xx.rc 加上自己机器板子上相关的设备节点。</p>
<p>好，回到打开 /dev/binder 那，这里有个 mmap ，前面有一篇说到这里看注释这是映射给 binder 驱动接受数据用的 buffer，但是你搜索完整个 binder 模块（frameworks/native/lib/binder）发现没一个地方使用 mVMStart 这个返回的映射地址空间。注意一下 mmap 设置的标志： <code>PROT_READ</code> 。这个标志说明映射的这段内存是只读的，当然在这个模块没使用（其实读也没用到）。</p>
<p>其实映射的这段内存是内核的 binder 驱动在使用，同时也在管理，而且这里也是前面提到的 IPC 中只复制一次的实现的地方。</p>
<p>我们去 binder 驱动中看下， mmap 经过系统调用，最后会调用 binder 驱动的 binder_mmap：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_mmap(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret; </div><div class="line">    <span class="keyword">struct</span> vm_struct *area;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line"></div><div class="line">    <span class="comment">// 限制下映射内存的大小，最大不超过 4M</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags & FORBIDDEN_MMAP_FLAGS) {</div><div class="line">        ret = -EPERM;</div><div class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</div><div class="line">        <span class="keyword">goto</span> err_bad_arg;</div><div class="line">    }</div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) & ~VM_MAYWRITE;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) {</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 在内核中申请一段内存空间，和用户空间的 malloc 差不多吧，我对内核方面的 api 了解基本为 0 -_-||</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    <span class="keyword">if</span> (area == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"get_vm_area"</span>;</div><div class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</div><div class="line">    }</div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CONFIG_CPU_CACHE_VIPT</span></div><div class="line">    <span class="keyword">if</span> (cache_is_vipt_aliasing()) {</div><div class="line">        <span class="keyword">while</span> (CACHE_COLOUR((vma-&gt;vm_start ^ (uint32_t)proc-&gt;buffer))) {</div><div class="line">            printk(KERN_INFO <span class="string">"binder_mmap: %d %lx-%lx maps %p bad alignment\n"</span>, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);</div><div class="line">            vma-&gt;vm_start += PAGE_SIZE;</div><div class="line">        }    </div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    <span class="comment">// 申请好内存页面结构所占用的内存</span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc-&gt;pages == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc page array"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</div><div class="line">    }</div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">    vma-&gt;vm_ops = &binder_vm_ops;</div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line"></div><div class="line">    <span class="comment">// 映射一个内存页（把内核空间和用户空间同时映射到同一物理地址）</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    }</div><div class="line">    <span class="comment">// 把分配好内存插入到对应的表中（空闲内存表）</span></div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    INIT_LIST_HEAD(&proc-&gt;buffers);</div><div class="line">    list_add(&buffer-&gt;entry, &proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(current);</div><div class="line">    proc-&gt;vma = vma;</div><div class="line"></div><div class="line">    printk(KERN_INFO <span class="string">"binder_mmap: %d %lx-%lx maps %p\n"</span>,</div><div class="line">         proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">err_alloc_small_buf_failed:</div><div class="line">    kfree(proc-&gt;pages);</div><div class="line">    proc-&gt;pages = NULL;</div><div class="line">err_alloc_pages_failed:</div><div class="line">    vfree(proc-&gt;buffer);</div><div class="line">    proc-&gt;buffer = NULL;</div><div class="line">err_get_vm_area_failed:</div><div class="line">err_already_mapped:</div><div class="line">err_bad_arg:</div><div class="line">    printk(KERN_ERR <span class="string">"binder_mmap: %d %lx-%lx %s failed %d\n"</span>,</div><div class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>额，从这开始要涉及到内核的一些相关知识，我其实对这些一窍不通，这里推荐去看下这里：<br><a href="http://blog.csdn.net/xiaojsj111/article/details/31422175" title="binder驱动-------之内存映射篇" target="_blank" rel="external">binder驱动———-之内存映射篇</a></p>
<p>其实我能弄明白 binder 的内存管理，很大程序上得感觉这篇博文的博，他已经说得挺清楚了的，但是还是自己再整一次记得比较深。</p>
<p>对应程序 map 内存的情况，可以通过 cat /proc/pid/maps 查看，普通走 android binder 封装的程序（就是 ProcessState 那）映射的内存大小是 1M 左右：</p>
<pre config="brush:bash;toolbar:false;">
#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))
</pre>

<p>唯独特殊的 servicemanager （它是直接通过 ioctl 来使用 binder 的）映射的内存比较小（frameworks/base/cmds/servicemanager/service_manager.c）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_state *bs;</div><div class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) {</div><div class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    svcmgr_handle = svcmgr;</div><div class="line">    binder_loop(bs, svcmgr_handler);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这片内存是接收 IPC 中客户发送过来的数据的，所以之前网上有人说使用 bundle 在 activity 之间传递数据不能太大，如果超过 1M 就会出现错误。现在明白了吧，bundle 最后是通过 binder 来传递数据的，底层接收数据的 buffer 一共才 1M（其实比1M小点，还减了8k去咧），超过 1M 肯定就失败啦。那 servicemanager 为什么才开 128k 的空间呢，去看看 servicemanager 的接口就知道了，它一共才3个接口：addService、getSerivce、checkSerivce，参数都没几个，所以 128k 肯定够了。上张图来看看吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/1.png" alt=""></p>
<p>servermanager /dev/binder map 的内存区域是： 40185000 - 401a5000（16进制的） 正好是 128*1024。那个 k7service 是我写的一个测试的 native 小程序（Bn端的），它 /dev/binder map 的内存区域是： 4020e000 - 4030c000，也正好是 1M - 4k。</p>
<p>vma 这个变量是 mmap 调用后，系统传过来的，包含了内核分配给这次 mmap 映射的内存地址的一些信息，其中就有比较重要的起始和结束地址： <code>vma-&gt;vm_start</code> 和 <code>vma-&gt;vm_end</code>。然后我们慢慢往下看，后面通过传递过来的地址计算出要映射的内存大小（这里注意下，vma 里面地址是用户空间的地址），然后使用 <code>get_vm_area</code> 这个调用向内核申请一片内存空间。这个申请的是内核空间的内存，感觉有点像上层的 malloc，我对这个也不是很了解，只能先这么认为了。再注意一点这里只是向内核申请了一片内存空间而已，还是真正的分配物理地址（建立虚拟地址到物理地址的映射关系）。</p>
<p>申请成功后，会返回一个 <code>vm_struct</code> 的结构，里面有描述这片内存区域的信息，这里把内核这片区域的起始地址 addr 保存在了 <code>proc-&gt;buffer</code> 这个变量里面。然后后面那个 <code>proc-&gt;user_buffer_offset</code> 这个变量的计算很关键：</p>
<pre config="brush:bash;toolbar:false;">
proc->user_buffer_offset = vma->vm_start - (uintptr_t)proc->buffer;
</pre>

<p>拿用户空间的地址去减内核空间的地址，得到这2个地址的偏移量（这个名字取得也很直接： <code>user_buffer_offset</code>）。前面给的一篇参考文章里说到，32位的 linux（目前的 android 还都是32位的）总共可用内存空间 4G，0G～3G 为用户空间（也就是应用程序使用的空间），3G～4G 为内核空间，用户空间无法访问内核空间，但是内核空间可以访问用户空间。所以这里申请到内核空间的地址，然后拿 mmap 传递过来的用户空间的地址去减得到偏移。但是这里有个奇怪的地方我不太理解的，这里是拿低地址 - 高地址，得到的应该是负数，但是地址是无符号的，所以得到的是 0xffffffff 减去的数值，然后后面拿这个值加上用户空间地址还能正确的得到内核空间地址，反正我是醉了。在 binder 里加了点打印，上个图来点真相（是我写的那个 k7service 的小程序）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/2.png" alt=""></p>
<p>1198 是 k7service 的 pid，然后分配的用户空间范围是： 4020e000 - 4030c000（和前面 cat 看到的一样），然后分配的内核空间起始地址是： e2f00000，确实是从 3G（0xc0000000）开始的。</p>
<p>后面 <code>proc-&gt;buffer_size</code> 就是用 mmap 传过来的地址一减就能得到映射内存的大小。后面 <code>binder_update_page_range</code> 这个函数是同时映射用户空间和内核空间，调用这个才是真正的分配物理地址，这个后面再说。</p>
<p>proc-&gt;pages 是一个指向指针的指针，struct page 是内核的代表内存页的数据结构。前面也说了 linux 带 MMU 的内存管理都是分页的（现在跑 android 的芯片基本都带 MMU）。这里是拿内核一页的大小（经过打印我手上的板子上 <code>PAGE_SIZE</code> 是 4096，也就是 4k，一般都是这大小吧），算出 mmap 映射的内存一共可以分为几页，然后事先先把保存内核页的数据结构的数组分配好。</p>
<p>然后后面那句： <code>buffer = proc-&gt;buffer;</code>。<code>proc-&gt;buffer</code> 是这片内存内核空间的首地址，这个 buffer 是一个叫 <code>binder_buffer</code> 的结构体，用来表示 binder 分配内存的块的一个块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_buffer {</div><div class="line">    <span class="keyword">struct</span> list_head entry; <span class="comment">/* free and allocated entries by addesss */</span></div><div class="line">    <span class="keyword">struct</span> rb_node rb_node; <span class="comment">/* free entry by size or allocated entry */</span></div><div class="line">                <span class="comment">/* by address */</span>               </div><div class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_node *target_node;</div><div class="line">    size_t data_size;</div><div class="line">    size_t offsets_size;</div><div class="line">    uint8_t data[<span class="number">0</span>];</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面的变量都先不说，注意看最后那个叫 data[0] 的变量。这个 data 其实表示的是地址来的。这个是怎么回事咧，其实 binder mmap 这一片内存中，是分成一块块的（<code>binder_buffer</code>），内存中的排列是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/3.png" alt=""></p>
<p>每一块数据前面跟着一个 <code>binder_buffer</code>，然后紧着下一个，一个跟一个保存在 <code>proc-&gt;buffers</code> 这个链表里。然后再看看刚刚说的那句：<code>buffer = proc-&gt;buffer;</code> 。这句话相当于是说：</p>
<ol>
<li>分配内核第一块 <code>binder_buffer</code>。</li>
<li>同时， <code>proc-&gt;buffer</code> 这个首地址就是第一个块 <code>binder_buffer</code>，并且 <code>binder_buffer</code> 的 data 就是这块 <code>binder_buffer</code> 指向的数据地址。所以这个 data 必须要放在这个结构体的最后（kernel 的链表实现则是利用结构体的首变量（地址），在这种淫荡的技能上，c 秒杀 java）。</li>
</ol>
<p>这种简洁、高效的办法，kernel 的代码中有不少，可以好好运用一下。</p>
<p>然后后面是把刚刚分配好的这块 <code>binder_buffer</code> 分别插入到 proc 的 buffers 链表和 <code>free_buffers</code> 红黑树中。这里稍微看下 <code>binder_proc</code> 中几个相关的成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc {</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root free_buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;</div><div class="line">    size_t free_async_space;</div><div class="line"></div><div class="line">    ... ...</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>



<p>这几个变量分别代表：</p>
<ul>
<li>buffers： 这个链表保存了所有已经分配的 <code>binder_buffer</code> 内存块。</li>
<li><code>free_buffers</code>: 这个红黑树保持了还未使用的 <code>binder_buffer</code> 内存块，就是已经分配了，但是没还创建物理内存映射的，说是分配倒不如说创建的好理解点，就是说 <code>binder_buffer</code> 这个结构体已经创建，然后在那片内存中占了个空位，要申请内存，可以不用重新创建对象，不用重新再那片内存重新分配。使用红黑树提高查找速度，按 <code>binder_buffer</code> 的 size 排列（后面的查找算法，会发现使用红黑树的好处）。</li>
<li><code>allocated_buffers</code>：这里保存的是已经建立好物理内存映射的 <code>binder_buffer</code> 内存块，也是说正在使用中的 <code>binder_buffer</code>。也是一颗红黑树。</li>
</ul>
<p>所以理论上，<code>proc-&gt;buffers</code> 里有所有的 <code>binder_buffer</code>，然后 <code>proc-&gt;buffers</code> 的里的是 <code>proc-&gt;free_buffers</code> 和 <code>allocated_buffers</code> 之和。</p>
<p>一般用法是刚开始新分配一个 <code>binder_buffer</code> 插入到 <code>proc-&gt;buffers</code> 里，同时也插入 <code>proc-&gt;free_buffers</code> 里。<code>binder_mmap</code> 就是一开是分配了一个 <code>binder_buffer</code>。然后后面数据来了，要申请使用 <code>binder_buffer</code> 会先在 <code>proc-&gt;free_buffers</code> 里查找大小最接近要求的 <code>binder_buffer</code> 块，然后调用 <code>binder_update_page_range</code> 将这块 <code>binder_buffer</code> 的用户空间地址和内核地址映射到物理地址（真正的分配内存），然后把这块 <code>binder_buffer</code> 从 <code>proc-&gt;free_buffers</code> 中删掉，再插入到 <code>allocated_buffers</code> 中。然后重复。当然里面还有不少细节，还有内存管理相关的，这些后面再说。</p>
<p>这里 <code>binder_mmap</code> 差不多看完了，那回去看看那个 <code>binder_update_page_range</code>，这个是将用户地址和内核地址映射到同一物理地址上，来看看是怎么做到的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_update_page_range(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> allocate,</div><div class="line">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</div><div class="line">                    <span class="keyword">struct</span> vm_area_struct *vma)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> *page_addr;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</div><div class="line">    <span class="keyword">struct</span> vm_struct tmp_area;</div><div class="line">    <span class="keyword">struct</span> page **page;</div><div class="line">    <span class="keyword">struct</span> mm_struct *mm;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (end &lt;= start)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma)</div><div class="line">        mm = NULL;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        mm = get_task_mm(proc-&gt;tsk);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mm) {</div><div class="line">        down_write(&mm-&gt;mmap_sem);</div><div class="line">        vma = proc-&gt;vma;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 第二个参数为 0 则是解除内存映射（释放内存）</span></div><div class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> free_range;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma == NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed to "</span></div><div class="line">               <span class="string">"map pages in userspace, no vma\n"</span>, proc-&gt;pid);</div><div class="line">        <span class="keyword">goto</span> err_no_vma;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 循环分配内存页面</span></div><div class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) {</div><div class="line">        <span class="keyword">int</span> ret;</div><div class="line">        <span class="keyword">struct</span> page **page_array_ptr;</div><div class="line">        <span class="comment">// 根据地址计算出所处的内存页面数组的索引</span></div><div class="line">        page = &proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</div><div class="line"></div><div class="line">        BUG_ON(*page);</div><div class="line">        <span class="comment">// 向内核申请内存页面</span></div><div class="line">        *page = alloc_page(GFP_KERNEL | __GFP_ZERO);</div><div class="line">        <span class="keyword">if</span> (*page == NULL) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed "</span></div><div class="line">                   <span class="string">"for page at %p\n"</span>, proc-&gt;pid, page_addr);</div><div class="line">            <span class="keyword">goto</span> err_alloc_page_failed;</div><div class="line">        }</div><div class="line">        <span class="comment">// 设置要映射的内核地址</span></div><div class="line">        tmp_area.addr = page_addr;</div><div class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>; </div><div class="line">        page_array_ptr = page;</div><div class="line">        <span class="comment">// 将设置好的内存页做物理内存映射（这里是内核的）</span></div><div class="line">        ret = map_vm_area(&tmp_area, PAGE_KERNEL, &page_array_ptr);</div><div class="line">        <span class="keyword">if</span> (ret) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed "</span></div><div class="line">                   <span class="string">"to map page at %p in kernel\n"</span>,</div><div class="line">                   proc-&gt;pid, page_addr);</div><div class="line">            <span class="keyword">goto</span> err_map_kernel_failed;</div><div class="line">        }</div><div class="line">        <span class="comment">// 根据前面保存的地址偏移，计算出内核地址对应的用户地址</span></div><div class="line">        user_page_addr =</div><div class="line">            (uintptr_t)page_addr + proc-&gt;user_buffer_offset;</div><div class="line">        <span class="comment">// 这里是做用户地址到物理内存的映射</span></div><div class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">if</span> (ret) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed "</span></div><div class="line">                   <span class="string">"to map page at %lx in userspace\n"</span>,</div><div class="line">                   proc-&gt;pid, user_page_addr);</div><div class="line">            <span class="keyword">goto</span> err_vm_insert_page_failed;</div><div class="line">        }</div><div class="line">        <span class="comment">/* vm_insert_page does not seem to increment the refcount */</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (mm) {</div><div class="line">        up_write(&mm-&gt;mmap_sem);</div><div class="line">        mmput(mm);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">free_range:</div><div class="line">    <span class="comment">// 这里是释放映射的</span></div><div class="line">    <span class="keyword">for</span> (page_addr = end - PAGE_SIZE; page_addr &gt;= start;</div><div class="line">         page_addr -= PAGE_SIZE) {</div><div class="line">        page = &proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</div><div class="line">        <span class="keyword">if</span> (vma)</div><div class="line">            zap_page_range(vma, (uintptr_t)page_addr +</div><div class="line">                proc-&gt;user_buffer_offset, PAGE_SIZE, NULL);</div><div class="line">err_vm_insert_page_failed:</div><div class="line">        unmap_kernel_range((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr, PAGE_SIZE);</div><div class="line">err_map_kernel_failed:</div><div class="line">        __free_page(*page);</div><div class="line">        *page = NULL;</div><div class="line">err_alloc_page_failed:</div><div class="line">        ;</div><div class="line">    }</div><div class="line">err_no_vma:</div><div class="line">    <span class="keyword">if</span> (mm) {</div><div class="line">        up_write(&mm-&gt;mmap_sem);</div><div class="line">        mmput(mm);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> -ENOMEM;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>一开始有个 end &lt;= start 的判断，后面会发现，当 end == start 的时候是表示这段内存已经映射过了。然后是那第二参数，为 0 的时候表示释放映射，我们先看映射的情况。下面是一个循环，前面说了 linux 内存是分页的，所以就要一页一页的映射，这里就是从映射起始地址到结束看需要映射几页。然后循环开始通过地址算出当前地址所在的页在之前创建的页数组中的位置，proc-&gt;pages 前面 mmap 那里提前创建好了。然后是 <code>alloc_page</code> 申请内核页面，以后有时间补补相关知识，现在暂时理解为 malloc 差不多就行了。后面设置这个页面的地址，然后大小的时候不知道为什么多加了 <code>PAGE_SIZE</code> 大小，看注释是说防止页面越界？？ <code>map_vm_area</code> 把刚刚设置的内核页面做物理内存映射，到这里才算真正分配内存。</p>
<p>这里 <code>proc-&gt;user_buffer_offset</code> 这个前面保存的内核到用户地址的偏移终于派上用场了。通过这个偏移可以算得出内核空间地址对应的用户空间地址。然后 <code>vm_insert_page</code> 把这段用户空间地址也做一次物理内存映射。这样内核空间地址和用户空间的地址就映射到同一块物理内存上了。这里由于缺少相关的知识我还是不怎么理解，这几个内核的 api 调用是咋回事，但是简单来说：如果你在 binder 驱动对内核这段地址的内存写入数据，对应用户空间的那段内存也会有同样的数据。这样就省去了一次 <code>copy_to_user</code> 的从内核空间到用户空间的数据 copy。</p>
<p>最后来张图吧，这样比较简单明了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/4.png" alt=""></p>
<h2 id="实际运用">实际运用</h2>
<p>前面说了那么多，来点例子看看是怎么运用只 copy 一次的。假设有个 proc A 发起了一次 IPC 调用，那么根据前面的讲解会通过 IPCThreadState.transact 发送到 binder 的 <code>binder_thread_write</code> 写请求，然后是跑到了 <code>binder_thread_transaction</code> 中。我们这里来看看前面 <code>binder_transaction</code> 中忽略的一些细节。在 <code>binder_transaction</code> 有这么一句：</p>
<pre config="brush:bash;toolbar:false;">
    t->buffer = binder_alloc_buf(target_proc, tr->data_size,
        tr->offsets_size, !reply && (t->flags & TF_ONE_WAY));
</pre>

<p>这里跑到了 <code>binder_alloc_buf</code> 里面，这个函数后面在内存管理那里再分析，这里向跳过，反正记住调用这个会给你返回一块符合你指定大小的 <code>buffer_size</code>（当然得有足够的内存空间）。然后这里注意一点，传递的一个参数是 <strong><code>target_proc</code></strong>，这个是从目标进程分配的 buffer，也就是 proc B。这个很关键，后面就能知道数据是怎么传递的了。然后接着看后面的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">    binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">        <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">    return_error = BR_FAILED_REPLY;</div><div class="line">    <span class="keyword">goto</span> err_copy_data_failed;     </div><div class="line">}</div><div class="line"><span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">    binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">        <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">    return_error = BR_FAILED_REPLY;</div><div class="line">    <span class="keyword">goto</span> err_copy_data_failed;     </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 <code>buffer-&gt;data</code> 的淫荡前面分析过了，这个就是这块 buffer 的存放数据的首地址。唉，这里其实调用了2次 <code>copy_from_user</code> 一次 copy parcel 的 data 数据，一次 copy parcel 里 <code>flat_binder_object</code> 的偏移地址的数据（-_-||）。其实我们就将就认为只有一次 copy 吧。这里就把 proc A 从用户空间传递过来的数据（parcel 打包）copy 到内核空间了。而且这个内核空间的内存是 proc B 提供的，而且这个块内核空间还和 proc B 的用户空间共同映射到了同一块物理内存上。</p>
<p>但是别激动先，我们把整个流程看完。根据前面的分析 <code>binder_transaction</code> 后面把从 proc B 获取了 <code>binder_buffer</code> 的 <code>binder_transaction</code> 这个数据结构插入到 proc B 的 work 队列中并且唤醒阻塞等待数据的 proc B 的 <code>binder_thread_read</code>。我们来看看 <code>binder_thread_read</code> 中前面忽略的一些比较重要的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tr.data_size = t-&gt;buffer-&gt;data_size;</div><div class="line">tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</div><div class="line">tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</div><div class="line">            proc-&gt;user_buffer_offset;      </div><div class="line">tr.data.ptr.offsets = tr.data.ptr.buffer +</div><div class="line">            ALIGN(t-&gt;buffer-&gt;data_size,    </div><div class="line">                <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));               </div><div class="line"></div><div class="line"><span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">    <span class="keyword">return</span> -EFAULT;   </div><div class="line">ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line"><span class="keyword">if</span> (copy_to_user(ptr, &tr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">    <span class="keyword">return</span> -EFAULT;   </div><div class="line">ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line"></div></pre></td></tr></table></figure>

<p>t 就是从前面 proc A <code>binder_transaction</code> 插到 proc B 的 work 队列里的，然后从它这里获取 <code>data_size</code>, <code>offsets_size</code> 之类，这些都是前面设置好的。然后观点的地方来了：</p>
<pre config="brush:bash;toolbar:false;">
        tr.data.ptr.buffer = (void *)t->buffer->data +
                    proc->user_buffer_offset; 
</pre>

<p>tr 是 <code>binder_transaction_data</code> 这个数据结构，是在用户层和 binder 驱动传递数据的数据结构。直接取 <code>buffer-&gt;data + user_buffer_offset</code> 这个地址。根据前面的分析 <code>buffer-&gt;data</code> 是前面 proc A 塞数据的内核地址，<code>user_buffer_offset</code> 是用内核地址到用户空间地址的偏移，一加就得到了同一物理地址的用户空间地址。这里其实就差不多相当于数据从 proc A 传递到 proc B 了。这里就相当于传递 IPC 内核到用户空间的那一次 copy，但是这里只是计算了一个地址偏移而已。</p>
<p>然后看看后面， <code>put_user</code> 是把 binder 命令（cmd）返回给用户空间。还有后面有一个 <code>copy_to_user</code> 但是这个不是 copy 数据的，而是 copy <code>binder_transaction_data</code> 这个数据结构，只不过这个数据结构里有传递数据的地址，所以这个不算在 binder 数据传递的复制次数中。也就是说就算传递比较大的数据，这次复制只是复制一个数据结构的大小。根据前面的分析，<code>binder_thread_read</code> 返回，<code>binder_ioctl</code> 就返回了，然后就到用户空间的 IPCThreadState 的 talkWithDriver，然后 proc B（从假设的例子看是 Bn 端）就该执行 executeCommand 的 <code>BR_TRANSACTION</code> 命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">binder_transaction_data tr;</div><div class="line">result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">ALOG_ASSERT(result == NO_ERROR,</div><div class="line">    <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line"><span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">Parcel buffer;</div><div class="line">buffer.ipcSetDataReference(</div><div class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">    tr.data_size,</div><div class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">    tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>看 <code>binder_transaction_data</code> 从 mIn 中读出来了吧，这个是前面 <code>binder_thread_read copy_to_user</code> 传递到用户空间的。然后这个里面的 tr.data.ptr.buffer 就是 proc A 传递的 IPC 函数调用参数数据啦。</p>
<h2 id="内存管理">内存管理</h2>
<p>前面把数据传递的基本流程走完了，最后看看内存管理。每一个 binder 通信的进程都 mmap 了一片内存（目前来看是 1M），然后在这片内存上按照请求分块（<code>binder_buffer</code>）。那一般就涉及到，如何分块，如果查找合适大小的 <code>binder_buffer</code> 块，以及使用完成后，碎片合并的问题。现在就来看看。</p>
<p>前面说了，一开始 binder 会映射一页的内存（一般是 4k），然后插入到 <code>proc-&gt;free_buffers</code> 中去。然后要需要使用的时候先从 <code>free_buffers</code> 里找大小最接近的，我们看看是怎么查找的，就是前面说的那个 <code>binder_alloc_buf</code> 函数啦：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_buffer *binder_alloc_buf(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          size_t data_size,              </div><div class="line">                          size_t offsets_size, <span class="keyword">int</span> is_async)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;free_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    size_t buffer_size;</div><div class="line">    <span class="keyword">struct</span> rb_node *best_fit = NULL;</div><div class="line">    <span class="keyword">void</span> *has_page_addr;</div><div class="line">    <span class="keyword">void</span> *end_page_addr;</div><div class="line">    size_t size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proc-&gt;vma == NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf, no vma\n"</span>,</div><div class="line">               proc-&gt;pid);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 计算总共需要 buffer 的大小，字节对齐</span></div><div class="line">    size = ALIGN(data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</div><div class="line">        ALIGN(offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &lt; data_size || size &lt; offsets_size) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d: got transaction with invalid "</span></div><div class="line">            <span class="string">"size %zd-%zd\n"</span>, proc-&gt;pid, data_size, offsets_size);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (is_async &&</div><div class="line">        proc-&gt;free_async_space &lt; size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer)) {</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                 <span class="string">"binder: %d: binder_alloc_buf size %zd"</span></div><div class="line">                 <span class="string">"failed, no async space left\n"</span>, proc-&gt;pid, size);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 在 free_buffers 红黑树查找大小合并的 buffer 块</span></div><div class="line">    <span class="keyword">while</span> (n) {</div><div class="line">        buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</div><div class="line">        buffer_size = binder_buffer_size(proc, buffer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (size &lt; buffer_size) {      </div><div class="line">            best_fit = n;</div><div class="line">            n = n-&gt;rb_left;   </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; buffer_size) </div><div class="line">            n = n-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            best_fit = n;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (best_fit == NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf size %zd failed, "</span></div><div class="line">               <span class="string">"no address space\n"</span>, proc-&gt;pid, size);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (n == NULL) {</div><div class="line">        buffer = rb_entry(best_fit, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        buffer_size = binder_buffer_size(proc, buffer);</div><div class="line">    }</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: binder_alloc_buf size %zd got buff"</span></div><div class="line">             <span class="string">"er %p size %zd\n"</span>, proc-&gt;pid, size, buffer, buffer_size);</div><div class="line"></div><div class="line">    <span class="comment">// 这个好像是用来地址是不是越界的吧</span></div><div class="line">    has_page_addr =</div><div class="line">        (<span class="keyword">void</span> *)(((uintptr_t)buffer-&gt;data + buffer_size) & PAGE_MASK);</div><div class="line">    <span class="comment">// n == NULL 表示没有大小精确的块，需要拆分</span></div><div class="line">    <span class="keyword">if</span> (n == NULL) {</div><div class="line">        <span class="keyword">if</span> (size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer) + <span class="number">4</span> &gt;= buffer_size)</div><div class="line">            buffer_size = size; <span class="comment">/* no room for other buffers */</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            buffer_size = size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</div><div class="line">    }</div><div class="line">    <span class="comment">// 计算所需要映射的内存的结束地址，注意页对齐</span></div><div class="line">    end_page_addr =</div><div class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + buffer_size);</div><div class="line">    <span class="keyword">if</span> (end_page_addr &gt; has_page_addr)</div><div class="line">        end_page_addr = has_page_addr;</div><div class="line">    <span class="comment">// 做物理内存映射</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>,</div><div class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr, NULL))</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line"></div><div class="line">    <span class="comment">// 从 free_buffers 中把刚刚分配的 buffer 块删掉</span></div><div class="line">    rb_erase(best_fit, &proc-&gt;free_buffers);</div><div class="line">    <span class="comment">// 标志这块 buffer 正在使用</span></div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 把这块 buffer 插入到 allocated_buffers 中</span></div><div class="line">    binder_insert_allocated_buffer(proc, buffer);</div><div class="line">    <span class="comment">// 如果要分配的 buffer_size 和原来 buffer 块不一样就要拆分</span></div><div class="line">    <span class="keyword">if</span> (buffer_size != size) {</div><div class="line">        <span class="keyword">struct</span> binder_buffer *new_buffer = (<span class="keyword">void</span> *)buffer-&gt;data + size;</div><div class="line">        <span class="comment">// 新块插入到 proc-&gt;buffers 中</span></div><div class="line">        list_add(&new_buffer-&gt;entry, &buffer-&gt;entry);</div><div class="line">        new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 新块插入到 free_buffers</span></div><div class="line">        binder_insert_free_buffer(proc, new_buffer);</div><div class="line">    }</div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: binder_alloc_buf size %zd got "</span></div><div class="line">             <span class="string">"%p\n"</span>, proc-&gt;pid, size, buffer);</div><div class="line">    buffer-&gt;data_size = data_size;</div><div class="line">    buffer-&gt;offsets_size = offsets_size;</div><div class="line">    buffer-&gt;async_transaction = is_async;</div><div class="line">    <span class="keyword">if</span> (is_async) {</div><div class="line">        proc-&gt;free_async_space -= size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</div><div class="line">                 <span class="string">"binder: %d: binder_alloc_buf size %zd "</span></div><div class="line">                 <span class="string">"async free %zd\n"</span>, proc-&gt;pid, size,</div><div class="line">                 proc-&gt;free_async_space);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> buffer;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>先说说这个函数的参数，第一个前面说了是目标进程的。后面2个 size 分别是 proc A 使用 parcel 打包的 data size 和 <code>flat_binder_object</code> 偏移数据的 size（见前一篇分析）（最后那个异步释放先不管）。这2个 size 加起来就是总共需要空间。然后后面那个 while 循环，是在从 free_buffers 的根开始查找大小合适的 buffer。<code>free_buffers</code> 红黑树按照大小排列，左子树一定比当前节点小，右子树一定比当前节点大。然后我们看下 <code>binder_buffer_size</code> 这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> size_t binder_buffer_size(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                 <span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (list_is_last(&buffer-&gt;entry, &proc-&gt;buffers))</div><div class="line">        <span class="keyword">return</span> proc-&gt;buffer + proc-&gt;buffer_size - (<span class="keyword">void</span> *)buffer-&gt;data;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> (size_t)list_entry(buffer-&gt;entry.next,</div><div class="line">            <span class="keyword">struct</span> binder_buffer, entry) - (size_t)buffer-&gt;data;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数是获取指定 <code>binder_buffer</code> 的大小，从实现可以看得出：</p>
<ol>
<li>如果这块 buffer 是最后那块，那么返回的后面剩下整块内存空间的大小。</li>
<li>如果这块 buffer 在中间，那么大小就是后面那块地址 - 当前这块地址。</li>
</ol>
<p>结合这2点可以看出这些 <code>binder_buffer</code> 在那 1M 的内存块中是连续排列的（这也为后面合并碎片块提供了便利性）。</p>
<p>从上面就能知道，如果这 1M 当中还有大于要求 size 的大小，就一定能找得到，就算分配的 buffer 没有这么大，如果找到最后那块，就是整个剩余空间的大小了。当然如果整个剩余空间都不够那就没办法了。所以上层应用写一些跨进程的功能的时候不要直接使用 binder 传递大于 1M 的数据（上面是 Bundle、Parcel 之类的），应该使用共享内存来传递（见前面一篇的分析）。</p>
<p>继续往下走，<code>best_fit == NULL</code> 表示没有足够的空间了（找不到比要求 size 大或者等于的 buffer 块）。然后能往后走说明 <code>best_fit</code> 这块至少是不小于要求 size 大小的。 n == NULL 这个判断就是说没找一块 buffer 大小正好是要求的 size 大小（实际上大小正好相等的情况是很少的），那么就意味要从这一块中分出 size 大小的出去另外做一块 buffer。所以后面重新计算了下 <code>buffer_size</code> 的大小，要加上 <code>binder_buffer</code> 结构体的大小，前面分析了，一块 buffer 前面是 <code>binder_buffer</code> 信息。</p>
<p>然后后面调用 <code>binder_update_page_range</code> 去映射物理内存。注意下，前面分析的，因为 linux 的内存是按页分的，所以映射的时候也要按页去映射，那就要按页对齐，一般一页是 4k，但是很多参数其实就几个、十几个字节。所以这里起始地址和结束地址一对齐很多情况都是相等的。所以前面那个 <code>binder_update_page_range</code> 有个判断是 end &gt;= start 就返回，这里如果 end == start 就表示这段内存已经映射过了（在同一页中）。</p>
<p>再后面就是把要用的那快 buffer 从 <code>free_buffers</code> 中删掉，然后把 free 标志改成正在使用的，插入到 <code>allocated_buffers</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_insert_allocated_buffer(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                       <span class="keyword">struct</span> binder_buffer *new_buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;allocated_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line"></div><div class="line">    BUG_ON(new_buffer-&gt;<span class="built_in">free</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        buffer = rb_entry(parent, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(buffer-&gt;<span class="built_in">free</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 按地址排列</span></div><div class="line">        <span class="keyword">if</span> (new_buffer &lt; buffer)</div><div class="line">            p = &parent-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_buffer &gt; buffer)</div><div class="line">            p = &parent-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            BUG();</div><div class="line">    }</div><div class="line">    rb_link_node(&new_buffer-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&new_buffer-&gt;rb_node, &proc-&gt;allocated_buffers);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看到 <code>allocated_buffers</code> 是按地址排列的。然后后面那个判断 <code>buffer_size != size</code>，如果前面找不到大小一样的 buffer 块，然后重新计算了 <code>buffer_size</code>， 那么如果这块 buffer 的大小比原来 size 大（这里肯定是大的，如果小的话就表示内存不够了）就要原来那块一分为二，前面拿 size 大小去用，后面剩下的作为空闲块。所以新弄了一个 <code>binder_buffer</code> 出来，然后把插入到 <code>free_buffers</code> 和 <code>proc-&gt;buffers</code> 里去了。那个 <code>proc-&gt;buffers</code> 是个链表，这里 <code>list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</code> 这种写法就是插入到这个链表的最后。然后来看插入到 <code>free_buffers</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_insert_free_buffer(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                      <span class="keyword">struct</span> binder_buffer *new_buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;free_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    size_t buffer_size;</div><div class="line">    size_t new_buffer_size;</div><div class="line"></div><div class="line">    BUG_ON(!new_buffer-&gt;<span class="built_in">free</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 计算新 buffer 的大小</span></div><div class="line">    new_buffer_size = binder_buffer_size(proc, new_buffer);</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: add free buffer, size %zd, "</span></div><div class="line">             <span class="string">"at %p\n"</span>, proc-&gt;pid, new_buffer_size, new_buffer);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        buffer = rb_entry(parent, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</div><div class="line"></div><div class="line">        buffer_size = binder_buffer_size(proc, buffer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (new_buffer_size &lt; buffer_size)</div><div class="line">            p = &parent-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p = &parent-&gt;rb_right;</div><div class="line">    }</div><div class="line">    rb_link_node(&new_buffer-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&new_buffer-&gt;rb_node, &proc-&gt;free_buffers);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数主要注意 <code>new_buffer_size = binder_buffer_size(proc, new_buffer);</code> 。从这里可以看得出，这些空闲的 buffer 是不保存本块的大小的，都是要用的时候现场计算的。然后这里证实了 <code>free_buffers</code> 是按大小排列的了。</p>
<p>然后我们来看看使用完之后释放这些 buffer 块的情况。前一篇 parcel 那里说到 Parcel 里有一个叫 mOwner 的函数指针，如果设置了的话，会在 parcel 的析够函数里调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Parcel::~Parcel()</div><div class="line">{</div><div class="line">    freeDataNoInit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::freeDataNoInit()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">        <span class="comment">//ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());</span></div><div class="line">        mOwner(<span class="keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        releaseObjects();</div><div class="line">        <span class="keyword">if</span> (mData) <span class="built_in">free</span>(mData);</div><div class="line">        <span class="keyword">if</span> (mObjects) <span class="built_in">free</span>(mObjects);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在 parcel 中设置 mOwner 的地方是 ipcSetDataReference 这个方法。然后在 IPCThreadState 有2个地方会调用 ipcSetDataReference 设置一个叫 freeBuffer 的函数：</p>
<p>一个是在 waitForResponse 中的 BR_REPLY 的命令那里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BR_REPLY:</div><div class="line">    {</div><div class="line">        binder_transaction_data tr;    </div><div class="line">        err = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">        ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (reply) {</div><div class="line">            <span class="keyword">if</span> ((tr.flags & TF_STATUS_CODE) == <span class="number">0</span>) {</div><div class="line">                reply-&gt;ipcSetDataReference(    </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer), </div><div class="line">                    tr.data_size,                  </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets), </div><div class="line">                    tr.offsets_size/<span class="keyword">sizeof</span>(size_t),</div><div class="line">                    freeBuffer, <span class="keyword">this</span>);             </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                err = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> status_t*&gt;(tr.data.ptr.buffer);</div><div class="line">                freeBuffer(NULL,               </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer), </div><div class="line">                    tr.data_size,                  </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets), </div><div class="line">                    tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">            }  </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            freeBuffer(NULL,               </div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer), </div><div class="line">                tr.data_size,                  </div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets), </div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">goto</span> finish;</div><div class="line"></div></pre></td></tr></table></figure>

<p>一个是在 executeCommand 的 BR_TRANSACTION 的命令那：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        {</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ALOG_ASSERT(result == NO_ERROR,</div><div class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) {</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                <span class="keyword">const</span> status_t error = b-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">const</span> status_t error = the_context_object-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后回到通信篇那里去看看我之前画的那张图，注意设置 freeBuffer 全都是 BR 命令，一个是 executeCommand， 这个是 Bn 端那里。在 <code>BR_TRANSACTION</code> 命令里定义了一个本地变量 Parcel buffer，并且给这个 parcel 设置了 feeBuffer。然后作为参数传递给后面执行 Bn 端的 transaction 实现远程调用。然后这个 executeCommand 执行完后，就会执行 Parcel 的析够函数从而触发 freeBuffer 的调用。freeBuffer 的实现我们后面再说，里面是让 binder 去释放之前申请的 buffer 块。然后前面说了 proc A 发起 IPC，binder 里面是用 proc B（也就是 Bn 端）来的内存来申请 buffer 的。所以这里在 proc B 设置释放 buffer 的函数是合理的。</p>
<p>然后第二个 waitForResponse 也是差不多的。前面那个是在 Bn 端释放，是 Bp —&gt; Bn 发送请求，target 是 Bn，这里呢是从 Bn 返回结果到 Bp，就是 Bn —&gt; Bp， target 就是 Bp 了（proc A）。waitForResponse 的参数 Parcel reply 是从 Bp 的 IPCThreadState 的 transact 传递过来的，这个就是上层发起 IPC 那个接口函数传递过来的，也是一个本地变量，transact 调用完成后就会调用 Parcel 的析够函数触发释放函数。这里是从 Bn 返回到 Bp，申请的内存就是 Bp 端的，所以在 Bp 释放也是对的。</p>
<p>通过上面先得搞清楚，内存从哪个进程来的，在哪个进程释放。基本上在谁那拿的，就由谁来释放。搞清楚后，现在可以看看 freeBuffer 的实现了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::freeBuffer(Parcel* parcel, <span class="keyword">const</span> uint8_t* data, size_t dataSize,</div><div class="line">                                <span class="keyword">const</span> size_t* objects, size_t objectsSize,</div><div class="line">                                <span class="keyword">void</span>* cookie)                  </div><div class="line">{</div><div class="line">    <span class="comment">//ALOGI("Freeing parcel %p", &parcel);</span></div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        alog &lt;&lt; <span class="string">"Writing BC_FREE_BUFFER for "</span> &lt;&lt; data &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    ALOG_ASSERT(data != NULL, <span class="string">"Called with NULL data"</span>);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) parcel-&gt;closeFileDescriptors();</div><div class="line">    IPCThreadState* state = self();</div><div class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</div><div class="line">    state-&gt;mOut.writeInt32((int32_t)data);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个通过 mOut 对 binder 写了一个 <code>BC_FREE_BUFFER</code> 的命令，然后把保存的 buffer 块的用户空间的地址也写了进去。这些内存都是由 kernel 的 binder 驱动管理的，所以只能由 binder 驱动来释放，用户空间无法释放的。这样的话这个进程下次和 binder 进行通信的时候，就会由 <code>BINDER_WRITE_READ</code> ioctl 把这条命令写到 binder 驱动中去。binder 驱动就会执行 <code>BC_FREE_BUFFER</code> 释放使用完的 <code>binder_buffer</code> 内存块。还记得前面说 parcel 打包 binder 命令（或是解析）可以打包多条命令的么，这里就体现出来了。释放命令是随真正的业务命令一起打包发送过去的。</p>
<p>然后我们可以回到 binder 驱动里，看看 <code>BC_FREE_BUFFER</code> 的处理，这个在 <code>binder_thread_write</code> 里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BC_FREE_BUFFER: {</div><div class="line">    <span class="keyword">void</span> __user *data_ptr;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;  </div><div class="line"></div><div class="line">    <span class="comment">// 获取用户传递过来 buffer 的地址</span></div><div class="line">    <span class="keyword">if</span> (get_user(data_ptr, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;</div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"></div><div class="line">    <span class="comment">// 通过地址查找 buffer 块</span></div><div class="line">    buffer = binder_buffer_lookup(proc, data_ptr);</div><div class="line">    <span class="keyword">if</span> (buffer == NULL) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">            <span class="string">"BC_FREE_BUFFER u%p no match\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, data_ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!buffer-&gt;allow_user_free) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">            <span class="string">"BC_FREE_BUFFER u%p matched "</span>  </div><div class="line">            <span class="string">"unreturned buffer\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, data_ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    binder_debug(BINDER_DEBUG_FREE_BUFFER,</div><div class="line">             <span class="string">"binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction\n"</span>,</div><div class="line">             proc-&gt;pid, thread-&gt;pid, data_ptr, buffer-&gt;debug_id,</div><div class="line">             buffer-&gt;transaction ? <span class="string">"active"</span> : <span class="string">"finished"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer-&gt;transaction) {</div><div class="line">        buffer-&gt;transaction-&gt;buffer = NULL;</div><div class="line">        buffer-&gt;transaction = NULL;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (buffer-&gt;async_transaction && buffer-&gt;target_node) {</div><div class="line">        BUG_ON(!buffer-&gt;target_node-&gt;has_async_transaction);</div><div class="line">        <span class="keyword">if</span> (list_empty(&buffer-&gt;target_node-&gt;async_todo))</div><div class="line">            buffer-&gt;target_node-&gt;has_async_transaction = <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &thread-&gt;todo);</div><div class="line">    }</div><div class="line">    <span class="comment">// 释放资源</span></div><div class="line">    binder_transaction_buffer_release(proc, buffer, NULL);</div><div class="line">    binder_free_buf(proc, buffer); </div><div class="line">    <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>通过 <code>get_user</code> 得到从用户空间传递过来要释放的 buffer 的地址。然后调用 <code>binder_buffer_lookup</code> 查找 buffer 块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_buffer *binder_buffer_lookup(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          <span class="keyword">void</span> __user *user_ptr)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;allocated_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *kern_ptr;</div><div class="line">                </div><div class="line">    <span class="comment">// 通过偏移由用户空间地址计算出内核空间地址</span></div><div class="line">    kern_ptr = user_ptr - proc-&gt;user_buffer_offset</div><div class="line">        - offsetof(<span class="keyword">struct</span> binder_buffer, data);</div><div class="line">                </div><div class="line">    <span class="comment">// 在已经映射的 buffer 红黑树中查找</span></div><div class="line">    <span class="keyword">while</span> (n) { </div><div class="line">        buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(buffer-&gt;<span class="built_in">free</span>);</div><div class="line">                    </div><div class="line">        <span class="keyword">if</span> (kern_ptr &lt; buffer)</div><div class="line">            n = n-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kern_ptr &gt; buffer)</div><div class="line">            n = n-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>user_buffer_offset</code> 的作用又来了，这里是通过用户空间地址计算出对应的内核空间地址。前面说了 <code>allocated_buffers</code> 是按地址排列的，所以通过地址查找。</p>
<p>然后后面先看看 <code>binder_transaction_buffer_release</code> 的释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction_buffer_release(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          <span class="keyword">struct</span> binder_buffer *buffer,  </div><div class="line">                          size_t *failed_at)             </div><div class="line">{</div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">int</span> debug_id = buffer-&gt;debug_id;</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">             <span class="string">"binder: %d buffer release %d, size %zd-%zd, failed at %p\n"</span>,</div><div class="line">             proc-&gt;pid, buffer-&gt;debug_id,   </div><div class="line">             buffer-&gt;data_size, buffer-&gt;offsets_size, failed_at);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer-&gt;target_node)</div><div class="line">        binder_dec_node(buffer-&gt;target_node, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    offp = (size_t *)(buffer-&gt;data + ALIGN(buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    <span class="keyword">if</span> (failed_at)</div><div class="line">        off_end = failed_at;  </div><div class="line">    <span class="keyword">else</span></div><div class="line">        off_end = (<span class="keyword">void</span> *)offp + buffer-&gt;offsets_size; </div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line">        <span class="keyword">struct</span> flat_binder_object *fp; </div><div class="line">        <span class="keyword">if</span> (*offp &gt; buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: transaction release %d bad"</span></div><div class="line">                    <span class="string">"offset %zd, size %zd\n"</span>, debug_id,</div><div class="line">                    *offp, buffer-&gt;data_size);     </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) {</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: {</div><div class="line">            <span class="keyword">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;binder);</div><div class="line">            <span class="keyword">if</span> (node == NULL) {            </div><div class="line">                printk(KERN_ERR <span class="string">"binder: transaction release %d"</span></div><div class="line">                       <span class="string">" bad node %p\n"</span>, debug_id, fp-&gt;binder);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        node %d u%p\n"</span>,       </div><div class="line">                     node-&gt;debug_id, node-&gt;ptr);    </div><div class="line">            binder_dec_node(node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                printk(KERN_ERR <span class="string">"binder: transaction release %d"</span></div><div class="line">                       <span class="string">" bad handle %ld\n"</span>, debug_id,</div><div class="line">                       fp-&gt;handle);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        ref %d desc %d (node %d)\n"</span>,</div><div class="line">                     ref-&gt;debug_id, ref-&gt;desc, ref-&gt;node-&gt;debug_id);</div><div class="line">            binder_dec_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD:</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        fd %ld\n"</span>, fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (failed_at)</div><div class="line">                task_close_fd(proc, fp-&gt;handle);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: transaction release %d bad "</span></div><div class="line">                   <span class="string">"object type %lx\n"</span>, debug_id, fp-&gt;type);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 buffer 后面保存了 parcel <code>flat_binder_object</code> 的偏移数据，这里是去取这个偏移，然后通过这些偏移取到打包在 parcel 里面的 <code>flat_binder_object</code> 数据，然后去根据不同的类型去减少引用之类的（前面使用的时候会增加相应的引用）。我是比较讨厌这些啥引用计算的，这里就随便过过就行了。</p>
<p>然后看后面的 <code>binder_free_buf</code>， 这个和 <code>binder_alloc_buf</code> 真对应啊：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_free_buf(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                <span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    size_t size, buffer_size;</div><div class="line"></div><div class="line">    <span class="comment">// 获取这块 buffer 的大小</span></div><div class="line">    buffer_size = binder_buffer_size(proc, buffer);</div><div class="line"></div><div class="line">    <span class="comment">// 计算 buffer 的 size 大小，注意字节对齐</span></div><div class="line">    size = ALIGN(buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</div><div class="line">        ALIGN(buffer-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: binder_free_buf %p size %zd buffer"</span></div><div class="line">             <span class="string">"_size %zd\n"</span>, proc-&gt;pid, buffer, size, buffer_size);</div><div class="line"></div><div class="line">    BUG_ON(buffer-&gt;<span class="built_in">free</span>);</div><div class="line">    BUG_ON(size &gt; buffer_size);</div><div class="line">    BUG_ON(buffer-&gt;transaction != NULL);</div><div class="line">    BUG_ON((<span class="keyword">void</span> *)buffer &lt; proc-&gt;buffer);</div><div class="line">    BUG_ON((<span class="keyword">void</span> *)buffer &gt; proc-&gt;buffer + proc-&gt;buffer_size);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer-&gt;async_transaction) {</div><div class="line">        proc-&gt;free_async_space += size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</div><div class="line"></div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</div><div class="line">                 <span class="string">"binder: %d: binder_free_buf size %zd "</span></div><div class="line">                 <span class="string">"async free %zd\n"</span>, proc-&gt;pid, size,</div><div class="line">                 proc-&gt;free_async_space);       </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 释放物理映射</span></div><div class="line">    binder_update_page_range(proc, <span class="number">0</span>,</div><div class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data),</div><div class="line">        (<span class="keyword">void</span> *)(((uintptr_t)buffer-&gt;data + buffer_size) & PAGE_MASK),</div><div class="line">        NULL);</div><div class="line">    <span class="comment">// 从 allocated_buffers 删除这块 buffer</span></div><div class="line">    rb_erase(&buffer-&gt;rb_node, &proc-&gt;allocated_buffers);</div><div class="line">    <span class="comment">// 设置空闲标志位</span></div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 向后查看有没有可以合并的空闲块</span></div><div class="line">    <span class="keyword">if</span> (!list_is_last(&buffer-&gt;entry, &proc-&gt;buffers)) {</div><div class="line">        <span class="keyword">struct</span> binder_buffer *next = list_entry(buffer-&gt;entry.next, </div><div class="line">                        <span class="keyword">struct</span> binder_buffer, entry);  </div><div class="line">        <span class="keyword">if</span> (next-&gt;<span class="built_in">free</span>) {</div><div class="line">            rb_erase(&next-&gt;rb_node, &proc-&gt;free_buffers);</div><div class="line">            binder_delete_free_buffer(proc, next);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 向前查看下有没有可以合并的空闲块</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffers.next != &buffer-&gt;entry) {</div><div class="line">        <span class="keyword">struct</span> binder_buffer *prev = list_entry(buffer-&gt;entry.prev,</div><div class="line">                        <span class="keyword">struct</span> binder_buffer, entry);</div><div class="line">        <span class="keyword">if</span> (prev-&gt;<span class="built_in">free</span>) {</div><div class="line">            binder_delete_free_buffer(proc, buffer);</div><div class="line">            rb_erase(&prev-&gt;rb_node, &proc-&gt;free_buffers);</div><div class="line">            buffer = prev;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 把合并好的块插入到 free_buffers 中，以供下次使用</span></div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里调用 <code>binder_update_page_range</code> 是第二个参数是传递 0 了，就表示是要释放物理内存映射，这个前面已经分析过了。然后从 <code>allocated_buffers</code> 中删掉这块 buffer，把 free 标志也设置一下。重点在后面：</p>
<p>判断这块是不是最后一块 buffer，这里其实就是向后查看后面那块 buffer 是不是也是 free 的（前面说 <code>proc-&gt;buffers</code> 是一个链表）。如果是的话，表示可以把这2块合并成一个更大的 buffer 块。这里插一句内存管理方面的常识，空闲的 buffer 块越大，下次申请成功概率就越大，所以要保证空闲 buffer 块尽量的大。如果 buffer 都是零零星星很小、数量很多的小块，那么下次申请很可能会失败，但是总体空间的大小却是够的，也就是我们常说的内存碎片。要尽可能的避免内存碎片，所以才需要有内存合并的处理。</p>
<p>那看看怎么合并的。要合并的话，先把后面那块从 <code>free_buffers</code> 中删掉，然后调用 <code>binder_delete_buffer</code> 去删除：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_delete_free_buffer(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                      <span class="keyword">struct</span> binder_buffer *buffer)  </div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_buffer *prev, *next = NULL;</div><div class="line">    <span class="comment">// 这2个标志，表示要释放的 buffer 是否于其他的 buffer 共用一个内存页</span></div><div class="line">    <span class="keyword">int</span> free_page_end = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> free_page_start = <span class="number">1</span>;</div><div class="line"></div><div class="line">    BUG_ON(proc-&gt;buffers.next == &buffer-&gt;entry);</div><div class="line">    prev = list_entry(buffer-&gt;entry.prev, <span class="keyword">struct</span> binder_buffer, entry);</div><div class="line">    <span class="comment">// 要释放这块 buffer，前面那个块必须是 free 的</span></div><div class="line">    BUG_ON(!prev-&gt;<span class="built_in">free</span>);</div><div class="line">    <span class="comment">// 查看这块 buffer 是否与前面一块 buffer 共用一个内存页</span></div><div class="line">    <span class="keyword">if</span> (buffer_end_page(prev) == buffer_start_page(buffer)) {</div><div class="line">        free_page_start = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">if</span> (buffer_end_page(prev) == buffer_end_page(buffer))</div><div class="line">            free_page_end = <span class="number">0</span>;</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                 <span class="string">"binder: %d: merge free, buffer %p "</span></div><div class="line">                 <span class="string">"share page with %p\n"</span>, proc-&gt;pid, buffer, prev);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 查看这块 buffer 是否于后面一块 buffer 共用一个内存页</span></div><div class="line">    <span class="keyword">if</span> (!list_is_last(&buffer-&gt;entry, &proc-&gt;buffers)) {</div><div class="line">        next = list_entry(buffer-&gt;entry.next, </div><div class="line">                  <span class="keyword">struct</span> binder_buffer, entry);  </div><div class="line">        <span class="keyword">if</span> (buffer_start_page(next) == buffer_end_page(buffer)) {</div><div class="line">            free_page_end = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (buffer_start_page(next) == </div><div class="line">                buffer_start_page(buffer))     </div><div class="line">                free_page_start = <span class="number">0</span>;           </div><div class="line">            <span class="comment">// PS 这个打印写错了吧，不是 prev 而是 next 吧 -_-||</span></div><div class="line">            binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                     <span class="string">"binder: %d: merge free, buffer"</span></div><div class="line">                     <span class="string">" %p share page with %p\n"</span>, proc-&gt;pid,</div><div class="line">                     buffer, prev);                 </div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 从 proc-&gt;buffers 删除这块 buffer</span></div><div class="line">    list_del(&buffer-&gt;entry); </div><div class="line">    <span class="comment">// 如果这块 buffer 不与前面和后面的 buffer 共用一个内存页的话，</span></div><div class="line">    <span class="comment">// 那就释放掉这块 buffer 所在的内存页的映射</span></div><div class="line">    <span class="keyword">if</span> (free_page_start || free_page_end) {</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                 <span class="string">"binder: %d: merge free, buffer %p do "</span></div><div class="line">                 <span class="string">"not share page%s%s with with %p or %p\n"</span>,</div><div class="line">                 proc-&gt;pid, buffer, free_page_start ? <span class="string">""</span> : <span class="string">" end"</span>, </div><div class="line">                 free_page_end ? <span class="string">""</span> : <span class="string">" start"</span>, prev, next);</div><div class="line">        binder_update_page_range(proc, <span class="number">0</span>, free_page_start ?</div><div class="line">            buffer_start_page(buffer) : buffer_end_page(buffer),</div><div class="line">            (free_page_end ? buffer_end_page(buffer) :</div><div class="line">            buffer_start_page(buffer)) + PAGE_SIZE, NULL);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到那个 <code>BUG_ON(!prev-&gt;free)</code> 感觉这个函数就是内存合并专用的，要调用这个释放 buffer 块，还必须前面那个块是 free 的，合并的时候就是这样（仔细看下前面，向前合并的时候，删除的是自己，所以前面那个也是 free 的）。然后后面的的判断是检测要释放的这块 buffer 所在的页面是不是别的 buffer 也在用。因为前面说了好几次了，一般一页是 4k， IPC 的参数经常只有几个、十几个字节而已，所以经常会一个页里面有好块 buffer。所以就向前（前一块）和向后（后一块）检测下自己的邻居是否和自己共用一个内存页：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *buffer_start_page(<span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)((uintptr_t)buffer & PAGE_MASK);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *buffer_end_page(<span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)(((uintptr_t)(buffer + <span class="number">1</span>) - <span class="number">1</span>) & PAGE_MASK);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>检测方法和前面差不多就是拿地址进行页面内存对齐。看对齐后的地址是不是落在一起。然后设置2个标志。在最后判断，只要前后有一块 buffer 和自己共用一页就不释放这片地址的物理内存映射。否则就调用 <code>binder_update_page_range</code> 去把自己映射的这片物理内存释放掉。以前在大学里面听老师说内存对齐的问题是最麻烦的，后来敲了几年代码没啥感觉，现在深深感受到恶意啦，页面对齐、字节对齐 -_-||。</p>
<p>回到 <code>binder_free_buf</code>，向后合并是删掉后面那块（next），向前合并是删掉自己（buffer），拿 prev 重新当作自己。最后 <code>binder_insert_free_buffer</code> 把合并之后的 buffer 重新插入到 <code>proc-&gt;free_buffers</code> 中供下次申请的时候使用。</p>
<p>这个做法其实我和以前弄 MiniGUI 的一个 GAL 中的显存管理很类似，简单但是有效，可以来这里对比一下（那里还有图说明）： <a href="http://light3moon.com/2015/01/21/STi7167 GAL 开发笔记/#显存管理" title="STi7167 GAL 显存管理" target="_blank" rel="external">STi7167 GAL 显存管理</a> </p>
<h2 id="总结">总结</h2>
<p>感觉 binder 下了不少功夫进行效率的优化：</p>
<ol>
<li>通过将内核地址和用户地址映射到同一个物理地址以减少数据传递中 copy 的次数。</li>
<li>自己进行内存管理、快速查找（红黑树）、合并碎片。</li>
<li>线程池支持，提供高服务端并发的响应能力（后面再分析）。</li>
<li>以及等等 … … </li>
</ol>
<p>另外 binder 还提供调用者和目的地的 pid 验证，对 IPC 的安全性也有提高。并且对上层提供友好的封装接口以及偷懒的代码自动生成工具（aidl），易用上也比传递 IPC 好。现在稍微能理解点 android 为什么要自己搞一套 IPC 的机制了。据说标准的 linux kernel 3.xx 好像加入 binder 了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%20Binder%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%A0%E9%80%92/</loc>
    <lastmod>2015-03-31T06:31:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——系统服务 Binder 对象的传递</title>
        <pubTime>2015-01-28T13:23:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>前面 binder 说了那多，但是有一个关键的一点前面忽略掉了，就是 binder 对象是传递给另外一个进程使用的，然后还引伸出一个问题，Proc A 是怎么通过 binder 接口找到 Proc B 进行 IPC 调用的。</p>
<p>那这篇主要就是分析这些，照例先把源代码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java 层 Service Manager 接口</span></div><div class="line">frameworks/base/core/java/android/os/IServiceManager.java</div><div class="line">frameworks/base/core/java/android/os/ServiceManagerNative.java</div><div class="line">frameworks/base/core/java/android/os/ServiceManager.java</div><div class="line">frameworks/base/core/java/com/android/internal/os/BinderInternal.java</div><div class="line"></div><div class="line"><span class="comment"># jni Service Manager 接口</span></div><div class="line">frameworks/base/core/jni/android_util_Binder.cpp</div><div class="line"></div><div class="line"><span class="comment"># Service Manager 模块（app）</span></div><div class="line">frameworks/native/cmds/servicemanager</div><div class="line"></div><div class="line"><span class="comment"># native 层 Service Manager 接口</span></div><div class="line">frameworks/native/include/binder/IServiceManager.h</div><div class="line">frameworks/native/include/binder/BinderService.h</div><div class="line">frameworks/native/libs/binder/IServiceManager.cpp</div><div class="line">frameworks/native/libs/binder/ProcessState.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<p>binder 对象的传递分为2种：一种是系统服务的 binder 对象（System Service，简称 SS 吧），一种是普通的第三方应用的服务。为什么会有这2种区别咧，主要是因为 SS 有 ServiceManager（简称 SM 吧）来管理（其实是保存）SS 的 binder 对象，所以可以直接向 SM 取，而第三方应用的服务没 SM 的待遇。 </p>
<h2 id="SM_相关接口">SM 相关接口</h2>
<h3 id="natvie_层接口">natvie 层接口</h3>
<p>在说 SM 之前，我们把 SM 的相关接口说下，也就是 SS 是怎么使用的。SM 的接口就下面4个（我的贴的是 native 层的，马甲 java 层的不贴了，一样的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IServiceManager.h ===========================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Retrieve an existing service, blocking for a few seconds</span></div><div class="line"><span class="comment">     * if it doesn't yet exist.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;         getService( <span class="keyword">const</span> String16& name) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Retrieve an existing service, non-blocking.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;         checkService( <span class="keyword">const</span> String16& name) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Register a service.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> status_t            addService( <span class="keyword">const</span> String16& name,</div><div class="line">                                            <span class="keyword">const</span> sp&lt;IBinder&gt;& service,</div><div class="line">                                            <span class="keyword">bool</span> allowIsolated = <span class="keyword">false</span>) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Return list of all existing services.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> Vector&lt;String16&gt;    listServices() = <span class="number">0</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>常用的就2个： addService 和 getService。一个拿来注册、一个用来取。这里你会觉得奇怪怎么没有 removeService， SM 是 SS 专用的，SS 正常来说直到系统 shutdown（reboot），都一直存在的，所以不需要 remove。</p>
<p>我们从实际使用来看看 SM 的接口怎么使用。先说 natvie 层的，以 SurfaceFlinger（SF） 为例，在 SF 的 main 函数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main_surfaceflinger.cpp ===========================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></div><div class="line">    <span class="comment">// binder threads to 4.</span></div><div class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">// start the thread pool</span></div><div class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">    ps-&gt;startThreadPool();</div><div class="line"></div><div class="line">    <span class="comment">// instantiate surfaceflinger</span></div><div class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_PTHREADS)</span></div><div class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</div><div class="line"></div><div class="line">    <span class="comment">// initialize before clients can connect</span></div><div class="line">    flinger-&gt;init();</div><div class="line"></div><div class="line">    <span class="comment">// 关键的2句话，第一个句获取 SM 的接口（Bp 端）</span></div><div class="line">    <span class="comment">// publish surface flinger</span></div><div class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">    <span class="comment">// 调用 addService 向 SM 注册</span></div><div class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// run in this thread</span></div><div class="line">    flinger-&gt;run();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面说了 SS（SF 姑且算 natvie 的 SS 吧） 的原理是，通过向 SM 注册，然其它进程可以通过 SM 取到 SS 的 binder 对象。由于本身向 SM 注册就是跨进程的操作，那么 SS 是怎么取到 SM 的 binder 对象的呢。这是不是有点像鸡生蛋、蛋生鸡呢。结论是 SM 的 binder 对象是特殊的，可以通过特殊的方法可以取得到。</p>
<p>这个 defaultServiceManager() 是 IServiceManager 中的一个全局函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (gDefaultServiceManager != NULL) <span class="keyword">return</span> gDefaultServiceManager;</div><div class="line">                                            </div><div class="line">    {</div><div class="line">        AutoMutex _l(gDefaultServiceManagerLock);</div><div class="line">        <span class="keyword">while</span> (gDefaultServiceManager == NULL) {</div><div class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</div><div class="line">                ProcessState::self()-&gt;getContextObject(NULL));</div><div class="line">            <span class="keyword">if</span> (gDefaultServiceManager == NULL)</div><div class="line">                sleep(<span class="number">1</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> gDefaultServiceManager;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>关键的在于 ProcessState 的 getContextObject：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;& caller)</div><div class="line">{</div><div class="line">    <span class="comment">// 注意这个 0，这个 handle 是 0 就是特殊的地方</span></div><div class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</div><div class="line">}</div><div class="line"></div><div class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</div><div class="line">{</div><div class="line">    sp&lt;IBinder&gt; result;</div><div class="line"></div><div class="line">    AutoMutex _l(mLock);</div><div class="line"></div><div class="line">    handle_entry* e = lookupHandleLocked(handle);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e != NULL) {</div><div class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></div><div class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></div><div class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></div><div class="line">        IBinder* b = e-&gt;binder;        </div><div class="line">        <span class="keyword">if</span> (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) {</div><div class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) {</div><div class="line">                <span class="comment">// Special case for context manager...</span></div><div class="line">                <span class="comment">// The context manager is the only object for which we create</span></div><div class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></div><div class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></div><div class="line">                <span class="comment">// is registered before we create the first local reference</span></div><div class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></div><div class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></div><div class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></div><div class="line">                <span class="comment">// provide a reference to the context manager, but the</span></div><div class="line">                <span class="comment">// driver API does not return status.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></div><div class="line">                <span class="comment">// dies while this code runs.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// TODO: add a driver API to wait for context manager, or</span></div><div class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></div><div class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></div><div class="line">                <span class="comment">// proper reference counting.</span></div><div class="line"></div><div class="line">                Parcel data;</div><div class="line">                status_t status = IPCThreadState::self()-&gt;transact(</div><div class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, NULL, <span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</div><div class="line">                   <span class="keyword">return</span> NULL;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 以 handle 0 创建了 Bp 端对象</span></div><div class="line">            b = <span class="keyword">new</span> BpBinder(handle);</div><div class="line">            e-&gt;binder = b;</div><div class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</div><div class="line">            result = b;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></div><div class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></div><div class="line">            <span class="comment">// but another team is sending the handle to us.</span></div><div class="line">            result.force_set(b);</div><div class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那一串长长注释好像是说为了验证 SM 是不是已经注册到 binder 驱动里面去了（后面会说到），所以要 ping 一下。前面那个 lookupHandleLocked 好像是 cache 之类的东西，也不管先。还有那几个我讨厌的引用计数也不管先。最关键的是通过这个函数创建了一个 handle 为 0 的 Bp 端对象。前面几篇说过 handle 就是 binder 对象寻找目标的关键，其他的 Bp handle 都是动态分配的，只有这个 0 是代表 SM 的。</p>
<p>取得 Bp 端之后，就可以调用 IPC 接口了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IServiceManager.cpp  ==============================</span></div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; getService(<span class="keyword">const</span> String16& name) <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">unsigned</span> n;           </div><div class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">5</span>; n++){       </div><div class="line">            sp&lt;IBinder&gt; svc = checkService(name);</div><div class="line">            <span class="keyword">if</span> (svc != NULL) <span class="keyword">return</span> svc;   </div><div class="line">            ALOGI(<span class="string">"Waiting for service %s...\n"</span>, String8(name).<span class="built_in">string</span>());</div><div class="line">            sleep(<span class="number">1</span>);         </div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; checkService( <span class="keyword">const</span> String16& name) <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</div><div class="line">        data.writeString16(name);      </div><div class="line">        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &reply);</div><div class="line">        <span class="keyword">return</span> reply.readStrongBinder();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> status_t addService(<span class="keyword">const</span> String16& name, <span class="keyword">const</span> sp&lt;IBinder&gt;& service,</div><div class="line">            <span class="keyword">bool</span> allowIsolated)            </div><div class="line">    {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</div><div class="line">        data.writeString16(name);      </div><div class="line">        data.writeStrongBinder(service);</div><div class="line">        data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &reply);</div><div class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 Parcel 篇说了 parcel 怎么打包 binder 对象的（<code>flat_binder_object</code>）的，这里就没啥难度了。不过你翻遍 IServiceManager.cpp 你发现怎么只有 Bp 端的实现，没有 Bn 端的实现，这好像不太科学。那因为 SM 本身就没用 Binder 面向对象那套东西，当然不会有谁去实现 Bn 端。这个我们在讲 SM 之前，还得先把 java 层的接口讲完先。</p>
<h3 id="java_层接口">java 层接口</h3>
<p>同样，我们拿 java 层的 ActivityManager（AM）为例看看 java 层的 SM 接口怎么用，下面是 AM 的一个初始化函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActivityManagerService.java ===============================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span>() {</div><div class="line">        <span class="keyword">try</span> { </div><div class="line">            ActivityManagerService m = mSelf;</div><div class="line"></div><div class="line">            <span class="comment">// java 层的好方便呐，static 函数直接调用</span></div><div class="line">            ServiceManager.addService(Context.ACTIVITY_SERVICE, m, <span class="keyword">true</span>);</div><div class="line">            ServiceManager.addService(ProcessStats.SERVICE_NAME, m.mProcessStats);</div><div class="line">            ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(m));</div><div class="line">            ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(m));</div><div class="line">            ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(m));</div><div class="line">            <span class="keyword">if</span> (MONITOR_CPU_USAGE) {</div><div class="line">                ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(m));</div><div class="line">            }     </div><div class="line">            ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(m));</div><div class="line"></div><div class="line">... ...</div><div class="line">        } <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Unable to find android system package"</span>, e);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>java 层的 SM 接口在 ServiceManager 这个类中，而且都是 static 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceManager.java ===========================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Returns a reference to a service with the given name.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param name the name of the service to get</span></div><div class="line"><span class="comment">     * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span>(String name) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            IBinder service = sCache.get(name);</div><div class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">return</span> service;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">return</span> getIServiceManager().getService(name);</div><div class="line">            }     </div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Log.e(TAG, <span class="string">"error in getService"</span>, e);</div><div class="line">        } </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Place a new @a service called @a name into the service</span></div><div class="line"><span class="comment">     * manager.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param name the name of the new service</span></div><div class="line"><span class="comment">     * @param service the service object</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span>(String name, IBinder service) {</div><div class="line">        <span class="keyword">try</span> {   </div><div class="line">            getIServiceManager().addService(name, service, <span class="keyword">false</span>);</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Log.e(TAG, <span class="string">"error in addService"</span>, e);</div><div class="line">        }   </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>又套马甲了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager sServiceManager;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, IBinder&gt; sCache = <span class="keyword">new</span> HashMap&lt;String, IBinder&gt;();</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span>() {</div><div class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> sServiceManager;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Find the service manager</span></div><div class="line">    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</div><div class="line">    <span class="keyword">return</span> sServiceManager;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ServiceManagerNative 就是前面原理篇中说的 java 层 IInterface 的实现，这里懒得重复贴了（忘记了的回去看看原理篇）。这里主要说参数关键的 IBinder 对象的来源。额，看这名字，多半又是 jni 套 native 层的马甲调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp =============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)</div><div class="line">{</div><div class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</div><div class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然是，最后还是通过 ProcessState 的 getContextObject 获取 handle 为 0 的 Bp 端对象。</p>
<p>那接下可以说说作为 Bn 端的 SM 的实现了。</p>
<h2 id="ServiceManager">ServiceManager</h2>
<h3 id="本体">本体</h3>
<p>SM 的本体是一个 native 的 app，在 init.rc 中开机启动：</p>
<pre config="brush:bash;toolbar:false;">
service servicemanager /system/bin/servicemanager
    class core
    user system
    group system
    critical
    onrestart restart healthd
    onrestart restart zygote
    onrestart restart media
    onrestart restart surfaceflinger
    onrestart restart drm 
</pre>

<p>SM 的主要功能就是接受 SS 的注册（addService），对其他进程提供 getService 的服务。所以它其实和 SS 差不多，只不过是 natvie 的而已。但是从它 native 层接口的位置来看，好像 android 把它当成 binder 组成的一部分了。</p>
<p>SM 的原理其实很简单：就是保存了所有的 SS 的 Bp 端的 handle 而已（可以通过这个东西找到 binder node，这个留到后面分析）。然后有人要用服务的时候，能够通过 SM 取得对应的 IBinder 接口（如果在同一进程空间接口是 BBinder，如果不在，则是 BpBinder）。</p>
<p>因此，所有的 SS 都需要向 SM 注册，然后应用可以通过 SM 查询（获取）到注册过的 service 的 IBinder 接口，进而调用 service 提供的服务接口。</p>
<p>既然 SM 是一个单独的程序，那么其他系统 service 要向它注册，或是 apk 通过它获取系统 service 的接口，都需要跨进程。没错， SM 也是使用 binder 通信的，它也提供一些列接口。但是它却没有使用 binder 那一套接口设计的框架，而是直接使用 binder 的驱动接口来完成功能的。怪不得代码是 c，不是 c++ 。</p>
<p>来看 SM 的本体代码，其实代码比较少，模块不算测试代码，就3个文件：</p>
<pre>
binder.h
binder.c
service_manager.c
</pre>

<p>main 函数在 service_manager.c 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_state *bs;</div><div class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 /dev/binder 驱动设备</span></div><div class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 设置自己成为 binder 的 context manager</span></div><div class="line">    <span class="comment">// binder 里面的 context 就是进程的意思吧，其实 SM 在 binder 可以看成是进程管理</span></div><div class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) {</div><div class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    svcmgr_handle = svcmgr;</div><div class="line">    <span class="comment">// 循环等待 binder 驱动 I/O 请求数据到来，并处理</span></div><div class="line">    binder_loop(bs, svcmgr_handler);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>很简洁。大部分功能都在调用的函数里完成了，一个一个来看。</p>
<p>1、开打 binder 设备驱动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个结构挺简单的，主要是设备 fd</span></div><div class="line"><span class="comment">// 然后是映射的内存地址，和映射的内存大小</span></div><div class="line"><span class="keyword">struct</span> binder_state</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd; </div><div class="line">    <span class="keyword">void</span> *mapped;</div><div class="line">    <span class="keyword">unsigned</span> mapsize;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_state *binder_open(<span class="keyword">unsigned</span> mapsize)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_state *bs;</div><div class="line"></div><div class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</div><div class="line">    <span class="keyword">if</span> (!bs) {</div><div class="line">        errno = ENOMEM;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 以读写打开 binder 设备，保存设备 fd</span></div><div class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder: cannot open device (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">        <span class="keyword">goto</span> fail_open;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 映射一下接收数据的内存，大小前面有设置： 128x1024</span></div><div class="line">    <span class="comment">// 看样子通信数据不是很大（确实 SM 的通信数据不大，普通的是 1024x1024 咧）</span></div><div class="line">    bs-&gt;mapsize = mapsize;</div><div class="line">    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>); </div><div class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder: cannot map device (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">        <span class="keyword">goto</span> fail_map;</div><div class="line">    }</div><div class="line"></div><div class="line">        <span class="comment">/* TODO: check version */</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> bs; </div><div class="line"></div><div class="line">fail_map:</div><div class="line">    close(bs-&gt;fd);</div><div class="line">fail_open:</div><div class="line">    <span class="built_in">free</span>(bs);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>打开 binder 设备比较简单，linux 的基本操作。</p>
<p>2、告诉 binder 自己的进程是 context manager。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_become_context_manager(<span class="keyword">struct</span> binder_state *bs)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ioctl 调用到 binder 驱动中的 <code>binder_ioctl</code> 这个函数，然后我们看下 <code>BINDER_SET_CONTEXT_MGR</code> 命令的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</div><div class="line">    <span class="comment">// 判断下 binder_context_mgr_node 是否已经被创建了</span></div><div class="line">    <span class="comment">// 如果已经创建了，则直接返回错误代码</span></div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node != NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);</div><div class="line">        ret = -EBUSY;</div><div class="line">        <span class="keyword">goto</span> err; </div><div class="line">    }</div><div class="line">    <span class="comment">// 双重检测啊，前面检测了 binder_node ，这里接着检测设置进程的 uid    </span></div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_uid != -<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: BINDER_SET_"</span></div><div class="line">                   <span class="string">"CONTEXT_MGR bad uid %d != %d\n"</span>,</div><div class="line">                   current-&gt;cred-&gt;euid,</div><div class="line">                   binder_context_mgr_uid);</div><div class="line">            ret = -EPERM;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">    } <span class="keyword">else</span> </div><div class="line">        binder_context_mgr_uid = current-&gt;cred-&gt;euid;</div><div class="line">    <span class="comment">// 通过检测后，创建 binder_context_mgr_node 节点</span></div><div class="line">    binder_context_mgr_node = binder_new_node(proc, NULL, NULL);</div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err; </div><div class="line">    }    </div><div class="line">    <span class="comment">// 我讨厌的 android 的引用计数</span></div><div class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</div><div class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</div><div class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>; </div><div class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>; </div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>binder 驱动里的处理除去前面的检测（防止多次设置 binder 的 context manager，并且也能有效防止一些恶意程序伪造 SM，SM 的由 init.rc 启动，所以可以说是比较早去 binder 驱动里面注册的），就只干了一件事：在 binder 驱动中，创建了一个 <code>binder_context_mgr_node</code> 的东西，这个是一个类型为 <code>binder_node</code> 的结构体。<code>binder_node</code> 在 binder 驱动中代表每一个 Bn 端，binder 驱动可以通过 <code>binder_node</code> 找到对应提供服务的进程，从而找到远程目标，这里后面再慢慢说。这里 <code>binder_new_node</code> 后面2个参数都是 NULL， 这2个参数，一个是 IBinder 的 wp 指针，一个是 IBinder 的指针（Bn 端的）， SM 的 <code>binder_node</code> 是很特殊的，直接用一个单独的变量保存。前面说的 SM 的 handle 是 0 固定的，因为人家有单独的变量保存。</p>
<p>3、循环阻塞的等待 binder I/O 的请求数据的到来。</p>
<p><code>svcmgr_handle</code> 应该是一个函数指针地址，但是这里用法好像很奇怪，我都有点搞不懂：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (*binder_handler)(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                              <span class="keyword">struct</span> binder_txn *txn,</div><div class="line">                              <span class="keyword">struct</span> binder_io *msg,</div><div class="line">                              <span class="keyword">struct</span> binder_io *reply);</div><div class="line"></div><div class="line"><span class="keyword">int</span> svcmgr_handler(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   <span class="keyword">struct</span> binder_txn *txn,</div><div class="line">                   <span class="keyword">struct</span> binder_io *msg, </div><div class="line">                   <span class="keyword">struct</span> binder_io *reply)</div><div class="line">{</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> binder_loop(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</div><div class="line">{</div><div class="line">... ... </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* the one magic object */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BINDER_SERVICE_MANAGER ((void*) 0)</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">svcmgr_handle = svcmgr;</div><div class="line">binder_loop(bs, svcmgr_handler);</div><div class="line"></div></pre></td></tr></table></figure>

<p>弄不清楚就算了，反正 <code>binder_loop</code> 那个 handle 函数肯定是 <code>svcmgr_handler</code> 就对了。</p>
<h3 id="通信模型">通信模型</h3>
<p>接着上一节最后的 <code>binder_loop</code> ，这个其实就是 SM 的通信模型了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> binder_loop(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> res; </div><div class="line">    <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</div><div class="line">    </div><div class="line">    bwr.write_size = <span class="number">0</span>;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 对 binder 写入 BC_ENTER_LOOPER，告诉 binder 有一个新的 binder 线程</span></div><div class="line">    <span class="comment">// 加入，相当于 IPCThreadState 的 joinThreadPool</span></div><div class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</div><div class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line">    </div><div class="line">    <span class="comment">// service 常见的无限循环模型</span></div><div class="line">    <span class="keyword">for</span> (;;) {</div><div class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</div><div class="line">        bwr.read_consumed = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</div><div class="line">    </div><div class="line">        <span class="comment">// ioctl 阻塞等待 Bp 端的请求到来</span></div><div class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &bwr);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">            ALOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="comment">// 解析命令，并调用 svcmgr_handler 回调执行命令</span></div><div class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</div><div class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) {</div><div class="line">            ALOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">            ALOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> binder_write(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">    <span class="comment">// 只填充 write 的变量</span></div><div class="line">    bwr.write_size = len;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</div><div class="line">    bwr.read_size = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    <span class="comment">// ioctl 对 binder 驱动写入命令</span></div><div class="line">    <span class="comment">// 由于只有 write 变量，所以 binder 驱动里面不会有 read 的阻塞</span></div><div class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &bwr);</div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实后面的东西， SM 和前面分析的 IPCThreadState 很像，毕竟 IPCThreadState 是封装的 binder 的接口。先是对驱动写一个 <code>BC_ENTER_LOOP</code> 命令，告诉驱动有一个新的线程加入。然后就开始循环等待 Bp 端的请求了（忘记了的回去看通信模型篇）。</p>
<p>然后是真正做事情的 <code>binder_parse</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_parse(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</div><div class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 按 4字节 来算的咧</span></div><div class="line">    uint32_t *end = ptr + (size / <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 和 IPCThreadState 的 waitForResponse 差不多的处理</span></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end) {</div><div class="line">        <span class="comment">// 获取 cmd 命令</span></div><div class="line">        uint32_t cmd = *ptr++;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> TRACE</span></div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"%s:\n"</span>, cmd_name(cmd));</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">        <span class="keyword">switch</span>(cmd) {</div><div class="line">        <span class="keyword">case</span> BR_NOOP:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:  </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_INCREFS:</div><div class="line">        <span class="keyword">case</span> BR_ACQUIRE:</div><div class="line">        <span class="keyword">case</span> BR_RELEASE:</div><div class="line">        <span class="keyword">case</span> BR_DECREFS:</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> TRACE</span></div><div class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">"  %08x %08x\n"</span>, ptr[<span class="number">0</span>], ptr[<span class="number">1</span>]);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">            <span class="comment">// 引用相关的命令直接无视，呵呵</span></div><div class="line">            ptr += <span class="number">2</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION: {</div><div class="line">            <span class="comment">// binder_txn 就是 kernel 里的 binder_transtion_data </span></div><div class="line">            <span class="keyword">struct</span> binder_txn *txn = (<span class="keyword">void</span> *) ptr;</div><div class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(uint32_t) &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_txn)) { </div><div class="line">                ALOGE(<span class="string">"parse: txn too small!\n"</span>);</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line">            binder_dump_txn(txn);          </div><div class="line">            <span class="keyword">if</span> (func) {</div><div class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];         </div><div class="line">                <span class="keyword">struct</span> binder_io msg;          </div><div class="line">                <span class="keyword">struct</span> binder_io reply;        </div><div class="line">                <span class="keyword">int</span> res;</div><div class="line"></div><div class="line">                <span class="comment">// 根据 kernel 传递过来的数据填充下自己的数据结构</span></div><div class="line">                bio_init(&reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</div><div class="line">                bio_init_from_txn(&msg, txn);  </div><div class="line">                <span class="comment">// 执行 svcmgr_handler 回调，完成 IPC 业务</span></div><div class="line">                res = func(bs, txn, &msg, &reply); </div><div class="line">                <span class="comment">// 对 binder 发送返回值命令</span></div><div class="line">                binder_send_reply(bs, &reply, txn-&gt;data, res);</div><div class="line">            }</div><div class="line">            <span class="comment">// 移动下数据指针</span></div><div class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BR_REPLY: {</div><div class="line">            <span class="keyword">struct</span> binder_txn *txn = (<span class="keyword">void</span>*) ptr; </div><div class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(uint32_t) &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_txn)) { </div><div class="line">                ALOGE(<span class="string">"parse: reply too small!\n"</span>);</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line">            binder_dump_txn(txn);</div><div class="line">            <span class="keyword">if</span> (bio) {</div><div class="line">                bio_init_from_txn(bio, txn);</div><div class="line">                bio = <span class="number">0</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">/* todo FREE BUFFER */</span></div><div class="line">            }</div><div class="line">            ptr += (<span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(uint32_t));</div><div class="line">            r = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: {</div><div class="line">            <span class="keyword">struct</span> binder_death *death = (<span class="keyword">void</span>*) *ptr++;</div><div class="line">            death-&gt;func(bs, death-&gt;ptr);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</div><div class="line">            r = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</div><div class="line">            r = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ALOGE(<span class="string">"parse: OOPS %d\n"</span>, cmd);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里差不多感觉就差不多是 IPCThreadState 一个模子里映出来的。前面分析了，Bp transtion 发 <code>BC_TRANSTION</code> 给 binder，binder 会给 Bn 端发 <code>BR_TRANSTION</code> 命令，然后前面 parcel 封装的数据格式是：</p>
<pre>
cmd + binder_transtion_data
</pre>

<p>然后看下这里定义的 <code>binder_txn</code> 这个玩意的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_txn</div><div class="line">{</div><div class="line">    <span class="comment">// target union 取 void* ptr</span></div><div class="line">    <span class="keyword">void</span> *target;</div><div class="line">    <span class="keyword">void</span> *cookie;</div><div class="line">    uint32_t code;</div><div class="line">    uint32_t flags;</div><div class="line"></div><div class="line">    uint32_t sender_pid;</div><div class="line">    uint32_t sender_euid;</div><div class="line"></div><div class="line">    uint32_t data_size;</div><div class="line">    uint32_t offs_size;</div><div class="line">    <span class="comment">// data union 取 struct ptr</span></div><div class="line">    <span class="keyword">void</span> *data; </div><div class="line">    <span class="keyword">void</span> *offs;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>去 Parcel 篇对比下 kernel 的 <code>binder_transtion_data</code> 这里因为参数确定（因为接口就3个），所以直接把那2个 union 给确定下来了。这就是把 binder 驱动的结构扣了出来（我更加确定是2个人写的了，其中有一个就不用原来写好的东西 -_-||）。</p>
<p>然后是 <code>binder_io</code> 这个东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_io</div><div class="line">{</div><div class="line">    <span class="keyword">char</span> *data;            <span class="comment">/* pointer to read/write from */</span></div><div class="line">    uint32_t *offs;        <span class="comment">/* array of offsets */</span></div><div class="line">    uint32_t data_avail;   <span class="comment">/* bytes available in data buffer */</span></div><div class="line">    uint32_t offs_avail;   <span class="comment">/* entries available in offsets array */</span></div><div class="line"></div><div class="line">    <span class="keyword">char</span> *data0;           <span class="comment">/* start of data buffer */</span></div><div class="line">    uint32_t *offs0;       <span class="comment">/* start of offsets buffer */</span></div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t unused;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个从结构上看虽然不太像直接扣某个东西，其实是为了迁就 Parcel 的结构，回忆下 Parcel 篇说的，对的，data 相当于是 mDataPos， offs 相当于是 mObjectPos（Parcel 没这个东西，但是这里的意义相当于是这个），data0 相当于 mData，offs0 相当于 mObjects，<code>data_avail</code> 相当于是 mDataSize，<code>offs_avail</code> 相当于是 mObjectSize。这些后面用的时候就能看出来了。再吐槽下 reply 这个名字都和 IPCThreadState 中的一样。</p>
<p>然后我们接下来看那看 <code>bio_init</code> 这2个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> bio_init_from_txn(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">struct</span> binder_txn *txn)</div><div class="line">{</div><div class="line">    bio-&gt;data = bio-&gt;data0 = txn-&gt;data;</div><div class="line">    bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs;</div><div class="line">    bio-&gt;data_avail = txn-&gt;data_size;</div><div class="line">    bio-&gt;offs_avail = txn-&gt;offs_size / <span class="number">4</span>;</div><div class="line">    bio-&gt;flags = BIO_F_SHARED;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> bio_init(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">void</span> *data,</div><div class="line">              uint32_t maxdata, uint32_t maxoffs)</div><div class="line">{</div><div class="line">    <span class="comment">// 这个就是放 offset 数据的空间</span></div><div class="line">    uint32_t n = maxoffs * <span class="keyword">sizeof</span>(uint32_t);</div><div class="line"></div><div class="line">    <span class="comment">// 放 offset 的超过总空间了</span></div><div class="line">    <span class="keyword">if</span> (n &gt; maxdata) {</div><div class="line">        bio-&gt;flags = BIO_F_OVERFLOW;   </div><div class="line">        bio-&gt;data_avail = <span class="number">0</span>;  </div><div class="line">        bio-&gt;offs_avail = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这里把 offset 数组放到前面去了，后面是 data 数据</span></div><div class="line">    bio-&gt;data = bio-&gt;data0 = (<span class="keyword">char</span> *) data + n;</div><div class="line">    bio-&gt;offs = bio-&gt;offs0 = data; </div><div class="line">    bio-&gt;data_avail = maxdata - n; </div><div class="line">    bio-&gt;offs_avail = maxoffs;</div><div class="line">    bio-&gt;flags = <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>回去看下 Parcel 篇的内存结构，放 <code>flat_binder_object</code> offset 的数组和本体的 data 数据是分开放的，这里图省事，放到一起了，从目前传递参数来看，前 4x4字节 是存放 offset 数组的（最多只能放4个 <code>flat_binder_object</code>），然后紧接着就是 256/4 - 4*4 的数据了。内存结构应该是这样的（懒得画图了，凑活一下）：</p>
<pre>
| offset |        data        |
</pre>

<p>然后那个 <code>bio_init_from_txn</code> 由于用的是 <code>binder_txn</code>（<code>binder_transtion_data</code>） 的数据，所以 data 和 offs 指向的是 <code>binder_txn</code> 的 data 和 offs。</p>
<p>然后是到真正实现 SM 业务的函数了，这里说2个主要功能： addService 和 getService：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> svcmgr_handler(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   <span class="keyword">struct</span> binder_txn *txn,</div><div class="line">                   <span class="keyword">struct</span> binder_io *msg,</div><div class="line">                   <span class="keyword">struct</span> binder_io *reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    uint16_t *s; </div><div class="line">    <span class="keyword">unsigned</span> len;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    uint32_t strict_policy;</div><div class="line">    <span class="keyword">int</span> allow_isolated;</div><div class="line"></div><div class="line"><span class="comment">//    ALOGI("target=%p code=%d pid=%d uid=%d\n",</span></div><div class="line"><span class="comment">//         txn-&gt;target, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span></div><div class="line"></div><div class="line">    <span class="comment">// 验证一下，如果 target 不是 SM 的话，就直接返回</span></div><div class="line">    <span class="keyword">if</span> (txn-&gt;target != svcmgr_handle)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line"></div><div class="line">    <span class="comment">// 这个注释说得很清楚了，相当于 Parcel::enforceInterface()</span></div><div class="line">    <span class="comment">// 验证下 service id</span></div><div class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></div><div class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></div><div class="line">    <span class="comment">// Note that we ignore the strict_policy and don't propagate it</span></div><div class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></div><div class="line">    strict_policy = bio_get_uint32(msg);</div><div class="line">    s = bio_get_string16(msg, &len);</div><div class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</div><div class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"invalid id %s\n"</span>, str8(s));</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// service 接口的 cmd</span></div><div class="line">    <span class="keyword">switch</span>(txn-&gt;code) {</div><div class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</div><div class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</div><div class="line">        s = bio_get_string16(msg, &len);</div><div class="line">        ptr = do_find_service(bs, s, len, txn-&gt;sender_euid);</div><div class="line">        <span class="keyword">if</span> (!ptr)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        bio_put_ref(reply, ptr);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</div><div class="line">        s = bio_get_string16(msg, &len);</div><div class="line">        ptr = bio_get_ref(msg);</div><div class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> SVC_MGR_LIST_SERVICES: {</div><div class="line">        <span class="keyword">unsigned</span> n = bio_get_uint32(msg);</div><div class="line"></div><div class="line">        si = svclist;</div><div class="line">        <span class="keyword">while</span> ((n-- &gt; <span class="number">0</span>) && si)</div><div class="line">            si = si-&gt;next;</div><div class="line">        <span class="keyword">if</span> (si) {</div><div class="line">            bio_put_string16(reply, si-&gt;name);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        ALOGE(<span class="string">"unknown code %d\n"</span>, txn-&gt;code);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    bio_put_uint32(reply, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在说真正的业务函数之前，先把一些细节说一下。最开始 txn-&gt;target != svcmgr_handle 这里，我终于知道前面那个 </p>
<pre>
#define BINDER_SERVICE_MANAGER ((void*) 0)
</pre>

<p>是什么意思了。SM 的 Bp handle 是 0，所以 <code>binder_transtion_data</code> 的 target 肯定是 0，这里做一个验证。然后后面那个取字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把取简单数据的都贴了</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *bio_get(<span class="keyword">struct</span> binder_io *bio, uint32_t size) </div><div class="line">{</div><div class="line">    <span class="comment">// 4 字节对齐</span></div><div class="line">    size = (size + <span class="number">3</span>) & (~<span class="number">3</span>); </div><div class="line"></div><div class="line">    <span class="comment">// 数据越界了</span></div><div class="line">    <span class="keyword">if</span> (bio-&gt;data_avail &lt; size){</div><div class="line">        bio-&gt;data_avail = <span class="number">0</span>;  </div><div class="line">        bio-&gt;flags |= BIO_F_OVERFLOW;  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }  <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这个和 parcel 直接的内存读取是一样的</span></div><div class="line">        <span class="keyword">void</span> *ptr = bio-&gt;data;</div><div class="line">        bio-&gt;data += size;    </div><div class="line">        bio-&gt;data_avail -= size;       </div><div class="line">        <span class="keyword">return</span> ptr;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t bio_get_uint32(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    uint32_t *ptr = bio_get(bio, <span class="keyword">sizeof</span>(*ptr));</div><div class="line">    <span class="keyword">return</span> ptr ? *ptr : <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line">uint16_t *bio_get_string16(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">unsigned</span> *sz)</div><div class="line">{</div><div class="line">    <span class="keyword">unsigned</span> len;</div><div class="line">    len = bio_get_uint32(bio);</div><div class="line">    <span class="keyword">if</span> (sz)</div><div class="line">        *sz = len;</div><div class="line">    <span class="keyword">return</span> bio_get(bio, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t)); </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里的代码就是和 parcel 读、写差不多。回到前面，注释说得很清楚了，因为 IPC 的协议定死了，前面一串字符是 service 的 id 标志，在 Bn 端可以用来验证，是不是本 service 的 Bp 端发送过来的请求，所以这里取前面一串字符（第一个 int32 是长度），然后和自己的 id 对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SM 中定义的 id 标识</span></div><div class="line">uint16_t svcmgr_id[] = {</div><div class="line">    <span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'i'</span>,<span class="string">'d'</span>,<span class="string">'.'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'.'</span>,</div><div class="line">    <span class="string">'I'</span>,<span class="string">'S'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'v'</span>,<span class="string">'i'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>,<span class="string">'M'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>,<span class="string">'r'</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IServiceManager 中定义 id 标志</span></div><div class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后后面 <code>binder_transtion_data</code> 中的 code 了，唉，前面连结构体都能扣出来，几个 int 值还搞不定么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SM 中的定义（binder.h） ==========================</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> {</div><div class="line">    SVC_MGR_GET_SERVICE = <span class="number">1</span>,</div><div class="line">    SVC_MGR_CHECK_SERVICE,</div><div class="line">    SVC_MGR_ADD_SERVICE,</div><div class="line">    SVC_MGR_LIST_SERVICES,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IServiceManager.h ===============================</span></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</div><div class="line">        CHECK_SERVICE_TRANSACTION,</div><div class="line">        ADD_SERVICE_TRANSACTION,</div><div class="line">        LIST_SERVICES_TRANSACTION,</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="comment">// 附上 IBinder 里面的定义：</span></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>,</div><div class="line">        LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>, </div><div class="line"></div><div class="line">        PING_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'G'</span>),</div><div class="line">        DUMP_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>),</div><div class="line">        INTERFACE_TRANSACTION   = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'N'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>),</div><div class="line">        SYSPROPS_TRANSACTION    = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'R'</span>),</div><div class="line">                                            </div><div class="line">        <span class="comment">// Corresponds to TF_ONE_WAY -- an asynchronous call.</span></div><div class="line">        FLAG_ONEWAY             = <span class="number">0x00000001</span></div><div class="line">    };</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们先讲 addService。SS 自己把自己 new 出来之后（Bn 端对象），然后通过 SM<br>的 Bp 端把自己（sp<ibinder>&amp;）当作参数传递给 addService 然后传给 SM。再传到 SM 这里之前，我们这里可以把前面几篇中留的一些坑给填上，就是 binder 驱动里面是怎么找到指定的目标进程的。这里我们先说特殊的 Bp 端（SM 的）。</ibinder></p>
<p>前面说 SM 的 Bp handle 是 0，然后也是经过 IPCThreadState transation，然后 ioctl 一步步写到 kernel 的驱动里面，这里 addService 的话，就应该到了 <code>binder_transtion</code> 那里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete; </div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list; </div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">    e = binder_transaction_log_add(&binder_transaction_log);</div><div class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags & TF_ONE_WAY);</div><div class="line">    e-&gt;from_proc = proc-&gt;pid; </div><div class="line">    e-&gt;from_thread = thread-&gt;pid;</div><div class="line">    e-&gt;target_handle = tr-&gt;target.handle;</div><div class="line">    e-&gt;data_size = tr-&gt;data_size;</div><div class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 注意和这个 handle， SM 的 Bp 传过来的是 0</span></div><div class="line">        <span class="comment">// 所以走的是下面的分支</span></div><div class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) {       </div><div class="line">... ...</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 前面 SM SET_CONTEXT_MGR 的时候 new 了一个 binder_node </span></div><div class="line">            <span class="comment">// 保存在 binder_context_mgr_node 中</span></div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">            <span class="keyword">if</span> (target_node == NULL) {     </div><div class="line">                return_error = BR_DEAD_REPLY;  </div><div class="line">                <span class="keyword">goto</span> err_no_context_mgr_node;  </div><div class="line">            }</div><div class="line">        }</div><div class="line">        e-&gt;to_node = target_node-&gt;debug_id;</div><div class="line">        <span class="comment">// 这里通过 binder_node 可以找到找到 SM 的进程</span></div><div class="line">        target_proc = target_node-&gt;proc;</div><div class="line">        <span class="keyword">if</span> (target_proc == NULL) {     </div><div class="line">            return_error = BR_DEAD_REPLY;  </div><div class="line">            <span class="keyword">goto</span> err_dead_binder;          </div><div class="line">        }</div><div class="line">... ...</div><div class="line">    }</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们再回过头来看看当时 SM <code>SET_CONTEXT_MGR</code> 的时候 new 出来的 <code>binder
_node</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_node *binder_new_node(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                       <span class="keyword">void</span> __user *ptr,              </div><div class="line">                       <span class="keyword">void</span> __user *cookie)           </div><div class="line">{</div><div class="line">    <span class="comment">// 提供 Service 的 proc 保存了自己进程提供的 binder 接口的 node</span></div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;nodes.rb_node;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL; </div><div class="line">    <span class="keyword">struct</span> binder_node *node; </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        node = rb_entry(parent, <span class="keyword">struct</span> binder_node, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)  </div><div class="line">            p = &(*p)-&gt;rb_left;            </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)      </div><div class="line">            p = &(*p)-&gt;rb_right;           </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> NULL;      </div><div class="line">    }</div><div class="line"></div><div class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (node == NULL)</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    binder_stats_created(BINDER_STAT_NODE);</div><div class="line">    rb_link_node(&node-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&node-&gt;rb_node, &proc-&gt;nodes);</div><div class="line">    node-&gt;debug_id = ++binder_last_id;</div><div class="line">    <span class="comment">// node 保存了自己所在的进程</span></div><div class="line">    node-&gt;proc = proc;</div><div class="line">    <span class="comment">// node 保存 binder 本地对象</span></div><div class="line">    node-&gt;ptr = ptr;</div><div class="line">    node-&gt;cookie = cookie;</div><div class="line">    node-&gt;work.type = BINDER_WORK_NODE;</div><div class="line">    INIT_LIST_HEAD(&node-&gt;work.entry);</div><div class="line">    INIT_LIST_HEAD(&node-&gt;async_todo);</div><div class="line">    binder_debug(BINDER_DEBUG_INTERNAL_REFS,</div><div class="line">             <span class="string">"binder: %d:%d node %d u%p c%p created\n"</span>,</div><div class="line">             proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,</div><div class="line">             node-&gt;ptr, node-&gt;cookie);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_new_node</code> new 出来的 node 保存了 binder 对象本地指针（后面会发现只有 Bn 端对象才会创建 node， Bp 端的全是引用（ref）），和相应的进程信息。这样通过 <code>binder_node</code> 就可以找到通信的目标进程。 SM 传递过去的 ptr 和 cookie 是 NULL， SM 的接口就没实现 Bn 端，所以不需要吧。</p>
<p>通过 handle 0 找到了 SM 的 <code>binder_node</code> 节点，进而找到 SM 的进程，然后根据通信篇讲的，唤醒 ioctl 等待 read 的线程，就能够从 ioctl 那返回了，上面就是前面的回到 SM 的 <code>svcmgr_handler</code> 的 <code>SVC_MGR_ADD_SERVICE</code> 处理那里了（代码再贴一次吧）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</div><div class="line">    <span class="comment">// 取注册的 service 的名字</span></div><div class="line">    s = bio_get_string16(msg, &len);</div><div class="line">    <span class="comment">// 取打包的 flat_binder_object 对象 </span></div><div class="line">    ptr = bio_get_ref(msg);</div><div class="line">    allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 保存解析出来的 flat_binder_object 对象</span></div><div class="line">    <span class="keyword">if</span> (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里和 Parcel 篇的一样，要注意读、写顺序，咋贴下 SM 接口实现中写的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span>(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</div><div class="line">        <span class="keyword">throws</span> RemoteException {</div><div class="line">    Parcel data = Parcel.obtain();</div><div class="line">    Parcel reply = Parcel.obtain();</div><div class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</div><div class="line">    data.writeString(name);</div><div class="line">    data.writeStrongBinder(service);</div><div class="line">    data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>); </div><div class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>); </div><div class="line">    reply.recycle();</div><div class="line">    data.recycle();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Bn 端的标志字符串最开始读去了，然后是 addService 要传递一个字符串名字，代表这个 SS 的名字（Context 里面定义的那一堆 <code>ACTIVITY_SERVICE</code> 之类的东西就是一个字符串，而且不是以包名来命名的，但是 SS 是系统开发的，所以可以人为的保证不重复）。然后是 Parcel 篇说到 writeStrongBinder 接口了，这个接口把 <code>flat_binder_object</code> 对象写入 Parcel 的数据内存中。如果是 Bn 端的话 <code>flat_binder_object</code> 的 binder 指针就是 binder 对象本身（addService 当然是 Bn 端）。SM 使用 <code>bio_get_ref</code> 取 <code>flat_binder_object</code> 数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_object *_bio_get_obj(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    <span class="keyword">unsigned</span> n;</div><div class="line">    <span class="keyword">unsigned</span> off = bio-&gt;data - bio-&gt;data0;</div><div class="line"></div><div class="line">    <span class="comment">// 这里直接取 off 不就好了，还费这事</span></div><div class="line">        <span class="comment">/* TODO: be smarter about this? */</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; bio-&gt;offs_avail; n++) { </div><div class="line">        <span class="keyword">if</span> (bio-&gt;offs[n] == off)</div><div class="line">            <span class="comment">// bio_get 自己去前面去看</span></div><div class="line">            <span class="keyword">return</span> bio_get(bio, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_object)); </div><div class="line">    }</div><div class="line"></div><div class="line">    bio-&gt;data_avail = <span class="number">0</span>;</div><div class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> *bio_get_ref(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_object *obj;</div><div class="line"></div><div class="line">    obj = _bio_get_obj(bio);</div><div class="line">    <span class="keyword">if</span> (!obj)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 注意这个判断</span></div><div class="line">    <span class="keyword">if</span> (obj-&gt;type == BINDER_TYPE_HANDLE)</div><div class="line">        <span class="keyword">return</span> obj-&gt;pointer;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里取 <code>flat_binder_object</code> 有好几个地方要说，一个一个来。首先上面那个 <code>_bio_get_object</code> 的写法有点奇怪，注释也说是不是要采用才好的办法，其实还是和写的顺序有关，前面把 writeInterfaceToken、writeString 的都取完了，那么现在指针的位置就应该在 <code>flat_binder_object</code> 那了，而且 offset 数组的第一个就是 object 的偏移，就是说直接 bio-&gt;data0 + bio_offs[0] 或者 bio-&gt;data 都是可以直接取地址的。但是它偏得麻烦的判断一下，我也不知道为什么要这样。</p>
<p>然后取出来的， SM 把它转成 <code>binder_object</code> 这个结构了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_object</div><div class="line">{</div><div class="line">    uint32_t type;</div><div class="line">    uint32_t flags;</div><div class="line">    <span class="keyword">void</span> *pointer;</div><div class="line">    <span class="keyword">void</span> *cookie;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>我这里就懒得贴 <code>flat_binder_object</code> 的结构对比了（你以为你改下变量名我就不认识你啦）。</p>
<p>然后下面 <code>if (obj-&gt;type == BINDER_TYPE_HANDLE)</code> 这个判断，就是说只有 type 是 handle 的时候才会返回有效值。但是通过前面的讲解我们知道，type handle 表示的是 Bp 端，但是 SS addService 传过来的 <code>flat_binder_object</code> 是 <code>BINDER_TYPE_BINDER</code>（Bn 端） 来的。这不是矛盾的么。这里还得再回到 binder 驱动的 <code>binder_transtion</code> 这个函数里，我们把 Parcel 篇中忽略的东西在这里说清楚：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete; </div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list; </div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 计算留给 parcel 的 object offset 数据的内存地址</span></div><div class="line">    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    <span class="comment">// 从用户空间 copy parcel 的 data 数据</span></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="comment">// 从用户空间 copy parcel 的 object offset 数据到刚刚留给 offset 的地址</span></div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(size_t))) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">            <span class="string">"invalid offsets size, %zd\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    }</div><div class="line">    <span class="comment">// 计算出 object offset 的结束地址</span></div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="comment">// 循环转化 flat_binder_object 对象</span></div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line">        <span class="keyword">struct</span> flat_binder_object *fp;</div><div class="line">        <span class="comment">// 判断 offset 的有效性</span></div><div class="line">        <span class="keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            t-&gt;buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">                <span class="string">"invalid offset, %zd\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, *offp);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_offset;</div><div class="line">        }</div><div class="line">        <span class="comment">// 从 offset 取得 flat_binder_object 对象</span></div><div class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) {</div><div class="line">        <span class="comment">// 分情况处理，这里传递过来的 flat_binder_object 是 binder 的情况，也就是 Bn 端的情况</span></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            <span class="comment">// 看看之前有没有创建过这个 Bn 的 node</span></div><div class="line">            <span class="keyword">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;binder);</div><div class="line">            <span class="keyword">if</span> (node == NULL) {</div><div class="line">                <span class="comment">// 没有的话，新创建一个，这里和 SM 不同，不再是 NULL 了</span></div><div class="line">                <span class="comment">// 注意这里先把 fp-&gt;binder 对象保存到 binder node 里面去了</span></div><div class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</div><div class="line">                <span class="keyword">if</span> (node == NULL) {</div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</div><div class="line">                }</div><div class="line">                node-&gt;min_priority = fp-&gt;flags & FLAT_BINDER_FLAG_PRIORITY_MASK;</div><div class="line">                node-&gt;accept_fds = !!(fp-&gt;flags & FLAT_BINDER_FLAG_ACCEPTS_FDS);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d sending u%p "</span></div><div class="line">                    <span class="string">"node %d, cookie mismatch %p != %p\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    fp-&gt;binder, node-&gt;debug_id,</div><div class="line">                    fp-&gt;cookie, node-&gt;cookie);</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 分配在目标进程对这个 node 的 ref</span></div><div class="line">            ref = binder_get_ref_for_node(target_proc, node);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 注意这里， BINDER 变 HANDLE（Bn 变 Bp）</span></div><div class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</div><div class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</div><div class="line">            <span class="comment">// 保存刚刚分配的 ref desc（我觉得可以理解为id）到 Bp 的 handle</span></div><div class="line">            <span class="comment">// 然后这里用 decs 把 flat_binder_object 的binder对象覆盖掉了</span></div><div class="line">            fp-&gt;handle = ref-&gt;desc;</div><div class="line">            <span class="comment">// 增加下引用计数</span></div><div class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</div><div class="line">                       &thread-&gt;todo);</div><div class="line"></div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        node %d u%p -&gt; ref %d desc %d\n"</span>,</div><div class="line">                     node-&gt;debug_id, node-&gt;ptr, ref-&gt;debug_id,</div><div class="line">                     ref-&gt;desc);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transactio"</span></div><div class="line">                <span class="string">"n with invalid object type, %lx\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, fp-&gt;type);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_object_type;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最开始 offp 获取内存那里，还记得内存管理篇，说每个 binder 进程分配的那 1M 的用来接收数据的内存不，这里派上用场了（其实主要用的还是目标进程，这里只是把 <code>flat_binder_object</code> 加工一下而已）。用来接收 Proc A parcel 打包的数据（data + offset）。下面，先把 data copy 过来，然后再是 offset。由于 <code>flat_binder_object</code> 可以打包多个，所以是一个循环。Parcle 篇不止说了一次 mObects 是偏移地址，这里取 <code>flat_binder_object</code> 又再一次证明了。<code>flat_binder_object</code> 里面放的东西，这里要经过一些转化才能传递给目标进程使用。</p>
<p>这得分情况，这里先说 <code>BINDER_TYPE_BINDER</code> 的情况。因为之前一直在说 addService。那么作为 Bn 端的 service 传递过来的肯定是 <code>BINDER_TYPE_BINDER</code>。</p>
<p>首先先去 addService 的进程中去查找是不是已经创建过 <code>binder_node</code> 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_node *binder_get_node(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                       <span class="keyword">void</span> __user *ptr)              </div><div class="line">{</div><div class="line">    <span class="comment">// 进程保存自己本进程内 node 的红黑树</span></div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;nodes.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_node *node; </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (n) {</div><div class="line">        node = rb_entry(n, <span class="keyword">struct</span> binder_node, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)  </div><div class="line">            n = n-&gt;rb_left;   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)      </div><div class="line">            n = n-&gt;rb_right;  </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> node;      </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>`</p>
<p>前面看到 <code>binder_new_node</code> 是会把创建的 node 保存到 proc 的一颗红黑树里面的。如果没找到（也就是之前没创建过），那就创建一个。这里要注意一点，这里把 <code>flat_binder_object</code> 的 binder 对象保存到 node 里面去了。为什么要注意这点，后面创建 ref 的时候会知道原因的。接着就要分配一个这个 node 的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_ref *binder_get_ref_for_node(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          <span class="keyword">struct</span> binder_node *node)      </div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node *n;</div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;refs_by_node.rb_node; </div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL; </div><div class="line">    <span class="keyword">struct</span> binder_ref *ref, *new_ref;</div><div class="line"></div><div class="line">    <span class="comment">// 先查看是不是能通过 node 查找到 ref</span></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        ref = rb_entry(parent, <span class="keyword">struct</span> binder_ref, rb_node_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (node &lt; ref-&gt;node) </div><div class="line">            p = &(*p)-&gt;rb_left;            </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; ref-&gt;node)     </div><div class="line">            p = &(*p)-&gt;rb_right;           </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> ref;       </div><div class="line">    }</div><div class="line">    <span class="comment">// 如果查找不到就新创建一个 ref</span></div><div class="line">    new_ref = kzalloc(<span class="keyword">sizeof</span>(*ref), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (new_ref == NULL)</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    binder_stats_created(BINDER_STAT_REF);</div><div class="line">    new_ref-&gt;debug_id = ++binder_last_id;</div><div class="line">    <span class="comment">// 设置引用这个 binder 的进程</span></div><div class="line">    new_ref-&gt;proc = proc;</div><div class="line">    <span class="comment">// 设置这个 ref 指向的 node</span></div><div class="line">    new_ref-&gt;node = node;</div><div class="line">    <span class="comment">// 把新创建的 ref 保存到通过 node 查找 ref 的红黑树中</span></div><div class="line">    rb_link_node(&new_ref-&gt;rb_node_node, parent, p);</div><div class="line">    rb_insert_color(&new_ref-&gt;rb_node_node, &proc-&gt;refs_by_node);</div><div class="line"></div><div class="line">    <span class="comment">// 初始化 ref（如果是 SM 的话从 0 开始）</span></div><div class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</div><div class="line">    <span class="comment">// 看看已经有几个 ref 指向这个 node 了， desc（id） 是累加的</span></div><div class="line">    <span class="keyword">for</span> (n = rb_first(&proc-&gt;refs_by_desc); n != NULL; n = rb_next(n)) {</div><div class="line">        ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</div><div class="line">        <span class="keyword">if</span> (ref-&gt;desc &gt; new_ref-&gt;desc) </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        new_ref-&gt;desc = ref-&gt;desc + <span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 然后根据 new ref 的 desc 保存到根据 desc 查找的红黑树中</span></div><div class="line">    p = &proc-&gt;refs_by_desc.rb_node; </div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        ref = rb_entry(parent, <span class="keyword">struct</span> binder_ref, rb_node_desc);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (new_ref-&gt;desc &lt; ref-&gt;desc)</div><div class="line">            p = &(*p)-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_ref-&gt;desc &gt; ref-&gt;desc)</div><div class="line">            p = &(*p)-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            BUG();</div><div class="line">    }</div><div class="line">    rb_link_node(&new_ref-&gt;rb_node_desc, parent, p);</div><div class="line">    rb_insert_color(&new_ref-&gt;rb_node_desc, &proc-&gt;refs_by_desc);</div><div class="line">    <span class="keyword">if</span> (node) {</div><div class="line">        hlist_add_head(&new_ref-&gt;node_entry, &node-&gt;refs);</div><div class="line"></div><div class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</div><div class="line">                 <span class="string">"binder: %d new ref %d desc %d for "</span></div><div class="line">                 <span class="string">"node %d\n"</span>, proc-&gt;pid, new_ref-&gt;debug_id,</div><div class="line">                 new_ref-&gt;desc, node-&gt;debug_id);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</div><div class="line">                 <span class="string">"binder: %d new ref %d desc %d for "</span></div><div class="line">                 <span class="string">"dead node\n"</span>, proc-&gt;pid, new_ref-&gt;debug_id,</div><div class="line">                  new_ref-&gt;desc);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> new_ref;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里可以说下 node 和 ref 的关系了。一个 Bn 端对应一个 node，一个 Bp 端对应一个 ref， 同一个 service 的 Bn 端只有一个，所以 node 只有一个，但是一个 service 可以被多个 client 请求（Bp 端），所以 ref 可以有多个，并且是进程相关的。就是说 ref 的 desc 是进程相关的，一个进程内唯一，但是放到别的进程无法识别。desc 0 代表 SM 的 Bp 端，SM 的 node 由特殊的变量保存。binder 对象 Bn 端传递到目标进程变成 Bp 端，然后 Bp 端通过 desc 在 kernel 中可以找到 ref，通过 ref 可以找到引用的 node，然后通过 node 可以找到这个 node 的 Bn 端所在的进程，就能把请求发送到目标进程了。来张图，形象点：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-system-service/1.png" alt=""></p>
<p>分配好 ref 后，就有了 ref 的 desc（handle），然后把这个 handle 保存在了 fp-&gt;handle 里面。这里是一个需要注意的地方，回忆下 <code>flat_binder_object</code> 的结构，你会发现 binder 和 handle 是一个 union，就是说同一个时候只能用一个。这里设置了 handle 就会把 binder 的值给覆盖掉。这个是关键的一点，后面 SM 保存 <code>flat_binder_object</code> 的时候能看到这么处理的意义。</p>
<p>然后这里说下为什么后面把 <code>BINDER_TYPE_BINDER</code> 变成了 <code>BINDER_TYPE_HANDLE</code> 。因为 binder 对象自身是本地对象，只能在 Bn 端才有效（通过它调用本地的接口），在远程是无法使用的（要能用就没 IPC 什么事了），所以远程要持有 Bp 对象才有用。因此 Bn 端通过 writeStrong 把本地的 binder 对象打包成 <code>flat_binder_object</code>，经过 kernel 的时候，要传递到对方（目标进程），就需要把 Proc A 的本地 binder 对象变成 Proc B 中的 远程对象（Bp 对象），所以这里才有了 <code>BINDER_TYPE_BINDER</code> 变 <code>BINDER_TYPE_HANDLE</code> 的处理。同理如果 Proc B 中把 Proc A 的 Bp 对象反过来传递给 Proc A 的话，kernel 会把 Bp 转成 Bn 的，<code>binder_transtion</code> 的后面那个 case 会有这样的处理，后面会看到。 </p>
<p>到这里你就应该能理解为什么 addService 调用的 <code>bio_get_ref</code> 后面会判断 type 要是 <code>BINDER_TYPE_HANDLE</code> 才会返回 <code>flat_binder_object</code> 的有效值吧。如果这里是 <code>BINDER_TYPE_HANDLE</code> 对方传递的才是 Bn。然后回想下 SM 山寨的 <code>binder_object</code> 结构体，那个 pointer 其实就是 <code>flat_binder_object</code> 的 union，本来我以为 SS 传递过来的应该是本地的 binder 指针的，但是 kernel 那里一转化，就用 Bp 的 handle 值把本地的 binder 对象给覆盖掉了，SS 的本地 binder 对象是保存在了 kernel 的 node 里面，SM 里保存的是 Bp 的 handle 值而已。其实想想看也应该是这样，在另一个进程里面保存本地的 binder 对象根本就没意义，只有在 SS 本进程中本地 binder 对象才于意义，所以另外进程里有意义的是 Bp 的 handle 值。</p>
<p>然后最后我们可以来看看 <code>do_add_service</code> 的处理了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里从 kernel 那里传递过来的 ptr 其实一个 int 指针（Bp handle 值），</span></div><div class="line"><span class="comment">// 不是本地 binder 对象指针</span></div><div class="line"><span class="keyword">int</span> do_add_service(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   uint16_t *s, <span class="keyword">unsigned</span> len,     </div><div class="line">                   <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid, <span class="keyword">int</span> allow_isolated)</div><div class="line">{</div><div class="line">    <span class="comment">// SM 保存 SS 的结构体</span></div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    <span class="comment">//ALOGI("add_service('%s',%p,%s) uid=%d\n", str8(s), ptr,</span></div><div class="line">    <span class="comment">//        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 通过 uid 判断 SS 所在的进程是否能是系统进程，</span></div><div class="line">    <span class="comment">// 只有系统进程才有权限注册 SS</span></div><div class="line">    <span class="keyword">if</span> (!svc_can_register(uid, s)) {</div><div class="line">        ALOGE(<span class="string">"add_service('%s',%p) uid=%d - PERMISSION DENIED\n"</span>,</div><div class="line">             str8(s), ptr, uid);            </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 查找下之前是否注册过</span></div><div class="line">    si = find_svc(s, len);</div><div class="line">    <span class="keyword">if</span> (si) {</div><div class="line">        <span class="comment">// 如果之前注册过的话，弄死原来那个服务，用这个新的代替原来那个 -_-||</span></div><div class="line">        <span class="keyword">if</span> (si-&gt;ptr) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</div><div class="line">                 str8(s), ptr, uid);            </div><div class="line">            svcinfo_death(bs, si);         </div><div class="line">        }</div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 没注册过的话，就 new 新的结构体来保存 binder 对象</span></div><div class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        <span class="keyword">if</span> (!si) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - OUT OF MEMORY\n"</span>,</div><div class="line">                 str8(s), ptr, uid);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 保存 handle 值</span></div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">        si-&gt;len = len;</div><div class="line">        <span class="comment">// 保存 SS 的注册的名字</span></div><div class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</div><div class="line">        <span class="comment">// 设置下死亡通知回调</span></div><div class="line">        si-&gt;death.func = svcinfo_death;</div><div class="line">        si-&gt;death.ptr = si;</div><div class="line">        si-&gt;allow_isolated = allow_isolated;</div><div class="line">        <span class="comment">// SM 拿了一个链表来保存 svcinfo，把这个新的对象插入到到链表中</span></div><div class="line">        si-&gt;next = svclist;</div><div class="line">        svclist = si;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 对新的 SS 的 binder node 增加下引用计数（还是得手动么）</span></div><div class="line">    binder_acquire(bs, ptr);</div><div class="line">    binder_link_to_death(bs, ptr, &si-&gt;death);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>首先看一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> svcinfo</div><div class="line">{</div><div class="line">    <span class="comment">// 首地址变量当作链表的下一个元素的节点，活用 kernel 链表的精髓</span></div><div class="line">    <span class="keyword">struct</span> svcinfo *next;</div><div class="line">    <span class="comment">// handle 值</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">struct</span> binder_death death;</div><div class="line">    <span class="keyword">int</span> allow_isolated;</div><div class="line">    <span class="comment">// 注册名字的长度</span></div><div class="line">    <span class="keyword">unsigned</span> len;</div><div class="line">    <span class="comment">// 注册的名字字符串</span></div><div class="line">    uint16_t name[<span class="number">0</span>];</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>SM 拿了一个链表来保存 svcinfo 结构，svclist 这个变量就是链表头。然后 <code>do_add_service</code> 这个函数的处理也挺简单的，先是检测请求注册的进程是否有权限能够注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 允许注册的 uid 组和服务的名字</span></div><div class="line"><span class="comment">/* TODO:</span></div><div class="line"><span class="comment"> * These should come from a config file or perhaps be</span></div><div class="line"><span class="comment"> * based on some namespace rules of some sort (media</span></div><div class="line"><span class="comment"> * uid can register media.*, etc)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> {</div><div class="line">    <span class="keyword">unsigned</span> uid;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">} allowed[] = {</div><div class="line">    { AID_MEDIA, <span class="string">"media.audio_flinger"</span> },</div><div class="line">    { AID_MEDIA, <span class="string">"media.log"</span> },</div><div class="line">    { AID_MEDIA, <span class="string">"media.player"</span> }, </div><div class="line">    { AID_MEDIA, <span class="string">"media.camera"</span> }, </div><div class="line">    { AID_MEDIA, <span class="string">"media.audio_policy"</span> },</div><div class="line">    { AID_DRM,   <span class="string">"drm.drmManager"</span> }, </div><div class="line">    { AID_NFC,   <span class="string">"nfc"</span> },</div><div class="line">    { AID_BLUETOOTH, <span class="string">"bluetooth"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.phone"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.sms"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.phonesubinfo"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.simphonebook"</span> },</div><div class="line"><span class="comment">/* TODO: remove after phone services are updated: */</span></div><div class="line">    { AID_RADIO, <span class="string">"phone"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"sip"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"isms"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"iphonesubinfo"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"simphonebook"</span> }, </div><div class="line">    { AID_MEDIA, <span class="string">"common_time.clock"</span> },</div><div class="line">    { AID_MEDIA, <span class="string">"common_time.config"</span> },</div><div class="line">    { AID_KEYSTORE, <span class="string">"android.security.keystore"</span> }, </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> svc_can_register(<span class="keyword">unsigned</span> uid, uint16_t *name)</div><div class="line">{</div><div class="line">    <span class="keyword">unsigned</span> n;</div><div class="line">    </div><div class="line">    <span class="comment">// uid 0 好像是 root</span></div><div class="line">    <span class="comment">// AID_SYSTEM 是 /system/app 下面的进程</span></div><div class="line">    <span class="keyword">if</span> ((uid == <span class="number">0</span>) || (uid == AID_SYSTEM))</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果上面2个都不是的，查询下是否在最开始定义的 allowed 表里面</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="keyword">sizeof</span>(allowed) / <span class="keyword">sizeof</span>(allowed[<span class="number">0</span>]); n++)</div><div class="line">        <span class="keyword">if</span> ((uid == allowed[n].uid) && str16eq(name, allowed[n].name))</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子 root 启动的进程、系统程序、还有一些特殊的 uid 能够向 SM 注册 SS。当然自己定义的系统的话，可以加一些 uid 进去。</p>
<p>之后就是查找发过来的 Service 之前是否注册过：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> svcinfo *find_svc(uint16_t *s16, <span class="keyword">unsigned</span> len)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) {</div><div class="line">        <span class="comment">// 果然是以名字来区分的</span></div><div class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &&        </div><div class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(uint16_t))) {</div><div class="line">            <span class="keyword">return</span> si;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>SM 里标示 SS 的是 SS 的 name，所以自己定制系统的时候新加一个 SS 不要取和原来系统名字一样的。已经注册过了把原来的弄死，就用的代替原来旧的，没有的话就新创建一个 svcinfo 结构，然后插入到链表中。后面设置一些死亡通知的回调，后面再说。之后就是要手动增加 <code>binder_node</code> 的引用计数（这里不贴这部分的源码了）。</p>
<p>addService 算是说完了，就是 SM 拿了一个链表来保存所有的 SS 在 SM 本进程中的 Bp handle 值。那么相应的 getService 就是从这个链表中取出 SS 的 Bp，然后通过 kernel 传递给对应的进程（又重复贴代码了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SVC_MGR_GET_SERVICE:</div><div class="line"><span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</div><div class="line">    <span class="comment">// SM 接口 getService 的参数是 SS 注册的名字</span></div><div class="line">    s = bio_get_string16(msg, &len);</div><div class="line">    <span class="comment">// 通过 name 来查找 svcinfo </span></div><div class="line">    ptr = do_find_service(bs, s, len, txn-&gt;sender_euid);</div><div class="line">    <span class="keyword">if</span> (!ptr)</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="comment">// 取到对应 SS 的 Bp handle 后，然后仿照 Parcel 打包</span></div><div class="line">    <span class="comment">// 注意这里调用的函数名字证明了我上面说的结论，put 的是 ref</span></div><div class="line">    bio_put_ref(reply, ptr);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>从接口 getService 传递过来的 name，这个 name 是 SS 向 SM addService 的时候传递过来的 name。然后通过这个 name 查找 svcinfo 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *do_find_service(<span class="keyword">struct</span> binder_state *bs, uint16_t *s, <span class="keyword">unsigned</span> len, <span class="keyword">unsigned</span> uid)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    <span class="comment">// 通过 name 查找 svcinfo</span></div><div class="line">    si = find_svc(s, len);</div><div class="line"></div><div class="line"><span class="comment">//    ALOGI("check_service('%s') ptr = %p\n", str8(s), si ? si-&gt;ptr : 0);</span></div><div class="line">    <span class="keyword">if</span> (si && si-&gt;ptr) {</div><div class="line">        <span class="keyword">if</span> (!si-&gt;allow_isolated) {     </div><div class="line">            <span class="comment">// If this service doesn't allow access from isolated processes,</span></div><div class="line">            <span class="comment">// then check the uid to see if it is isolated.</span></div><div class="line">            <span class="keyword">unsigned</span> appid = uid % AID_USER;</div><div class="line">            <span class="keyword">if</span> (appid &gt;= AID_ISOLATED_START && appid &lt;= AID_ISOLATED_END) {</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// 找到后返回 Bp handle</span></div><div class="line">        <span class="keyword">return</span> si-&gt;ptr;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后通过 <code>binder_put_ref</code> 使用 handle 构造 <code>flat_binder_object</code> 打包到要返回的数据里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> bio_put_ref(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">void</span> *ptr)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_object *obj;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr)</div><div class="line">        <span class="comment">// 为 flat_binder_object 对象分配内存</span></div><div class="line">        obj = bio_alloc_obj(bio);      </div><div class="line">    <span class="keyword">else</span></div><div class="line">        obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!obj)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    <span class="comment">// type 是 handle</span></div><div class="line">    obj-&gt;type = BINDER_TYPE_HANDLE;</div><div class="line">    <span class="comment">// 这个 pointer 是 handle 值，所以这个 flat_binder_object 是 Bp</span></div><div class="line">    obj-&gt;pointer = ptr;</div><div class="line">    obj-&gt;cookie = <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_object *bio_alloc_obj(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_object *obj;</div><div class="line"></div><div class="line">    obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> (obj && bio-&gt;offs_avail) {</div><div class="line">        bio-&gt;offs_avail--;</div><div class="line">        *bio-&gt;offs++ = ((<span class="keyword">char</span>*) obj) - ((<span class="keyword">char</span>*) bio-&gt;data0);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    }</div><div class="line"></div><div class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *bio_alloc(<span class="keyword">struct</span> binder_io *bio, uint32_t size) </div><div class="line">{</div><div class="line">    size = (size + <span class="number">3</span>) & (~<span class="number">3</span>); </div><div class="line">    <span class="keyword">if</span> (size &gt; bio-&gt;data_avail) {</div><div class="line">        bio-&gt;flags |= BIO_F_OVERFLOW;  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">void</span> *ptr = bio-&gt;data;</div><div class="line">        bio-&gt;data += size;</div><div class="line">        bio-&gt;data_avail -= size;       </div><div class="line">        <span class="keyword">return</span> ptr;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里使用的 <code>bio_put_ref</code>，这个函数填充的 <code>flat_binder_object</code> 类型是 handle，此外 SM 还有一个函数叫 <code>bio_put_obj</code>，那个是填充的是 binder 类型，不过 <code>bio_put_obj</code> 目前并没有被使用。所以 SM 保存的是 Bp 的 handle 值。其他的我不想多解释啥了，自己去对比下 Parcel 篇，writeStrongBinder 相关的代码，就几乎是一样的东西，换几个函数名而已。</p>
<p>那么 <code>svcmgr_handler</code> 的业务逻辑处理完了，主要是把数据都打包好了，然后后面就把把数据当作返回值发回去（通过 kernel 的 binder）。这里就要回去看 <code>binder_parse</code> <code>BR_TRANSTION</code> 最后那里的 <code>binder_send_reply</code>（名字都和 IPCThreadState 的 sendReply 很像）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> binder_send_reply(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                       <span class="keyword">struct</span> binder_io *reply,       </div><div class="line">                       <span class="keyword">void</span> *buffer_to_free,          </div><div class="line">                       <span class="keyword">int</span> status)                    </div><div class="line">{</div><div class="line">    <span class="comment">// 这里一次性打包发送了2条命令：</span></div><div class="line">    <span class="comment">// 一条是释放前面发送 BC_TRANSTION 那次命令的 buffer 的</span></div><div class="line">    <span class="comment">// 一条是 BC_REPLY 发送返回值命令</span></div><div class="line">    <span class="keyword">struct</span> {</div><div class="line">        uint32_t cmd_free;</div><div class="line">        <span class="keyword">void</span> *buffer;</div><div class="line">        uint32_t cmd_reply;   </div><div class="line">        <span class="keyword">struct</span> binder_txn txn;</div><div class="line">    } __attribute__((packed)) data;</div><div class="line"></div><div class="line">    data.cmd_free = BC_FREE_BUFFER;</div><div class="line">    data.buffer = buffer_to_free;</div><div class="line">    data.cmd_reply = BC_REPLY;</div><div class="line">    data.txn.target = <span class="number">0</span>;</div><div class="line">    data.txn.cookie = <span class="number">0</span>;</div><div class="line">    data.txn.code = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (status) {</div><div class="line">        data.txn.flags = TF_STATUS_CODE;</div><div class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">        data.txn.offs_size = <span class="number">0</span>;        </div><div class="line">        data.txn.data = &status;       </div><div class="line">        data.txn.offs = <span class="number">0</span>;    </div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        data.txn.flags = <span class="number">0</span>;   </div><div class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</div><div class="line">        data.txn.offs_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</div><div class="line">        data.txn.data = reply-&gt;data0;  </div><div class="line">        data.txn.offs = reply-&gt;offs0;  </div><div class="line">    }</div><div class="line">    <span class="comment">// 写入 binder 驱动</span></div><div class="line">    binder_write(bs, &data, <span class="keyword">sizeof</span>(data));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> binder_write(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len) </div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">    <span class="comment">// 只填充 write 部分，binder 驱动不会在阻塞等待 read</span></div><div class="line">    bwr.write_size = len;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</div><div class="line">    bwr.read_size = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    <span class="comment">// ioctl 发送读、写命令</span></div><div class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &bwr);</div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</div><div class="line">                strerror(errno));              </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实这段有了前面 Parcel 篇的分析就不需要再多说什么了。只不过这里我们可以接着下面看完 kernel 中 <code>binder_transtion</code> <code>BINDER_TYPE_HANDLE</code> 的处理，上面 SM 是通过保存的 binder 对象指针发送 <code>BINDER_TYPE_HANDLE</code> 过去的（Bp）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:       </div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="comment">// 在本进程中取 ref，这里是 SM，前面 addService 的时候</span></div><div class="line">            <span class="comment">// 发送 flat_binder_object 创建 node 的时候在 SM 中分配了 ref</span></div><div class="line">            <span class="comment">// 这里正好能取回来</span></div><div class="line">            <span class="keyword">struct</span> binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got "</span></div><div class="line">                    <span class="string">"transaction with invalid "</span>    </div><div class="line">                    <span class="string">"handle, %ld\n"</span>, proc-&gt;pid,    </div><div class="line">                    thread-&gt;pid, fp-&gt;handle);      </div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果 getService 的进程就是 SS 所在的进程，直接转化为 Bn</span></div><div class="line">            <span class="comment">// 这典型的出口转内销 -_-||</span></div><div class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) {</div><div class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</div><div class="line">                    fp-&gt;type = BINDER_TYPE_BINDER; </div><div class="line">                <span class="keyword">else</span></div><div class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</div><div class="line">                <span class="comment">// 本地 binder 对象在 node 中有保存</span></div><div class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;   </div><div class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</div><div class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, NULL);</div><div class="line">                binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                         <span class="string">"        ref %d desc %d -&gt; node %d u%p\n"</span>,</div><div class="line">                         ref-&gt;debug_id, ref-&gt;desc, ref-&gt;node-&gt;debug_id,</div><div class="line">                         ref-&gt;node-&gt;ptr);               </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 如果是不同的进程的话，老老实实分配 ref 吧</span></div><div class="line">                <span class="keyword">struct</span> binder_ref *new_ref;    </div><div class="line">                <span class="comment">// 注意分配 ref 都要在调用进程分配的，ref 是进程相关的</span></div><div class="line">                <span class="comment">// 进程别搞错了。</span></div><div class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</div><div class="line">                <span class="keyword">if</span> (new_ref == NULL) {         </div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">                }</div><div class="line">                <span class="comment">// 分配好的 desc（handle）要保存好</span></div><div class="line">                fp-&gt;handle = new_ref-&gt;desc;    </div><div class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);</div><div class="line">                binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                         <span class="string">"        ref %d desc %d -&gt; ref %d desc %d (node %d)\n"</span>,</div><div class="line">                         ref-&gt;debug_id, ref-&gt;desc, new_ref-&gt;debug_id,</div><div class="line">                         new_ref-&gt;desc, ref-&gt;node-&gt;debug_id);</div><div class="line">            }</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_ref *binder_get_ref(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                     uint32_t desc)                 </div><div class="line">{</div><div class="line">    <span class="comment">// 前面分配好 ref，把 ref 保存到相关进程的这颗红黑树当中的</span></div><div class="line">    <span class="comment">// 忘记了的回去看前面的 addService 那的代码</span></div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;refs_by_desc.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_ref *ref;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (n) {</div><div class="line">        ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (desc &lt; ref-&gt;desc) </div><div class="line">            n = n-&gt;rb_left;   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;desc)     </div><div class="line">            n = n-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> ref;       </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>要 getService，肯定得先 addService，如果之前 SS 有 addService，那么这里的 <code>binder_get_ref</code> 肯定能取得对应 handle 值的 ref（这的 proc 是 SM，是 SM进 程发送 getService 的返回值的引起的 kernel binder 的 ioctl 调用的，别那么容易晕）。ref 有保存对应的 Service 所在的 proc。这里要判断下“出口转内销”的情况。就是发起 getService 的进程正好就是要取的 Service 所在的进程（这种情况很常见的，SS 的进程中有很多个 Service 的，经常要在一个 Service 调用另一个 Service 的接口，其实它们都在同一个进程，可以直接调用的，但是既然 binder 都封装好了，开发人员就应该专注业务功能，不用理会这些）。如果是的话，就把 <code>flat_binder_object</code> 变成 binder 类型的（node 中有保存本地的 binder 对象指针，所以可以转化的）。</p>
<p>如果不是的话，就老老实实调用 <code>binder_get_ref_for_node</code> 创建新的 ref 。这个函数前面 new SM 的 ref 的时候分析过了。唯一要注意的是传递的过去的 proc 是发起 getService 的。前面说了 ref 是进程相关的，必须要分配到要用 Bp 端的进程中才能正常使用。这个说这么多次，然我们们来看下原因吧。因为还是在 <code>binder_transtion</code> 这个函数里面，在这个函数最开始，通过 Bp handle 找 ref 那：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这段代码前面贴过了，这里再强调一下</span></div><div class="line"><span class="keyword">if</span> (tr-&gt;target.handle) {</div><div class="line">    <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">    <span class="comment">// 注意这个 proc </span></div><div class="line">    ref = binder_get_ref(proc, tr-&gt;target.handle);</div><div class="line">    <span class="keyword">if</span> (ref == NULL) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got "</span></div><div class="line">            <span class="string">"transaction to invalid handle\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_invalid_target_handle;</div><div class="line">    }</div><div class="line">    target_node = ref-&gt;node;</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们假设，client proc 通过 getService 取得了 Bp 对象，然后通过 Bp 发起一次 IPC 调用。那么最后也是要到 <code>binder_transtion</code> 这里。然后这个 target.handle 就是通过 getService 取得的 Service 的 Bp 的 handle。这个 handle 是当初在 kernel 在 client proc 中分配的，并且保存在 client proc 的一颗红黑树中。所以这里就从 client proc 的这颗红黑树中取当初分配的 ref（key 是 handle 值，当然保存的时候也是按 handle 值构造红黑树的，所以现在查找的时候速度会非常快）。所以说 ref 是进程相关的，其实 node 也是进程相关的，就是提供 service 的进程自己保存了 node。 ref 中保存有 node，node 中保存有 proc ，所以 client 的请求可以激活阻塞等待的 service 进程，然后 service 执行 IPC 调用。 </p>
<p><code>binder_transtion</code> 转化 <code>flat_binder_object</code> 最后还有一个 case： <code>BINDER_TYPE_FD</code>，这个是转化 fd 的，去共享内存篇去看吧。</p>
<p>这样前面那几篇中的疑问就都清楚了。client 的 IPC 是怎么找到 service 的？？ binder 对象怎么传递到别的进程使用？？ 其实主要是在 kernel 的 binder 驱动中，所有的进程都可见，才能实现这些功能，可以说 kernel 给各个进程穿针引线了。最后来张图总结一下吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-system-service/2.png" alt=""></p>
<p>（稍微说明下，图中一共三条线；第一条 SS（ProcA）通过 addService 向 SM 注册，第二条 ProcB 通过 getService 向 SM 取 ProcA 的 binder 对象；第三条 ProcB 取回 ProcA 的 binder 对象后，通过其发起 IPC 调用）</p>
<p>那么 SS binder 对象的传递就说完了，那么还有第三方应用的咧。我发现这篇已经很长了，哎，本来先一篇讲完的，但是还是分开一篇吧。那么第三方应用 binder 对象传递就去看下一篇吧。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%99%AE%E9%80%9A%E6%9C%8D%E5%8A%A1%20Binder%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%A0%E9%80%92/</loc>
    <lastmod>2015-03-31T06:30:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——普通服务 Binder 对象的传递</title>
        <pubTime>2015-01-28T13:33:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>上一篇把 SS 传递 binder 对象说了， SS 传递是要依靠 SM 的。但是普通应用的服务是没权向 SM 注册的，就是说普通应用获取普通服务的接口不能像 SS 那样，通过 SM 的接口去取。这篇就来讲讲普通应用中 binder 对象的传递。</p>
<p>那这篇主要就是分析这些，照例先把源代码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java 层 Context 相关接口</span></div><div class="line">frameworks/base/core/java/android/app/ContextImpl.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line">frameworks/base/core/java/android/app/ActivityThread.java</div><div class="line">frameworks/base/core/java/android/content/ServiceConnection</div><div class="line"></div><div class="line"><span class="comment"># java 层 Service 相关接口</span></div><div class="line">frameworks/base/core/java/android/app/IActivityManager.java</div><div class="line">frameworks/base/core/java/android/app/ActivityManager.java</div><div class="line">frameworks/base/core/java/android/app/ActivityManagerNative.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActiveServices.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ServiceRecord.java</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="Client_相关接口">Client 相关接口</h2>
<p>还是和上一篇的一样，先从相关接口说。普通服务和 SS 不一样，好像没有 native 层相关的接口，虽然说 native 层有个 BinderService 的东西，但是没有相关绑定的接口，所以说应该没办法写 native 的普通服务。所以这里只说 java 层的。</p>
<p>要在别的进程使用普通服务提供的 IPC 接口，需要绑定服务，我们来看下绑定服务的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">bindService</span>(Intent service, ServiceConnection conn,</div><div class="line">        <span class="keyword">int</span> flags);</div><div class="line"></div></pre></td></tr></table></figure>



<p>这个是 Context 里面的接口，就是说一般在 Activity 里面可以调用这个来绑定服务。Intent 是要绑定的服务。ServiceConnection 是个接口，我们待会再说。flags 是一个标志，可以设置好几个，这里我们讨论最常见的一个： <code>BIND_AUTO_CREATE</code> 这个表示如果要绑定的服务的进程没有运行就自动启动。</p>
<p>然后我们来说说 ServiceConnection 这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceConnection</span> </span>{</div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">     * Called when a connection to the Service has been established, with</span></div><div class="line"><span class="comment">     * the {@link android.os.IBinder} of the communication channel to the</span></div><div class="line"><span class="comment">     * Service.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param name The concrete component name of the service that has</span></div><div class="line"><span class="comment">     * been connected.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param service The IBinder of the Service's communication channel,</span></div><div class="line"><span class="comment">     * which you can now make calls on.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span>(ComponentName name, IBinder service);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Called when a connection to the Service has been lost.  This typically</span></div><div class="line"><span class="comment">     * happens when the process hosting the service has crashed or been killed.</span></div><div class="line"><span class="comment">     * This does &lt;em&gt;not&lt;/em&gt; remove the ServiceConnection itself -- this</span></div><div class="line"><span class="comment">     * binding to the service will remain active, and you will receive a call</span></div><div class="line"><span class="comment">     * to {@link #onServiceConnected} when the Service is next running.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param name The concrete component name of the service whose</span></div><div class="line"><span class="comment">     * connection has been lost.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span>(ComponentName name);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>注释已经说得比较清楚了。在 onServiceConnected 中有 IBinder 对象，前面原理篇说了，这个就是 java 层的 binder 对象，有了这个就是拿到了 Bp 端对象了，就可以通过这个发起 IPC 调用了。一般来说在某个 Activity 中要 bindService，就会让这个 Activity 实现 ServiceConnection 接口，然后在 onServiceConnected 回调取到要使用的 Service 的 binder 对象，然后就完成了普通应用的 binder 对象的传递。</p>
<p>onServiceDisconnected 是告诉你服务连接中断了，在 onServiceDisconnected 中取到的 IBinder 对象无效了。这个时候可能是服务所在的进程被杀掉，或是异常退出了。这个问题后面再说，这里只讨论连接的情况，也就是 IBinder 对象的传递。</p>
<h2 id="Service_相关接口">Service 相关接口</h2>
<p>前面说了 Client 端的接口，在 Client 需要 bindService，那么 Service 这边也有相应的接口。framework 里面有一个抽象类 Service.java ，普通服务都要继承这个类，然后实现 IBinder 接口。这个 Service 是一个抽象类，它有一个比较重要的需要重载的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IBinder <span class="title">onBind</span>(Intent intent);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数的注释太长了，意思就是说需要返回自己服务的 IBinder 对象。没错，这个返回的 IBinder 对象就是前面 Client ServiceConnection 接口 onServiceConnected 的那个参数。只不过在 Service 的 onBind 里返回的是 Bn，到了 Client 的 onServiceConnected 就变成 Bp 了（具体的可以回去看 SS 传递篇，binder 的传递过程是一样的）。</p>
<h2 id="bindService_的实现">bindService 的实现</h2>
<p>前面把接口、用法说完了。我们来看看系统的实现吧。首先我们假设有个一个普通的服务叫 SA（Service A，它在 Proc A 中），另一个普通应用 AppB（它在 Porc B 中）。现在 SA 要提供一些 IPC 接口，它首先得继承 Service ，然后实现 IBinder 接口，并且在 onBind 函数中返回自己实现的 IBinder 对象。 AppB 要调用 SA 的某个接口，那么它就得调用 Context 的 bindService，并且自己实现 ServiceConnection，在 onServiceConnected 中取得 SA 的 IBiner 对象，然后就可以通过取得的 IBinder 对象调用 SA 的 IPC 接口了。</p>
<p>Context 的 bindService 实现在 ContextImpl 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span>(Intent service, ServiceConnection conn,</div><div class="line">        <span class="keyword">int</span> flags) {</div><div class="line">    warnIfCallingFromSystemProcess();</div><div class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, Process.myUserHandle());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 真正干活的是这个函数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span>(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</div><div class="line">        UserHandle user) {</div><div class="line">    IServiceConnection sd;</div><div class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</div><div class="line">    }    </div><div class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) {</div><div class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</div><div class="line">                mMainThread.getHandler(), flags);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</div><div class="line">    }    </div><div class="line">    validateServiceIntent(service);</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        IBinder token = getActivityToken();</div><div class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> && (flags&BIND_AUTO_CREATE) == <span class="number">0</span> && mPackageInfo != <span class="keyword">null</span> </div><div class="line">                && mPackageInfo.getApplicationInfo().targetSdkVersion</div><div class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {</div><div class="line">            flags |= BIND_WAIVE_PRIORITY;</div><div class="line">        }    </div><div class="line">        service.prepareToLeaveProcess();</div><div class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</div><div class="line">            mMainThread.getApplicationThread(), getActivityToken(),</div><div class="line">            service, service.resolveTypeIfNeeded(getContentResolver()),</div><div class="line">            sd, flags, user.getIdentifier());</div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</div><div class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面的代码讲解，我会忽略很多不太重要的东西，因为 ActivityManager（AM）实在是太庞大了，如果追根究底的话，就太多了，而且容易丢掉主要的东西。首先来看看 mPackageInfo 这个东西。它是一个 LoadedApk 的变量。这个类好像是会保存一些加载了 apk 的信息，例如应用 data 目录，lib 目录等等，在这里最重要的是它保存了 service 绑定的一些信息。我们来看看下它的 getServiceDispatcher 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">getServiceDispatcher</span>(ServiceConnection c,</div><div class="line">        Context context, Handler handler, <span class="keyword">int</span> flags) {</div><div class="line">    <span class="keyword">synchronized</span> (mServices) {</div><div class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 这个 mServices 就是连接的信息的 map 表</span></div><div class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</div><div class="line">            sd = map.get(c);</div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (sd == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 没有的话就创建一个新的</span></div><div class="line">            sd = <span class="keyword">new</span> ServiceDispatcher(c, context, handler, flags);</div><div class="line">            <span class="comment">// 然后保存起来，方便下次使用</span></div><div class="line">            <span class="keyword">if</span> (map == <span class="keyword">null</span>) {</div><div class="line">                map = <span class="keyword">new</span> ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</div><div class="line">                mServices.put(context, map);</div><div class="line">            }    </div><div class="line">            map.put(c, sd); </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 如果之前保存就直接取</span></div><div class="line">            sd.validate(context, handler);</div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>接下去看下 ServiceDispatcher（它是 LoadedApk 中的内部类） 这个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> class ServiceDispatcher {</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ServiceDispatcher.InnerConnection mIServiceConnection;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection mConnection;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler mActivityThread;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnectionLeaked mLocation;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mFlags;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> RuntimeException mUnbindLocation;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mDied;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mForgotten;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionInfo</span> </span>{</div><div class="line">            IBinder binder;</div><div class="line">            IBinder.DeathRecipient deathMonitor;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// IserviceConnection 接口的实现</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConnection</span> <span class="keyword">extends</span> <span class="title">IServiceConnection</span>.<span class="title">Stub</span> </span>{</div><div class="line">            <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</div><div class="line"></div><div class="line">            InnerConnection(LoadedApk.ServiceDispatcher sd) {</div><div class="line">                mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span>(ComponentName name, IBinder service) <span class="keyword">throws</span> RemoteException {</div><div class="line">                LoadedApk.ServiceDispatcher sd = mDispatcher.get();</div><div class="line">                <span class="keyword">if</span> (sd != <span class="keyword">null</span>) {              </div><div class="line">                    sd.connected(name, service);   </div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections</div><div class="line">            = <span class="keyword">new</span> ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();</div><div class="line"></div><div class="line">        ServiceDispatcher(ServiceConnection conn,</div><div class="line">                Context context, Handler activityThread, <span class="keyword">int</span> flags) {</div><div class="line">            mIServiceConnection = <span class="keyword">new</span> InnerConnection(<span class="keyword">this</span>);</div><div class="line">            mConnection = conn;            </div><div class="line">            mContext = context;            </div><div class="line">            mActivityThread = activityThread;</div><div class="line">            mLocation = <span class="keyword">new</span> ServiceConnectionLeaked(<span class="keyword">null</span>);</div><div class="line">            mLocation.fillInStackTrace();</div><div class="line">            mFlags = flags;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span>(ComponentName name, IBinder service) {</div><div class="line">            <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) { </div><div class="line">                mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>));</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                doConnected(name, service);    </div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span>(ComponentName name, IBinder service) {</div><div class="line">            ServiceDispatcher.ConnectionInfo old;</div><div class="line">            ServiceDispatcher.ConnectionInfo info;</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {          </div><div class="line">                <span class="keyword">if</span> (mForgotten) {              </div><div class="line">                    <span class="comment">// We unbound before receiving the connection; ignore</span></div><div class="line">                    <span class="comment">// any connection received.    </span></div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">                old = mActiveConnections.get(name);</div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span> && old.binder == service) {</div><div class="line">                    <span class="comment">// Huh, already have this one.  Oh well!</span></div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (service != <span class="keyword">null</span>) {         </div><div class="line">                    <span class="comment">// A new service is being connected... set it all up.</span></div><div class="line">                    mDied = <span class="keyword">false</span>;                 </div><div class="line">                    info = <span class="keyword">new</span> ConnectionInfo();   </div><div class="line">                    info.binder = service;         </div><div class="line">                    info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</div><div class="line">                        mActiveConnections.put(name, info);</div><div class="line">                    } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">                        <span class="comment">// This service was dead before we got it...  just</span></div><div class="line">                        <span class="comment">// don't do anything with it.  </span></div><div class="line">                        mActiveConnections.remove(name);</div><div class="line">                        <span class="keyword">return</span>;                        </div><div class="line">                    }</div><div class="line"></div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// The named service is being disconnected... clean up.</span></div><div class="line">                    mActiveConnections.remove(name);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span>) {             </div><div class="line">                    old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// If there was an old service, it is not disconnected.</span></div><div class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) {</div><div class="line">                mConnection.onServiceDisconnected(name);</div><div class="line">            }</div><div class="line">            <span class="comment">// If there is a new service, it is now connected.</span></div><div class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// 终于调到这个回调了</span></div><div class="line">                mConnection.onServiceConnected(name, service);</div><div class="line">            }</div><div class="line">        }</div><div class="line">... ... </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>



<p>其实 ServiceDispatcher 就是封装了下 ServiceConnection，因为 ServiceConnection 是没有实现 IBinder 接口，但是最后 ServiceConnection 的接口是在 AM 里面调用的，所以它必须要实现 IBinder 接口才能在 AM 调用。所以这里弄了一个 InnerConnection 的实现出来，其实就是包装了下 ServiceConnection 的回调而已。这里还多弄了一堆东西出来，层层调用，这里不管别的，只要知道 InnerConnection 实现的 IServiceConnection 接口能够在 AM 被调用，调用后就会调用 Proc B 实现的 onServiceConnected，然后 Proc B 就能得到 SA 的 IBinder 对像了。</p>
<p>好这里现在就要看看是哪里调用了 IServiceConnection 的接口（其实在 AM 里面）。然后我们回到 ContextImpl 的 bindServiceCommon，取到 IServiceConnection 接口后（这里是 Bn 端），然后就调用 AM 的 bindService 的 IPC 接口了，并且把 IServiceConnection 传了过去。这里 IServiceConnection 也是一个 IBinder 对象来的，它的传递参见 SS 那篇。其实 IBinder 对象的传递，只要有最原始的 Bn 端就能够传递，SS 是把自己的 Bn 传给了 SM，其它进程再从 SM 那取。因为其它进程没 SS 原始 Bn 端。但是在 binder 设计上 SM 是特殊的（handle 固定是 0），在任何进程可以取得到，所以可以通过 SM 取指定的 SS 的 IBinder 对象。这里有 IServiceConnection 的原始 Bn 对象所以是可以传递给 AM 的。</p>
<p>接下来我们就要去看 AM 的 bindService 接口了（其实很多一部分工作是在 AM 里面完成的，普通应用程序通过 SM 取 AM -_-||）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span>(IApplicationThread caller, IBinder token,</div><div class="line">        Intent service, String resolvedType,</div><div class="line">        IServiceConnection connection, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId) {</div><div class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</div><div class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></div><div class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> && service.hasFileDescriptors() == <span class="keyword">true</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service, resolvedType,</div><div class="line">                connection, flags, userId);    </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>AM 中 Service 这一块的相关工作是在 ActiveServices.java 中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">int</span> bindServiceLocked(IApplicationThread caller, IBinder token,</div><div class="line">            Intent service, String resolvedType,</div><div class="line">            IServiceConnection connection, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId) {</div><div class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"bindService: "</span> + service</div><div class="line">                + <span class="string">" type="</span> + resolvedType + <span class="string">" conn="</span> + connection.asBinder()</div><div class="line">                + <span class="string">" flags=0x"</span> + Integer.toHexString(flags));</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 这里取到 ServiceRecord</span></div><div class="line">        ServiceLookupResult res =</div><div class="line">            retrieveServiceLocked(service, resolvedType,</div><div class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg);</div><div class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        ServiceRecord s = res.record;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数比较长，我们只看关键的地方。首先通过 retrieveServiceLocked 获取 ServiceRecord（这个 ServiceRecord 是个比较重要的东西，在 AM 中记录了 Service 的相关数据）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceLookupResult <span class="title">retrieveServiceLocked</span>(Intent service,</div><div class="line">        String resolvedType, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId,</div><div class="line">        <span class="keyword">boolean</span> createIfNeeded, <span class="keyword">boolean</span> callingFromFg) {</div><div class="line">    ServiceRecord r = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"retrieveServiceLocked: "</span> + service</div><div class="line">            + <span class="string">" type="</span> + resolvedType + <span class="string">" callingUid="</span> + callingUid);</div><div class="line"></div><div class="line">    userId = mAm.handleIncomingUser(callingPid, callingUid, userId,</div><div class="line">            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"service"</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    ServiceMap smap = getServiceMap(userId);</div><div class="line">    <span class="keyword">final</span> ComponentName comp = service.getComponent();</div><div class="line">    <span class="comment">// 先通过 ComponentName 在 ServiceMap 中取 ServiceMap</span></div><div class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) {</div><div class="line">        r = smap.mServicesByName.get(comp);</div><div class="line">    }</div><div class="line">    <span class="comment">// ComponentName 没取到的话，再通过 Intent filer 取    </span></div><div class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) {</div><div class="line">        Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(service);</div><div class="line">        r = smap.mServicesByIntent.get(filter);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">try</span> {       </div><div class="line">            ResolveInfo rInfo =</div><div class="line">                AppGlobals.getPackageManager().resolveService(</div><div class="line">                            service, resolvedType,</div><div class="line">                            ActivityManagerService.STOCK_PM_FLAGS, userId);</div><div class="line">            ServiceInfo sInfo =</div><div class="line">                rInfo != <span class="keyword">null</span> ? rInfo.serviceInfo : <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (sInfo == <span class="keyword">null</span>) {</div><div class="line">                Slog.w(TAG, <span class="string">"Unable to start service "</span> + service + <span class="string">" U="</span> + userId +</div><div class="line">                      <span class="string">": not found"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            ComponentName name = <span class="keyword">new</span> ComponentName(</div><div class="line">                    sInfo.applicationInfo.packageName, sInfo.name);</div><div class="line">            <span class="keyword">if</span> (userId &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (mAm.isSingleton(sInfo.processName, sInfo.applicationInfo,</div><div class="line">                        sInfo.name, sInfo.flags)) {</div><div class="line">                    userId = <span class="number">0</span>;</div><div class="line">                    smap = getServiceMap(<span class="number">0</span>);</div><div class="line">                }</div><div class="line">                sInfo = <span class="keyword">new</span> ServiceInfo(sInfo);</div><div class="line">                sInfo.applicationInfo = mAm.getAppInfoForUser(sInfo.applicationInfo, userId);</div><div class="line">            }</div><div class="line">            <span class="comment">// 最后再取一次</span></div><div class="line">            r = smap.mServicesByName.get(name);</div><div class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span> && createIfNeeded) {</div><div class="line">                Intent.FilterComparison filter</div><div class="line">                        = <span class="keyword">new</span> Intent.FilterComparison(service.cloneFilter());</div><div class="line">                ServiceRestarter res = <span class="keyword">new</span> ServiceRestarter();</div><div class="line">                BatteryStatsImpl.Uid.Pkg.Serv ss = <span class="keyword">null</span>;</div><div class="line">                BatteryStatsImpl stats = mAm.mBatteryStatsService.getActiveStatistics();</div><div class="line">                <span class="keyword">synchronized</span> (stats) {</div><div class="line">                    ss = stats.getServiceStatsLocked(</div><div class="line">                            sInfo.applicationInfo.uid, sInfo.packageName,</div><div class="line">                            sInfo.name);</div><div class="line">                }</div><div class="line">                <span class="comment">// 再取不到就 new 一个了</span></div><div class="line">                r = <span class="keyword">new</span> ServiceRecord(mAm, ss, name, filter, sInfo, callingFromFg, res);</div><div class="line">                res.setService(r);</div><div class="line">                <span class="comment">// 然后添加到 ServiceMap 中去</span></div><div class="line">                smap.mServicesByName.put(name, r);</div><div class="line">                smap.mServicesByIntent.put(filter, r);</div><div class="line"></div><div class="line">                <span class="comment">// Make sure this component isn't in the pending list.</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) {</div><div class="line">                    ServiceRecord pr = mPendingServices.get(i);</div><div class="line">                    <span class="keyword">if</span> (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid</div><div class="line">                            && pr.name.equals(name)) {</div><div class="line">                        mPendingServices.remove(i);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">            <span class="comment">// pm is in same process, this will never happen.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 后面 ServiceLookupResult 其实可以不怎么管</span></div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">if</span> (mAm.checkComponentPermission(r.permission,</div><div class="line">                callingPid, callingUid, r.appInfo.uid, r.exported)</div><div class="line">                != PackageManager.PERMISSION_GRANTED) {</div><div class="line">            <span class="keyword">if</span> (!r.exported) {</div><div class="line">                Slog.w(TAG, <span class="string">"Permission Denial: Accessing service "</span> + r.name</div><div class="line">                        + <span class="string">" from pid="</span> + callingPid</div><div class="line">                        + <span class="string">", uid="</span> + callingUid</div><div class="line">                        + <span class="string">" that is not exported from uid "</span> + r.appInfo.uid);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ServiceLookupResult(<span class="keyword">null</span>, <span class="string">"not exported from uid "</span></div><div class="line">                        + r.appInfo.uid);</div><div class="line">            }</div><div class="line">            Slog.w(TAG, <span class="string">"Permission Denial: Accessing service "</span> + r.name</div><div class="line">                    + <span class="string">" from pid="</span> + callingPid</div><div class="line">                    + <span class="string">", uid="</span> + callingUid</div><div class="line">                    + <span class="string">" requires "</span> + r.permission);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceLookupResult(<span class="keyword">null</span>, r.permission);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (!mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid,</div><div class="line">                resolvedType, r.appInfo)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLookupResult(r, <span class="keyword">null</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>AM 中有一个 ServiceMap 保存了 ComponentName、Intent filter 相关的 ServiceRecord （反正通过 Intent 能找得到的）。然后我们来看下 ServiceRecord 的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceRecord.java ======================================</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * A running application service.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">final</span> class ServiceRecord extends Binder {</div><div class="line">    <span class="comment">// Maximum number of delivery attempts before giving up.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DELIVERY_COUNT = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Maximum number of times it can fail during execution before giving up.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DONE_EXECUTING_COUNT = <span class="number">6</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings</div><div class="line">            = <span class="keyword">new</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;();</div><div class="line">                            <span class="comment">// All active bindings to the service.</span></div><div class="line">    <span class="keyword">final</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections</div><div class="line">            = <span class="keyword">new</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt;();</div><div class="line">                            <span class="comment">// IBinder -&gt; ConnectionRecord of all bound clients</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ConnectionRecord.java =====================================</span></div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"><span class="javadoc"> * Description of a single binding to a service.</span></div><div class="line"><span class="javadoc"> */</span></div><div class="line"><span class="keyword">final</span> class ConnectionRecord {</div><div class="line">    <span class="keyword">final</span> AppBindRecord binding;    <span class="comment">// The application/service binding.</span></div><div class="line">    <span class="keyword">final</span> ActivityRecord activity;  <span class="comment">// If non-null, the owning activity.</span></div><div class="line">    <span class="keyword">final</span> IServiceConnection conn;  <span class="comment">// The client connection.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags;                <span class="comment">// Binding options.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> clientLabel;          <span class="comment">// String resource labeling this client.</span></div><div class="line">    <span class="keyword">final</span> PendingIntent clientIntent; <span class="comment">// How to launch the client.</span></div><div class="line">    String stringName;              <span class="comment">// Caching of toString.</span></div><div class="line">    <span class="keyword">boolean</span> serviceDead;            <span class="comment">// Well is it?</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="comment">// IntentBindRecord.java ===================================== </span></div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"><span class="javadoc"> * A particular Intent that has been bound to a Service.</span></div><div class="line"><span class="javadoc"> */</span></div><div class="line"><span class="keyword">final</span> class IntentBindRecord {</div><div class="line">    <span class="javadoc">/** The running service. */</span></div><div class="line">    <span class="keyword">final</span> ServiceRecord service;</div><div class="line">    <span class="javadoc">/** The intent that is bound.*/</span></div><div class="line">    <span class="keyword">final</span> Intent.FilterComparison intent; <span class="comment">//</span></div><div class="line">    <span class="javadoc">/** All apps that have bound to this Intent. */</span></div><div class="line">    <span class="keyword">final</span> ArrayMap&lt;ProcessRecord, AppBindRecord&gt; apps</div><div class="line">            = <span class="keyword">new</span> ArrayMap&lt;ProcessRecord, AppBindRecord&gt;();</div><div class="line">    <span class="javadoc">/** Binder published from service. */</span></div><div class="line">    IBinder binder;</div><div class="line">    <span class="javadoc">/** Set when we have initiated a request for this binder. */</span></div><div class="line">    <span class="keyword">boolean</span> requested;</div><div class="line">    <span class="javadoc">/** Set when we have received the requested binder. */</span></div><div class="line">    <span class="keyword">boolean</span> received;</div><div class="line">    <span class="javadoc">/** Set when we still need to tell the service all clients are unbound. */</span></div><div class="line">    <span class="keyword">boolean</span> hasBound;</div><div class="line">    <span class="javadoc">/** Set when the service's onUnbind() has asked to be told about new clients. */</span></div><div class="line">    <span class="keyword">boolean</span> doRebind;</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ServiceRecord 中有一个 ConnectionRecord 的数组，ConnectionRecord 中有 IServiceConnection 这个 IBinder 接口。这个就是上面封装 Client 中实现的 ServiceConnection 接口。然后 ServiceRcord 里面还有一个 IntentBindRecord 这个记录服务被绑定的信息。不过 new ServiceRecord 那里并没设置 connections，我们接着往下看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActiveServices--bindServiceLocked  ====================</span></div><div class="line"></div><div class="line">        <span class="comment">// s 为之前取到的 ServiceRecord</span></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (unscheduleServiceRestartLocked(s, callerApp.info.uid, <span class="keyword">false</span>)) {</div><div class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"BIND SERVICE WHILE RESTART PENDING: "</span></div><div class="line">                        + s);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((flags&Context.BIND_AUTO_CREATE) != <span class="number">0</span>) {</div><div class="line">                s.lastActivity = SystemClock.uptimeMillis();</div><div class="line">                <span class="keyword">if</span> (!s.hasAutoCreateConnections()) {</div><div class="line">                    <span class="comment">// This is the first binding, let the tracker know.</span></div><div class="line">                    ProcessStats.ServiceState stracker = s.getTracker();</div><div class="line">                    <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) {</div><div class="line">                        stracker.setBound(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(),</div><div class="line">                                s.lastActivity);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 在 ServiceRecord 里取 AppBindRecord，最关键的是这个函数</span></div><div class="line">            <span class="comment">// 会触发ServiceRecord创建IntentBindRecord（如果还没创建的话）</span></div><div class="line">            <span class="comment">// IntentBindRecord 前面说了，保存了绑定的信息的</span></div><div class="line">            AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</div><div class="line">            <span class="comment">// 这里 new ConnectionRecord 了，注意参数 connection 是</span></div><div class="line">            <span class="comment">// client bindService 传过来的 IServiceConnection</span></div><div class="line">            ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</div><div class="line">                    connection, flags, clientLabel, clientIntent);</div><div class="line"></div><div class="line">            <span class="comment">// 之前没 ServiceRecord 的 connections 没设置，这里设置了哦</span></div><div class="line">            IBinder binder = connection.asBinder();</div><div class="line">            ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</div><div class="line">            <span class="keyword">if</span> (clist == <span class="keyword">null</span>) {</div><div class="line">                clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</div><div class="line">                s.connections.put(binder, clist);</div><div class="line">            }</div><div class="line">            clist.add(c);</div><div class="line">            b.connections.add(c);</div><div class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (activity.connections == <span class="keyword">null</span>) {</div><div class="line">                    activity.connections = <span class="keyword">new</span> HashSet&lt;ConnectionRecord&gt;();</div><div class="line">                }</div><div class="line">                activity.connections.add(c);</div><div class="line">            }</div><div class="line">            b.client.connections.add(c);</div><div class="line">            <span class="keyword">if</span> ((c.flags&Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) {</div><div class="line">                b.client.hasAboveClient = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) {</div><div class="line">                updateServiceClientActivitiesLocked(s.app, c);</div><div class="line">            }</div><div class="line">            clist = mServiceConnections.get(binder);</div><div class="line">            <span class="keyword">if</span> (clist == <span class="keyword">null</span>) {</div><div class="line">                clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</div><div class="line">                mServiceConnections.put(binder, clist);</div><div class="line">            }</div><div class="line">            clist.add(c);</div><div class="line"></div><div class="line">            ... ...</div><div class="line"></div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            Binder.restoreCallingIdentity(origId);</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>将 Client 的 IServiceConneciton 保存到 AM 中了。然后后面的处理要分为3种情况来说：</p>
<ol>
<li>要绑定的服务所在的进程已经在运行，并且服务代码也已经执行了，这个时候只要请求绑定服务就行了。</li>
<li>要绑定的服务所在的进程已经在运行，但是服务代码没有执行，这个时候需要执行服务代码，然后再绑定服务。</li>
<li>要绑定的服务的进程还没运行，要先启动服务所在的进程，然后执行服务代码，最后再绑定服务。</li>
</ol>
<h3 id="服务进程和服务都已经启动">服务进程和服务都已经启动</h3>
<p>第一种情况比较简单，进程和服务都在运行，直接绑定就可以了。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-service/1.png" alt=""></p>
<p>我们继续看 bindServiceLocked 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((flags&Context.BIND_AUTO_CREATE) != <span class="number">0</span>) {</div><div class="line">    s.lastActivity = SystemClock.uptimeMillis();</div><div class="line">    <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>) != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>BIND_AUTO_CREATE</code> 前面说了，如果要绑定的服务没启动的话，会自动帮你启动服务。主要是 bringUpServiceLocked 这个函数处理，看名字还挺形象的，把服务拉起来 -_-||。这里既然是第一种情况，我们也当设置了这个标志，进去看看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span>(ServiceRecord r,</div><div class="line">            <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting) {</div><div class="line">        <span class="comment">//Slog.i(TAG, "Bring up service:");</span></div><div class="line">        <span class="comment">//r.dump("  ");</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span> && r.app.thread != <span class="keyword">null</span>) {</div><div class="line">            sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }      </div><div class="line"></div><div class="line">... ...</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>如果是服务所在进程已经在运行（r.app != null），服务代码也已经被执行了（r.app.thread != null），这里啥也没做，马上就返回 null 了。我们回到 bindServiceLocked 继续往下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新下最近运行的程序和 OOM</span></div><div class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span>) {           </div><div class="line">    <span class="comment">// This could have made the service more important.</span></div><div class="line">    mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities, b.client);</div><div class="line">    mAm.updateOomAdjLocked(s.app); </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"Bind "</span> + s + <span class="string">" with "</span> + b</div><div class="line">        + <span class="string">": received="</span> + b.intent.received</div><div class="line">        + <span class="string">" apps="</span> + b.intent.apps.size()</div><div class="line">        + <span class="string">" doRebind="</span> + b.intent.doRebind);</div><div class="line"></div><div class="line"><span class="comment">// 这个判断代表服务已经跑起来了</span></div><div class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span> && b.intent.received) {</div><div class="line">    <span class="comment">// Service is already running, so we can immediately</span></div><div class="line">    <span class="comment">// publish the connection.     </span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 调用 Client 的 IServiceConnection 的接口了</span></div><div class="line">        c.conn.connected(s.name, b.intent.binder);</div><div class="line">    } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">        Slog.w(TAG, <span class="string">"Failure sending service "</span> + s.shortName</div><div class="line">                + <span class="string">" to connection "</span> + c.conn.asBinder()</div><div class="line">                + <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 我们先不管重新绑定的情况</span></div><div class="line">    <span class="comment">// If this is the first app connected back to this binding,</span></div><div class="line">    <span class="comment">// and the service had previously asked to be told when</span></div><div class="line">    <span class="comment">// rebound, then do so.</span></div><div class="line">    <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> && b.intent.doRebind) {</div><div class="line">        requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) {</div><div class="line">    <span class="comment">// 正常应该走这里的</span></div><div class="line">    requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line">getServiceMap(s.userId).ensureNotStartingBackground(s);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里这个 s.app != null &amp;&amp; b.intent.received 判断应该是比较特殊的， app != null 好说。那个 IntentBindRecord 的 received == true 的话，后面会看到，请求绑定的话，会被设置为 true 的，就是说这个已经绑定过了，所以可以直接调用 IServiceConnection 接口了。调用这个接口相关的，后面再说。我们主要看正常路线，就是下面那个 !b.intent.requested。这个会调用 requestServiceBindingLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span>(ServiceRecord r, </div><div class="line">        IntentBindRecord i, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind) {</div><div class="line">    <span class="comment">// 看这个判断，前面那个实际上只有 b.intent.received 有用而已</span></div><div class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// If service is not currently running, can't yet bind.</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 注意这个 requested 的判断，如果已经 requested 过了就不处理了       </span></div><div class="line">    <span class="keyword">if</span> ((!i.requested || rebind) && i.apps.size() &gt; <span class="number">0</span>) {</div><div class="line">        <span class="keyword">try</span> {   </div><div class="line">            <span class="comment">// 远程调用到服务的线程执行绑定操作</span></div><div class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</div><div class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</div><div class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class="line">                    r.app.repProcState);</div><div class="line">            <span class="comment">// 成功后，会把 IntentBindRecord的 requested 设置为 true</span></div><div class="line">            <span class="keyword">if</span> (!rebind) {</div><div class="line">                i.requested = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            i.hasBound = <span class="keyword">true</span>;</div><div class="line">            i.doRebind = <span class="keyword">false</span>;</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"Crashed while binding "</span> + r);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最开始 r.app == null || r.app.thread == null 这个判断说明这条路线需要绑定的服务，进程、执行线程都要在运行才行。然后 r.app.thread 这个其实是一个 IActivityThread 的 IBinder 接口。ActivityThread（AT） 是 android 应用进程的主线程，java 的 main 函数在这个线程里面跑的。AT 管理了进程的主线程，负责执行各种 Activity、Service 和 Broadcast。简单的来说就这里这个 IPC 远程调用，就跑到服务运行的进程中去了。注意传递的一个参数，把 ServiceRecord 传过去了，ServiceRecord 在 java 层继承自 Binder，能够在 IPC 之间传递的。我们来具体看下吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActivityThread.java ==========================</span></div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span>(IBinder token, Intent intent,</div><div class="line">                <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState) {</div><div class="line">            updateProcessState(processState, <span class="keyword">false</span>);</div><div class="line">            BindServiceData s = <span class="keyword">new</span> BindServiceData();</div><div class="line">            s.token = token;</div><div class="line">            s.intent = intent;</div><div class="line">            s.rebind = rebind;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (DEBUG_SERVICE)</div><div class="line">                Slog.v(TAG, <span class="string">"scheduleBindService token="</span> + token + <span class="string">" intent="</span> + intent + <span class="string">" uid="</span></div><div class="line">                        + Binder.getCallingUid() + <span class="string">" pid="</span> + Binder.getCallingPid());</div><div class="line">            sendMessage(H.BIND_SERVICE, s);</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里是发送消息到 Handle 里面去了，然后就返回了。我们看到 AT 的这个 Handle（mH）其实还是在 AT 这个线程里面（代码我不贴了，直接在 AT 中 new 出来的，Looper 还是 AT 的线程来的）。为什么还要费劲转到 Handle 里处理呢。这里说一下，主要是为了能够马上返回，因为这个调用是在 AM 的 bindService 里面的，这个函数后面的调用是有 AM 的锁的。然后后面会看到 handleBindService 里面又要调到 AM 里面去的，然后那个里面也有 AM 的锁，如果这里不返回的话，后面会调用 AM 里面就会死锁的（至于为什么 AM 里面有那么多锁，后面多线程篇会讲到的）。这里返回后后面就为什么处理了，我们去看 AT Handle 里面的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span>(BindServiceData data) {</div><div class="line">    Service s = mServices.get(data.token);</div><div class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</div><div class="line">        Slog.v(TAG, <span class="string">"handleBindService s="</span> + s + <span class="string">" rebind="</span> + data.rebind);</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">try</span> {   </div><div class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="keyword">if</span> (!data.rebind) {</div><div class="line">                    <span class="comment">// 这里调用 Service 实现的 onBind 获取 Service </span></div><div class="line">                    <span class="comment">// 的 IBinder 对象了。</span></div><div class="line">                    IBinder binder = s.onBind(data.intent);</div><div class="line">                    ActivityManagerNative.getDefault().publishService(</div><div class="line">                            data.token, data.intent, binder);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    s.onRebind(data.intent);</div><div class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class="line">                            data.token, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">                }</div><div class="line">                ensureJitEnabled();</div><div class="line">            } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                        <span class="string">"Unable to bind to service "</span> + s</div><div class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>开始那个 mServices 是一个 map，用来保存 Service 对象的，key 是 scheduleBindService 传递的 ServiceRecord 的 IBinder 对象。后面启动服务的时候，会看到，在本线程内每启动一个 Service 会把这个 Service 对象保存到 mServices 里去的。这么看其实可以一个线程里面跑多个服务，在应用层来说应该是一个进程里面可以跑多个服务的（这个是主线程）。</p>
<p>取到 Service 对象后，在 Service 本进程里可以调用 Service 的 onBind 函数取得 Service 的 IBinder 对象。然后把这个 IBinder 对象又传递给 AM 那调用 publishService 了。转了半天又回去了（不过想想其实也是对的，后面要调用 Client 的 IServiceConnection 的回调，这个应该由 AM 处理比较好）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActivityManagerService.java ==========================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span>(IBinder token, Intent intent, IBinder service) {</div><div class="line">        <span class="comment">// Refuse possible leaked file descriptors</span></div><div class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span> && intent.hasFileDescriptors() == <span class="keyword">true</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">            <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</div><div class="line">            }</div><div class="line">            mServices.publishServiceLocked((ServiceRecord)token, intent, service);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然又是要到 ActiveServices.java 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceRecord 被 AM 传递给 ActivityThread，又传回来了 -_-||</span></div><div class="line"><span class="comment">// 第二 service（IBinder） 是 ActivityThread 取的 Service 的，</span></div><div class="line"><span class="comment">// Client 就是要这个 IBinder 对象</span></div><div class="line"><span class="keyword">void</span> publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) {</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"PUBLISHING "</span> + r</div><div class="line">                + <span class="string">" "</span> + intent + <span class="string">": "</span> + service);</div><div class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">            Intent.FilterComparison filter</div><div class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</div><div class="line">            IntentBindRecord b = r.bindings.get(filter);</div><div class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> && !b.received) {</div><div class="line">                b.binder = service;</div><div class="line">                <span class="comment">// 这里 requested 和 received 都设置 true 了</span></div><div class="line">                b.requested = <span class="keyword">true</span>;</div><div class="line">                b.received = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 前面 bindService 保存的 ConnectionRecord 这里要派上用场了</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) {</div><div class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) {</div><div class="line">                        ConnectionRecord c = clist.get(i);</div><div class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) {</div><div class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</div><div class="line">                                    TAG, <span class="string">"Not publishing to: "</span> + c);</div><div class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</div><div class="line">                                    TAG, <span class="string">"Bound intent: "</span> + c.binding.intent.intent);</div><div class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</div><div class="line">                                    TAG, <span class="string">"Published intent: "</span> + intent);</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"Publishing to: "</span> + c);</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="comment">// 终于调 IServiceConnection 回调了</span></div><div class="line">                            c.conn.connected(r.name, service);</div><div class="line">                        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                            Slog.w(TAG, <span class="string">"Failure sending service "</span> + r.name +</div><div class="line">                                  <span class="string">" to connection "</span> + c.conn.asBinder() +</div><div class="line">                                  <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 其他的都先忽略吧</span></div><div class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</div><div class="line">        }</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就算是最后一步了。 ActivityThread 把 Service 的 IBinder 对象传递过来了，然后 AM 把 bindService 中保存的 ConnectionRecord 遍历了一次，依次调用 IServiceConneciton 接口，这样 Client 那里就能得到 Service 的 IBinder 对象了（IBinder 对象的具体传递细节可以看上一篇）。注意下前面把 IntentBindRecord 的 requested 和 received 设置为 true 了，这样能防止重复调用 IServiceConneciton 接口（设置了特殊标志位的除外）。</p>
<h3 id="服务进程已经启动，但是服务还没运行">服务进程已经启动，但是服务还没运行</h3>
<p>接下来我们来看第二种情况，这种情况服务所在进程依然已经启动，但是服务可能还没运行。我们需要启动服务后，再绑定。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-service/2.png" alt=""><br>（handleBindService 后面的我省略了，第一种情况画过了）</p>
<p>这条分支的话，我们在 bringUpServiceLocked 开头不会返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span>(ServiceRecord r,</div><div class="line">            <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting) {</div><div class="line">        <span class="comment">//Slog.i(TAG, "Bring up service:");</span></div><div class="line">        <span class="comment">//r.dump("  ");</span></div><div class="line"></div><div class="line">        <span class="comment">// 这里不会返回</span></div><div class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span> && r.app.thread != <span class="keyword">null</span>) {</div><div class="line">            sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!whileRestarting && r.restartDelay &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// If waiting for a restart, then do nothing.</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG, <span class="string">"Bringing up "</span> + r + <span class="string">" "</span> + r.intent);</div><div class="line"></div><div class="line">        <span class="comment">// We are now bringing the service up, so no longer in the</span></div><div class="line">        <span class="comment">// restarting state.</span></div><div class="line">        <span class="keyword">if</span> (mRestartingServices.remove(r)) {</div><div class="line">            clearRestartingIfNeededLocked(r);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Make sure this service is no longer considered delayed, we are starting it now.</span></div><div class="line">        <span class="keyword">if</span> (r.delayed) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STATS) Slog.v(TAG, <span class="string">"REM FR DELAY LIST (bring up): "</span> + r);</div><div class="line">            getServiceMap(r.userId).mDelayedStartList.remove(r);</div><div class="line">            r.delayed = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that the user who owns this service is started.  If not,</span></div><div class="line">        <span class="comment">// we don't want to allow it to run.</span></div><div class="line">        <span class="keyword">if</span> (mAm.mStartedUsers.get(r.userId) == <span class="keyword">null</span>) {</div><div class="line">            String msg = <span class="string">"Unable to launch app "</span></div><div class="line">                    + r.appInfo.packageName + <span class="string">"/"</span></div><div class="line">                    + r.appInfo.uid + <span class="string">" for service "</span></div><div class="line">                    + r.intent.getIntent() + <span class="string">": user "</span> + r.userId + <span class="string">" is stopped"</span>;</div><div class="line">            Slog.w(TAG, msg);</div><div class="line">            bringDownServiceLocked(r);</div><div class="line">            <span class="keyword">return</span> msg;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Service is now being launched, its package can't be stopped.</span></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</div><div class="line">                    r.packageName, <span class="keyword">false</span>, r.userId);</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        } <span class="keyword">catch</span> (IllegalArgumentException e) {</div><div class="line">            Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></div><div class="line">                    + r.packageName + <span class="string">": "</span> + e);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">final</span> String procName = r.processName;</div><div class="line">        ProcessRecord app;</div><div class="line"></div><div class="line">        <span class="comment">// 前面就打打酱油，主要看下面的，这里正常使用不是 isolated 的</span></div><div class="line">        <span class="keyword">if</span> (!isolated) {</div><div class="line">            <span class="comment">// 通过 Service 的 procName 取 ProcessRecord</span></div><div class="line">            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"bringUpServiceLocked: appInfo.uid="</span> + r.appInfo.uid</div><div class="line">                        + <span class="string">" app="</span> + app);</div><div class="line">            <span class="comment">// 这里如果第二种分支，这里就会走这条分支，去启动服务。</span></div><div class="line">            <span class="comment">// 然后返回，后面和第一种分支一样绑定服务了。</span></div><div class="line">            <span class="keyword">if</span> (app != <span class="keyword">null</span> && app.thread != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    app.addPackage(r.appInfo.packageName, mAm.mProcessStats);</div><div class="line">                    realStartServiceLocked(r, app, execInFg);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// If a dead object exception was thrown -- fall through to</span></div><div class="line">                <span class="comment">// restart the application.</span></div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// If this service runs in an isolated process, then each time</span></div><div class="line">            <span class="comment">// we call startProcessLocked() we will get a new isolated</span></div><div class="line">            <span class="comment">// process, starting another process if we are currently waiting</span></div><div class="line">            <span class="comment">// for a previous process to come up.  To deal with this, we store</span></div><div class="line">            <span class="comment">// in the service any current isolated process it is running in or</span></div><div class="line">            <span class="comment">// waiting to have come up.</span></div><div class="line">            app = r.isolatedProc;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line">       </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>app != null &amp;&amp; app.thread != null 这个判断说明服务所在的进程已经启动了（主线程也在跑了），就调用 realStartServiceLocked 去启动服务。如果不出错的话，启动完成后，bringUpServiceLocked 就会返回 null，然后继续第一种情况的分支，后面绑定服务。我们来看看 realStartServiceLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceRerord 和 ProcessRecord 传递过来了</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span>(ServiceRecord r,</div><div class="line">        ProcessRecord app, <span class="keyword">boolean</span> execInFg) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (DEBUG_MU)</div><div class="line">        Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</div><div class="line">                + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</div><div class="line">    <span class="comment">// 这里把 ProcessRecord 保存到 ServiceRecrod 里面去了</span></div><div class="line">    <span class="comment">// 以前再跑 bindService 就会走第一种情况的分支了 </span></div><div class="line">    r.app = app;</div><div class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</div><div class="line"> </div><div class="line">    app.services.add(r);</div><div class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</div><div class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">    mAm.updateOomAdjLocked();</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        String nameTerm;</div><div class="line">        <span class="keyword">int</span> lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</div><div class="line">        nameTerm = lastPeriod &gt;= <span class="number">0</span> ? r.shortName.substring(lastPeriod) : r.shortName;</div><div class="line">        EventLogTags.writeAmCreateService(</div><div class="line">                r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</div><div class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) {</div><div class="line">            r.stats.startLaunchedLocked();</div><div class="line">        }    </div><div class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</div><div class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</div><div class="line">        <span class="comment">// 和第一种情况差不多，远程跑到服务的进程中调用相关函数处理</span></div><div class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class="line">                app.repProcState);</div><div class="line">        r.postNotification();</div><div class="line">        created = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        <span class="keyword">if</span> (!created) {</div><div class="line">            app.services.remove(r);</div><div class="line">            r.app = <span class="keyword">null</span>;</div><div class="line">            scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</div><div class="line">        }    </div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="comment">// 这里怎么调用请求绑定的函数，后面返回之后同样还会调用的，</span></div><div class="line">    <span class="comment">// 不过有设置变量，倒不会重复调用，不过感觉有点怪</span></div><div class="line">    requestServiceBindingsLocked(r, execInFg);</div><div class="line"></div><div class="line">    <span class="comment">// 后面的忽略了 ... ...</span></div><div class="line">    <span class="comment">// If the service is in the started state, and there are no</span></div><div class="line">    <span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></div><div class="line">    <span class="comment">// be called.</span></div><div class="line">    <span class="keyword">if</span> (r.startRequested && r.callStart && r.pendingStarts.size() == <span class="number">0</span>) {</div><div class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</div><div class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (r.delayed) {</div><div class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STATS) Slog.v(TAG, <span class="string">"REM FR DELAY LIST (new proc): "</span> + r);</div><div class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</div><div class="line">        r.delayed = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (r.delayedStop) {</div><div class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></div><div class="line">        r.delayedStop = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (r.startRequested) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STATS) Slog.v(TAG, <span class="string">"Applying delayed stop (from start): "</span> + r);</div><div class="line">            stopServiceLocked(r);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>只要 realStartServiceLocked 之后，ServiceRecord 的 app 就不是 null 了，以后绑定，就可以走第一种情况的分支（这个快）。然后主要是远程调用到 AT 的 scheduleCreateService 去让 Service 的进程的主线程执行 Service 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span>(IBinder token,</div><div class="line">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState) {</div><div class="line">    updateProcessState(processState, <span class="keyword">false</span>);</div><div class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</div><div class="line">    <span class="comment">// token 是 ServiceRecord 的 IBinder 对象</span></div><div class="line">    s.token = token;</div><div class="line">    <span class="comment">// info 里面有 Service 类名</span></div><div class="line">    s.info = info;</div><div class="line">    s.compatInfo = compatInfo;     </div><div class="line"></div><div class="line">    sendMessage(H.CREATE_SERVICE, s);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里和前面一样也是发到 Handle 里面的，然后能够直接返回，我们先看看返回后，还有什么处理。其实返回后然后会调用 requestServiceBindsLocked（里面调用 requestServiceBindingsLocked） 去请求绑定服务，这个第一种情况的分支分析过了。不过 bringUpServiceLocked 返回 null 后，还有调用这个的，这里有设置标志，不会重复调用的，至于什么会有2个地方有请求绑定服务的函数，后面到第三种情况就知道了。</p>
<p>现在回到 AT 这边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span>(CreateServiceData data) {</div><div class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></div><div class="line">    <span class="comment">// we are back active so skip it.</span></div><div class="line">    unscheduleGcIdler();</div><div class="line"></div><div class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class="line">            data.info.applicationInfo, data.compatInfo);</div><div class="line">    Service service = <span class="keyword">null</span>;        </div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 这里用反射 new 出 Service 的对象出来了                 </span></div><div class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class="line">    } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Unable to instantiate service "</span> + data.info.name</div><div class="line">                + <span class="string">": "</span> + e.toString(), e);     </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</div><div class="line"></div><div class="line">        <span class="comment">// Context 也 new 了一个出来</span></div><div class="line">        ContextImpl context = <span class="keyword">new</span> ContextImpl();</div><div class="line">        context.init(packageInfo, <span class="keyword">null</span>, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line">        context.setOuterContext(service);</div><div class="line">        <span class="comment">// 这个 attach 设置下Service的运行上下文环境（刚刚new出来那个） </span></div><div class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</div><div class="line">                ActivityManagerNative.getDefault());</div><div class="line">        <span class="comment">// 调用了 Service 的生命周期函数 onCreate 了</span></div><div class="line">        service.onCreate();            </div><div class="line">        <span class="comment">// 把这个 new 出来的 Service 对象保存到 mServices 里了。</span></div><div class="line">        <span class="comment">// key 是 ServiceRecord 的 IBinder 对象。</span></div><div class="line">        <span class="comment">// 前面 handleBindService 有用到这个东西。</span></div><div class="line">        mServices.put(data.token, service);</div><div class="line">        <span class="comment">// 后面的忽略 ... ...</span></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class="line">                    data.token, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);          </div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">            <span class="comment">// nothing to do.              </span></div><div class="line">        }</div><div class="line">    } <span class="keyword">catch</span> (Exception e) {</div><div class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Unable to create service "</span> + data.info.name</div><div class="line">                + <span class="string">": "</span> + e.toString(), e);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 scheduleCreateService 名字太形象的，还真是 new 了一个 Service 对象出来 -_-||。这样 Service 的代码就在主线程中加载起来了（执行了）。前面 AM 那边又会调用 requestServiceBindingsLocked 会让 AT 这边继续向 Handle 发一个 handleBindService 的消息，Handle 的 MessageQueue 会排队的，不用担心，能保证先 CreateService 再 BindService。</p>
<h3 id="服务进程没有启动，服务代码也还没执行">服务进程没有启动，服务代码也还没执行</h3>
<p>前面2种情况说完了。第三种是最悲剧的，服务没运行，连所在的进程都还没跑起来。这种情况下需要启动服务所在进程、然后执行服务代码，最后才能绑定服务。这种情况是最慢的，所以 bindService 有些时候回调快、有些时候回调慢，就是这个原因（看我这篇文章里有关 Zygote 启动进程的就知道慢了： <a href="http://light3moon.com/2015/01/31/工作小笔记——Android 动态切换系统字体" title="工作小笔记——Android 动态切换系统字体" target="_blank" rel="external">工作小笔记——Android 动态切换系统字体</a>）。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-service/3.png" alt=""><br>（realStartServiceLocked 后面的我省略了，第二种情况画过了）</p>
<p>我们回到 bringUpServiceLocked 那个分支那：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span>(ServiceRecord r,</div><div class="line">            <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 这里接着前面那里就可以接着往下走了</span></div><div class="line">        <span class="comment">// Not running -- get it started, and enqueue this service record</span></div><div class="line">        <span class="comment">// to be executed when the app comes up.</span></div><div class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 调用 AM 的接口去启动服务的进程</span></div><div class="line">            <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</div><div class="line">                    <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) {</div><div class="line">                String msg = <span class="string">"Unable to launch app "</span></div><div class="line">                        + r.appInfo.packageName + <span class="string">"/"</span></div><div class="line">                        + r.appInfo.uid + <span class="string">" for service "</span></div><div class="line">                        + r.intent.getIntent() + <span class="string">": process is bad"</span>;</div><div class="line">                Slog.w(TAG, msg);</div><div class="line">                bringDownServiceLocked(r);</div><div class="line">                <span class="keyword">return</span> msg;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (isolated) {</div><div class="line">                r.isolatedProc = app;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 把 ServiceRecord 添加到 mPendingServices</span></div><div class="line">        <span class="comment">// 这个玩意后面会有用的</span></div><div class="line">        <span class="keyword">if</span> (!mPendingServices.contains(r)) {</div><div class="line">            mPendingServices.add(r);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 后面的忽略了 ... ...</span></div><div class="line">        <span class="keyword">if</span> (r.delayedStop) {</div><div class="line">            <span class="comment">// Oh and hey we've already been asked to stop!</span></div><div class="line">            r.delayedStop = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (r.startRequested) {</div><div class="line">                <span class="keyword">if</span> (DEBUG_DELAYED_STATS) Slog.v(TAG, <span class="string">"Applying delayed stop (in bring up): "</span> + r);</div><div class="line">                stopServiceLocked(r);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这是第三种情况的分支，前面获取 ProcessRecord 是 null，就会往下走了。然后就要调用 AM 的 startProcessLocked 去启动服务所在的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ProcessRecord startProcessLocked(String processName,</div><div class="line">        ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</div><div class="line">        String hostingType, ComponentName hostingName, <span class="keyword">boolean</span> allowWhileBooting,</div><div class="line">        <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge) {</div><div class="line">    ProcessRecord app;</div><div class="line">    <span class="comment">// 先已经存在的进程记录集中取一下，看是不是进程已经存在了</span></div><div class="line">    <span class="comment">// 已经存在的话用已经存在的进程记录</span></div><div class="line">    <span class="keyword">if</span> (!isolated) {</div><div class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// If this is an isolated process, it can't re-use an existing process.</span></div><div class="line">        app = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// We don't have to do anything more if:</span></div><div class="line">    <span class="comment">// (1) There is an existing application record; and</span></div><div class="line">    <span class="comment">// (2) The caller doesn't think it is dead, OR there is no thread</span></div><div class="line">    <span class="comment">//     object attached to it so we know it couldn't have crashed; and</span></div><div class="line">    <span class="comment">// (3) There is a pid assigned to it, so it is either starting or</span></div><div class="line">    <span class="comment">//     already running.</span></div><div class="line">    <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"startProcess: name="</span> + processName</div><div class="line">            + <span class="string">" app="</span> + app + <span class="string">" knownToBeDead="</span> + knownToBeDead</div><div class="line">            + <span class="string">" thread="</span> + (app != <span class="keyword">null</span> ? app.thread : <span class="keyword">null</span>)</div><div class="line">            + <span class="string">" pid="</span> + (app != <span class="keyword">null</span> ? app.pid : -<span class="number">1</span>));</div><div class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> && app.pid &gt; <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (!knownToBeDead || app.thread == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// We already have the app running, or are waiting for it to</span></div><div class="line">            <span class="comment">// come up (we have a pid but not yet its thread), so keep it.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"App already running: "</span> + app);</div><div class="line">            <span class="comment">// If this is a new package in the process, add the package to the list</span></div><div class="line">            app.addPackage(info.packageName, mProcessStats);</div><div class="line">            <span class="keyword">return</span> app;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// An application record is attached to a previous process,</span></div><div class="line">        <span class="comment">// clean it up now.</span></div><div class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG, <span class="string">"App died: "</span> + app);</div><div class="line">        handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    String hostingNameStr = hostingName != <span class="keyword">null</span></div><div class="line">            ? hostingName.flattenToShortString() : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isolated) {</div><div class="line">        <span class="keyword">if</span> ((intentFlags&Intent.FLAG_FROM_BACKGROUND) != <span class="number">0</span>) {</div><div class="line">            <span class="comment">// If we are in the background, then check to see if this process</span></div><div class="line">            <span class="comment">// is bad.  If so, we will just silently fail.</span></div><div class="line">            <span class="keyword">if</span> (mBadProcesses.get(info.processName, info.uid) != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"Bad process: "</span> + info.uid</div><div class="line">                        + <span class="string">"/"</span> + info.processName);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// When the user is explicitly starting a process, then clear its</span></div><div class="line">            <span class="comment">// crash count so that we won't make it bad until they see at</span></div><div class="line">            <span class="comment">// least one crash dialog again, and make the process good again</span></div><div class="line">            <span class="comment">// if it had been bad.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"Clearing bad process: "</span> + info.uid</div><div class="line">                    + <span class="string">"/"</span> + info.processName);</div><div class="line">            mProcessCrashTimes.remove(info.processName, info.uid);</div><div class="line">            <span class="keyword">if</span> (mBadProcesses.get(info.processName, info.uid) != <span class="keyword">null</span>) {</div><div class="line">                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</div><div class="line">                        UserHandle.getUserId(info.uid), info.uid,</div><div class="line">                        info.processName);</div><div class="line">                mBadProcesses.remove(info.processName, info.uid);</div><div class="line">                <span class="keyword">if</span> (app != <span class="keyword">null</span>) {</div><div class="line">                    app.bad = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 不存在的话，new 一个 ProcessRecord 出来的，然后保存一下</span></div><div class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) {</div><div class="line">        app = newProcessRecordLocked(info, processName, isolated);</div><div class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) {</div><div class="line">            Slog.w(TAG, <span class="string">"Failed making new process record for "</span></div><div class="line">                    + processName + <span class="string">"/"</span> + info.uid + <span class="string">" isolated="</span> + isolated);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        mProcessNames.put(processName, app.uid, app);</div><div class="line">        <span class="keyword">if</span> (isolated) {</div><div class="line">            mIsolatedProcesses.put(app.uid, app);</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// If this is a new package in the process, add the package to the list</span></div><div class="line">        app.addPackage(info.packageName, mProcessStats);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// If the system is not ready yet, then hold off on starting this</span></div><div class="line">    <span class="comment">// process until it is.</span></div><div class="line">    <span class="keyword">if</span> (!mProcessesReady</div><div class="line">            && !isAllowedWhileBooting(info)</div><div class="line">            && !allowWhileBooting) {</div><div class="line">        <span class="keyword">if</span> (!mProcessesOnHold.contains(app)) {</div><div class="line">            mProcessesOnHold.add(app);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"System not ready, putting on hold: "</span> + app);</div><div class="line">        <span class="keyword">return</span> app;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 又是马甲调用</span></div><div class="line">    startProcessLocked(app, hostingType, hostingNameStr);</div><div class="line">    <span class="keyword">return</span> (app.pid != <span class="number">0</span>) ? app : <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面做了一些时候存在的处理，关键的还是最后一个，又调用到另一个同名不同参数的 startProcessLocked 里去了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span>(ProcessRecord app,</div><div class="line">            String hostingType, String hostingNameStr) {</div><div class="line">        <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> && app.pid != MY_PID) {</div><div class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) {</div><div class="line">                mPidsSelfLocked.remove(app.pid);</div><div class="line">                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</div><div class="line">            }</div><div class="line">            app.setPid(<span class="number">0</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG,</div><div class="line">                <span class="string">"startProcessLocked removing on hold: "</span> + app);</div><div class="line">        mProcessesOnHold.remove(app);</div><div class="line">        </div><div class="line">        <span class="comment">// 更新下 cpu 统计        </span></div><div class="line">        updateCpuStats();</div><div class="line">                </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">int</span> uid = app.uid;</div><div class="line">            </div><div class="line">            <span class="comment">// 获取下这个应用的安装位置（对应 class 文件的位置）</span></div><div class="line">            <span class="comment">// 以及用户组等信息</span></div><div class="line">            <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</div><div class="line">            <span class="keyword">if</span> (!app.isolated) {</div><div class="line">                <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="keyword">final</span> PackageManager pm = mContext.getPackageManager();</div><div class="line">                    permGids = pm.getPackageGids(app.info.packageName);</div><div class="line">               </div><div class="line">                    <span class="keyword">if</span> (Environment.isExternalStorageEmulated()) {</div><div class="line">                        <span class="keyword">if</span> (pm.checkPermission(</div><div class="line">                                android.Manifest.permission.ACCESS_ALL_EXTERNAL_STORAGE,</div><div class="line">                                app.info.packageName) == PERMISSION_GRANTED) {</div><div class="line">                            mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER_ALL;</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                } <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"Unable to retrieve gids"</span>, e);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                 * Add shared application GID so applications can share some</span></div><div class="line"><span class="comment">                 * resources like shared libraries</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">if</span> (permGids == <span class="keyword">null</span>) {</div><div class="line">                    gids = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.length + <span class="number">1</span>];</div><div class="line">                    System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">1</span>, permGids.length);</div><div class="line">                }</div><div class="line">                gids[<span class="number">0</span>] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mFactoryTest != SystemServer.FACTORY_TEST_OFF) {</div><div class="line">                <span class="keyword">if</span> (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL</div><div class="line">                        && mTopComponent != <span class="keyword">null</span></div><div class="line">                        && app.processName.equals(mTopComponent.getPackageName())) {</div><div class="line">                    uid = <span class="number">0</span>;</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (mFactoryTest == SystemServer.FACTORY_TEST_HIGH_LEVEL</div><div class="line">                        && (app.info.flags&ApplicationInfo.FLAG_FACTORY_TEST) != <span class="number">0</span>) {</div><div class="line">                    uid = <span class="number">0</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">// 设置下 zygote 调试信息标志</span></div><div class="line">            <span class="keyword">int</span> debugFlags = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) {</div><div class="line">                debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;</div><div class="line">                <span class="comment">// Also turn on CheckJNI for debuggable apps. It's quite</span></div><div class="line">                <span class="comment">// awkward to turn on otherwise.</span></div><div class="line">                debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</div><div class="line">            }</div><div class="line">            <span class="comment">// Run the app in safe mode if its manifest requests so or the</span></div><div class="line">            <span class="comment">// system is booted in safe mode.</span></div><div class="line">            <span class="keyword">if</span> ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != <span class="number">0</span> ||</div><div class="line">                Zygote.systemInSafeMode == <span class="keyword">true</span>) {</div><div class="line">                debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.checkjni"</span>))) {</div><div class="line">                debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.jni.logging"</span>))) {</div><div class="line">                debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.assert"</span>))) {</div><div class="line">                debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 调用 Procss 去启动进程</span></div><div class="line">            <span class="comment">// Start the process.  It will either succeed and return a result containing</span></div><div class="line">            <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></div><div class="line">            Process.ProcessStartResult startResult = Process.start(<span class="string">"android.app.ActivityThread"</span>,</div><div class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class="line">                    app.info.targetSdkVersion, app.info.seinfo, <span class="keyword">null</span>);</div><div class="line"></div><div class="line"><span class="comment">// 后面不贴了，和这里关系不大的</span></div><div class="line">... ...</div><div class="line"></div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">            <span class="comment">// XXX do better error recovery.</span></div><div class="line">            app.setPid(<span class="number">0</span>);</div><div class="line">            Slog.e(TAG, <span class="string">"Failure starting process "</span> + app.processName, e);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>启动进程前面要准备比较多参数。最后是调用 Process.java 中的 start 接口去启动进程的。进程通过 Zygote fork 出来的，细节可以看我前面说的我的那篇工作小笔记。这里发过去的要加载的 java 类是 ActivityThread，前面说了这个是 android 应用程序进程的主线程，里面有 java 的 main 函数。然后通过 Zygote fork 后，Service 的进程就跑起来了，然后会跑到 AT 的 main 函数里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">    SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);  </div><div class="line"></div><div class="line">    Environment.initForCurrentUser();</div><div class="line"></div><div class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line"></div><div class="line">    Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</div><div class="line"></div><div class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">    Looper.prepareMainLooper();    </div><div class="line"></div><div class="line">    <span class="comment">// 关键看这里， attch 这个函数</span></div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread(); </div><div class="line">    thread.attach(<span class="keyword">false</span>); </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) { </div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    }</div><div class="line"></div><div class="line">    AsyncTask.init();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">    Looper.loop();</div><div class="line"></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 main 函数，new 了一个 AT 对象出来，然后跑了 AT 的 attch 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span>(<span class="keyword">boolean</span> system) {</div><div class="line">    sCurrentActivityThread = <span class="keyword">this</span>; </div><div class="line">    mSystemThread = system;</div><div class="line">    <span class="comment">// 系统进程走的下面那个        </span></div><div class="line">    <span class="keyword">if</span> (!system) {</div><div class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {            </div><div class="line">                ensureJitEnabled();            </div><div class="line">            }</div><div class="line">        });</div><div class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</div><div class="line">                                                UserHandle.myUserId());        </div><div class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 主要是这个，调用了 AM 的 attchApplication</span></div><div class="line">            mgr.attachApplication(mAppThread);</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) { </div><div class="line">            <span class="comment">// Ignore</span></div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {       </div><div class="line">        <span class="comment">// 系统进程可能在别的地方 attchApplication 了吧</span></div><div class="line">        <span class="comment">// 看注释不想给系统进程设置崩溃弹出的那个对话框       </span></div><div class="line">        <span class="comment">// Don't set application object here -- if the system crashes,</span></div><div class="line">        <span class="comment">// we can't display an alert, we just want to die die die.</span></div><div class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</div><div class="line">                                                UserHandle.myUserId());        </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            mInstrumentation = <span class="keyword">new</span> Instrumentation();</div><div class="line">            ContextImpl context = <span class="keyword">new</span> ContextImpl();</div><div class="line">            context.init(getSystemContext().mPackageInfo, <span class="keyword">null</span>, <span class="keyword">this</span>);</div><div class="line">            Application app = Instrumentation.newApplication(Application.class, context);</div><div class="line">            mAllApplications.add(app);     </div><div class="line">            mInitialApplication = app;     </div><div class="line">            app.onCreate();                </div><div class="line">        } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                    <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 后面继续忽略 ... ...</span></div><div class="line">    <span class="comment">// add dropbox logging to libcore</span></div><div class="line">    DropBox.setReporter(<span class="keyword">new</span> DropBoxReporter());</div><div class="line"></div><div class="line">    ViewRootImpl.addConfigCallback(<span class="keyword">new</span> ComponentCallbacks2() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span>(Configuration newConfig) {</div><div class="line">            <span class="keyword">synchronized</span> (mResourcesManager) {</div><div class="line">                <span class="comment">// We need to apply this change to the resources</span></div><div class="line">                <span class="comment">// immediately, because upon returning the view</span></div><div class="line">                <span class="comment">// hierarchy will be informed about it.</span></div><div class="line">                <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, <span class="keyword">null</span>)) {</div><div class="line">                    <span class="comment">// This actually changed the resources!  Tell</span></div><div class="line">                    <span class="comment">// everyone about it.</span></div><div class="line">                    <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span> ||</div><div class="line">                            mPendingConfiguration.isOtherSeqNewer(newConfig)) {</div><div class="line">                        mPendingConfiguration = newConfig;</div><div class="line"></div><div class="line">                        sendMessage(H.CONFIGURATION_CHANGED, newConfig);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span>() {</div><div class="line">        }</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span>(<span class="keyword">int</span> level) {</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里主要是看调用 AM 的 attachApplication，然后又转到 AM 里面了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span>(IApplicationThread thread) {</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity(); </div><div class="line">        attachApplicationLocked(thread, callingPid);</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>是个马甲，但是注意锁。这里我们要回到前面 AM 调用 Process 去 start 服务进程那里，因为那里也是有锁的。所以 AT 这里的 atttach 应该是会被锁住的（binder 的多线程问题见我的另一篇线程篇）。我们先回去到 AM 调用完 Process.start 那里。回去看前面的代码，调用 Process.start 就会从 AM 返回到 bringUpServiceLocked，然后后面把 ServiceRecord 添加到 mPendingServices，然后返回 null 到 bindServiceLocked 继续往下执行，但是到 requestServiceBindingLocked 那里回由于 ServiceRecord 的 app 为 null 而失败，因为进程虽然跑起来了，但是服务还没执行。然后这个 Client 的 AM 的 bindService 应该就调用结束了。然后 AM 的锁就应该没了，现在可以继续回到 Service 的 AT 调用 AM 的 attachApplication 那里继续了。</p>
<p>这里是调用了另一个 attachApplicationLocked:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span>(IApplicationThread thread,</div><div class="line">            <span class="keyword">int</span> pid) {</div><div class="line"></div><div class="line">        <span class="comment">// Find the application record that is being attached...  either via</span></div><div class="line">        <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></div><div class="line">        <span class="comment">// next app record if we are emulating process with anonymous threads.</span></div><div class="line">        ProcessRecord app;</div><div class="line">        <span class="keyword">if</span> (pid != MY_PID && pid &gt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) {</div><div class="line">                app = mPidsSelfLocked.get(pid);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            app = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line"><span class="comment">// 这函数太长了，前面都是和这篇关系不大的，忽略先</span></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 主要看这个，果然又调用到 ActiveServices 里面去了</span></div><div class="line">        <span class="comment">// Find any services that should be running in this process...</span></div><div class="line">        <span class="keyword">if</span> (!badApp) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                didSomething |= mServices.attachApplicationLocked(app, processName);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                badApp = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!didSomething) {</div><div class="line">            updateOomAdjLocked();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们继续去 ActiveServices 里面去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> attachApplicationLocked(ProcessRecord proc, String processName) <span class="keyword">throws</span> Exception {</div><div class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 前面那个 mPendingServices 作用就是这里啦</span></div><div class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></div><div class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) {</div><div class="line">        ServiceRecord sr = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {   </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) {</div><div class="line">                sr = mPendingServices.get(i);</div><div class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc && (proc.uid != sr.appInfo.uid</div><div class="line">                        || !processName.equals(sr.processName))) {</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">        </div><div class="line">                <span class="comment">// 调用 realStartServiceLocked 去启动服务了</span></div><div class="line">                mPendingServices.remove(i);</div><div class="line">                i--;</div><div class="line">                proc.addPackage(sr.appInfo.packageName, mAm.mProcessStats);</div><div class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</div><div class="line">                didSomething = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            Slog.w(TAG, <span class="string">"Exception in new application when starting service "</span></div><div class="line">                    + sr.shortName, e);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        }   </div><div class="line">    }       </div><div class="line">    <span class="comment">// Also, if there are any services that are waiting to restart and</span></div><div class="line">    <span class="comment">// would run in this process, now is a good time to start them.  It would</span></div><div class="line">    <span class="comment">// be weird to bring up the process but arbitrarily not let the services</span></div><div class="line">    <span class="comment">// run at this point just because their restart time hasn't come up.</span></div><div class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) {</div><div class="line">        ServiceRecord sr = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) {</div><div class="line">            sr = mRestartingServices.get(i);</div><div class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc && (proc.uid != sr.appInfo.uid</div><div class="line">                    || !processName.equals(sr.processName))) {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</div><div class="line">            mAm.mHandler.post(sr.restarter);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> didSomething;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得前面 bringUpServiceLocked 调用完 AM startProcessLocked 把 ServiceRecord 添加到 mPendingServices 中，我说这个东西后面会有用的。就是在这里用的。前面也看到了，bindService 继续完后走，但是由于服务还没执行，所以无法进行绑定操作。所以就拿了个东西把要绑定的服务信息保存起来，当服务所在的进程跑起来去 attach 上下文的时候去检测这个东西，如果有的话就去启动需要绑定的服务。怪不得叫 Pending XX ，其实就是延迟处理的意思。怪不得前面分析 realStartServiceLocked 为什么最后那里还有 requestServiceBindingsLocked 的操作，明明 bindServiceLocked 后面已经有了，原来是这里用的啊。</p>
<p>realStartServiceLocked 前面分析过了，回去看看吧，这里不重复说了。到这里 bindService 三种情况都说完了。可以看得出来第三种情况是最麻烦的，得拿个东西保存一下要绑定的信息，然后去启动服务所在的进程，等进程跑主线程的 main 函数再去执行服务代码，然后才能绑定。</p>
<h2 id="总结">总结</h2>
<p>普通服务的 binder 对象的传递就分析完了。其实普通服务 binder 对象的获取原理上和 SS 是差不多的，SS 是向 SM 注册，然后 SM 保存了 SS binder 的 handle 值，然后通过向 SM 取 SS 的 binder 对象。而普通服务则是在启动的时候在 AM 保存了 ServiceRecord，然后普通应用通过 AM 的 bindService 去让 AM 向普通服务要 binder 对象，然后传给普通应用。感觉对于普通应用（服务）来说，AM 就牵了根线，有点像 SM 的感觉了。还有一点区别，SS 是一开机就启动的，正常情况下一直运行的，所以不存在说服务还没运行一说，所以 SM 一直返回之前保存的 handle 值就行了。但是普通服务没这待遇，开机不一定能启动不说，还可能由于系统资源不足而被杀死，所以 AM 在 bindService 的时候还得兼顾进程、服务还没启动的情况。</p>
<p>这就是铁饭碗和临时工的区别啊 -_-|| 。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/</loc>
    <lastmod>2015-03-31T06:29:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——多线程支持</title>
        <pubTime>2015-01-28T13:42:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>前面普通服务篇那里说到 ActivityManager（AM） 里锁的问题，其实不光 AM，WindowManager（WM）、PackageMananger（PM）中基本上很多对外的业务函数里面都是加锁的，所以这些 SS 里面有会有带 Locked 结尾的函数（这些函数都是在锁里执行）。这里就提出一个疑问为什么要加锁。这篇就来解答这个问题，顺带扯出 binder 的多线程支持的问题。</p>
<p>照例先把相关源码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java 层 SS 相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/SystemServer.java</div><div class="line"></div><div class="line"><span class="comment"># java 层 zygote 相关接口</span></div><div class="line">frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</div><div class="line">frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</div><div class="line">libcore/dalvik/src/main/java/dalvik/system/Zygote.java</div><div class="line"></div><div class="line"><span class="comment"># jni runtime 接口</span></div><div class="line">frameworks/base/core/jni/AndroidRuntime.cpp</div><div class="line"></div><div class="line"><span class="comment"># native app process 程序</span></div><div class="line">frameworks/base/cmds/app_process/app_main.cpp</div><div class="line"></div><div class="line"><span class="comment"># native binder 库</span></div><div class="line">frameworks/native/libs/binder/ProcessState.cpp</div><div class="line">frameworks/native/libs/binder/IPCThreadState.cpp</div><div class="line">frameworks/native/libs/binder/Static.cpp</div><div class="line"></div><div class="line"><span class="comment"># native SS 主程序</span></div><div class="line">frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</div><div class="line">frameworks/native/services/sensorservice/main_sensorservice.cpp</div><div class="line"></div><div class="line"><span class="comment"># libutils 库（线程支持）</span></div><div class="line">system/core/include/utils/AndroidThreads.h</div><div class="line">system/core/include/utils/Thread.h</div><div class="line">system/core/libutils/Threads.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="SS_多线程的例子">SS 多线程的例子</h2>
<p>前面说了 binder 是 C/S 模型。既然是 C/S 模型，很容易让人想到会服务器同时可能会被多个客户端连接、请求。传统的服务器，都会开一个线程池来应对这种情况，避免请求数一多，某些客户端长时间没响应的情况。</p>
<p>这个在 binder 中是一样的，只不过 binder 是本地的而已（这里说的本地是相对网络上的服务器来说的）。你想想你写 android 代码的时候，经常就 get AM ，然后 AM xx 的调用了。所以说 binder 中的 Bn 端经常会同一时候有多个 Bp 请求的，特别是 SS（谁让它们是公用的）。既然这样的话，我们在写服务的时候是不是也要像传统的服务器一样考虑使用线程池来提高服务的并发响应能力咧。先别急，android 早就帮我们整好一个现成的框架了。</p>
<p>我们先来看看一些实际的列子。我们以 sensorservice 为例（先说 native 的 SS，java 层的要绕好久，后面再说）。sensorservice 的 main 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main_sensorservice.cpp =============================</span></div><div class="line"></div><div class="line"><span class="comment">// 这个 main 函数就一句话 ... ...</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    SensorService::publishAndJoinThreadPool();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>SensorService 是继承自 BinderService 的类，我们去看看 BinderService：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BinderService.h =============================</span></div><div class="line"></div><div class="line"><span class="comment">// 这是一个模板类</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</div><div class="line"><span class="keyword">class</span> BinderService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> status_t publish(<span class="keyword">bool</span> allowIsolated = <span class="keyword">false</span>) {</div><div class="line">        <span class="comment">// 获取 SM</span></div><div class="line">        sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">        <span class="comment">// new Service 对象，然后 add 到 SM 中</span></div><div class="line">        <span class="keyword">return</span> sm-&gt;addService(</div><div class="line">                String16(SERVICE::getServiceName()),</div><div class="line">                <span class="keyword">new</span> SERVICE(), allowIsolated);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> publishAndJoinThreadPool(<span class="keyword">bool</span> allowIsolated = <span class="keyword">false</span>) {</div><div class="line">        publish(allowIsolated);</div><div class="line">        joinThreadPool();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> instantiate() { publish(); }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> status_t shutdown() { <span class="keyword">return</span> NO_ERROR; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> joinThreadPool() {</div><div class="line">        <span class="comment">// 初始化 ProcessState 对象</span></div><div class="line">        sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">        <span class="comment">// 启动线程池</span></div><div class="line">        ps-&gt;startThreadPool();</div><div class="line">        ps-&gt;giveThreadPoolName();</div><div class="line">        <span class="comment">// 当前线程加入线程池</span></div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 BinderService.h 是在 natvie binder 的 include 头文件中，看样子 android 直接提供了一个模板，SS 直接继承，然后在 main 函数调用一句话就行了。模板就是先 new 一个 Service 对象，然后 add 到 SM 中，然后构造一个 ProcessState 对象（这个对象一个进程只有一个），调用 ProcessState-&gt;startThreadPool 开线程池（新开了一个线程），最后调用 IPCThreadState-&gt;joinThreadPool 将当前进程加入到线程池中（开始阻塞等待了）。</p>
<h2 id="进程对象和线程对象">进程对象和线程对象</h2>
<p>new Service 对象不说了，不同的服务逻辑不一样的。先来看 ProcessState。这个东西前面通信篇介绍过的，一个进程就一个对象，怎么保证的呢，来看它的典型调用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Static.cpp =====================================</span></div><div class="line"></div><div class="line"><span class="comment">// 原来整了一个静态变量噻</span></div><div class="line">Mutex gProcessMutex;</div><div class="line">sp&lt;ProcessState&gt; gProcess;</div><div class="line"></div><div class="line"><span class="comment">// ProcessState.h =================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> ProcessState : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 这个也是一个静态函数</span></div><div class="line">    <span class="keyword">static</span>  sp&lt;ProcessState&gt;    self();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// ProcessState.cpp ================================</span></div><div class="line"></div><div class="line">sp&lt;ProcessState&gt; ProcessState::self()</div><div class="line">{</div><div class="line">    Mutex::Autolock _l(gProcessMutex);</div><div class="line">    <span class="keyword">if</span> (gProcess != NULL) {</div><div class="line">        <span class="keyword">return</span> gProcess;        </div><div class="line">    }</div><div class="line">    gProcess = <span class="keyword">new</span> ProcessState;</div><div class="line">    <span class="keyword">return</span> gProcess;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>就是搞了一个静态变量，然后一个进程只会创建一次，之后就直接返回这个静态变量就行了，借此来保证一个进程就只有一个 ProcessState 对象，怪不得叫 ProcessState。然后 self() 是静态的，而且无参数，所以进程任何地方任何时候都能够使用。</p>
<p>既然说到了 ProcessState 的 self()，我们顺带也来看下 IPCThreadState 的 self()。看名字这个应该就是一个线程有一个这样对象的了。这个是怎么实现的咧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IPCThreadState.h ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> IPCThreadState</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span>  IPCThreadState*     self();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IPCThreadState.cpp ==============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gHaveTLS = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">static</span> pthread_key_t gTLS = <span class="number">0</span>; </div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gShutdown = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gDisableBackgroundScheduling = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">IPCThreadState* IPCThreadState::self()</div><div class="line">{</div><div class="line">    <span class="comment">// 首先得确保 pthread_key 创建了</span></div><div class="line">    <span class="keyword">if</span> (gHaveTLS) {</div><div class="line">restart:</div><div class="line">        <span class="keyword">const</span> pthread_key_t k = gTLS;</div><div class="line">        <span class="comment">// 如果之前设置了线程私有变量，取线程私有变量返回</span></div><div class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</div><div class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</div><div class="line">        <span class="comment">// 否则 new 一个新对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 如果线程已经退出了，就直接返回 NULL 了</span></div><div class="line">    <span class="keyword">if</span> (gShutdown) <span class="keyword">return</span> NULL;</div><div class="line">    </div><div class="line">    <span class="comment">// pthread_key 没创建的话，先创建 pthread_key</span></div><div class="line">    pthread_mutex_lock(&gTLSMutex);</div><div class="line">    <span class="keyword">if</span> (!gHaveTLS) {</div><div class="line">        <span class="keyword">if</span> (pthread_key_create(&gTLS, threadDestructor) != <span class="number">0</span>) { </div><div class="line">            pthread_mutex_unlock(&gTLSMutex);</div><div class="line">            <span class="keyword">return</span> NULL;</div><div class="line">        }    </div><div class="line">        gHaveTLS = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    pthread_mutex_unlock(&gTLSMutex);</div><div class="line">    <span class="comment">// 回去取线程私有变量</span></div><div class="line">    <span class="keyword">goto</span> restart;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>IPCThreadState 的 self() 稍微复杂点，因为一个进程有多个线程，要保证一个线程一个对象，这个时候就有利用 linux pthread 的线程私有变量，这个东西可以给每一个 pthread 线程（android 使用 linux 的 pthread 作为多线程的支持）创建一个线程独立的私有变量，这个变量是线程私有的，不用考虑多线程的互斥、锁问题。利用这个特性就很容易显示一个线程一个对象了，把 IPCThreadState 对象保存为 pthread 的线程私有变量就行了，用得的时候就去取线程私有变量，每个线程都是自己的。有了这些知识，上面的代码就不难理解了，就是开始看有没有设置线程私有变量（取之前得先创建 phtread_key，这方面的用法可以去看《UNIX环境高级编程》这本书），有的话直接去线程私有变量就行了，没有的话就 new 一个 IPCThreadState 出来。但是是在哪设置线程私有变量的咧，我们来看看 IPCThreadState 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IPCThreadState::IPCThreadState()</div><div class="line">    : mProcess(ProcessState::self()),</div><div class="line">      mMyThreadId(androidGetTid()),</div><div class="line">      mStrictModePolicy(<span class="number">0</span>),</div><div class="line">      mLastTransactionBinderFlags(<span class="number">0</span>) </div><div class="line">{</div><div class="line">    <span class="comment">// 就是这里把自己的对象设置为线程私有变量啦</span></div><div class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</div><div class="line">    clearCaller();</div><div class="line">    mIn.setDataCapacity(<span class="number">256</span>);</div><div class="line">    mOut.setDataCapacity(<span class="number">256</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>第一句就是设置。然后我们回去看下 <code>pthread_key_create</code> 第二参数 threadDestructor，这是一个函数指针，是说线程退出的话，就调用这个函数，我们看看里面做了什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::threadDestructor(<span class="keyword">void</span> *st)</div><div class="line">{</div><div class="line">        IPCThreadState* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;IPCThreadState*&gt;(st);</div><div class="line">        <span class="keyword">if</span> (self) {</div><div class="line">                self-&gt;flushCommands();</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_ANDROID_OS)</span></div><div class="line">        <span class="keyword">if</span> (self-&gt;mProcess-&gt;mDriverFD &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 向 binder 发送线程退出的命令</span></div><div class="line">            ioctl(self-&gt;mProcess-&gt;mDriverFD, BINDER_THREAD_EXIT, <span class="number">0</span>);</div><div class="line">        }   </div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span>      </span></div><div class="line">                <span class="keyword">delete</span> self;</div><div class="line">        }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个退出函数调用 ioctl 对 binder 驱动发送了一条 <code>BINDER_THREAD_EXIT</code> 退出的消息。这个消息后面再说，不过到最后你会发现这个函数其实暂时没用的。</p>
<p>现在我们知道了在进程任何地方调用 ProcessState::self() 就能取到本进程的进程对象，并且可以调用一些 binder 进程相关的接口，在进程任何地方调用 IPCThreadState::self() 就能取得当前线程的对象，并且可以调用一些 binder 线程相关的接口。</p>
<h2 id="多线程接口实现-上">多线程接口实现.上</h2>
<p>其实前面调用的接口就2个：ProcessState 的 startThreadPool 和 IPCThreadState 的 joinThreadPool。我们先来看 startThreadPool：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ProcessState::startThreadPool()</div><div class="line">{</div><div class="line">    AutoMutex _l(mLock);</div><div class="line">    <span class="comment">// 看样子这个判断，startThreadPool 的调用只会有效一次</span></div><div class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) {</div><div class="line">        mThreadPoolStarted = <span class="keyword">true</span>;     </div><div class="line">        spawnPooledThread(<span class="keyword">true</span>);       </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后看下 spawnPooledThread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面传递过来的 isMain 是 true</span></div><div class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mThreadPoolStarted) {</div><div class="line">        String8 name = makeBinderThreadName(); </div><div class="line">        ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, name.<span class="built_in">string</span>());</div><div class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</div><div class="line">        t-&gt;run(name.<span class="built_in">string</span>());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数很简单，主要是 new 了一个 PoolThread 对象，然后调用了它的 run 方法。这里就先要暂停一下，插说下 android 线程的东西。</p>
<h2 id="android_中的线程">android 中的线程</h2>
<p>android 中的线程到底是啥东西。这里先说下答案：就是 pthread，native 层的从代码可以看得出，java 层的虽然是虚拟机实现的，但是应该还是用 pthread 实现的（我猜的，没去看代码）。这里就看下 natvie 的就行了。</p>
<p>首先之前在 ProcessState 中 new 的 PoolThread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> PoolThread : <span class="keyword">public</span> Thread</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PoolThread(<span class="keyword">bool</span> isMain)</div><div class="line">        : mIsMain(isMain)</div><div class="line">    {</div><div class="line">    }</div><div class="line">       </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> threadLoop()</div><div class="line">    {</div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>PoolThread 很简单，它继承自 libutils 里面的 Thread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Thread : <span class="keyword">virtual</span> <span class="keyword">public</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Create a Thread object, but doesn't create or start the associated</span></div><div class="line">    <span class="comment">// thread. See the run() method.</span></div><div class="line">                        Thread(<span class="keyword">bool</span> canCallJava = <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">virtual</span>             ~Thread();</div><div class="line"></div><div class="line">    <span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></div><div class="line">    <span class="keyword">virtual</span> status_t    run(    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="number">0</span>,</div><div class="line">                                int32_t priority = PRIORITY_DEFAULT,</div><div class="line">                                size_t <span class="built_in">stack</span> = <span class="number">0</span>); </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></div><div class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></div><div class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></div><div class="line">    <span class="comment">//          requestExit() wasn't called.</span></div><div class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span>        threadLoop() = <span class="number">0</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>



<p>这个就算是基类了（父类都是我讨厌的那个引用计数的玩意了）。这类就封装了 android 线程的实现。有2个重要的函数，看注释。一个是 run，看注释说 new 了 Thread 对象后，线程并没有执行，要调用 run 才会跑的。第二是 threadLoop，子类要重载这个函数，就是线程真正的执行函数（回调），如果返回 false，调用一次线程就会结束，如果返回 true，这个函数会循环调用执行。我们看到 PoolThread 重载了 threadLoop 这个函数，在里面调用了 IPCThread 的 joinThreadPool，然后返回 false。</p>
<p>我们一个一个看，首先看下 Thread 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread::Thread(<span class="keyword">bool</span> canCallJava)</div><div class="line">    :   mCanCallJava(canCallJava),</div><div class="line">        mThread(thread_id_t(-<span class="number">1</span>)),</div><div class="line">        mLock(<span class="string">"Thread::mLock"</span>),</div><div class="line">        mStatus(NO_ERROR),</div><div class="line">        mExitPending(<span class="keyword">false</span>), mRunning(<span class="keyword">false</span>)</div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS</span></div><div class="line">        , mTid(-<span class="number">1</span>)</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">Thread::~Thread()</div><div class="line">{</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>构造函数挺简单，我们这里关心的是 mCanCallJava 这个 bool 值，默认是 true，这个值表示在 native 的线程能不能调用虚拟机 java 的环境（例如利用个反射，调用一些 java 层的函数等等）。然后我们看 run：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">status_t Thread::run(<span class="keyword">const</span> <span class="keyword">char</span>* name, int32_t priority, size_t <span class="built_in">stack</span>)</div><div class="line">{</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    </div><div class="line">    <span class="comment">// 正在运行的，不允许再执行</span></div><div class="line">    <span class="keyword">if</span> (mRunning) {</div><div class="line">        <span class="comment">// thread already started</span></div><div class="line">        <span class="keyword">return</span> INVALID_OPERATION;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// reset status and exitPending to their default value, so we can</span></div><div class="line">    <span class="comment">// try again after an error happened (either below, or in readyToRun())</span></div><div class="line">    mStatus = NO_ERROR;</div><div class="line">    mExitPending = <span class="keyword">false</span>;</div><div class="line">    mThread = thread_id_t(-<span class="number">1</span>);</div><div class="line">        </div><div class="line">    <span class="comment">// hold a strong reference on ourself</span></div><div class="line">    mHoldSelf = <span class="keyword">this</span>;</div><div class="line">    </div><div class="line">    mRunning = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 这里，前面说了默认是 true，就是走上面那个分支</span></div><div class="line">    <span class="keyword">bool</span> res;</div><div class="line">    <span class="keyword">if</span> (mCanCallJava) {</div><div class="line">        res = createThreadEtc(_threadLoop,</div><div class="line">                <span class="keyword">this</span>, name, priority, <span class="built_in">stack</span>, &mThread);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        res = androidCreateRawThreadEtc(_threadLoop,</div><div class="line">                <span class="keyword">this</span>, name, priority, <span class="built_in">stack</span>, &mThread);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res == <span class="keyword">false</span>) {</div><div class="line">        mStatus = UNKNOWN_ERROR;   <span class="comment">// something happened!</span></div><div class="line">        mRunning = <span class="keyword">false</span>;</div><div class="line">        mThread = thread_id_t(-<span class="number">1</span>);</div><div class="line">        mHoldSelf.clear();  <span class="comment">// "this" may have gone away after this.</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Do not refer to mStatus here: The thread is already running (may, in fact</span></div><div class="line">    <span class="comment">// already have exited with a valid mStatus result). The NO_ERROR indication</span></div><div class="line">    <span class="comment">// here merely indicates successfully starting the thread and does not</span></div><div class="line">    <span class="comment">// imply successful termination/execution.</span></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    <span class="comment">// Exiting scope of mLock is a memory barrier and allows new thread to run</span></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数其实最关键就是 mCanCallJava 这里的这个2个分支，这才是创建线程的地方。mCanCallJava 前面说了默认是 true，就是说一般是走前面那个分支的，但是这里我们先说下面那个分支（至于原因后面你就知道了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entryFunction 是线程执行函数指针</span></div><div class="line"><span class="keyword">int</span> androidCreateRawThreadEtc(android_thread_func_t entryFunction,</div><div class="line">                               <span class="keyword">void</span> *userData,                </div><div class="line">                               <span class="keyword">const</span> <span class="keyword">char</span>* threadName,        </div><div class="line">                               int32_t threadPriority,        </div><div class="line">                               size_t threadStackSize,        </div><div class="line">                               android_thread_id_t *threadId) </div><div class="line">{</div><div class="line">    <span class="comment">// 呵呵，是 pthread 的调用了吧</span></div><div class="line">    pthread_attr_t attr;</div><div class="line">    pthread_attr_init(&attr);</div><div class="line">    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS  /* valgrind is rejecting RT-priority create reqs */</span></div><div class="line">    <span class="keyword">if</span> (threadPriority != PRIORITY_DEFAULT || threadName != NULL) {</div><div class="line">        <span class="comment">// Now that the pthread_t has a method to find the associated</span></div><div class="line">        <span class="comment">// android_thread_id_t (pid) from pthread_t, it would be possible to avoid</span></div><div class="line">        <span class="comment">// this trampoline in some cases as the parent could set the properties</span></div><div class="line">        <span class="comment">// for the child.  However, there would be a race condition because the</span></div><div class="line">        <span class="comment">// child becomes ready immediately, and it doesn't work for the name.</span></div><div class="line">        <span class="comment">// prctl(PR_SET_NAME) only works for self; prctl(PR_SET_THREAD_NAME) was</span></div><div class="line">        <span class="comment">// proposed but not yet accepted.</span></div><div class="line">        thread_data_t* t = <span class="keyword">new</span> thread_data_t;</div><div class="line">        t-&gt;priority = threadPriority;  </div><div class="line">        t-&gt;threadName = threadName ? strdup(threadName) : NULL;</div><div class="line">        t-&gt;entryFunction = entryFunction;</div><div class="line">        t-&gt;userData = userData;        </div><div class="line">        entryFunction = (android_thread_func_t)&thread_data_t::trampoline;</div><div class="line">        userData = t;                  </div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (threadStackSize) {</div><div class="line">        pthread_attr_setstacksize(&attr, threadStackSize);</div><div class="line">    }</div><div class="line">    </div><div class="line">    errno = <span class="number">0</span>;</div><div class="line">    pthread_t thread;</div><div class="line">    <span class="keyword">int</span> result = pthread_create(&thread, &attr, </div><div class="line">                    (android_pthread_entry)entryFunction, userData);</div><div class="line">    pthread_attr_destroy(&attr);</div><div class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) {</div><div class="line">        ALOGE(<span class="string">"androidCreateRawThreadEtc failed (entry=%p, res=%d, errno=%d)\n"</span></div><div class="line">             <span class="string">"(android threadPriority=%d)"</span>, </div><div class="line">            entryFunction, result, errno, threadPriority);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Note that *threadID is directly available to the parent only, as it is</span></div><div class="line">    <span class="comment">// assigned after the child starts.  Use memory barrier / lock if the child</span></div><div class="line">    <span class="comment">// or other threads also need access.</span></div><div class="line">    <span class="keyword">if</span> (threadId != NULL) {</div><div class="line">        *threadId = (android_thread_id_t)thread; <span class="comment">// XXX: this is not portable</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面也好说了对 phread 的接口不太清楚的去看《UNIX高级环境编程》。这里简单说下，传了线程执行函数、线程名字、优先级、线程堆栈、用户自定义数据进来，然后那个 threadId 是个输出参数，返回的是线程的 id 号（tid，类似 pid）。函数返回后，<code>pthread_create</code> 就会创建线程，并且执行 entryFunction。这里传过来的 entryFunction 是 <code>_threadLoop</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Thread::_threadLoop(<span class="keyword">void</span>* user)</div><div class="line">{</div><div class="line">    Thread* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;Thread*&gt;(user);</div><div class="line"></div><div class="line">    sp&lt;Thread&gt; strong(self-&gt;mHoldSelf);</div><div class="line">    wp&lt;Thread&gt; weak(strong);</div><div class="line">    self-&gt;mHoldSelf.clear();</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS</span></div><div class="line">    <span class="comment">// this is very useful for debugging with gdb</span></div><div class="line">    self-&gt;mTid = gettid();</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">    <span class="keyword">bool</span> first = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        <span class="comment">// 还是调用 threadLoop 的</span></div><div class="line">        <span class="keyword">bool</span> result;</div><div class="line">        <span class="keyword">if</span> (first) {</div><div class="line">            first = <span class="keyword">false</span>;</div><div class="line">            self-&gt;mStatus = self-&gt;readyToRun();</div><div class="line">            result = (self-&gt;mStatus == NO_ERROR); </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (result && !self-&gt;exitPending()) {</div><div class="line">                <span class="comment">// Binder threads (and maybe others) rely on threadLoop</span></div><div class="line">                <span class="comment">// running at least once after a successful ::readyToRun()</span></div><div class="line">                <span class="comment">// (unless, of course, the thread has already been asked to exit</span></div><div class="line">                <span class="comment">// at that point).             </span></div><div class="line">                <span class="comment">// This is because threads are essentially used like this:</span></div><div class="line">                <span class="comment">//   (new ThreadSubclass())-&gt;run();</span></div><div class="line">                <span class="comment">// The caller therefore does not retain a strong reference to</span></div><div class="line">                <span class="comment">// the thread and the thread would simply disappear after the</span></div><div class="line">                <span class="comment">// successful ::readyToRun() call instead of entering the</span></div><div class="line">                <span class="comment">// threadLoop at least once.</span></div><div class="line">                result = self-&gt;threadLoop();</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            result = self-&gt;threadLoop();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 知道前面的注释为什么说返回 false 只会执行一次了</span></div><div class="line">        <span class="comment">// establish a scope for mLock</span></div><div class="line">        {</div><div class="line">        Mutex::Autolock _l(self-&gt;mLock);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">false</span> || self-&gt;mExitPending) {</div><div class="line">            self-&gt;mExitPending = <span class="keyword">true</span>;</div><div class="line">            self-&gt;mRunning = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// clear thread ID so that requestExitAndWait() does not exit if</span></div><div class="line">            <span class="comment">// called by a new thread using the same thread ID as this one.</span></div><div class="line">            self-&gt;mThread = thread_id_t(-<span class="number">1</span>);</div><div class="line">            <span class="comment">// note that interested observers blocked in requestExitAndWait are</span></div><div class="line">            <span class="comment">// awoken by broadcast, but blocked on mLock until break exits scope</span></div><div class="line">            self-&gt;mThreadExitedCondition.broadcast();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Release our strong reference, to let a chance to the thread</span></div><div class="line">        <span class="comment">// to die a peaceful death.</span></div><div class="line">        strong.clear();</div><div class="line">        <span class="comment">// And immediately, re-acquire a strong reference for the next loop</span></div><div class="line">        strong = weak.promote();</div><div class="line">    } <span class="keyword">while</span>(strong != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>线程函数，一旦执行完，线程就会退出。这里的 <code>_threadLoop</code> 里面是一个循环，取决于 threadLoop 这个的返回值（怪不得叫 loop）。所以 Thread 的子类只要重载 threadLoop 然后根据自己的需要返回合适值就不用管线程的创建、运行之类的了。</p>
<p>然后我们回去看看 mCanCallJava 那个分支上的那个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AndroidThreads.h ==============================</span></div><div class="line"></div><div class="line"><span class="comment">// inline 又挂马甲</span></div><div class="line"><span class="comment">// Create thread with lots of parameters</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> createThreadEtc(thread_func_t entryFunction,</div><div class="line">                            <span class="keyword">void</span> *userData,</div><div class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* threadName = <span class="string">"android:unnamed_thread"</span>,</div><div class="line">                            int32_t threadPriority = PRIORITY_DEFAULT,</div><div class="line">                            size_t threadStackSize = <span class="number">0</span>,</div><div class="line">                            thread_id_t *threadId = <span class="number">0</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> androidCreateThreadEtc(entryFunction, userData, threadName,</div><div class="line">        threadPriority, threadStackSize, threadId) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Threads.cpp ==============================</span></div><div class="line"></div><div class="line"><span class="comment">// 这个函数指针一开始指向的就是 mCanCallJava == false 那个分支的那个函数</span></div><div class="line"><span class="keyword">static</span> android_create_thread_fn gCreateThreadFn = androidCreateRawThreadEtc;</div><div class="line"></div><div class="line"><span class="keyword">int</span> androidCreateThreadEtc(android_thread_func_t entryFunction,</div><div class="line">                            <span class="keyword">void</span> *userData,</div><div class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* threadName,</div><div class="line">                            int32_t threadPriority,</div><div class="line">                            size_t threadStackSize,</div><div class="line">                            android_thread_id_t *threadId)</div><div class="line">{</div><div class="line">    <span class="comment">// 是调用上面那个函数指针说指向的函数</span></div><div class="line">    <span class="keyword">return</span> gCreateThreadFn(entryFunction, userData, threadName,</div><div class="line">        threadPriority, threadStackSize, threadId);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 有接口设置的哦</span></div><div class="line"><span class="keyword">void</span> androidSetCreateThreadFunc(android_create_thread_fn func)</div><div class="line">{</div><div class="line">    gCreateThreadFn = func; </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个分支，按照代码写的最开始和 mCanCallJava == false 是一样的。但是注意，Threads 有个接口可以设置这个函数指针的。我搜了一下代码，发现有一个地方设置了这个函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Register android native functions with the VM.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env) </div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This hook causes all future threads created in this process to be</span></div><div class="line"><span class="comment">     * attached to the JavaVM.  (This needs to go away in favor of JNI</span></div><div class="line"><span class="comment">     * Attach calls.)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</div><div class="line"></div><div class="line">    ALOGV(<span class="string">"--- registering native functions ---\n"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Every "register" function calls one or more things that return</span></div><div class="line"><span class="comment">     * a local reference (e.g. FindClass).  Because we haven't really</span></div><div class="line"><span class="comment">     * started the VM yet, they're all getting stored in the base frame</span></div><div class="line"><span class="comment">     * and never released.  Use Push/Pop to manage the storage.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) { </div><div class="line">        env-&gt;PopLocalFrame(NULL);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line">    env-&gt;PopLocalFrame(NULL);</div><div class="line"></div><div class="line">    <span class="comment">//createJavaThread("fubar", quickTest, (void*) "hello");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个是 AndroidRuntime.cpp 里面注册 jni 函数的时候设置的。这个前面说 SystemService 好像有说过启 Zygote 会调用这个东西。反正就是初始化 java 虚拟机的时候设置了，看注释是为能让在 natvie 的线程中调用 java 中的东西。设置的函数是 javaCreateThreadEtc:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This is invoked from androidCreateThreadEtc() via the callback</span></div><div class="line"><span class="comment"> * set with androidSetCreateThreadFunc().</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We need to create the new thread in such a way that it gets hooked</span></div><div class="line"><span class="comment"> * into the VM before it really starts executing.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::javaCreateThreadEtc(</div><div class="line">                                android_thread_func_t entryFunction,</div><div class="line">                                <span class="keyword">void</span>* userData,                </div><div class="line">                                <span class="keyword">const</span> <span class="keyword">char</span>* threadName,        </div><div class="line">                                int32_t threadPriority,        </div><div class="line">                                size_t threadStackSize,        </div><div class="line">                                android_thread_id_t* threadId) </div><div class="line">{</div><div class="line">    <span class="keyword">void</span>** args = (<span class="keyword">void</span>**) <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));   <span class="comment">// javaThreadShell must free</span></div><div class="line">    <span class="keyword">int</span> result;</div><div class="line"></div><div class="line">    assert(threadName != NULL);</div><div class="line"></div><div class="line">    <span class="comment">// 真正的线程执行函数</span></div><div class="line">    args[<span class="number">0</span>] = (<span class="keyword">void</span>*) entryFunction;</div><div class="line">    <span class="comment">// 用户自定义数据</span></div><div class="line">    args[<span class="number">1</span>] = userData;</div><div class="line">    <span class="comment">// 线程名字</span></div><div class="line">    args[<span class="number">2</span>] = (<span class="keyword">void</span>*) strdup(threadName);   <span class="comment">// javaThreadShell must free</span></div><div class="line"></div><div class="line">    <span class="comment">// 知道前面为什么先说这个函数了吧，最后还是调用同一个</span></div><div class="line">    result = androidCreateRawThreadEtc(AndroidRuntime::javaThreadShell, args,</div><div class="line">        threadName, threadPriority, threadStackSize, threadId);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>知道前面为什么先说 androidCreateRawThreadEtc 了不，其中最终还是调用同一个，所以之后都是 pthread 的调用。但是执行函数不一样，这里的是 javaThreadShell：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * When starting a native thread that will be visible from the VM, we</span></div><div class="line"><span class="comment"> * bounce through this to get the right attach/detach action.</span></div><div class="line"><span class="comment"> * Note that this function calls free(args)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::javaThreadShell(<span class="keyword">void</span>* args) {</div><div class="line">    <span class="keyword">void</span>* start = ((<span class="keyword">void</span>**)args)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">void</span>* userData = ((<span class="keyword">void</span> **)args)[<span class="number">1</span>];</div><div class="line">    <span class="keyword">char</span>* name = (<span class="keyword">char</span>*) ((<span class="keyword">void</span> **)args)[<span class="number">2</span>];        <span class="comment">// we own this storage</span></div><div class="line">    <span class="built_in">free</span>(args);</div><div class="line">    JNIEnv* env;</div><div class="line">    <span class="keyword">int</span> result;</div><div class="line"></div><div class="line">    <span class="comment">// 就是多了一个 java attach</span></div><div class="line">    <span class="comment">/* hook us into the VM */</span></div><div class="line">    <span class="keyword">if</span> (javaAttachThread(name, &env) != JNI_OK)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* start the thread running */</span></div><div class="line">    result = (*(android_thread_func_t)start)(userData);</div><div class="line"></div><div class="line">    <span class="comment">// 和 unattach 吧</span></div><div class="line">    <span class="comment">/* unhook us */</span></div><div class="line">    javaDetachThread();</div><div class="line">    <span class="built_in">free</span>(name);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就多了一个 attach 到 JVM 中。这里不多分析这个，因为这篇不是主要说 JVM 的，反正这么整一下之后，natvie 的线程对 JVM 可见，native 的线程也可以调用 java 的东西。</p>
<h2 id="多线程接口实现-下">多线程接口实现.下</h2>
<p>简单的说了下 android 的线程后，回来继续到 ProcessState 中。前面说了 spawnPooledThread 那里 new 了一个 PoolThread 出来，然后跑 run，之后就会执行 PoolThread 的 threadLoop：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">virtual</span> <span class="keyword">bool</span> threadLoop()</div><div class="line">{</div><div class="line">    IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>调用的正好是我们下面要说的 IPCThreadState 的 joinThreadPool。这里 mIsMain，PorcessState startThreadPool 转过来的是 true。然后 threadLoop 返回的是 false。就是说这个函数只会执行一次，但是 binder 的 Bn 端不是应该循环等待 Bp 的请求么，往下看你就知道只要一次就够了。</p>
<p>前面那个模板 BinderService 最后也调用了 joinThreadPool 了，这个函数是然当前线程加入到线程池，是当前线程。所以那个模板 BinderService 是主线程加入，这里是 new PoolThread 的线程（pthread 创建的）。我来具体看下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</div><div class="line">{</div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n"</span>, (<span class="keyword">void</span>*)pthread_self(), getpid());</div><div class="line"></div><div class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line">       </div><div class="line">    <span class="comment">// This thread may have been spawned by a thread that was in the background</span></div><div class="line">    <span class="comment">// scheduling group, so first we will make sure it is in the foreground</span></div><div class="line">    <span class="comment">// one to avoid performing an initial transaction in the background.</span></div><div class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">        </div><div class="line">    status_t result;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        processPendingDerefs();        </div><div class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></div><div class="line">        result = getAndExecuteCommand();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR && result != TIMED_OUT && result != -ECONNREFUSED && result != -EBADF) {</div><div class="line">            ALOGE(<span class="string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,</div><div class="line">                  mProcess-&gt;mDriverFD, result);  </div><div class="line">            <span class="built_in">abort</span>();</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></div><div class="line">        <span class="comment">// needed and it is not the main process thread.</span></div><div class="line">        <span class="keyword">if</span>(result == TIMED_OUT && !isMain) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    } <span class="keyword">while</span> (result != -ECONNREFUSED && result != -EBADF);</div><div class="line"></div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%p\n"</span>,</div><div class="line">        (<span class="keyword">void</span>*)pthread_self(), getpid(), (<span class="keyword">void</span>*)result);</div><div class="line">       </div><div class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</div><div class="line">    talkWithDriver(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数其实之前通信模型篇里有说过。里面有个 do while 的循环（前面知道为什么那个 threadLoop 返回 false 了吧，一次就够了，一直在循环咧）。那个 isMain 的区别就是，如果 isMain 是 false， getAndExecuteCommand 如果返回是 <code>TIMED_OUT</code> 的话就会退出这个线程。然后 getAndExecuteCommand 返回 <code>TIMED_OUT</code> 的条件是 kernel binder 驱动给你返回 <code>BR_FINISHED</code>，但是目前的 binder 驱动（通信协议版本 version7）根本就没返回 <code>BR_FINISHED</code> 这个值，所以说目前这个 isMain 可以忽略不计，可以认为都是 true。 </p>
<p>getAndExecuteCommand 这些我就不说了，通信模型篇里说得比较清楚了。但是这里你会有个疑问，按照 BinderService 的写法，目前也就只有2个线程再等待 Bp 端的请求而已。如果同一个时候的 Bp 多于2个的话，不是要等待么。别急，binder 在 kernel 会自动帮你处理这种情况的。接下来我们要去 kernel 里面看看 binder 驱动的处理。</p>
<h2 id="自动创建线程">自动创建线程</h2>
<p>通信模型篇，我们知道 binder 驱动中结构体 <code>binder_proc</code> 代表一个进程，结构体 <code>binder_thread</code> 代表一个线程。我们先看看 <code>binder_proc</code> 中几个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 保存这个进程中所有线程的红黑树的根节点</span></div><div class="line">    <span class="keyword">struct</span> rb_root threads;</div><div class="line"></div><div class="line">    <span class="comment">// 运行开启的最大线程数</span></div><div class="line">    <span class="keyword">int</span> max_threads;</div><div class="line">    <span class="comment">// 请求开启的线程数</span></div><div class="line">    <span class="keyword">int</span> requested_threads;</div><div class="line">    <span class="comment">// 应请求运行的线程数</span></div><div class="line">    <span class="keyword">int</span> requested_threads_started;</div><div class="line">    <span class="comment">// 准备好的线程（空闲的线程）</span></div><div class="line">    <span class="keyword">int</span> ready_threads;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个结构在 <code>binder_open</code> 的时候会创建（binder open 的操作在 ProcessState 的构造函数那，所以一个进程只会 open 一次，所以一个进程 <code>binder_proc</code> 只会创建一次）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_open(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc; </div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">"binder_open: %d:%d\n"</span>,</div><div class="line">             current-&gt;group_leader-&gt;pid, current-&gt;pid);</div><div class="line"></div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == NULL)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;       </div><div class="line">    get_task_struct(current); </div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    INIT_LIST_HEAD(&proc-&gt;todo);</div><div class="line">    init_waitqueue_head(&proc-&gt;wait);</div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line">    mutex_lock(&binder_lock); </div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    hlist_add_head(&proc-&gt;proc_node, &binder_procs);</div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&proc-&gt;delivered_death);</div><div class="line">    filp-&gt;private_data = proc;</div><div class="line">    mutex_unlock(&binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) {</div><div class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];      </div><div class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</div><div class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">            binder_debugfs_dir_entry_proc, proc, &binder_proc_fops);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>没有显示的初始化那几个变量，不过默认都是 0。然后来看 <code>binder_thread</code> 的创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line">    <span class="comment">/*printk(KERN_INFO "binder_ioctl: %d:%d %x %lx\n", proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></div><div class="line"></div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    <span class="keyword">if</span> (thread == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_thread</code> 的创建在 <code>binder_ioctl</code> 的 <code>binder_get_thread</code> 这个函数中。只要调用 binder 的 ioctl 接口就会触发这个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 咋顺带把这个结构体也贴一下</span></div><div class="line"><span class="keyword">struct</span> binder_thread {</div><div class="line">    <span class="comment">// 这个线程所在的进程对象</span></div><div class="line">    <span class="keyword">struct</span> binder_proc *proc; </div><div class="line">    <span class="keyword">struct</span> rb_node rb_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="comment">// 线程当前运行状态</span></div><div class="line">    <span class="keyword">int</span> looper;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction_stack;</div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    uint32_t return_error; <span class="comment">/* Write failed, return error code in read buf */</span></div><div class="line">    uint32_t return_error2; <span class="comment">/* Write failed, return error code in read */</span></div><div class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></div><div class="line">        <span class="comment">/* we are also waiting on */</span>   </div><div class="line">    wait_queue_head_t wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_thread *binder_get_thread(<span class="keyword">struct</span> binder_proc *proc)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread = NULL;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL; </div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;threads.rb_node;</div><div class="line"></div><div class="line">    <span class="comment">// proc 中的 thread 按 pid 保存在 proc 的红黑树中</span></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        thread = rb_entry(parent, <span class="keyword">struct</span> binder_thread, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</div><div class="line">            p = &(*p)-&gt;rb_left;            </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</div><div class="line">            p = &(*p)-&gt;rb_right;           </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;            </div><div class="line">    }</div><div class="line">    <span class="comment">// 如果之前没创建过，就 new 一个新的出来</span></div><div class="line">    <span class="keyword">if</span> (*p == NULL) {</div><div class="line">        thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</div><div class="line">        <span class="keyword">if</span> (thread == NULL)</div><div class="line">            <span class="keyword">return</span> NULL;</div><div class="line">        binder_stats_created(BINDER_STAT_THREAD);</div><div class="line">        <span class="comment">// 设置线程所在的 proc 和 pid</span></div><div class="line">        <span class="comment">// 这里的 pid 相当于是 tid </span></div><div class="line">        thread-&gt;proc = proc;</div><div class="line">        thread-&gt;pid = current-&gt;pid;    </div><div class="line">        init_waitqueue_head(&thread-&gt;wait);</div><div class="line">        INIT_LIST_HEAD(&thread-&gt;todo);</div><div class="line">        <span class="comment">// 保存到 proc 中 </span></div><div class="line">        rb_link_node(&thread-&gt;rb_node, parent, p);</div><div class="line">        rb_insert_color(&thread-&gt;rb_node, &proc-&gt;threads);</div><div class="line">        <span class="comment">// 注意初始化状态</span></div><div class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">        thread-&gt;return_error = BR_OK;  </div><div class="line">        thread-&gt;return_error2 = BR_OK; </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> thread;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>这里要说下 current 这个全局变量。这个东西代表当前运行的线程的一些结构（其实结构应该是 <code>task_struct</code>）。具体的可以去看 linux 内核相关的书。反正用这个东西可以取得到当前运行的线程的一些信息就对了（好像是通过取堆栈最顶的东西）。</p>
<p>然后我们看下 <code>binder_thread_read</code> 这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> { </div><div class="line">    BINDER_LOOPER_STATE_REGISTERED  = <span class="number">0x01</span>,</div><div class="line">    BINDER_LOOPER_STATE_ENTERED     = <span class="number">0x02</span>,</div><div class="line">    BINDER_LOOPER_STATE_EXITED      = <span class="number">0x04</span>,</div><div class="line">    BINDER_LOOPER_STATE_INVALID     = <span class="number">0x08</span>,</div><div class="line">    BINDER_LOOPER_STATE_WAITING     = <span class="number">0x10</span>,</div><div class="line">    BINDER_LOOPER_STATE_NEED_RETURN = <span class="number">0x20</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Bn 会阻塞等待在这等待 Bp 的请求的到来</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                  <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</div><div class="line">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">    }</div><div class="line"></div><div class="line">retry:</div><div class="line">    <span class="comment">// transaction_stack == NULL 代表是第一次的 read（Bn 的阻塞read就是）</span></div><div class="line">    <span class="comment">// Bn 的阻塞等待的 read todo list 也是空的</span></div><div class="line">    <span class="comment">// 所以 Bn 的阻塞 read 这里的 wait_for_proc_work 是 true</span></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == NULL &&</div><div class="line">                list_empty(&thread-&gt;todo);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (thread-&gt;return_error != BR_OK && ptr &lt; end) {</div><div class="line">        <span class="keyword">if</span> (thread-&gt;return_error2 != BR_OK) {</div><div class="line">            <span class="keyword">if</span> (put_user(thread-&gt;return_error2, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="keyword">if</span> (ptr == end)</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            thread-&gt;return_error2 = BR_OK;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (put_user(thread-&gt;return_error, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        thread-&gt;return_error = BR_OK;</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 前面说了这个 looper 是当前线程的状态，</span></div><div class="line">    <span class="comment">// 注意这里设置为 WAITING 了，表示正在等待</span></div><div class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</div><div class="line">    <span class="comment">// Bn read 这里是 true，表示本进程空闲的进程数加1</span></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads++;</div><div class="line">    mutex_unlock(&binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) {</div><div class="line">        <span class="comment">// 这里检测 thread 是不是有下面这2个标志，这2个标志后面会说到。</span></div><div class="line">        <span class="comment">// 还有注意前面设置那个 WAITTING 的是用 | 设置的，然后这里检测是用 &</span></div><div class="line">        <span class="comment">// 然后看看这几个标志定义的值，会发现这里微妙的用法</span></div><div class="line">        <span class="keyword">if</span> (!(thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">                    BINDER_LOOPER_STATE_ENTERED))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></div><div class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></div><div class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</div><div class="line">            wait_event_interruptible(binder_user_error_wait,</div><div class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">        }</div><div class="line">        binder_set_nice(proc-&gt;default_priority);</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            <span class="comment">// 这里就阻塞在这里，等 thread 的 todo list 不为空（Bp 请求）</span></div><div class="line">            ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</div><div class="line">    }</div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    <span class="comment">// 如果这个等待的线程被唤醒了（有 Bp 请求来了），</span></div><div class="line">    <span class="comment">// 把这个进程空闲的线程数减1，</span></div><div class="line">    <span class="comment">// 因为这个线程后面马上就要到用户空间去执行相关业务的函数了。</span></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads--;</div><div class="line">    <span class="comment">// 把线程的 WAITTING 标志去掉</span></div><div class="line">    thread-&gt;looper &= ~BINDER_LOOPER_STATE_WAITING;</div><div class="line"></div><div class="line">    <span class="comment">// wait 出错的话，返回错误值</span></div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">done:</div><div class="line"></div><div class="line">    *consumed = ptr - buffer;</div><div class="line">    <span class="comment">// 最后这里 requested_threads 表示发出请求要启动的线程数，</span></div><div class="line">    <span class="comment">// ready_threads 表示空闲的线程数。</span></div><div class="line">    <span class="comment">// 如果这2个加起来 == 0 就表示当前进程（服务进程）没有空闲的线程来处理请求，</span></div><div class="line">    <span class="comment">// 并且还没请求去启动线程，所以需要启动一个新的线程来等待 Bp 的请求。</span></div><div class="line">    <span class="comment">// requested_threads_started 表示本进程应请求启动的线程数，</span></div><div class="line">    <span class="comment">// 这个不能超过 max_threads 设置的上限。</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &&</div><div class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &&</div><div class="line">        (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">         BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></div><div class="line">         <span class="comment">/*spawn a new thread if we leave this out */</span>) {</div><div class="line">        <span class="comment">// 这里发 BR_SPAWN_LOOPER 到用户去创建新线程去了</span></div><div class="line">        <span class="comment">// 然后把请求启动的线程数加1</span></div><div class="line">        proc-&gt;requested_threads++;</div><div class="line">        binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                 <span class="string">"binder: %d:%d BR_SPAWN_LOOPER\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid);</div><div class="line">        <span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 binder 驱动其实用了个很简单的办法来管理线程。就是假设 Bn 端有一个线程 wait 在 read 那了，就相当于多了一个空闲线程（能够处理 Bp 的请求）。上面分析过了，BinderService 一开始就整个2个线程 wait read 那了。然后如果来一个 Bp 请求，<code>binder_transation</code> 那里找到目标进程，然后把请求放到目标进程的 todo list 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete; </div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list; </div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 第一次 Bp 发请求给 Bn target_thread 是 null，走的是下面那个</span></div><div class="line">    <span class="keyword">if</span> (target_thread) {</div><div class="line">        e-&gt;to_thread = target_thread-&gt;pid;</div><div class="line">        target_list = &target_thread-&gt;todo;</div><div class="line">        target_wait = &target_thread-&gt;wait;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// todo list 是 target_proc 的</span></div><div class="line">        target_list = &target_proc-&gt;todo;</div><div class="line">        target_wait = &target_proc-&gt;wait;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    <span class="comment">// 把请求打包成工作（work），加入到 todo list 中</span></div><div class="line">    list_add_tail(&t-&gt;work.entry, target_list);</div><div class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    list_add_tail(&tcomplete-&gt;entry, &thread-&gt;todo);</div><div class="line">    <span class="comment">// 唤醒等待队列</span></div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_transtion</code> 就是消耗 Bn 工作线程的地方了。通信模型篇里分析过了，Bp 第一次发请求给 Bn，是没 <code>target_thread</code> 的，所以请求就加入到 <code>target_proc</code> 的 todo list 中了。然后唤醒 Bn 在 read 那休眠的线程。</p>
<p>这里说下 wait queue 的小知识，<code>binder_thread_read</code> 使用的 <code>wait_event_interruptible_exclusive</code> 第二参数是一个检测条件，这里是检测 proc 的 todo list 是否为空，这个会是不停的检测的（应该不怎么耗 cpu 吧），一旦条件为 true 就唤醒继续执行。所以 <code>binder_transation</code> 应该没那个唤醒的操作也可以，不过也还是保险一点好。</p>
<p>然后你也发现上面 wait proc 的用的是 <code>wait_event_interruptible_exclusive</code>，下面那个 wait thread 用的是 <code>wait_event_interruptible</code>。这2个有啥区别咧。我查到的是说 <code>wait_event_interruptible_exclusive</code> 在检测唤醒条件的时候是一个互斥过程，是不是说如果有多个线程 wait 的时候只检测一个线程的条件，因为之前的例子，Bn 那已经有2个线程 wait proc 那了。下面那个不带互斥，下面那个由于是 wait 本线程的，所以只会有一个线程 wait。还是说 wait queue 一次只会唤醒一个线程而已。我加的打印发现是唤醒的是最后那个等待的线程。由于比较难写 kernel 的小例子，我这里就不验证这个等待队列的用法了。反正由于种种原因这里一次就只能唤醒一个等待线程。</p>
<p>然后说下 <code>transaction_stack</code> 这个东西，看上面知道第一次 <code>transaction_stack</code> 是 NULL，也就是 Bn 等待 Bp 来请求的时候是 NULL，然后之后 Bp 通过 <code>binder_transaction</code> 把 work 加到 Bn 的 todo list， <code>transaction_stack</code> 就保存了 Bp 的 thread，然后 Bn <code>binder_thread_read</code> 之后，Bn proc 的 <code>transaction_stack</code> Bn 的 thread。然后 <code>binder_transaction</code> 一开始判断 reply == true 从 <code>transaction_stack</code> 去取 target。这么搞是为了保证， Bp 发送请求到 Bn 的线程处理后，Bn 能返回到正确的 Bp 线程，就是保证返回值能送到发送请求的那个线程处理。这个通信原理有具体分析代码，这里再点一下。这里结合后面说一个进程跑多个服务，binder 的多线程机制并不会导致混乱。 </p>
<p>那这样就差把 binder 驱动里面做的事说完了。每当一个 Bn 的线程在 <code>binder_thread_read</code> 等待，<code>proc-&gt;ready_threads</code> 就会 +1，如果 todo list 里接到请求，最后那个等待的线程被唤醒，<code>proc-&gt;ready_threads</code> -1，然后唤醒的线程去执行 IPC 请求业务函数，在最后判断是否还有空闲的线程（已经在等待的（<code>ready_threads</code>）+发送启动请求的（<code>requested_threads</code>）是否为0）。如果没有 Bn 没空闲的线程，并且已经启动的线程（<code>requested_threads_started</code>）没超过限制（<code>max_threas</code>）就发一个 <code>BR_SPAWN_LOOPER</code> 给用户空间去创建线程。</p>
<p>我们来看看用户空间怎么处理 <code>BR_SPAWN_LOOPER</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    ... ...</div><div class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</div><div class="line">        <span class="comment">// 调用的是 ProcessState 的 spawnPooledThread，参数是 false</span></div><div class="line">        mProcess-&gt;spawnPooledThread(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>; </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>结果就是 kernel 帮我们自动调用 ProcessState 的 PooledThread 而已。这里的参数是 false 了，就是说 isMain 是 false 了。这个 isMain 前面说没啥用的，不过还是有点小区别。回去看 joinThreadPool（spwanPooledThread 最后还是调用了 joinThreadPool） 那：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line"></div></pre></td></tr></table></figure>

<p>isMain 的对 binder 发的是 <code>BC_ENTER_LOOPER</code>，false 的发的是 <code>BC_REGISTER_LOOPER</code>。我去看下这2个有啥区别不：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;   </div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) { </div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        }</div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</div><div class="line">            <span class="comment">// 不允许已经 ENTER_LOOPER 的线程再 REGISTER_LOOPER</span></div><div class="line">            binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                     <span class="string">"binder: %d:%d BC_REGISTER_LOOPER\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);</div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper & BINDER_LOOPER_STATE_ENTERED) {</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></div><div class="line">                    <span class="string">"after BC_ENTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            <span class="comment">// 没发起请求的也不允许 REGISTER_LOOPER</span></div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span>) {</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></div><div class="line">                    <span class="string">"without request\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 请求线程数 -1</span></div><div class="line">                proc-&gt;requested_threads--;</div><div class="line">                <span class="comment">// 已经启动的线程数 +1</span></div><div class="line">                proc-&gt;requested_threads_started++;</div><div class="line">            }   </div><div class="line">            <span class="comment">// 设置下线程状态</span></div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</div><div class="line">            <span class="comment">// 不允许 REGISTER_LOOPER 的线程再 ENTER_LOOPER</span></div><div class="line">            binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                     <span class="string">"binder: %d:%d BC_ENTER_LOOPER\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);</div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper & BINDER_LOOPER_STATE_REGISTERED) {</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></div><div class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            }</div><div class="line">            <span class="comment">// 设置下线程状态</span></div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</div><div class="line">            <span class="comment">// 这个退出只是把状态设置了下</span></div><div class="line">            binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                     <span class="string">"binder: %d:%d BC_EXIT_LOOPER\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);</div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>isMain 的除去是否会超时自动退出外（前面说了，这个机制目前是没用的），就是上面那些判断了，isMain 是 true 是手动创建的，所以没什么限制。false 则是 binder 驱动根据当前可用线程数的情况自动请求创建的，所以确定 binder 驱动确实请求了才允许创建（requested_threads 不为 0）。还有 <code>BC_ENTER_LOOPER</code> 的是不算在 <code>requested_threads_started</code> 里面的，所以手动启动的线程理论上可以无限个（不过我看到 SS 除了一开始手动调用一次 startPoolThread，然后把当前线程 joinThreadPool 之外，就再也没手动启动过线程，都是交由驱动管理）。</p>
<p>然后说下既然有创建线程，那什么时候退出呢。前面说了超时暂时没用，joinThreadPool 那里 io 错误也会导致退出，这些异常的不算。正常目前好像没那个地方会退出，binder 启动的线程。是的，没错，目前 binder 的线程一旦启动就不会退出的，直到达到上限为止，只要 binder 一发现当前服务进程没空闲线程了就会 spawn 一个出来。但是由于服务线程一旦执行完 IPC 调用就会变成空闲的，所以只要同一个时候没很多 Bp 请求过来，不会创建太多线程的。而且就算创建了不少线程，这些线程只是休眠而已，不乎占用 cpu 资源，所以没啥太大关系，可能后续的 binder 版本会考虑一段时间这个线程没有执行请求就把这个线程退出吧。</p>
<p>然后 binder 自动创建的线程数可以设置上限的。说起这个 binder 有条命令： <code>BINDER_SET_MAX_THREADS</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// binder_thread_write:</span></div><div class="line"></div><div class="line">    <span class="comment">// 就是把进程的 max_threads 设置了一下</span></div><div class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS:</div><div class="line">        <span class="keyword">if</span> (copy_from_user(&proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) {</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>说到这个，我们来看看默认设置最大线程数是多少吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> open_driver()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR); </div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</div><div class="line">        <span class="keyword">int</span> vers;</div><div class="line">        status_t result = ioctl(fd, BINDER_VERSION, &vers);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) {</div><div class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 最大线程数为 15</span></div><div class="line">        size_t maxThreads = <span class="number">15</span>;        </div><div class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &maxThreads);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ProcessState 的构造函数会调用 <code>open_driver()</code>，binder 默认允许最大的线程数为 15 个。一般来说继承 BindService 的默认就是用这个数量了，但是也有特殊的。SurfaceFlinger（SF）没 BindService，手动写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main_surfaceflinger.cpp =============================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    <span class="comment">// 最大线程数为 4</span></div><div class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></div><div class="line">    <span class="comment">// binder threads to 4.</span></div><div class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 还有一个主线程（isMain）</span></div><div class="line">    <span class="comment">// start the thread pool</span></div><div class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">    ps-&gt;startThreadPool();</div><div class="line"></div><div class="line">    <span class="comment">// instantiate surfaceflinger</span></div><div class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_PTHREADS)</span></div><div class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</div><div class="line"></div><div class="line">    <span class="comment">// initialize before clients can connect</span></div><div class="line">    flinger-&gt;init();</div><div class="line"></div><div class="line">    <span class="comment">// publish surface flinger</span></div><div class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// run in this thread</span></div><div class="line">    flinger-&gt;run();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ProcessState.cpp ===============================</span></div><div class="line"></div><div class="line">status_t ProcessState::setThreadPoolMaxThreadCount(size_t maxThreads) {</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">    <span class="keyword">if</span> (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &maxThreads) == -<span class="number">1</span>) {</div><div class="line">        result = -errno;</div><div class="line">        ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(-result));</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>SF 就只设置了4个可以自动创建的线程，还有一个主线程（应该还有一个吧，当前那个线程跑哪去了，以后分析 SF 再说吧）。这里注意一点，如果要手动写的话，主要设置要放到 IPCThreadState-&gt;joinThreadPool 的前面，因为调用 joinThreadPool 当前线程就加入到 binder 的主线程中去了，阻塞循环就开始了，除非线程退出了，否则后面的代码执行不到的。</p>
<p>前面讨论了线程过多的情况，如果 Bn 中的线程不够的话，会怎么样咧。就是当前服务进程中没空闲的线程了（都在执行业务函数），答案是 Bp 端等待。前面不是说 proc 有 todo list 么（thread 也有的），既然是 list 就可以保存多个工作请求（work），然后一次处理一个，当没空闲线程马上处理的时候，把请求加到 todo list 后面，等线程执行完当前的业务函数，回到 <code>binder_thread_read</code> 那，准备等待的时候，发现 todo list 中不空，就马上取下一个 work 然后执行，就不会进入休眠，直到 todo list 为空。所以如果服务进程空闲线程不足，然后这个时候 Bp 请求又多的话，会导致 IPC 调用非常慢（要排队等，哥又想起排队抢火车票了）。所以要根据自身业务的情况去设置 binder 自动创建线程的上限，不要设得太小。顺带贴下线程取工作请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// binder_thread_read: </span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        uint32_t cmd; </div><div class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line">        <span class="keyword">struct</span> binder_work *w;</div><div class="line">        <span class="keyword">struct</span> binder_transaction *t = NULL;</div><div class="line"></div><div class="line">        <span class="comment">// 去 todo list 中取工作请求</span></div><div class="line">        <span class="keyword">if</span> (!list_empty(&thread-&gt;todo))</div><div class="line">            w = list_first_entry(&thread-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&proc-&gt;todo) && wait_for_proc_work)</div><div class="line">            w = list_first_entry(&proc-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> && !(thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }    </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>) </div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以那些 SS 里面很多函数都加了锁，因为有多线程的支持，可能同一个时间在执行不同客户端的业务函数。有可能 Bp1 的执行的函数是读一个变量，而 Bp2 执行的函数正好要写这个变量，这个时候需要互斥操作，所以很多操作都带锁了。但是注意不要什么操作都带锁，因为互斥锁会影响执行效率的，对于可以重入的函数不需要加锁（例如函数里面全是局部变量）。</p>
<p>还有要注意 SS 协同完成一些任务的时候的问题，例如一个 Proc A IPC 调用 Proc B 的某个函数，这个函数又跑去调用 AM 里面的某个函数，然后 AM 这个函数正好又去 IPC 调用 Proc B 中的某个函数。如果这些 IPC 函数都加了锁的话，就会死锁。关于这个例子可以去看 Binder 对象传递的普通服务篇。</p>
<h2 id="java_层的_SS">java 层的 SS</h2>
<p>前面差不多 binder 多线程的支持说完了，也看了一些 native SS 的例子。最后来看下 java 层的，也是我们应用开发中接触最多的那一票系统服务（AM、WM、PM 等）。前面说这个有点麻烦，主要是它还得启动 java 虚拟机。我们来一点点看吧，顺带把 SS 启动过程也走一下。</p>
<p>首先说了 init.rc 里有启动 zygote（不是 SS 么，怎么变成 zygote 了，别急，往下看）：</p>
<pre config="brush:bash;toolbar:false;">
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
    onrestart restart netd
</pre>

<p>注意那个 <code>--start-system-server</code> 和 <code>--zygote</code> 的参数。其实是启动 <code>app_process</code> 这个 native 程序。我们来先上一张序列图，还挺麻烦的说（因为是通过启动一个程序（zygote），然后再 fork 出另外一个（SS））：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-thread/1.png" alt=""></p>
<p>我来来看下 app_process 的 main 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app_main.cpp ================================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    AppRuntime runtime;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* argv0 = argv[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// Process command line arguments</span></div><div class="line">    <span class="comment">// ignore argv[0]</span></div><div class="line">    argc--;</div><div class="line">    argv++;</div><div class="line"></div><div class="line">    <span class="comment">// Everything up to '--' or first non '-' arg goes to the vm</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = runtime.addVmArguments(argc, argv);</div><div class="line"></div><div class="line">    <span class="comment">// init.rc 传过来的参数 --zygote 和 --start-system-server</span></div><div class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></div><div class="line">    <span class="keyword">bool</span> zygote = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">bool</span> startSystemServer = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">bool</span> application = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* parentDir = NULL;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* niceName = NULL;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* className = NULL;</div><div class="line">    <span class="keyword">while</span> (i &lt; argc) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</div><div class="line">        <span class="keyword">if</span> (!parentDir) {</div><div class="line">            parentDir = arg;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) {</div><div class="line">            zygote = <span class="keyword">true</span>;</div><div class="line">            niceName = <span class="string">"zygote"</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) {</div><div class="line">            startSystemServer = <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) {</div><div class="line">            application = <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) {</div><div class="line">            niceName = arg + <span class="number">12</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            className = arg;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (niceName && *niceName) {</div><div class="line">        setArgv0(argv0, niceName);</div><div class="line">        set_process_name(niceName);</div><div class="line">    }</div><div class="line"></div><div class="line">    runtime.mParentDir = parentDir;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (zygote) {</div><div class="line">        <span class="comment">// 那就是走这里的</span></div><div class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>,</div><div class="line">                startSystemServer ? <span class="string">"start-system-server"</span> : <span class="string">""</span>);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (className) {</div><div class="line">        <span class="comment">// Remainder of args get passed to startup class main()</span></div><div class="line">        runtime.mClassName = className;</div><div class="line">        runtime.mArgC = argc - i;</div><div class="line">        runtime.mArgV = argv + i;</div><div class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>,</div><div class="line">                application ? <span class="string">"application"</span> : <span class="string">"tool"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</div><div class="line">        app_usage();</div><div class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>init.rc 传过来的参数来看，跑去调用 AppRuntime 的 start 去了。AppRuntime 在 <code>app_main.cpp</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AppRuntime : <span class="keyword">public</span> AndroidRuntime</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    AppRuntime()</div><div class="line">        : mParentDir(NULL)</div><div class="line">        , mClassName(NULL)</div><div class="line">        , mClass(NULL)</div><div class="line">        , mArgC(<span class="number">0</span>)</div><div class="line">        , mArgV(NULL)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 注意这个函数</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> onZygoteInit()</div><div class="line">    {</div><div class="line">        <span class="comment">// Re-enable tracing now that we're no longer in Zygote.</span></div><div class="line">        atrace_set_tracing_enabled(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 这里初始化了 ProcessState，并调用了 startThreadPool</span></div><div class="line">        sp&lt;ProcessState&gt; proc = ProcessState::self();</div><div class="line">        ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</div><div class="line">        proc-&gt;startThreadPool();</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mParentDir;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mClassName;</div><div class="line">    jclass mClass;</div><div class="line">    <span class="keyword">int</span> mArgC;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* mArgV;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>



<p>AppRuntime 继承 AndroidRuntime，我们得去看父类里面的 start：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前面传过来的 className 是： com.android.internal.os.ZygoteInit</span></div><div class="line"><span class="comment">// options 是： start-system-server</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></div><div class="line"><span class="comment"> * and calling the "static void main(String[] args)" method in the class</span></div><div class="line"><span class="comment"> * named by "className".</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></div><div class="line"><span class="comment"> * options string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> <span class="keyword">char</span>* options)</div><div class="line">{</div><div class="line">    ALOGD(<span class="string">"\n&gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START %s &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</div><div class="line">            className != NULL ? className : <span class="string">"(unknown)"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">     * 'startSystemServer == true' means runtime is obsolete and not run from</span></div><div class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(options, <span class="string">"start-system-server"</span>) == <span class="number">0</span>) { </div><div class="line">        <span class="comment">/* track our progress through the boot sequence */</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</div><div class="line">        LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,</div><div class="line">                       ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</div><div class="line">    <span class="keyword">if</span> (rootDir == NULL) {</div><div class="line">        rootDir = <span class="string">"/system"</span>;  </div><div class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) {      </div><div class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /android does not exist."</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></div><div class="line">    <span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></div><div class="line"></div><div class="line">    <span class="comment">// 启动 VM，这里不管这个</span></div><div class="line">    <span class="comment">/* start the virtual machine */</span></div><div class="line">    JniInvocation jni_invocation;</div><div class="line">    jni_invocation.Init(NULL);</div><div class="line">    JNIEnv* env;</div><div class="line">    <span class="keyword">if</span> (startVm(&mJavaVM, &env) != <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 之前的子类 AppRuntime 有重载，不过这里启动 zygote 这个函数直接返回的</span></div><div class="line">    onVmCreated(env);</div><div class="line"></div><div class="line">    <span class="comment">// 这个 startReg 还记得不，前面说 android 线程的时候</span></div><div class="line">    <span class="comment">// 改变 libutils Threads 里面的线程函数指针就是在这个函数里面</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Register android functions.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) {</div><div class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></div><div class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></div><div class="line"><span class="comment">     * Create an array to hold them.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    jclass stringClass;</div><div class="line">    jobjectArray strArray;</div><div class="line">    jstring classNameStr;</div><div class="line">    jstring optionsStr;</div><div class="line"></div><div class="line">    <span class="comment">// 下面这一大串就是取 className 的 main 函数，然后执行而已</span></div><div class="line">    <span class="comment">// className 是 com.android.internal.os.ZygoteInit</span></div><div class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</div><div class="line">    assert(stringClass != NULL);</div><div class="line">    strArray = env-&gt;NewObjectArray(<span class="number">2</span>, stringClass, NULL);</div><div class="line">    assert(strArray != NULL);</div><div class="line">    classNameStr = env-&gt;NewStringUTF(className);</div><div class="line">    assert(classNameStr != NULL);</div><div class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</div><div class="line">    optionsStr = env-&gt;NewStringUTF(options);</div><div class="line">    <span class="comment">// 把 start-system-service 参数打包成 java 函数的参数</span></div><div class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">1</span>, optionsStr);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></div><div class="line"><span class="comment">     * not return until the VM exits.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</div><div class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class="line">    <span class="keyword">if</span> (startClass == NULL) {</div><div class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</div><div class="line">        <span class="comment">/* keep going */</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 取 className 的 main 函数</span></div><div class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</div><div class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</div><div class="line">        <span class="keyword">if</span> (startMeth == NULL) {</div><div class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</div><div class="line">            <span class="comment">/* keep going */</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 通过反射调用 main 函数，</span></div><div class="line">            <span class="comment">// 注意把前面的 start-system-service 当作参数传过去了</span></div><div class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</div><div class="line">                threadExitUncaughtException(env);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="built_in">free</span>(slashClassName);</div><div class="line"></div><div class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</div><div class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</div><div class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</div><div class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</div><div class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里忽略了 JVM 的启动过程（和 binder 关系不大），然后后面主要就是启动 java 层里面的东西了。这里是去执行了 com.android.internal.os.ZygoteInit 的 main 函数（下面欢迎进入 java 世界）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String argv[]) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// Start profiling the zygote initialization.</span></div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">        <span class="comment">// 打开 zygote 通信用的 socket</span></div><div class="line">        registerZygoteSocket();</div><div class="line">         <span class="comment">// Finish profiling the zygote initialization.</span></div><div class="line">        <span class="keyword">boolean</span> isFirstBooting = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//if first time booting and zygote restart need preload full class</span></div><div class="line">        <span class="keyword">if</span>(Process.myPid() &gt; <span class="number">300</span> || SystemProperties.getBoolean(PROPERTY_FIRST_TIME_BOOTING, <span class="keyword">true</span>)){</div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">            preload();</div><div class="line">            isFirstBooting = <span class="keyword">true</span>;         </div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">        }                 </div><div class="line">        <span class="comment">// Finish profiling the zygote initialization.</span></div><div class="line">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class="line"></div><div class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></div><div class="line">        gc();</div><div class="line"></div><div class="line">        <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags from</span></div><div class="line">        <span class="comment">// Zygote.</span></div><div class="line">        Trace.setTracingEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If requested, start system server directly from Zygote</span></div><div class="line">        <span class="keyword">if</span> (argv.length != <span class="number">2</span>) {        </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 那个参数传了半天终于有用了，这个函数就是去启动 SS 的进程</span></div><div class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>].equals(<span class="string">"start-system-server"</span>)) {</div><div class="line">            startSystemServer();           </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!argv[<span class="number">1</span>].equals(<span class="string">""</span>)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</div><div class="line">        }</div><div class="line"></div><div class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</div><div class="line">        <span class="keyword">if</span>(!isFirstBooting){           </div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">            preload();</div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">            gc();</div><div class="line">        }</div><div class="line">        <span class="comment">// 这个就是 zygote 循环阻塞等待请求的函数了</span></div><div class="line">        runSelectLoop();</div><div class="line"></div><div class="line">        <span class="comment">// 上面那个函数退出就说明 zygote 退出了，关闭之前打开的 socket</span></div><div class="line">        closeServerSocket();</div><div class="line">    } <span class="keyword">catch</span> (MethodAndArgsCaller caller) {</div><div class="line">        caller.run();</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException ex) {</div><div class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</div><div class="line">        closeServerSocket();</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们这里主要看 startSystemServer 这个函数，其它的是 zygote 的，zygote 的话，我有一篇工作小笔记（换系统字体那个）有说到，这里不多说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Prepare the arguments and fork for the system server process.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span>()</div><div class="line">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException {</div><div class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</div><div class="line">        OsConstants.CAP_KILL,</div><div class="line">        OsConstants.CAP_NET_ADMIN,</div><div class="line">        OsConstants.CAP_NET_BIND_SERVICE,</div><div class="line">        OsConstants.CAP_NET_BROADCAST,</div><div class="line">        OsConstants.CAP_NET_RAW,</div><div class="line">        OsConstants.CAP_SYS_MODULE,</div><div class="line">        OsConstants.CAP_SYS_NICE,</div><div class="line">        OsConstants.CAP_SYS_RESOURCE,</div><div class="line">        OsConstants.CAP_SYS_TIME,</div><div class="line">        OsConstants.CAP_SYS_TTY_CONFIG</div><div class="line">    );  </div><div class="line">    <span class="comment">// 下面一堆参数，注意最下面那个类名（我们 SS 终于露面了）</span></div><div class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></div><div class="line">    String args[] = { </div><div class="line">        <span class="string">"--setuid=1000"</span>,</div><div class="line">        <span class="string">"--setgid=1000"</span>,</div><div class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007"</span>,</div><div class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</div><div class="line">        <span class="string">"--runtime-init"</span>,</div><div class="line">        <span class="string">"--nice-name=system_server"</span>,</div><div class="line">        <span class="string">"com.android.server.SystemServer"</span>,</div><div class="line">    };  </div><div class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 将上面那堆字符串参数解析成一个专门用来 zygote 通信的数据结构</span></div><div class="line">        <span class="comment">// 不过这里启动 SS 根本没和 zygote 通信，这里纯粹借用这个数据而已</span></div><div class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</div><div class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class="line"></div><div class="line">        <span class="comment">// fork SS 进程</span></div><div class="line">        <span class="comment">/* Request to fork the system server process */</span></div><div class="line">        pid = Zygote.forkSystemServer(</div><div class="line">                parsedArgs.uid, parsedArgs.gid,</div><div class="line">                parsedArgs.gids,</div><div class="line">                parsedArgs.debugFlags,</div><div class="line">                <span class="keyword">null</span>,</div><div class="line">                parsedArgs.permittedCapabilities,</div><div class="line">                parsedArgs.effectiveCapabilities);</div><div class="line">    } <span class="keyword">catch</span> (IllegalArgumentException ex) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">    }   </div><div class="line"></div><div class="line">    <span class="comment">// pid == 0 是 fork 出来的 SS 进程，要去启动 SS 服务了</span></div><div class="line">    <span class="comment">/* For child process */</span></div><div class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</div><div class="line">        handleSystemServerProcess(parsedArgs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们去看下 Zygote.forkSystemServer 这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Special method to start the system server process. In addition to the</span></div><div class="line"><span class="comment"> * common actions performed in forkAndSpecialize, the pid of the child</span></div><div class="line"><span class="comment"> * process is recorded such that the death of the child process will cause</span></div><div class="line"><span class="comment"> * zygote to exit.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param uid the UNIX uid that the new process should setuid() to after</span></div><div class="line"><span class="comment"> * fork()ing and and before spawning any threads.</span></div><div class="line"><span class="comment"> * @param gid the UNIX gid that the new process should setgid() to after</span></div><div class="line"><span class="comment"> * fork()ing and and before spawning any threads.</span></div><div class="line"><span class="comment"> * @param gids null-ok; a list of UNIX gids that the new process should</span></div><div class="line"><span class="comment"> * setgroups() to after fork and before spawning any threads.</span></div><div class="line"><span class="comment"> * @param debugFlags bit flags that enable debugging features.</span></div><div class="line"><span class="comment"> * @param rlimits null-ok an array of rlimit tuples, with the second</span></div><div class="line"><span class="comment"> * dimension having a length of 3 and representing</span></div><div class="line"><span class="comment"> * (resource, rlim_cur, rlim_max). These are set via the posix</span></div><div class="line"><span class="comment"> * setrlimit(2) call.</span></div><div class="line"><span class="comment"> * @param permittedCapabilities argument for setcap()</span></div><div class="line"><span class="comment"> * @param effectiveCapabilities argument for setcap()</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @return 0 if this is the child, pid of the child</span></div><div class="line"><span class="comment"> * if this is the parent, or -1 on error.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span>(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</div><div class="line">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities) {</div><div class="line">    preFork();</div><div class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(</div><div class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</div><div class="line">    postFork();</div><div class="line">    <span class="keyword">return</span> pid;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释这个函数专门为 SS 写的，不去深究这个函数了，最后应该 jni 调用 linux 的 fork 函数吧。SS 是 zygote 第一个 fork 出来的值进程。然后回到 startSystemService 那里，后面有 pid == 0 的，这个就表示 SS 的进程，然后进到 handleSystemServerProcess：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意前面打包的那个参数数据结构</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Finish remaining work for the newly forked system server process.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span>(</div><div class="line">        ZygoteConnection.Arguments parsedArgs)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line"></div><div class="line">    <span class="comment">// 由于 fork 继承了父进程的 socket，</span></div><div class="line">    <span class="comment">// SS 不需要这个，所以关掉</span></div><div class="line">    closeServerSocket();</div><div class="line"></div><div class="line">    <span class="comment">// set umask to 0077 so new files and directories will default to owner-only permissions.</span></div><div class="line">    Libcore.os.umask(S_IRWXG | S_IRWXO);</div><div class="line"></div><div class="line">    <span class="comment">// 这个 niceName 是上面那个 system_server</span></div><div class="line">    <span class="comment">// adb shell ps 能看得到 SS 的名字是 system_server</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) {</div><div class="line">        Process.setArgV0(parsedArgs.niceName);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 上面没设置 inovkeWith 所以走的下面那个分支</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) {</div><div class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class="line">                <span class="keyword">null</span>, parsedArgs.remainingArgs);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这个remainingArgs是最后那个 com.android.server.SystemServer</span></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Pass the remaining arguments to SystemServer.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* should never reach here */</span>  </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面看那个 nineName 设置为 <code>system_server</code>，这个在 adb shell ps 能看得到的，还能看得出 SS 确实是 zygote 的子进程（看 SS 的父进程号）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-thread/2.png" alt=""></p>
<p>这里终于跑到 SS 进程里面去了，然后我接下去看 RuntimeInit.zygoteInit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The main function called when started through the zygote process. This</span></div><div class="line"><span class="comment"> * could be unified with main(), if the native code in nativeFinishInit()</span></div><div class="line"><span class="comment"> * were rationalized with Zygote startup.&lt;p&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Current recognized args:</span></div><div class="line"><span class="comment"> * &lt;ul&gt;</span></div><div class="line"><span class="comment"> *   &lt;li&gt; &lt;code&gt; [--] &lt;start class name&gt;  &lt;args&gt;</span></div><div class="line"><span class="comment"> * &lt;/ul&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param targetSdkVersion target SDK version</span></div><div class="line"><span class="comment"> * @param argv arg strings</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span>(<span class="keyword">int</span> targetSdkVersion, String[] argv)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 这个不管</span></div><div class="line">    redirectLogStreams();</div><div class="line"></div><div class="line">    <span class="comment">// 这个 commonInit 这里也没什么要特别注意的</span></div><div class="line">    commonInit();</div><div class="line">    <span class="comment">// 下面那个要注意下</span></div><div class="line">    nativeZygoteInit();</div><div class="line"></div><div class="line">    <span class="comment">// 启动 SS 的 java 类的在这个函数里面</span></div><div class="line">    applicationInit(targetSdkVersion, argv);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 nativeZygoteInit 在 AndroidRuntime 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> AndroidRuntime* gCurRuntime = NULL;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class="line">{</div><div class="line">    gCurRuntime-&gt;onZygoteInit();</div><div class="line">}</div><div class="line"></div><div class="line">AndroidRuntime::AndroidRuntime() :</div><div class="line">        mExitWithoutCleanup(<span class="keyword">false</span>)     </div><div class="line">{</div><div class="line">    SkGraphics::Init();</div><div class="line">    <span class="comment">// this sets our preference for 16bit images during decode</span></div><div class="line">    <span class="comment">// in case the src is opaque and 24bit</span></div><div class="line">    SkImageDecoder::SetDeviceConfig(SkBitmap::kRGB_565_Config);</div><div class="line">    <span class="comment">// This cache is shared between browser native images, and java "purgeable"</span></div><div class="line">    <span class="comment">// bitmaps. This globalpool is for images that do not either use the java</span></div><div class="line">    <span class="comment">// heap, or are not backed by ashmem. See BitmapFactory.cpp for the key</span></div><div class="line">    <span class="comment">// java call site.</span></div><div class="line">    SkImageRef_GlobalPool::SetRAMBudget(<span class="number">512</span> * <span class="number">1024</span>);</div><div class="line">    <span class="comment">// There is also a global font cache, but its budget is specified in code</span></div><div class="line">    <span class="comment">// see SkFontHost_android.cpp</span></div><div class="line"></div><div class="line">    <span class="comment">// Pre-allocate enough space to hold a fair number of options.</span></div><div class="line">    mOptions.setCapacity(<span class="number">20</span>);</div><div class="line"></div><div class="line">    <span class="comment">// gCurRuntime 每个进程一个</span></div><div class="line">    assert(gCurRuntime == NULL);        <span class="comment">// one per process</span></div><div class="line">    gCurRuntime = <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得最开始 AppRuntime 这个之类重载的 onZygoteInit 么，没错就是在这里调用了。这里初始化了 ProcessState（打开 binder 驱动，设置 binder 自动线程最大数目为 15），然后手动启动了一个主线程。</p>
<p>然后我们继续看 applicationInit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span>(<span class="keyword">int</span> targetSdkVersion, String[] argv)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></div><div class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></div><div class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></div><div class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></div><div class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></div><div class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 设置一下虚拟机的一些参数</span></div><div class="line">    <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></div><div class="line">    <span class="comment">// holding on to a lot of memory that isn't needed.</span></div><div class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75</span>f);</div><div class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Arguments args;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        args = <span class="keyword">new</span> Arguments(argv);    </div><div class="line">    } <span class="keyword">catch</span> (IllegalArgumentException ex) {</div><div class="line">        Slog.e(TAG, ex.getMessage());  </div><div class="line">        <span class="comment">// let the process exit        </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 终于快到了</span></div><div class="line">    <span class="comment">// Remaining arguments are passed to the start class's static main</span></div><div class="line">    invokeStaticMain(args.startClass, args.startArgs);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续看 invokeStaticMain（名字都叫这个份上了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invokes a static "main(argv[]) method on class "className".</span></div><div class="line"><span class="comment"> * Converts various failing exceptions into RuntimeExceptions, with</span></div><div class="line"><span class="comment"> * the assumption that they will then cause the VM instance to exit.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param className Fully-qualified class name</span></div><div class="line"><span class="comment"> * @param argv Argument vector for main()</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span>(String className, String[] argv)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line">    Class&lt;?&gt; cl;</div><div class="line"></div><div class="line">    <span class="comment">// com.android.server.SystemServer 这个类名终于有用了</span></div><div class="line">    <span class="keyword">try</span> {                 </div><div class="line">        cl = Class.forName(className); </div><div class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</div><div class="line">                ex);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 终于去取 main 函数了</span></div><div class="line">    Method m;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] { String[].class });</div><div class="line">    } <span class="keyword">catch</span> (NoSuchMethodException ex) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Missing static main on "</span> + className, ex);</div><div class="line">    } <span class="keyword">catch</span> (SecurityException ex) { </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</div><div class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Main method is not public and static on "</span> + className);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这里搞了个花样，好像是通过抛出异常来清理调用堆栈</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></div><div class="line"><span class="comment">     * by invoking the exception's run() method. This arrangement</span></div><div class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></div><div class="line"><span class="comment">     * up the process.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数前面都没什么，关键是最后一句，抛出一个异常。看注释说这个异常在 ZygoteInit.main 中有捕获，我们回去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String argv[]) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">... ...</div><div class="line">         </div><div class="line">        } <span class="keyword">catch</span> (MethodAndArgsCaller caller) {</div><div class="line">            <span class="comment">// 在这里运行抛过来的函数</span></div><div class="line">            caller.run();</div><div class="line">        } <span class="keyword">catch</span> (RuntimeException ex) {</div><div class="line">            Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</div><div class="line">            closeServerSocket();</div><div class="line">            <span class="keyword">throw</span> ex;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>还真有捕获，然后在 catch 直接运行传递过来的 main 函数。看注释说这么做的原因是为了清除函数调用堆栈（确实从调用到 SS 的 main 函数，前面函数堆栈有好几层了）。这样能让 SS 感觉更像直接启动的吧（忽悠谁咧）。</p>
<p>然后我们终于能够去看 SS 的业务了，SS 的 main 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * In case the runtime switched since last boot (such as when</span></div><div class="line"><span class="comment">     * the old runtime was removed in an OTA), set the system</span></div><div class="line"><span class="comment">     * property so that it is in sync. We can't do this in</span></div><div class="line"><span class="comment">     * libnativehelper's JniInvocation::Init code where we already</span></div><div class="line"><span class="comment">     * had to fallback to a different runtime because it is</span></div><div class="line"><span class="comment">     * running as root and we need to be the system user to set</span></div><div class="line"><span class="comment">     * the property. http://b/11463182</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib"</span>,</div><div class="line">                         VMRuntime.getRuntime().vmLibrary());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) {</div><div class="line">        <span class="comment">// If a device's clock is before 1970 (before 0), a lot of</span></div><div class="line">        <span class="comment">// APIs crash dealing with negative numbers, notably</span></div><div class="line">        <span class="comment">// java.io.File#setLastModified, so instead we fake it and</span></div><div class="line">        <span class="comment">// hope that time from cell towers or NTP fixes it</span></div><div class="line">        <span class="comment">// shortly.</span></div><div class="line">        Slog.w(TAG, <span class="string">"System clock is before 1970; setting to 1970."</span>);</div><div class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) {</div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line">        timer = <span class="keyword">new</span> Timer();</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                SamplingProfilerIntegration.writeSnapshot(<span class="string">"system_server"</span>, <span class="keyword">null</span>);</div><div class="line">            }    </div><div class="line">        }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="comment">// Mmmmmm... more memory!</span></div><div class="line">    dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();</div><div class="line"></div><div class="line">    <span class="comment">// The system server has to run all of the time, so it needs to be</span></div><div class="line">    <span class="comment">// as efficient as possible with its memory usage.</span></div><div class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8</span>f);</div><div class="line"></div><div class="line">    Environment.setUserRequired(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    System.loadLibrary(<span class="string">"android_servers"</span>);</div><div class="line"></div><div class="line">    Slog.i(TAG, <span class="string">"Entered the Android system server!"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 启动 native 服务</span></div><div class="line">    <span class="comment">// Initialize native services.</span></div><div class="line">    nativeInit();</div><div class="line"></div><div class="line">    <span class="comment">// 启动 java 层服务</span></div><div class="line">    <span class="comment">// This used to be its own separate thread, but now it is</span></div><div class="line">    <span class="comment">// just the loop we run on the main thread.</span></div><div class="line">    ServerThread thr = <span class="keyword">new</span> ServerThread();</div><div class="line">    thr.initAndLoop();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 main 其实不长（后面的在后面那个 ServerThread 里面），先是 nativeInit 启动 native 的服务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// com_android_server_SystemServer.cpp  ========================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) {</div><div class="line">    <span class="keyword">char</span> propBuf[PROPERTY_VALUE_MAX];</div><div class="line">    property_get(<span class="string">"system_init.startsensorservice"</span>, propBuf, <span class="string">"1"</span>);</div><div class="line">    <span class="comment">// 就启动了一个 SensorService </span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">"1"</span>) == <span class="number">0</span>) {</div><div class="line">        <span class="comment">// Start the sensor service</span></div><div class="line">        SensorService::instantiate();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后主要工作在 ServerThread 中。这个是 SystemServer 的内部类，看名字就很形象，服务线程啊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 这个函数巨长，有 1000 多行，我只贴一些有代表性的</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAndLoop</span>() {</div><div class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN,</div><div class="line">            SystemClock.uptimeMillis());   </div><div class="line"></div><div class="line">        <span class="comment">// 创建主线程 Looper</span></div><div class="line">        Looper.prepareMainLooper();    </div><div class="line"></div><div class="line">        android.os.Process.setThreadPriority(</div><div class="line">                android.os.Process.THREAD_PRIORITY_FOREGROUND);</div><div class="line"></div><div class="line">        BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</div><div class="line">        android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Check whether we failed to shut down last time we tried.</span></div><div class="line">        {</div><div class="line">            <span class="keyword">final</span> String shutdownAction = SystemProperties.get(</div><div class="line">                    ShutdownThread.SHUTDOWN_ACTION_PROPERTY, <span class="string">""</span>);</div><div class="line">            <span class="keyword">if</span> (shutdownAction != <span class="keyword">null</span> && shutdownAction.length() &gt; <span class="number">0</span>) { </div><div class="line">                <span class="keyword">boolean</span> reboot = (shutdownAction.charAt(<span class="number">0</span>) == <span class="string">'1'</span>);</div><div class="line"></div><div class="line">                <span class="keyword">final</span> String reason;           </div><div class="line">                <span class="keyword">if</span> (shutdownAction.length() &gt; <span class="number">1</span>) {</div><div class="line">                    reason = shutdownAction.substring(<span class="number">1</span>, shutdownAction.length());</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    reason = <span class="keyword">null</span>;                 </div><div class="line">                }</div><div class="line"></div><div class="line">                ShutdownThread.rebootOrShutdown(reboot, reason);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        String factoryTestStr = SystemProperties.get(<span class="string">"ro.factorytest"</span>);</div><div class="line">        <span class="keyword">int</span> factoryTest = <span class="string">""</span>.equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF</div><div class="line">                : Integer.parseInt(factoryTestStr);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> headless = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"ro.config.headless"</span>, <span class="string">"0"</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 看到这一票熟悉的 Manager 了没</span></div><div class="line">        <span class="comment">// 这里不是全部的，下面还有，不贴了</span></div><div class="line">        Installer installer = <span class="keyword">null</span>;</div><div class="line">        AccountManagerService accountManager = <span class="keyword">null</span>;</div><div class="line">        ContentService contentService = <span class="keyword">null</span>;</div><div class="line">        LightsService lights = <span class="keyword">null</span>;</div><div class="line">        PowerManagerService power = <span class="keyword">null</span>;</div><div class="line">        DisplayManagerService display = <span class="keyword">null</span>;</div><div class="line">        BatteryService battery = <span class="keyword">null</span>;</div><div class="line">        VibratorService vibrator = <span class="keyword">null</span>;</div><div class="line">        AlarmManagerService alarm = <span class="keyword">null</span>;</div><div class="line">        MountService mountService = <span class="keyword">null</span>;</div><div class="line">        NetworkManagementService networkManagement = <span class="keyword">null</span>;</div><div class="line">        NetworkStatsService networkStats = <span class="keyword">null</span>;</div><div class="line">        NetworkPolicyManagerService networkPolicy = <span class="keyword">null</span>;</div><div class="line">        ConnectivityService connectivity = <span class="keyword">null</span>;</div><div class="line">        EthernetService eth = <span class="keyword">null</span>;</div><div class="line">        WifiP2pService wifiP2p = <span class="keyword">null</span>;</div><div class="line">        WifiService wifi = <span class="keyword">null</span>;</div><div class="line">        NsdService serviceDiscovery= <span class="keyword">null</span>;</div><div class="line">        IPackageManager pm = <span class="keyword">null</span>;</div><div class="line">        Context context = <span class="keyword">null</span>;</div><div class="line">        WindowManagerService wm = <span class="keyword">null</span>;</div><div class="line">        BluetoothManagerService bluetooth = <span class="keyword">null</span>;</div><div class="line">        DockObserver dock = <span class="keyword">null</span>;</div><div class="line">        UsbService usb = <span class="keyword">null</span>;</div><div class="line">        SerialService serial = <span class="keyword">null</span>;</div><div class="line">        TwilightService twilight = <span class="keyword">null</span>;</div><div class="line">        UiModeManagerService uiMode = <span class="keyword">null</span>;</div><div class="line">        RecognitionManagerService recognition = <span class="keyword">null</span>;</div><div class="line">        NetworkTimeUpdateService networkTimeUpdater = <span class="keyword">null</span>;</div><div class="line">        CommonTimeManagementService commonTimeMgmtService = <span class="keyword">null</span>;</div><div class="line">        InputManagerService inputManager = <span class="keyword">null</span>;</div><div class="line">        TelephonyRegistry telephonyRegistry = <span class="keyword">null</span>;</div><div class="line">        ConsumerIrService consumerIr = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// new Service 对象，然后 add 到 SM 中，非常规范的操作</span></div><div class="line">            <span class="comment">// 这里也只贴前面几个，下面都差不多，无非有几个玩非主流</span></div><div class="line">            <span class="comment">// 后面分析到那些再说。</span></div><div class="line">            Slog.i(TAG, <span class="string">"Display Manager"</span>);</div><div class="line">            display = <span class="keyword">new</span> DisplayManagerService(context, wmHandler);</div><div class="line">            ServiceManager.addService(Context.DISPLAY_SERVICE, display, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            Slog.i(TAG, <span class="string">"Telephony Registry"</span>);</div><div class="line">            telephonyRegistry = <span class="keyword">new</span> TelephonyRegistry(context);</div><div class="line">            ServiceManager.addService(<span class="string">"telephony.registry"</span>, telephonyRegistry);</div><div class="line"></div><div class="line">            Slog.i(TAG, <span class="string">"Scheduling Policy"</span>);</div><div class="line">            ServiceManager.addService(<span class="string">"scheduling_policy"</span>, <span class="keyword">new</span> SchedulingPolicyService());</div><div class="line"></div><div class="line">            AttributeCache.init(context);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!display.waitForDefaultDisplay()) {</div><div class="line">                reportWtf(<span class="string">"Timeout waiting for default display to be initialized."</span>,</div><div class="line">                        <span class="keyword">new</span> Throwable());</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        } <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">            Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</div><div class="line">            Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting core service"</span>, e);</div><div class="line">        }</div><div class="line"></div><div class="line">... ... </div><div class="line"></div><div class="line">        <span class="comment">// 主线程 Looper 开始循环</span></div><div class="line">        Looper.loop();</div><div class="line">        Slog.d(TAG, <span class="string">"System ServerThread is exiting!"</span>);</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看 SS main 最后那里注释说，这些 SS 应该在单独的线程里面跑，但是现在暂时都在主线程中了。看 ServerThread 中代码，是都是在主线程中。SS 是一个典型的一个进程里面多个服务的例子（服务还很多，好像有十几个吧 -_-||）。DDMS 里面的截图很明显了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-thread/3.png" alt=""><br>（pid 430 是上面 ps 看到的 SS 的）</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-thread/4.png" alt=""></p>
<p>之前还觉得 binder 默认给自动线程设置 15 个是不是有点多，现在看起来这个值是不是就是对着 SS 来设的。结合前面的讨论，15 个加上前面那个主动开的线程应该能应付大多数情况。看截图一般高峰期就 11、12 个 Bp 吧（<code>Binder_C</code>、<code>Binder_D</code>，前面说了 kernel 自动调节的线程目前一旦传了，不会退出的，所以这个最大数差不多能说明最大负载的情况吧）。然后看到这些线程的名字都是 Binder_X、这个名字是在 ProcessState 里取的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String8 ProcessState::makeBinderThreadName() {</div><div class="line">    int32_t s = android_atomic_add(<span class="number">1</span>, &mThreadPoolSeq);</div><div class="line">    String8 name;</div><div class="line">    name.appendFormat(<span class="string">"Binder_%X"</span>, s);</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这不是 isMain 的线程连名字都是大众脸（所以看到 Binder_X 的线程，就知道是 kernel binder 驱动自动调节创建出来的）。</p>
<p>然后这里再讨论一个问题，就是 SS 一个进程同时在跑多个不同的服务，那不同的线程如果能够把不同服务的 Bp 请求发送到对应的服务处理呢。刚开始我也觉得有点不好理解，但是从上一篇 binder 对象传递之后我就明白了，binder 根本不需要区分这个请求是服务进程中哪个服务的。还记得 binder 对象传递篇中，服务向 SM 注册的时候，传递过去的对象是 Bn，然后把本地对象的指针传递过去了，然后在 kernel 的 <code>binder_node</code> 中有保存这个本地指针的。所以只要能找到正确的 node （通过的 Bp 的 handle 值取 ref，再通过 ref 取 node，忘记了的回去看 binder 对象传递篇）就能取得服务的本地对象指针，然后在服务进程的线程中执行这个本地对象的方法就能执行正确的服务函数了。所以这些对于多线程，一个进程多个服务来说是透明，它们不用管这个 binder 对象是本进程内哪个服务的，只管执行它的 transation 方法就行。</p>
<h2 id="总结">总结</h2>
<p>android 真的为 IPC 做了很多事情，前面说的效率、框架封装不说，这里直接帮你把并发多线程支持给你解决了。但是还有 framework 还是有些服务不是用 binder 的（vold、zygote），唉，人多了，另起炉灶就再所难免了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%AD%BB%E4%BA%A1%E9%80%9A%E7%9F%A5%5BDeathRecipient%5D/</loc>
    <lastmod>2015-03-31T06:28:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——死亡通知（DeathRecipient）</title>
        <pubTime>2015-01-28T14:12:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>binder 是跨进程间的通信，那就是说有本地和远程之说，通过前面几篇也知道 Bp 需要发请求到 Bn 端。但是写过网络通信程序的都知道，远程不一定“靠谱”，就是说可能某些时候远程服务器挂了。所以一般网络通信程序会弄一个心跳的机制，就是每隔一段时间向服务发一些东西，看服务是否还有响应。同理的还有看门狗，如果不定时去“喂狗”（证明程序还活着），机器就会重启之类的。所以 binder 通信也存在这个问题，不过同样也是 android 帮我们弄好框架了。</p>
<p>照例先把相关源码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java binder 相关接口</span></div><div class="line">frameworks/base/core/android/os/IBinder.java</div><div class="line">frameworks/base/core/android/os/Binder.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line"></div><div class="line"><span class="comment"># jni binder 相关接口</span></div><div class="line">frameworks/base/core/jni/android_util_Binder.cpp</div><div class="line"></div><div class="line"><span class="comment"># SM 程序</span></div><div class="line">frameworks/native/cmds/servicemanager/binder.c</div><div class="line">frameworks/native/cmds/servicemanager/binder.h</div><div class="line">frameworks/native/cmds/servicemanager/service_manager.c</div><div class="line"></div><div class="line"><span class="comment"># native binder 库</span></div><div class="line">frameworks/native/include/binder/Binder.h</div><div class="line">frameworks/native/include/binder/BpBinder.h</div><div class="line">frameworks/native/include/binder/IPCThreadState.h</div><div class="line">frameworks/native/include/binder/ProcessState.h</div><div class="line">frameworks/native/libs/binder/IInterface.cpp</div><div class="line">frameworks/native/libs/binder/Binder.cpp</div><div class="line">frameworks/native/libs/binder/BpBinder.cpp</div><div class="line">frameworks/native/libs/binder/IPCThreadState.cpp</div><div class="line">frameworks/native/libs/binder/ProcessState.cpp</div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="native_层的接口">native 层的接口</h2>
<p>binder 的东西是 native，java 层挂马甲的，所以先说 native 层的。在 libbinder 中的 IBinder.h 中有一个函数和一个接口类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment"> * This method allows you to add data that is transported through</span></div><div class="line"><span class="comment"> * IPC along with your IBinder pointer.  When implementing a Binder</span></div><div class="line"><span class="comment"> * object, override it to write your desired data in to @a outData.</span></div><div class="line"><span class="comment"> * You can then call getConstantData() on your IBinder to retrieve</span></div><div class="line"><span class="comment"> * that data, from any process.  You MUST return the number of bytes</span></div><div class="line"><span class="comment"> * written in to the parcel (including padding).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class</span> DeathRecipient : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> binderDied(<span class="keyword">const</span> wp&lt;IBinder&gt;& who) = <span class="number">0</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment"> * Register the @a recipient for a notification if this binder</span></div><div class="line"><span class="comment"> * goes away.  If this binder object unexpectedly goes away</span></div><div class="line"><span class="comment"> * (typically because its hosting process has been killed),</span></div><div class="line"><span class="comment"> * then DeathRecipient::binderDied() will be called with a reference</span></div><div class="line"><span class="comment"> * to this.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The @a cookie is optional -- if non-NULL, it should be a</span></div><div class="line"><span class="comment"> * memory address that you own (that is, you know it is unique).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @note You will only receive death notifications for remote binders,</span></div><div class="line"><span class="comment"> * as local binders by definition can't die without you dying as well.</span></div><div class="line"><span class="comment"> * Trying to use this function on a local binder will result in an</span></div><div class="line"><span class="comment"> * INVALID_OPERATION code being returned and nothing happening.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @note This link always holds a weak reference to its recipient.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @note You will only receive a weak reference to the dead</span></div><div class="line"><span class="comment"> * binder.  You should not try to promote this to a strong reference.</span></div><div class="line"><span class="comment"> * (Nor should you need to, as there is nothing useful you can</span></div><div class="line"><span class="comment"> * directly do with it now that it has passed on.)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> status_t        linkToDeath(<span class="keyword">const</span> sp&lt;DeathRecipient&gt;& recipient,</div><div class="line">                                    <span class="keyword">void</span>* cookie = NULL,</div><div class="line">                                    uint32_t flags = <span class="number">0</span>) = <span class="number">0</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>注释很长，意思就是 linkToDeath 可以允许你注册一个回调接口 DeathRecipient 到 Bp。然后当 Bp 对应的 Bn 挂掉了，DeathRecipient 中的 binderDied 会被调用，然后你可以根据你的业务情况做一些处理。那个 binderDied 的参数就是 Bp 对象自己（看后面的代码）。</p>
<p>注意了，虽然 linkToDeath 是 IBinder 的接口，但是只允许在 Bp 端注册。下面的代码能看得出。而且你想想看，这个东西是通知服务端（Bn）挂了的，如果你注册在 Bn 端，你都挂了，还能掉回调么。所以 <strong>注册死亡通知只有在 Bp 才有效</strong>。</p>
<p>然后我们接下去看实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">status_t BpBinder::linkToDeath(</div><div class="line">    <span class="keyword">const</span> sp&lt;DeathRecipient&gt;& recipient, <span class="keyword">void</span>* cookie, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="comment">// 保存回调的数据结构，单词 Obituary 好像是仆告的意思</span></div><div class="line">    <span class="comment">// 看后面的代码，这个结构就只有recipient有用而已（这是回调的指针，最重要）</span></div><div class="line">    Obituary ob;</div><div class="line">    ob.recipient = recipient;</div><div class="line">    ob.cookie = cookie;</div><div class="line">    ob.flags = flags;</div><div class="line"></div><div class="line">    LOG_ALWAYS_FATAL_IF(recipient == NULL,</div><div class="line">                        <span class="string">"linkToDeath(): recipient must be non-NULL"</span>);</div><div class="line"></div><div class="line">    {</div><div class="line">        AutoMutex _l(mLock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!mObitsSent) {</div><div class="line">            <span class="comment">// 用了一个 Vector 来保存，这么说一个 Bp 可以注册多个死亡通知回调</span></div><div class="line">            <span class="keyword">if</span> (!mObituaries) {            </div><div class="line">                mObituaries = <span class="keyword">new</span> Vector&lt;Obituary&gt;;</div><div class="line">                <span class="keyword">if</span> (!mObituaries) {            </div><div class="line">                    <span class="keyword">return</span> NO_MEMORY;              </div><div class="line">                }</div><div class="line">                ALOGV(<span class="string">"Requesting death notification: %p handle %d\n"</span>, <span class="keyword">this</span>, mHandle);</div><div class="line">                <span class="comment">// 又得手动增加引用计数 </span></div><div class="line">                getWeakRefs()-&gt;incWeak(<span class="keyword">this</span>);</div><div class="line">                <span class="comment">// 调用到 IPCThreadState 里面去了  </span></div><div class="line">                IPCThreadState* self = IPCThreadState::self(); </div><div class="line">                <span class="comment">// 注意参数，把自己 ref 的 handle 值和自己的对象传过去了</span></div><div class="line">                self-&gt;requestDeathNotification(mHandle, <span class="keyword">this</span>);</div><div class="line">                <span class="comment">// 类似 flush 的函数，看样子应该对 binder 驱动发命令了</span></div><div class="line">                self-&gt;flushCommands();         </div><div class="line">            }</div><div class="line">            ssize_t res = mObituaries-&gt;add(ob);</div><div class="line">            <span class="keyword">return</span> res &gt;= (ssize_t)NO_ERROR ? (status_t)NO_ERROR : res;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> DEAD_OBJECT;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>BpBinder 拿一个 Vector 来保存死亡回调，说明一个 Bp 可以注册多个回调的。然后我们在去看 IPCThreadState 的处理之前，来看下 Binder 里 linkToDeath 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">status_t BBinder::linkToDeath(</div><div class="line">    <span class="keyword">const</span> sp&lt;DeathRecipient&gt;& recipient, <span class="keyword">void</span>* cookie, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> INVALID_OPERATION;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然和前面说的一样，Bn 端的 linkToDeath 是不允许调用的。然后我们可以去 IPCThreadState 来看看 requestDeathNotification 的处理了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)</div><div class="line">{</div><div class="line">    <span class="comment">// 果然是对 binder 驱动发命令</span></div><div class="line">    <span class="comment">// 注意下面的参数，一个是 Bp 的 handle 值，一个 Bp 自身的对象指针</span></div><div class="line">    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);</div><div class="line">    mOut.writeInt32((int32_t)handle);</div><div class="line">    mOut.writeInt32((int32_t)proxy);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面把 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 命令写入要发送的数据包（BC 开头的命令是用户空间往内核空间发送的，忘记的回去看通信篇）。然后把 Bp 的 handle 也写入（Bp 的 handle 值在 kernel 中可能找到 node 的 ref，忘记的回去看对象传递篇）。最后把 Bp 自己对象指针也写入（注意是指针，4字节的地址，看过前面的都应该知道，保存指针能用的只能是本进程而已（Bn 的本地指针是到 Bn 进程才能调用的），所以注册死亡通知只能在 Bp 端注册，所以这里可以保存 Bp 指针）。</p>
<p>然后后面还有个 flushCommands：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::flushCommands()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// talkWithDriver 就调用 ioctl 发送 BINDER_WRITE_READ 命令。</span></div><div class="line">    <span class="comment">// false 表示不需要返回，只会写，不会阻塞等待读，马上就返回。</span></div><div class="line">    talkWithDriver(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Bp 本来要等到 transact（调用 talkWithDriver） 才会真正去对驱动写数据。这个 flushCommands 意思就是马上把命令发出去（很多 I/O 接口都有类似的叫 flush 的函数）。原来就是直接调用了 talkWithDriver 而已（false 不需要返回的）。下面就是到 kernel 的 binder 驱动中去了。我们继续去 kernel 里面去看。</p>
<h2 id="注册死亡通知到_kernel">注册死亡通知到 kernel</h2>
<p>IPCThreadState 调用的 ioctl 发送的是 <code>BINDER_WRITE_READ</code> 命令，然后不需要返回，那就是只会调用 <code>binder_thread_write</code> 而已，然后我来看看 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 命令的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd; </div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {</div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        }    </div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">        </div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 注册死亡通知和清除走一个分支，又搞在一起 -_-||</span></div><div class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</div><div class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">            uint32_t target;</div><div class="line">            <span class="keyword">void</span> __user *cookie;</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line"></div><div class="line">            <span class="comment">// 取 Bp 的 handle 值</span></div><div class="line">            <span class="keyword">if</span> (get_user(target, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="comment">// 取从用户空间传下来的指针，刚刚上面传过来的是 Bp 指针</span></div><div class="line">            <span class="comment">// 这里为什么保持用户空间的指针，而不转化成一个具体的类型，</span></div><div class="line">            <span class="comment">// 后面看到 SM 的例子的时候就会知道。</span></div><div class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            <span class="comment">// 通过 handle 值取 ref</span></div><div class="line">            ref = binder_get_ref(proc, target);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d %s "</span></div><div class="line">                    <span class="string">"invalid ref %d\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    cmd == BC_REQUEST_DEATH_NOTIFICATION ?</div><div class="line">                    <span class="string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :</div><div class="line">                    <span class="string">"BC_CLEAR_DEATH_NOTIFICATION"</span>, </div><div class="line">                    target);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">                     <span class="string">"binder: %d:%d %s %p ref %d desc %d s %d w %d for node %d\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid,        </div><div class="line">                     cmd == BC_REQUEST_DEATH_NOTIFICATION ?</div><div class="line">                     <span class="string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :</div><div class="line">                     <span class="string">"BC_CLEAR_DEATH_NOTIFICATION"</span>, </div><div class="line">                     cookie, ref-&gt;debug_id, ref-&gt;desc,</div><div class="line">                     ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);</div><div class="line"></div><div class="line">            <span class="comment">// 说走一条分支么，后面还不是分开啦</span></div><div class="line">            <span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) {</div><div class="line">                <span class="comment">// 上面好像 Bp 可以注册多个，但是在kernel里面只能注册一个咧</span></div><div class="line">                <span class="keyword">if</span> (ref-&gt;death) {</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">                        <span class="string">"d BC_REQUEST_DEATH_NOTI"</span></div><div class="line">                        <span class="string">"FICATION death notific"</span></div><div class="line">                        <span class="string">"ation already set\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                <span class="comment">// 这个 binder_ref_death 是kernel中保存死亡通知回调的结构</span></div><div class="line">                death = kzalloc(<span class="keyword">sizeof</span>(*death), GFP_KERNEL);</div><div class="line">                <span class="keyword">if</span> (death == NULL) {</div><div class="line">                    thread-&gt;return_error = BR_ERROR;</div><div class="line">                    binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</div><div class="line">                             <span class="string">"binder: %d:%d "</span></div><div class="line">                             <span class="string">"BC_REQUEST_DEATH_NOTIFICATION failed\n"</span>,</div><div class="line">                             proc-&gt;pid, thread-&gt;pid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                binder_stats_created(BINDER_STAT_DEATH);</div><div class="line">                <span class="comment">// 初始化的工作队列列表</span></div><div class="line">                INIT_LIST_HEAD(&death-&gt;work.entry);</div><div class="line">                <span class="comment">// 把用户空间传过来的那个指针保存起来</span></div><div class="line">                death-&gt;cookie = cookie;</div><div class="line">                <span class="comment">// 每一个 ref 保存有一个 binder_ref_death</span></div><div class="line">                ref-&gt;death = death;</div><div class="line">                <span class="comment">// 如果 ref 对应的 node 的 进程已经挂了，这里直接就发通知了</span></div><div class="line">                <span class="comment">// 这种情况不属于一般情况，我们这里讨论</span></div><div class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == NULL) {</div><div class="line">                    ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</div><div class="line">                    printk(KERN_INFO <span class="string">"binder: %d:%d in binder_thread_write BC_REQUEST_DEATH or CLEAR: 0x%08x \n"</span>,</div><div class="line">                            proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">                    <span class="keyword">if</span> (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {</div><div class="line">                        list_add_tail(&ref-&gt;death-&gt;work.entry, &thread-&gt;todo);</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        list_add_tail(&ref-&gt;death-&gt;work.entry, &proc-&gt;todo);</div><div class="line">                        wake_up_interruptible(&proc-&gt;wait);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line"><span class="comment">// 下面是清除已经注册的死亡通知的，我们先不看</span></div><div class="line">... ...</div><div class="line">            }</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后先来看看相关的数据结构先：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个 work 其实前面通信篇有涉及到，不过那个时候好像没贴代码出来</span></div><div class="line"><span class="keyword">struct</span> binder_work {</div><div class="line">    <span class="comment">// 其实这个结构就只是一个列表而已，要不然怎么叫工作队列 -_-||</span></div><div class="line">    <span class="keyword">struct</span> list_head entry;</div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,   </div><div class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</div><div class="line">        BINDER_WORK_NODE,</div><div class="line">        BINDER_WORK_DEAD_BINDER,       </div><div class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</div><div class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</div><div class="line">    } type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 这个其实也挺简单，一个工作结构，下面是用户空间那个指针</span></div><div class="line"><span class="keyword">struct</span> binder_ref_death {</div><div class="line">    <span class="keyword">struct</span> binder_work work; </div><div class="line">    <span class="keyword">void</span> __user *cookie;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_ref {</div><div class="line">    <span class="comment">/* Lookups needed: */</span></div><div class="line">    <span class="comment">/*   node + proc =&gt; ref (transaction) */</span></div><div class="line">    <span class="comment">/*   desc + proc =&gt; ref (transaction, inc/dec ref) */</span></div><div class="line">    <span class="comment">/*   node =&gt; refs + procs (proc exit) */</span></div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="keyword">struct</span> rb_node rb_node_desc;</div><div class="line">    <span class="keyword">struct</span> rb_node rb_node_node;</div><div class="line">    <span class="keyword">struct</span> hlist_node node_entry;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc; </div><div class="line">    <span class="keyword">struct</span> binder_node *node;</div><div class="line">    uint32_t desc;</div><div class="line">    <span class="keyword">int</span> strong;</div><div class="line">    <span class="keyword">int</span> weak;</div><div class="line">    <span class="comment">// 注册了的死亡通知结构</span></div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>数据结构不算复杂。然后这个注册过程就算结束了。当 Bp 注册了死亡回调后，native 的 Bp 会把 DeathRecipient 保存到自己的一个结构中，然后发命令给 kernel，在 kernel 中的 Bp 对应的 ref 中也保存到了一个结构中。就是说这个回调最终是注册到 kernel 里面的。</p>
<h2 id="触发死亡通知">触发死亡通知</h2>
<p>上面说了注册最终是注册到 kernel 里面的，那触发也应该是由 kernel 来触发的。实际就是这样的。那我们来看下是怎么触发死亡通知的。binder 驱动有个关闭（释放）操作的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = {</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .poll = binder_poll,</div><div class="line">    .unlocked_ioctl = binder_ioctl,</div><div class="line">    .mmap = binder_mmap,</div><div class="line">    .open = binder_open,</div><div class="line">    .flush = binder_flush,</div><div class="line">    .release = binder_release,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_release(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    debugfs_remove(proc-&gt;debugfs_entry);</div><div class="line">    <span class="comment">// 定义了一个 kernel 的工作队列</span></div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们来看最后那个函数 <code>binder_defer_work</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> HLIST_HEAD(binder_procs);</div><div class="line"><span class="comment">// 全局的延迟工作列表</span></div><div class="line"><span class="keyword">static</span> HLIST_HEAD(binder_deferred_list);</div><div class="line"><span class="keyword">static</span> HLIST_HEAD(binder_dead_nodes); </div><div class="line"></div><div class="line"><span class="comment">// 全局的工作队列</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> workqueue_struct *binder_deferred_workqueue;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init binder_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建单线程的工作队列</span></div><div class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</div><div class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 静态定义一个工作队列</span></div><div class="line"><span class="keyword">static</span> DECLARE_WORK(binder_deferred_work, binder_deferred_func);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">binder_defer_work(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">enum</span> binder_deferred_state defer)</div><div class="line">{</div><div class="line">    mutex_lock(&binder_deferred_lock);</div><div class="line">    <span class="comment">// 设置进程工作的类型，这里是前面那个 BINDER_DEFERRED_RELEASE</span></div><div class="line">    proc-&gt;deferred_work |= defer;</div><div class="line">    <span class="comment">// 判断这个进程是不是已经加到工作队列里去了</span></div><div class="line">    <span class="keyword">if</span> (hlist_unhashed(&proc-&gt;deferred_work_node)) {</div><div class="line">        <span class="comment">// 还没有的话把这个进程的工作节点加到全局的工作队列里</span></div><div class="line">        hlist_add_head(&proc-&gt;deferred_work_node,</div><div class="line">                &binder_deferred_list);</div><div class="line">        <span class="comment">// 这里是加到 kernel 的工作队列中        </span></div><div class="line">        queue_work(binder_deferred_workqueue, &binder_deferred_work);</div><div class="line">    }</div><div class="line">    mutex_unlock(&binder_deferred_lock);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数是设置一个工作队列。注意这里的工作队列是 kernel 提供的机制，不是前面说的 binder 添加的那个工作列队。kernel 提供的 workqueue 是提供一种延迟执行的机制，通常硬件设备需要一定的时间才能执行完指令操作，所以需要这种机制。这里应该是等 binder 设备关闭完成才执行吧（关于 workqueue 可以自己去查一些 kernel 相关的资料）。看这个函数的名字： <code>binder_defer_work</code>，名字都带延迟（defer 就是延迟的意思）。反正这里就理解为 binder 设备关闭之后，会执行工作队列设置的那个函数 <code>binder_deferred_func</code> 就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_deferred_func(<span class="keyword">struct</span> work_struct *work)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;</div><div class="line">    <span class="keyword">struct</span> files_struct *files;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> defer;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        mutex_lock(&binder_lock);      </div><div class="line">        mutex_lock(&binder_deferred_lock);</div><div class="line">        <span class="keyword">if</span> (!hlist_empty(&binder_deferred_list)) {</div><div class="line">            <span class="comment">// 在全局的工作队列中取最靠前的那个</span></div><div class="line">            proc = hlist_entry(binder_deferred_list.first,</div><div class="line">                    <span class="keyword">struct</span> binder_proc, deferred_work_node);</div><div class="line">            <span class="comment">// 取出来后，从全局工作队列中删除</span></div><div class="line">            hlist_del_init(&proc-&gt;deferred_work_node);</div><div class="line">            <span class="comment">// 取之前 binder_defer_work 设置的变量，</span></div><div class="line">            <span class="comment">// 就是那个 BINDER_DEFERRED_RELEASE</span></div><div class="line">            defer = proc-&gt;deferred_work;   </div><div class="line">            proc-&gt;deferred_work = <span class="number">0</span>;       </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            proc = NULL;</div><div class="line">            defer = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        mutex_unlock(&binder_deferred_lock);</div><div class="line"></div><div class="line">        files = NULL;</div><div class="line">        <span class="keyword">if</span> (defer & BINDER_DEFERRED_PUT_FILES) { </div><div class="line">            files = proc-&gt;files;           </div><div class="line">            <span class="keyword">if</span> (files)</div><div class="line">                proc-&gt;files = NULL;            </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (defer & BINDER_DEFERRED_FLUSH)</div><div class="line">            binder_deferred_flush(proc);</div><div class="line"></div><div class="line">        <span class="comment">// 所以这里是走这个分支</span></div><div class="line">        <span class="keyword">if</span> (defer & BINDER_DEFERRED_RELEASE)</div><div class="line">            binder_deferred_release(proc); <span class="comment">/* frees proc */</span></div><div class="line"></div><div class="line">        mutex_unlock(&binder_lock);</div><div class="line">        <span class="keyword">if</span> (files)</div><div class="line">            put_files_struct(files);</div><div class="line">    } <span class="keyword">while</span> (proc);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接下去看 <code>binder_deferred_release</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意这里传过来的 proc 是 Bn 的</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_deferred_release(<span class="keyword">struct</span> binder_proc *proc)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> hlist_node *pos;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> rb_node *n;</div><div class="line">    <span class="keyword">int</span> threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;</div><div class="line"></div><div class="line">    BUG_ON(proc-&gt;vma);</div><div class="line">    BUG_ON(proc-&gt;files);</div><div class="line"></div><div class="line">    hlist_del(&proc-&gt;proc_node);</div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node && binder_context_mgr_node-&gt;proc == proc) {</div><div class="line">        binder_debug(BINDER_DEBUG_DEAD_BINDER,</div><div class="line">                 <span class="string">"binder_release: %d context_mgr_node gone\n"</span>,</div><div class="line">                 proc-&gt;pid);</div><div class="line">        binder_context_mgr_node = NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    threads = <span class="number">0</span>;</div><div class="line">    active_transactions = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 这里是释放之前申请的 thread 相关的变量的内存吧。</span></div><div class="line">    <span class="comment">// 前面线程篇有说 Bn 每开一个线程会 new 一个 binder_thread 的</span></div><div class="line">    <span class="keyword">while</span> ((n = rb_first(&proc-&gt;threads))) {</div><div class="line">        <span class="keyword">struct</span> binder_thread *thread = rb_entry(n, <span class="keyword">struct</span> binder_thread, rb_node);</div><div class="line">        threads++;</div><div class="line">        active_transactions += binder_free_thread(proc, thread);</div><div class="line">    }</div><div class="line">    nodes = <span class="number">0</span>;</div><div class="line">    incoming_refs = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 这里是遍历进程的每一个 node（一个 node 对应一个 Bn）</span></div><div class="line">    <span class="keyword">while</span> ((n = rb_first(&proc-&gt;nodes))) {</div><div class="line">        <span class="keyword">struct</span> binder_node *node = rb_entry(n, <span class="keyword">struct</span> binder_node, rb_node);</div><div class="line"></div><div class="line">        nodes++;</div><div class="line">        rb_erase(&node-&gt;rb_node, &proc-&gt;nodes);</div><div class="line">        list_del_init(&node-&gt;work.entry);</div><div class="line">        <span class="keyword">if</span> (hlist_empty(&node-&gt;refs)) {</div><div class="line">            <span class="comment">// 如果这个 node 没有 ref 的话，可以直接删除</span></div><div class="line">            kfree(node);</div><div class="line">            binder_stats_deleted(BINDER_STAT_NODE);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            <span class="keyword">int</span> death = <span class="number">0</span>;</div><div class="line"></div><div class="line">            node-&gt;proc = NULL;</div><div class="line">            node-&gt;local_strong_refs = <span class="number">0</span>;</div><div class="line">            node-&gt;local_weak_refs = <span class="number">0</span>;</div><div class="line">            hlist_add_head(&node-&gt;dead_node, &binder_dead_nodes);</div><div class="line"></div><div class="line">            <span class="comment">// 否则得看看 ref 里面是否设置了死亡通知回调</span></div><div class="line">            hlist_for_each_entry(ref, pos, &node-&gt;refs, node_entry) {</div><div class="line">                incoming_refs++;</div><div class="line">                <span class="keyword">if</span> (ref-&gt;death) {</div><div class="line">                    death++;</div><div class="line">                    <span class="comment">// 如果有设置的话，要发送死亡通知回调</span></div><div class="line">                    <span class="comment">//这里先判断这个死亡回调是否正在发送，如果是就不用再发送了</span></div><div class="line">                    <span class="keyword">if</span> (list_empty(&ref-&gt;death-&gt;work.entry)) {</div><div class="line">                        <span class="comment">// 没发送的话，就把死亡回调的工作状态设置一下</span></div><div class="line">                        <span class="comment">// 死亡回调发送也和前面 Bp 发请求差不多，</span></div><div class="line">                        <span class="comment">// 弄成了一个binder_work的东西，其实就是一个状态。</span></div><div class="line">                        ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</div><div class="line">                        <span class="comment">// 然后把这个 work 添加到 ref 的进程的 todo list</span></div><div class="line">                        <span class="comment">// 注意添加到的是 ref 的进程，就是 Bp 的进程。</span></div><div class="line">                        list_add_tail(&ref-&gt;death-&gt;work.entry, &ref-&gt;proc-&gt;todo);</div><div class="line">                        <span class="comment">// 然后唤醒 ref 的进程（Bp 进程）</span></div><div class="line">                        wake_up_interruptible(&ref-&gt;proc-&gt;wait);</div><div class="line">                    } <span class="keyword">else</span></div><div class="line">                        BUG();</div><div class="line">                }</div><div class="line">            }</div><div class="line">            binder_debug(BINDER_DEBUG_DEAD_BINDER,</div><div class="line">                     <span class="string">"binder: node %d now dead, "</span></div><div class="line">                     <span class="string">"refs %d, death %d\n"</span>, node-&gt;debug_id,</div><div class="line">                     incoming_refs, death);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="comment">// 后面就是 binder_proc 结构的清理，</span></div><div class="line"><span class="comment">// 例如清除一些引用和之前申请的一些结构体的内存等。这里不细看了。</span></div><div class="line">... ...</div><div class="line"></div><div class="line">    kfree(proc);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子是在释放 Bn 的 kernel 的 proc 时候去检测在 proc 的 node 的 ref 有没有注册死亡通知回调（前面上层发注册命令注册）。如果注册了，就添加一个 work 到 ref 的进程的 todo list，并唤醒它。这个 ref 的进程就是 Bp 了，前面注册也是 Bp 注册的。然后根据前面通信篇说的，这个唤醒的是 <code>binder_thread_read</code>，但是不是所有 Bp 都会阻塞在 read 那的，一般 Bn 才会（不过很多 Bn 也经常当 Bp 的，例如请求别的服务）。如果是普通单纯的 Bp 的要等到下一次 transact 才能有机会收到这个通知。好了，我们继续去 Bp 的 <code>binder_thread_read</code> 里面去看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                  <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</div><div class="line">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block) </div><div class="line">{</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        uint32_t cmd;</div><div class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line">        <span class="keyword">struct</span> binder_work *w;</div><div class="line">        <span class="keyword">struct</span> binder_transaction *t = NULL;</div><div class="line"></div><div class="line">        <span class="comment">//printk(KERN_INFO "binder: %d:%d ptr=%08lx end=%08lx buffer=%08lx\n", proc-&gt;pid, thread-&gt;pid, ptr, end, buffer);</span></div><div class="line">        <span class="keyword">if</span> (!list_empty(&thread-&gt;todo)) </div><div class="line">            w = list_first_entry(&thread-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&proc-&gt;todo) && wait_for_proc_work) </div><div class="line">            w = list_first_entry(&proc-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> && !(thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span> </div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (w-&gt;type) {</div><div class="line">... ...</div><div class="line">        <span class="comment">// 又一是堆走一个分支，</span></div><div class="line">        <span class="comment">// 刚刚前面发过来的 work type 是 BINDER_WORK_DEAD_BINDER</span></div><div class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">            <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">            uint32_t cmd;</div><div class="line"></div><div class="line">            <span class="comment">// 从发过来的 work 中取 death 结构</span></div><div class="line">            death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">// 这里返回给用户的是 BR_DEAD_BINDER             </span></div><div class="line">                cmd = BR_DEAD_BINDER;</div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="comment">// 把用户空间注册过来时传过来的那个指针，原封不动的传回去</span></div><div class="line">            <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">                     <span class="string">"binder: %d:%d %s %p\n"</span>,</div><div class="line">                      proc-&gt;pid, thread-&gt;pid,</div><div class="line">                      cmd == BR_DEAD_BINDER ?</div><div class="line">                      <span class="string">"BR_DEAD_BINDER"</span> :</div><div class="line">                      <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>,</div><div class="line">                      death-&gt;cookie);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {</div><div class="line">                <span class="comment">// 如果是清除死亡通知的话，可以释放之前申请的death结构的内存</span></div><div class="line">                list_del(&w-&gt;entry);</div><div class="line">                kfree(death);</div><div class="line">                binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">            } <span class="keyword">else</span></div><div class="line">                <span class="comment">// 这里不是清除，是触发通知，</span></div><div class="line">                <span class="comment">// 把这个 work 队列放到该进程的 delivered_death 队列中</span></div><div class="line">                list_move(&w-&gt;entry, &proc-&gt;delivered_death);</div><div class="line">            <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)</div><div class="line">                <span class="comment">// 这个很省事，直接就完工了，下面的处理都不用跑了</span></div><div class="line">                <span class="comment">// 看注释是说发送死亡通知可以中断传输</span></div><div class="line">                <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">done:</div><div class="line"></div><div class="line">    *consumed = ptr - buffer;</div><div class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &&</div><div class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &&</div><div class="line">        (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">         BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></div><div class="line">         <span class="comment">/*spawn a new thread if we leave this out */</span>) {</div><div class="line">        proc-&gt;requested_threads++;</div><div class="line">        binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                 <span class="string">"binder: %d:%d BR_SPAWN_LOOPER\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid);</div><div class="line">        <span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>根据前面通信篇的分析，这里 kernel 向用户空间发送了一个返回值： <code>BR_DEAD_BINDER</code>，并把之前用户空间注册时候发过来的那个指针原封不动的发了回去。我们现在要去用户空间看下，最终是怎么触发用户空间的回调的。我们发现 IPCThreadState 有处理 <code>BR_DEAD_BINDER</code> 的地方是 executeCommand。这个函数我们看看在哪几个地方会调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::getAndExecuteCommand()</div><div class="line">{</div><div class="line">    status_t result;</div><div class="line">    int32_t cmd;</div><div class="line"></div><div class="line">    result = talkWithDriver();</div><div class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">        size_t IN = mIn.dataAvail();   </div><div class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这里调用了</span></div><div class="line">        result = executeCommand(cmd);  </div><div class="line"></div><div class="line">        <span class="comment">// After executing the command, ensure that the thread is returned to the</span></div><div class="line">        <span class="comment">// foreground cgroup before rejoining the pool.  The driver takes care of</span></div><div class="line">        <span class="comment">// restoring the priority, but doesn't do anything with cgroups so we</span></div><div class="line">        <span class="comment">// need to take care of that here in userspace.  Note that we do make</span></div><div class="line">        <span class="comment">// sure to go in the foreground after executing a transaction, but</span></div><div class="line">        <span class="comment">// there are other callbacks into user code that could have changed</span></div><div class="line">        <span class="comment">// our group so we want to make absolutely sure it is put back.</span></div><div class="line">        set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</div><div class="line">{</div><div class="line">    int32_t cmd;</div><div class="line">    int32_t err;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        err = mIn.errorCheck();        </div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;     </div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        </div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></div><div class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// 还有这里</span></div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">finish:</div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        mLastError = err;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个2个函数，一个 getAndExecuteCommand 是当 Bn 的服务循环阻塞等待请求的时候调用的；一个 waitForResponse 是 Bp 发请求给 Bn，等待服务返回的时候调用的。正好对应上面说的2种情况，一个是服务中当别服务的 Bp，一个是普通应用的 Bp。</p>
<p>然后我们继续看 executeCommand：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">       </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">case</span> BR_DEAD_BINDER:</div><div class="line">        {</div><div class="line">            <span class="comment">// 这里转化成 Bp 指针了，前面注意就是 Bp 指针</span></div><div class="line">            BpBinder *proxy = (BpBinder*)mIn.readInt32();</div><div class="line">            <span class="comment">// 然后调用 Bp 的发送仆告的函数</span></div><div class="line">            proxy-&gt;sendObituary();</div><div class="line">            <span class="comment">// 然后对 kernel 发 BC_DEAD_BINDER_DONE 通知放送完成的命令</span></div><div class="line">            mOut.writeInt32(BC_DEAD_BINDER_DONE);</div><div class="line">            <span class="comment">// 把 Bp 的 handle 写进入刚刚的命名包里</span></div><div class="line">            mOut.writeInt32((int32_t)proxy);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 Bp 注册把自己的指针传到注册里面去，这里又取出，调用自己的函数。所以前面说注册只能在 Bp 里面注册，要是在 Bn 里注册，这里怎么调用 Bp 的函数。我们去看下 Bp 的 sendObituary 函数（名字真形象，发送仆告）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BpBinder::sendObituary()</div><div class="line">{</div><div class="line">    ALOGV(<span class="string">"Sending obituary for proxy %p handle %d, mObitsSent=%s\n"</span>,</div><div class="line">        <span class="keyword">this</span>, mHandle, mObitsSent ? <span class="string">"true"</span> : <span class="string">"false"</span>);</div><div class="line"></div><div class="line">    mAlive = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果通知已经发送，就返回</span></div><div class="line">    <span class="keyword">if</span> (mObitsSent) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    mLock.lock();</div><div class="line">    <span class="comment">// 取前面注册保存的回调</span></div><div class="line">    Vector&lt;Obituary&gt;* obits = mObituaries;</div><div class="line">    <span class="keyword">if</span>(obits != NULL) {</div><div class="line">        ALOGV(<span class="string">"Clearing sent death notification: %p handle %d\n"</span>, <span class="keyword">this</span>, mHandle);</div><div class="line">        <span class="comment">// 这里发通知前先把已经注册了通知清理掉</span></div><div class="line">        IPCThreadState* self = IPCThreadState::self(); </div><div class="line">        self-&gt;clearDeathNotification(mHandle, <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// 马上对 kernel 发清理命令</span></div><div class="line">        self-&gt;flushCommands();</div><div class="line">        mObituaries = NULL;</div><div class="line">    }</div><div class="line">    <span class="comment">// 设置当前通知已经发送</span></div><div class="line">    mObitsSent = <span class="number">1</span>;</div><div class="line">    mLock.unlock();</div><div class="line"></div><div class="line">    ALOGV(<span class="string">"Reporting death of proxy %p for %d recipients\n"</span>,</div><div class="line">        <span class="keyword">this</span>, obits ? obits-&gt;size() : <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (obits != NULL) {</div><div class="line">        <span class="keyword">const</span> size_t N = obits-&gt;size();</div><div class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">            <span class="comment">// 发送通知   </span></div><div class="line">            reportOneDeath(obits-&gt;itemAt(i));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">delete</span> obits;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子，这个死亡通知会如果被触发过一次就会被自动清理掉。想想看，确实，发送过一次，说明那个服务已经挂了，当然不会死二次。那我们先去看看这个回调怎么清理掉的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::clearDeathNotification(int32_t handle, BpBinder* proxy)</div><div class="line">{</div><div class="line">    mOut.writeInt32(BC_CLEAR_DEATH_NOTIFICATION);</div><div class="line">    mOut.writeInt32((int32_t)handle);</div><div class="line">    mOut.writeInt32((int32_t)proxy);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>简单明了的处理。对 kernel 发了一个 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 命令，然后后面一个 flushCommands，马上调用 ioctl 能马上发送到 kernel。这个处理在 <code>binder_thread_write</code> 里面，还记得前面发注册命令 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 时候那个分支也有 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 的么，现在可以来看一下了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面取用户空间写的 Bp 的 handle，然后可以取得到 ref </span></div><div class="line"><span class="comment">// 然后那个 cookie 就是用户空间传过来那个指针</span></div><div class="line"><span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) {</div><div class="line">    <span class="comment">// 这里是上面处理注册回调的</span></div><div class="line">    ... ...</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    <span class="comment">// 这里是清理回调的</span></div><div class="line">    <span class="comment">// 如果 ref 的 death 没有，要是没注册，要么是已经清理过了</span></div><div class="line">    <span class="keyword">if</span> (ref-&gt;death == NULL) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">            <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></div><div class="line">            <span class="string">"CATION death notificat"</span></div><div class="line">            <span class="string">"ion not active\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    death = ref-&gt;death;</div><div class="line">    <span class="comment">// 这里拿传过来那个指针做下验证</span></div><div class="line">    <span class="keyword">if</span> (death-&gt;cookie != cookie) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">            <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></div><div class="line">            <span class="string">"CATION death notificat"</span></div><div class="line">            <span class="string">"ion cookie mismatch "</span></div><div class="line">            <span class="string">"%p != %p\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid,</div><div class="line">            death-&gt;cookie, cookie);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 把 ref 的回调设置为空</span></div><div class="line">    ref-&gt;death = NULL;</div><div class="line">    <span class="comment">// 这里一般这个死亡通知回调的 work 列队是空的</span></div><div class="line">    <span class="comment">// 前面触发了通知后，把这个队列移到 proc-&gt;delivered_death 去了 </span></div><div class="line">    <span class="keyword">if</span> (list_empty(&death-&gt;work.entry)) {</div><div class="line">        <span class="comment">// work 状态又变了</span></div><div class="line">        death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</div><div class="line">        <span class="comment">// 这里是改变那个 work 状态，然后根据这个线程的情况加到</span></div><div class="line">        <span class="comment">// 对应的 todo list，唤醒 binder_thread_read</span></div><div class="line">        <span class="keyword">if</span> (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &thread-&gt;todo);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &proc-&gt;todo);</div><div class="line">            wake_up_interruptible(&proc-&gt;wait);</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);</div><div class="line">        death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_thead_write</code> 里面的清理只是把 ref 的回调设置成 NULL 了。然后要靠下一次 <code>binder_thread_read</code> 继续清理。注意这里是要等到下一次 ioctl 才能有 <code>binder_thread_read</code> 的，因为前面用 flushCommads 调用 talkWithDeriver 是不带返回值的，所以这次不会调用 <code>binder_thread_read</code> 的。那个我们先提前来看下吧（<code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> 前面也有看到，都是走一个分支的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:  </div><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line"><span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">    uint32_t cmd;</div><div class="line"></div><div class="line">    death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">        <span class="comment">// 这次返回给用户空间的是这个命令咯</span></div><div class="line">        cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        cmd = BR_DEAD_BINDER;</div><div class="line">    <span class="comment">// 继续原封不动的把这些东西传给用户空间          </span></div><div class="line">    <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">    <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);         </div><div class="line">    binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">             <span class="string">"binder: %d:%d %s %p\n"</span>,       </div><div class="line">              proc-&gt;pid, thread-&gt;pid,        </div><div class="line">              cmd == BR_DEAD_BINDER ?        </div><div class="line">              <span class="string">"BR_DEAD_BINDER"</span> :             </div><div class="line">              <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>,</div><div class="line">              death-&gt;cookie);                </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {</div><div class="line">        <span class="comment">// 删除死亡通知的 work 队列</span></div><div class="line">        list_del(&w-&gt;entry);       </div><div class="line">        <span class="comment">// 这里把注册的时候 kalloc 申请的 binder_death 给释放掉了    </span></div><div class="line">        kfree(death); </div><div class="line">        binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">    } <span class="keyword">else</span></div><div class="line">        list_move(&w-&gt;entry, &proc-&gt;delivered_death);</div><div class="line">    <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)     </div><div class="line">        <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">} <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这样之前注册时候申请的资源就差不多释放完了。不过还要继续去用户空间看看 <code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> 的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">   </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 我就说我恨这些啥引用计数</span></div><div class="line">    <span class="keyword">case</span> BR_CLEAR_DEATH_NOTIFICATION_DONE:</div><div class="line">        {</div><div class="line">            BpBinder *proxy = (BpBinder*)mIn.readInt32();</div><div class="line">            proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">            </div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>死亡通知回调就差不多清理完了。然后我们可以继续来看死亡通知的发送了（搞了半天还没触发回调咧）。我们回到 sendObituary 的后面那部分，循环取 mObituaries 的每一元素，然后调用 reportOneDeath： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BpBinder::reportOneDeath(<span class="keyword">const</span> Obituary& obit)</div><div class="line">{</div><div class="line">    <span class="comment">// 之前注册，new Obituary 的时候有传 Bp 的 this 指针过去，</span></div><div class="line">    <span class="comment">// 又要搞啥弱引用转强引用</span></div><div class="line">    sp&lt;DeathRecipient&gt; recipient = obit.recipient.promote();</div><div class="line">    ALOGV(<span class="string">"Reporting death to recipient: %p\n"</span>, recipient.get());</div><div class="line">    <span class="keyword">if</span> (recipient == NULL) <span class="keyword">return</span>; </div><div class="line"></div><div class="line">    <span class="comment">// 终于调用死亡通知的回调函数了，参数就是 Bp 自己的指针</span></div><div class="line">    recipient-&gt;binderDied(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>到这里就算把死亡通知通知到位了。调用了 Bp 注册的回调，然后就是不同的业务不同的处理了。</p>
<p>通知发送完了，但是上面 IPCThreadState 的 <code>BR_DEAD_BINDER</code> 最后还有一个处理：对 kernel 发了一条 <code>BC_DEAD_BINDER_DONE</code> 命令，我们来看看最后的处理吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BC_DEAD_BINDER_DONE: {    </div><div class="line">    <span class="keyword">struct</span> binder_work *w;         </div><div class="line">    <span class="keyword">void</span> __user *cookie;           </div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death = NULL;</div><div class="line">    <span class="comment">// 这个是注册的时候写的用户空间那个指针</span></div><div class="line">    <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line"></div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);    </div><div class="line">    <span class="comment">// 前面在触发通知的时候，death 的work移动到了delivered_death了</span></div><div class="line">    <span class="comment">// 这里在 delivered_death 中通过那个指针找到对应的 death      </span></div><div class="line">    list_for_each_entry(w, &proc-&gt;delivered_death, entry) {</div><div class="line">        <span class="keyword">struct</span> binder_ref_death *tmp_death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">        <span class="keyword">if</span> (tmp_death-&gt;cookie == cookie) {</div><div class="line">            death = tmp_death;             </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    binder_debug(BINDER_DEBUG_DEAD_BINDER,</div><div class="line">             <span class="string">"binder: %d:%d BC_DEAD_BINDER_DONE %p found %p\n"</span>,</div><div class="line">             proc-&gt;pid, thread-&gt;pid, cookie, death);</div><div class="line">    <span class="keyword">if</span> (death == NULL) {           </div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d BC_DEAD"</span></div><div class="line">            <span class="string">"_BINDER_DONE %p not found\n"</span>, </div><div class="line">            proc-&gt;pid, thread-&gt;pid, cookie);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 删除 death 中 work 队列</span></div><div class="line">    list_del_init(&death-&gt;work.entry);</div><div class="line">    <span class="comment">// 最后把 work 的 type 设置一下，最后还要发送到 read 去处理下，</span></div><div class="line">    <span class="comment">// 看样子最后还要清理一下，申请的 death 结构还没释放咧</span></div><div class="line">    <span class="keyword">if</span> (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {</div><div class="line">        death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</div><div class="line">        <span class="keyword">if</span> (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &thread-&gt;todo);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &proc-&gt;todo);</div><div class="line">            wake_up_interruptible(&proc-&gt;wait);</div><div class="line">        }</div><div class="line">    }</div><div class="line">} <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接着去看 <code>binder_thread_read</code> 里面看看 <code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> 的处理（前面好像有看到过）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:  </div><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line"><span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">    uint32_t cmd;     </div><div class="line"></div><div class="line">    death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">    <span class="comment">// 完成还要返回给用户空间一个 DONE 消息</span></div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">        cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        cmd = BR_DEAD_BINDER;          </div><div class="line">    <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">    <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);         </div><div class="line">    binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">             <span class="string">"binder: %d:%d %s %p\n"</span>,       </div><div class="line">              proc-&gt;pid, thread-&gt;pid,        </div><div class="line">              cmd == BR_DEAD_BINDER ?        </div><div class="line">              <span class="string">"BR_DEAD_BINDER"</span> :             </div><div class="line">              <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>,</div><div class="line">              death-&gt;cookie);                </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {</div><div class="line">        <span class="comment">// 果然把 death 释放掉，然后把 work 也删掉了</span></div><div class="line">        list_del(&w-&gt;entry);           </div><div class="line">        kfree(death); </div><div class="line">        binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">    } <span class="keyword">else</span></div><div class="line">        list_move(&w-&gt;entry, &proc-&gt;delivered_death);</div><div class="line">    <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)     </div><div class="line">        <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">} <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后接着回去 IPCThreadState 再去看看 <code>BR_CLEAR_DEATH_NOTIFICATION_DONE</code> 的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BR_CLEAR_DEATH_NOTIFICATION_DONE:</div><div class="line">    {</div><div class="line">        <span class="comment">// 之前手动增加的引用计数，还是手动减少</span></div><div class="line">        BpBinder *proxy = (BpBinder*)mIn.readInt32();</div><div class="line">        proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</div><div class="line">    } <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>到这里处理终于完了。上一张图吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-death/1.png" alt=""></p>
<p>但是这里还有一个疑问。根据前面的分析，最后能触发调用注册的死亡通知回调，最开始是因为 Bn 的 binder 驱动关闭函数（<code>binder_release</code>）里面设置的延迟工作队列触发的。我们很清楚 ProcessState 的构造函数里有明确的 open 过 binder 驱动，但是好像没哪里 close 过。是的，没错，我 grep 了代码好久，确实没哪里 close 过。</p>
<p>于是我就猜测是不是在程序结束后会自动关闭打开过的设备驱动。我询问我们那弄 kernel 的同事，他说应该不会的。然后我做了个小试验，我弄了 native 的服务，跑在命令行下面。不管我是 ctrl + C 发信号量退出，还是写个 client 发个命令让它正常退出，还是直接 kill -9 强制终止，<code>binder_release</code> 都会调用（我有在 kernel 的 binder 驱动里面加打印）。我刚开始怀疑是不是注册了一些信号量函数，然后在收到一个些信号量里面做写什么处理。但是又去翻了好久，没找到相关的代码。</p>
<p>后来没办法，我就专门写了个小程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    <span class="comment">// 打开 binder 设备驱动</span></div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="comment">// 不手动关闭</span></div><div class="line">    <span class="comment">//close(fd);</span></div><div class="line">    <span class="comment">// 然后直接退出</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>通过 dmesg 的 kernel 打印，发现这个程序退出后，<code>binder_release</code> 依然调用了。后面去度娘查了下，好像 kernel 从哪个版本开始加入了文件设备的计数引用支持。难道又是啥引用计数自动检测到这个打开的文件描述符没人用了，然后就自动关闭啦。后面又拿这个现象去问了下搞 kernel 的同事，他说有可能在文件系统级别有支持。不过这个就比较复杂了。</p>
<p>哎，没办法了，这里我们只能简单的理解为：<strong>当打开了 binder 设备的程序，停止运行后（不管是正常退出，还是异常结束）会自动关闭打开过的 binder 设备</strong>。然后由 <code>binder_release</code> 设置的延迟工作队列就会触发上面一系列的处理，最终调用到注册的死亡通知回调函数。</p>
<h2 id="java_层接口">java 层接口</h2>
<p>前面从 native 层接口，说到 kernel 怎么触发死亡通知。现在我们来看下 java 层的接口是怎么样的。其实从原理篇就应该能看得出，java 层只不过套着 jni 调用 native 层 binder 的接口而已。这里先看看 java 层 binder 的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBinder</span> </span>{</div><div class="line">    </div><div class="line">    ... ....</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Interface for receiving a callback when the process hosting an IBinder</span></div><div class="line"><span class="comment">     * has gone away.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @see #linkToDeath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeathRecipient</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Register the recipient for a notification if this binder</span></div><div class="line"><span class="comment">     * goes away.  If this binder object unexpectedly goes away</span></div><div class="line"><span class="comment">     * (typically because its hosting process has been killed),</span></div><div class="line"><span class="comment">     * then the given {@link DeathRecipient}'s</span></div><div class="line"><span class="comment">     * {@link DeathRecipient#binderDied DeathRecipient.binderDied()} method</span></div><div class="line"><span class="comment">     * will be called.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * &lt;p&gt;You will only receive death notifications for remote binders,</span></div><div class="line"><span class="comment">     * as local binders by definition can't die without you dying as well.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @throws RemoteException if the target IBinder's</span></div><div class="line"><span class="comment">     * process has already died.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @see #unlinkToDeath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Remove a previously registered death notification.</span></div><div class="line"><span class="comment">     * The recipient will no longer be called if this object</span></div><div class="line"><span class="comment">     * dies.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @return {@code true} if the &lt;var&gt;recipient&lt;/var&gt; is successfully</span></div><div class="line"><span class="comment">     * unlinked, assuring you that its</span></div><div class="line"><span class="comment">     * {@link DeathRecipient#binderDied DeathRecipient.binderDied()} method</span></div><div class="line"><span class="comment">     * will not be called;  {@code false} if the target IBinder has already</span></div><div class="line"><span class="comment">     * died, meaning the method has been (or soon will be) called.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @throws java.util.NoSuchElementException if the given</span></div><div class="line"><span class="comment">     * &lt;var&gt;recipient&lt;/var&gt; has not been registered with the IBinder, and</span></div><div class="line"><span class="comment">     * the IBinder is still alive.  Note that if the &lt;var&gt;recipient&lt;/var&gt;</span></div><div class="line"><span class="comment">     * was never registered, but the IBinder has already died, then this</span></div><div class="line"><span class="comment">     * exception will &lt;em&gt;not&lt;/em&gt; be thrown, and you will receive a false</span></div><div class="line"><span class="comment">     * return value instead.</span></div><div class="line"><span class="comment">     */</span> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>总体来看和 native 的几乎是一样的。那个 DeathRecipient 的 interface 就是少了自己的对象的参数而已（这个参数 native 层的不要也没关系，反正是自己）。然后我们再来看看 java 层 binder 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Binder.java ====================================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>{</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 和 native 层的一样，Bn 不允许注册的（这里是空函数而已）</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Local implementation is a no-op.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags) {</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Local implementation is a no-op.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">final</span> class BinderProxy implements IBinder {</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// Bp 的直接去调 jni 的去了</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">linkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>java 的 Bn 的接口实现是空函数（和 native 一样，不予以实现），Bp 直接去调 jni，我们去看下 jni：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_BinderProxy_linkToDeath(JNIEnv* env, jobject obj,</div><div class="line">        jobject recipient, jint flags) <span class="comment">// throws RemoteException</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (recipient == NULL) {</div><div class="line">        jniThrowNullPointerException(env, NULL);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 前面原理篇说的这个 mObject 就是 native 层的 binder 对象指针</span></div><div class="line">    IBinder* target = (IBinder*)</div><div class="line">        env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</div><div class="line">    <span class="keyword">if</span> (target == NULL) {</div><div class="line">        ALOGW(<span class="string">"Binder has been finalized when calling linkToDeath() with recip=%p)\n"</span>, recipient);</div><div class="line">        assert(<span class="keyword">false</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    LOGDEATH(<span class="string">"linkToDeath: binder=%p recipient=%p\n"</span>, target, recipient);</div><div class="line"></div><div class="line">    <span class="comment">// 这里再判断下要是 Bp 才行</span></div><div class="line">    <span class="keyword">if</span> (!target-&gt;localBinder()) {</div><div class="line">        <span class="comment">// 这里估计是要保持和 native 层一样，搞一个列表出来</span></div><div class="line">        DeathRecipientList* <span class="built_in">list</span> = (DeathRecipientList*)</div><div class="line">                env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div><div class="line">        <span class="comment">// 然后 new 一个 jni 层对象，应该是封装了 java 层的死亡通知回调</span></div><div class="line">        sp&lt;JavaDeathRecipient&gt; jdr = <span class="keyword">new</span> JavaDeathRecipient(env, recipient, <span class="built_in">list</span>);</div><div class="line">        <span class="comment">// 果然还是调用 native 层 binder 的注册接口</span></div><div class="line">        status_t err = target-&gt;linkToDeath(jdr, NULL, flags);</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">            <span class="comment">// Failure adding the death recipient, so clear its reference</span></div><div class="line">            <span class="comment">// now.</span></div><div class="line">            jdr-&gt;clearReference(); </div><div class="line">            signalExceptionForError(env, obj, err, <span class="keyword">true</span> <span class="comment">/*canThrowRemoteException*/</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个列表我们不去管他，主要看下 JavaDeathRecipient 这个对象（那个 gBinderProxyOffsets 保存了 java 层 BinderProxy 的一些类信息的，完了的回去看下原理篇的 java 层那里）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp ===============================</span></div><div class="line"></div><div class="line"><span class="comment">// 看继承关系就知道这个是实现了 native 层 binder 的那个死亡通知回调</span></div><div class="line"><span class="keyword">class</span> JavaDeathRecipient : <span class="keyword">public</span> IBinder::DeathRecipient </div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    JavaDeathRecipient(JNIEnv* env, jobject object, <span class="keyword">const</span> sp&lt;DeathRecipientList&gt;& <span class="built_in">list</span>)</div><div class="line">        : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object)),</div><div class="line">          mObjectWeak(NULL), mList(<span class="built_in">list</span>) </div><div class="line">    {</div><div class="line">        <span class="comment">// 把死亡通知回调对象保存到那个 list 中</span></div><div class="line">        <span class="comment">// These objects manage their own lifetimes so are responsible for final bookkeeping.</span></div><div class="line">        <span class="comment">// The list holds a strong reference to this object.</span></div><div class="line">        LOGDEATH(<span class="string">"Adding JDR %p to DRL %p"</span>, <span class="keyword">this</span>, <span class="built_in">list</span>.get());</div><div class="line">        <span class="built_in">list</span>-&gt;add(<span class="keyword">this</span>);      </div><div class="line"></div><div class="line">        android_atomic_inc(&gNumDeathRefs);</div><div class="line">        incRefsCreated(env);  </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">void</span> binderDied(<span class="keyword">const</span> wp&lt;IBinder&gt;& who)</div><div class="line">    {</div><div class="line">        LOGDEATH(<span class="string">"Receiving binderDied() on JavaDeathRecipient %p\n"</span>, <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (mObject != NULL) {</div><div class="line">            JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line"></div><div class="line">            <span class="comment">// 然后在这个函数里面调 java 层的回调</span></div><div class="line">            env-&gt;CallStaticVoidMethod(gBinderProxyOffsets.mClass,</div><div class="line">                    gBinderProxyOffsets.mSendDeathNotice, mObject);</div><div class="line">            jthrowable excep = env-&gt;ExceptionOccurred();</div><div class="line">            <span class="keyword">if</span> (excep) {</div><div class="line">                report_exception(env, excep,   </div><div class="line">                        <span class="string">"*** Uncaught exception returned from death notification!"</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Demote from strong ref to weak after binderDied() has been delivered,</span></div><div class="line">            <span class="comment">// to allow the DeathRecipient and BinderProxy to be GC'd if no longer needed.</span></div><div class="line">            mObjectWeak = env-&gt;NewWeakGlobalRef(mObject);</div><div class="line">            env-&gt;DeleteGlobalRef(mObject); </div><div class="line">            mObject = NULL;   </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~JavaDeathRecipient()</div><div class="line">    {</div><div class="line">        <span class="comment">//ALOGI("Removing death ref: recipient=%p\n", mObject);</span></div><div class="line">        android_atomic_dec(&gNumDeathRefs);</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line">        <span class="keyword">if</span> (mObject != NULL) {</div><div class="line">            env-&gt;DeleteGlobalRef(mObject);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            env-&gt;DeleteWeakGlobalRef(mObjectWeak);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    JavaVM* <span class="keyword">const</span> mVM;</div><div class="line">    jobject mObject;</div><div class="line">    jweak mObjectWeak; <span class="comment">// will be a weak ref to the same VM-side DeathRecipient after binderDied()</span></div><div class="line">    wp&lt;DeathRecipientList&gt; mList;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>咋再去复习下 gBinderProxyOffsets 获取的那几个 java 类的函数方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> int_register_android_os_BinderProxy(JNIEnv* env)</div><div class="line">{</div><div class="line">    jclass clazz;</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Error"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class java.lang.Error"</span>);</div><div class="line">    gErrorOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(kBinderProxyPathName);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class android.os.BinderProxy"</span>);</div><div class="line"></div><div class="line">    gBinderProxyOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gBinderProxyOffsets.mConstructor</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mConstructor);</div><div class="line">    <span class="comment">// 上面那个实现 native 层 binder 的死亡通知回调，</span></div><div class="line">    <span class="comment">// 最后是调用 java 层的 BinderProxy 的 sendDeathNotice 函数的</span></div><div class="line">    gBinderProxyOffsets.mSendDeathNotice</div><div class="line">        = env-&gt;GetStaticMethodID(clazz, <span class="string">"sendDeathNotice"</span>, <span class="string">"(Landroid/os/IBinder$DeathRecipient;)V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mSendDeathNotice);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(</div><div class="line">        env, kBinderProxyPathName,     </div><div class="line">        gBinderProxyMethods, NELEM(gBinderProxyMethods));</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们去看下 BinderProxy 的 sendDeathNotice：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Binder.java ===============================</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendDeathNotice</span>(DeathRecipient recipient) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"JavaBinder"</span>, <span class="string">"sendDeathNotice to "</span> + recipient);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            recipient.binderDied();</div><div class="line">        }</div><div class="line">        <span class="keyword">catch</span> (RuntimeException exc) { </div><div class="line">            Log.w(<span class="string">"BinderNative"</span>, <span class="string">"Uncaught exception from death notification"</span>,</div><div class="line">                    exc);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以说 java 层其实还是要靠 native 框架运作才行，然后 jni 里面把 native 对象和 java 对象倒腾一下，相互调用一下。</p>
<p>然后 java 层要使用的话，直接调用 java 层 IBinder 的 linkToDeath 接口注册自己的监听对象就行了。不过回想一下前面普通对象传递篇中，ServiceConnection 接口中有一个函数是：</p>
<pre config="brush:bash;toolbar:false;">
public void onServiceDisconnected(ComponentName name);
</pre>

<p>没错，这个就是绑定了普通服务的 Bp 端的死亡通知函数。通过这个函数，我们可以指定我们绑定的远程服务已经挂了。不过我们并没调用 linkToDeath 接口啊。这个一猜就知道是系统帮我们调用了。</p>
<p>我们回想下普通对象传递篇。bindService 后，如果服务启动了，就会调用 LoadedApk 里面的一个内部类的 ServiceDispatcher 的 doConnected 函数，进程调用 ServiceConnection 接口的 onServiceConnected 通知我们普通已经连接上了。现在我们再来看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoadedApk.cpp ===============================</span></div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span>(ComponentName name, IBinder service) {</div><div class="line">            ServiceDispatcher.ConnectionInfo old; </div><div class="line">            ServiceDispatcher.ConnectionInfo info;</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">                <span class="keyword">if</span> (mForgotten) {</div><div class="line">                    <span class="comment">// We unbound before receiving the connection; ignore</span></div><div class="line">                    <span class="comment">// any connection received.</span></div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }    </div><div class="line">                old = mActiveConnections.get(name);</div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span> && old.binder == service) {</div><div class="line">                    <span class="comment">// Huh, already have this one.  Oh well!</span></div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }    </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">// A new service is being connected... set it all up.</span></div><div class="line">                    mDied = <span class="keyword">false</span>;</div><div class="line">                    info = <span class="keyword">new</span> ConnectionInfo();</div><div class="line">                    info.binder = service;</div><div class="line">                    info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        <span class="comment">// 果然帮我们调用了</span></div><div class="line">                        service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</div><div class="line">                        mActiveConnections.put(name, info);</div><div class="line">                    } <span class="keyword">catch</span> (RemoteException e) { </div><div class="line">                        <span class="comment">// This service was dead before we got it...  just</span></div><div class="line">                        <span class="comment">// don't do anything with it.</span></div><div class="line">                        mActiveConnections.remove(name);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    }    </div><div class="line"></div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// The named service is being disconnected... clean up.</span></div><div class="line">                    mActiveConnections.remove(name);</div><div class="line">                }    </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span>) {</div><div class="line">                    old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</div><div class="line">                }    </div><div class="line">            }   </div><div class="line"></div><div class="line">            <span class="comment">// If there was an old service, it is not disconnected.</span></div><div class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) {</div><div class="line">                mConnection.onServiceDisconnected(name);</div><div class="line">            }</div><div class="line">            <span class="comment">// If there is a new service, it is now connected.</span></div><div class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                mConnection.onServiceConnected(name, service);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>系统的处理是，当服务一连接上，在触发的 onServiceConnected 的函数里面，帮我们调用了 linkToDeath，自动注册死亡通知函数。不过好像还绕了几下，我继续跟进去看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoadedApk.cpp ===============================</span></div><div class="line"></div><div class="line">        <span class="comment">// 这是 LoadedApk 里面 ServiceDispatcher 的一个内部类 -_-||</span></div><div class="line">        <span class="comment">// 实现了 java 的 IBinder.DeathRecipient</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathMonitor</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span></span></div><div class="line"><span class="class">        </span>{</div><div class="line">            DeathMonitor(ComponentName name, IBinder service) {</div><div class="line">                mName = name;</div><div class="line">                mService = service;            </div><div class="line">            }                 </div><div class="line"></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>() {     </div><div class="line">                death(mName, mService);        </div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">final</span> ComponentName mName;     </div><div class="line">            <span class="keyword">final</span> IBinder mService;        </div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个 death 是 ServiceDispatcher 的一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span>(ComponentName name, IBinder service) {</div><div class="line">    ServiceDispatcher.ConnectionInfo old;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {          </div><div class="line">        mDied = <span class="keyword">true</span>;</div><div class="line">        old = mActiveConnections.remove(name);</div><div class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span> || old.binder != service) {</div><div class="line">            <span class="comment">// Death for someone different than who we last</span></div><div class="line">            <span class="comment">// reported...  just ignore it.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 把老的回调清理掉</span></div><div class="line">        old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 要搞那么复杂么，如果有可能的话尽量在 Handler 中处理回调函数</span></div><div class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) { </div><div class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">1</span>));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        doDeath(name, service);        </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后如果有跑 activity 线程的 Handler 就发到 Handler 里面去处理，如果没有的话，就直接调用 doDeath：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeath</span>(ComponentName name, IBinder service) {</div><div class="line">    <span class="comment">// 终于调用这个接口了</span></div><div class="line">    mConnection.onServiceDisconnected(name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunConnection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</div><div class="line">    RunConnection(ComponentName name, IBinder service, <span class="keyword">int</span> command) {</div><div class="line">        mName = name;</div><div class="line">        mService = service;            </div><div class="line">        mCommand = command;            </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {            </div><div class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) {           </div><div class="line">            doConnected(mName, mService);  </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) {    </div><div class="line">            <span class="comment">// 上面 death 的 post 是 1，</span></div><div class="line">            <span class="comment">// 所以和上面直接执行 doDeath 差不多</span></div><div class="line">            doDeath(mName, mService);      </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ComponentName mName;     </div><div class="line">    <span class="keyword">final</span> IBinder mService;        </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCommand;            </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以对普通应用来说，android 给你层层封装好了，什么时候服务准备好了，告诉你可以使用 IPC 进行通信了，什么时候服务挂了，你要么重新启动服务，要么做别的处理。</p>
<h2 id="特殊的_SM">特殊的 SM</h2>
<p>最后，再说一个特殊的列子。还记得前面系统传递 binder 对象篇中说 SM 是很特殊的一个和程序么。它用到了 binder，但是却没有使用 binder 库的那一套框架，而已自己直接写通信程序（为此它把 kernel 里面的一堆数据结构扣了出来）。对了，这里又是 SM 玩非主流。它注册的死亡通知回调和普通又不太一样。</p>
<p>SM 怎么个不一样法，让我们先来看看它注册的是什么东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// service_manager.c ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> do_add_service(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   uint16_t *s, <span class="keyword">unsigned</span> len,</div><div class="line">                   <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid, <span class="keyword">int</span> allow_isolated)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    <span class="comment">//ALOGI("add_service('%s',%p,%s) uid=%d\n", str8(s), ptr,</span></div><div class="line">    <span class="comment">//        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!svc_can_register(uid, s)) {</div><div class="line">        ALOGE(<span class="string">"add_service('%s',%p) uid=%d - PERMISSION DENIED\n"</span>,</div><div class="line">             str8(s), ptr, uid);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    si = find_svc(s, len);</div><div class="line">    <span class="keyword">if</span> (si) {</div><div class="line">        <span class="keyword">if</span> (si-&gt;ptr) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</div><div class="line">                 str8(s), ptr, uid);</div><div class="line">            svcinfo_death(bs, si);</div><div class="line">        }   </div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        <span class="keyword">if</span> (!si) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - OUT OF MEMORY\n"</span>,</div><div class="line">                 str8(s), ptr, uid);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">        }   </div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">        si-&gt;len = len;</div><div class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</div><div class="line">        <span class="comment">// 保存回调函数指针</span></div><div class="line">        si-&gt;death.func = svcinfo_death;</div><div class="line">        <span class="comment">// 保存 svcinfo 对象自己</span></div><div class="line">        si-&gt;death.ptr = si; </div><div class="line">        si-&gt;allow_isolated = allow_isolated;</div><div class="line">        si-&gt;next = svclist;</div><div class="line">        svclist = si; </div><div class="line">    }</div><div class="line"></div><div class="line">    binder_acquire(bs, ptr);</div><div class="line">    <span class="comment">// 这个是向 kernel 注册死亡通知回调的函数</span></div><div class="line">    binder_link_to_death(bs, ptr, &si-&gt;death);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>原来每当一个 SS 向 SM 注册的时候，SM 都会为这个 SS 注册一个死亡通知回调。我们来看看这个 <code>binder_link_to_death</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> binder_link_to_death(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *ptr, <span class="keyword">struct</span> binder_death *death)</div><div class="line">{</div><div class="line">    uint32_t cmd[<span class="number">3</span>];</div><div class="line">    <span class="comment">// 和 IPCThreadState 的 requestDeathNotification 发的是一样的命令</span></div><div class="line">    cmd[<span class="number">0</span>] = BC_REQUEST_DEATH_NOTIFICATION;</div><div class="line">    <span class="comment">// 第一个参数也是一样， SM 这个 ptr 就是 Bp 的 handle 值</span></div><div class="line">    cmd[<span class="number">1</span>] = (uint32_t) ptr;</div><div class="line">    <span class="comment">// 但是注意第二参数，是一个 binder_death 的结构的指针</span></div><div class="line">    cmd[<span class="number">2</span>] = (uint32_t) death;</div><div class="line">    binder_write(bs, cmd, <span class="keyword">sizeof</span>(cmd));</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得前面说 kernel 那个保存用户空间传过来的那个地址的时候，为什么要原封不动的保存，然后再原封不动的传回去了不。因为这个指针有2套东西，普通的 IPCThreadState 发下去的是 Bp 对象的指针，而 SM 发下去的是自己的一个 <code>binder_death</code> 结构体的指针。标准不一样，你让人家底下驱动也没办法处理，所以只要原封不动的，发回注册的人自己处理。</p>
<p>我们来看这个 <code>binder_death</code> 里面有什么东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// binder.h ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_death {</div><div class="line">    <span class="comment">// 一个是一个函数指针</span></div><div class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *ptr);</div><div class="line">    <span class="comment">// 一个是一个数据指针</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们前面 SM 处理 SS 那里，这个函数指针被指向了一个叫 <code>svcinfo_death</code> 的函数，然后 ptr 是把 svcinfo 这个 SM 保存 SS 信息的数据结构保存了起来。我们看下 <code>svcinfo_death</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> svcinfo_death(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *ptr)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si = ptr;</div><div class="line">    <span class="comment">// 打印一条信息</span></div><div class="line">    ALOGI(<span class="string">"service '%s' died\n"</span>, str8(si-&gt;name));</div><div class="line">    <span class="keyword">if</span> (si-&gt;ptr) {</div><div class="line">        <span class="comment">// 然后释放注册 SS 申请的资源</span></div><div class="line">        binder_release(bs, si-&gt;ptr);</div><div class="line">        si-&gt;ptr = <span class="number">0</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数没什么特别要说的，就是打印一条信息，然后释放下资源。前面说了 SM 是自己写 binder 通信的，我们来看看它收到 kernel 发送过来的死亡消息的时候怎么处理的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_parse(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</div><div class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</div><div class="line">    uint32_t *end = ptr + (size / <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end) {</div><div class="line">        uint32_t cmd = *ptr++;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> TRACE</span></div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"%s:\n"</span>, cmd_name(cmd));</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">        <span class="keyword">switch</span>(cmd) {</div><div class="line"></div><div class="line">        ... ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: {</div><div class="line">            <span class="comment">// 果然 kernel 原封不动的发回来，</span></div><div class="line">            <span class="comment">// 然后这边就可以转化成 binder_death 使用了</span></div><div class="line">            <span class="keyword">struct</span> binder_death *death = (<span class="keyword">void</span>*) *ptr++;</div><div class="line">            <span class="comment">// 搞了半天也就相当于只传递了这个指针而已</span></div><div class="line">            death-&gt;func(bs, death-&gt;ptr);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        ... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ALOGE(<span class="string">"parse: OOPS %d\n"</span>, cmd);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }   </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到这个处理，我感觉 <code>binder_death</code> 这个结构完全没必要定义，那个函数是固定的，所以真正传递是那个 svcinfo 的指针，所以发 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 这个命令的第二参数直接写 svcinfo 的指针就行了。然后死亡通知函数固定调 svcinfo_death 就行。难不成以后还有不同的 SS 死亡通知函数不同不成。</p>
<h2 id="总结">总结</h2>
<p>android binder 这套框架还是包括了很多东西的，android 也帮我们处理了很多东西。要提供一套高效、易用、可靠的跨进程通信机制还是要处理不少东西。怪不得我以前的头头说 MiniGUI 的多进程版就是一个 demo 而已，离真正使用还很远。现在我才能体会到。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%87%92%E4%BA%BA%E7%9A%84%E5%B7%A5%E5%85%B7%5BAIDL%5D/</loc>
    <lastmod>2015-03-31T06:28:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Binder 分析——懒人的工具（AIDL）</title>
        <pubTime>2015-01-28T13:53:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>前面说了 binder 的原理，和 parcel，当时也说了实现 IBinder 接口（Bp 端、Bn 端）代码都非常的机械，人工写的话，不仅浪费时间，而且很有可能会出错（复制、粘贴后忘记改某个地方）。所以 android 弄了代码自动生成的东西。然后还美名其曰 XX 语言—— AIDL（Android Interface Definition Language）。这里不研究这个东西的实现代码，只是说说有这么个东西可以用，然后就是其实你不用也可以。</p>
<p>照例先把相关源码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># AM 接口实现相关代码</span></div><div class="line">frameworks/base/core/android/app/ActivityManager.java</div><div class="line">frameworks/base/core/android/app/ActivityManagerNative.java</div><div class="line">frameworks/base/core/android/app/IActivityManager.java</div><div class="line"></div><div class="line"><span class="comment"># AMS 代码</span></div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line"></div><div class="line"><span class="comment"># WM 接口实现相关代码</span></div><div class="line">frameworks/base/core/android/view/WindowManager.java</div><div class="line">frameworks/base/core/android/view/IWindowManager.aidl</div><div class="line"></div><div class="line"><span class="comment"># WM 接口自动生成的代码</span></div><div class="line">out/target/common/obj/JAVA_LIBRARIES/framework-base_intermediates/src/com/android/view/IWindowManager.java</div><div class="line"></div><div class="line"><span class="comment"># WMS 代码</span></div><div class="line">services/java/com/android/server/wm/WindowManagerService.java</div><div class="line"></div><div class="line"><span class="comment"># Context 相关代码</span></div><div class="line">frameworks/base/core/java/android/app/ContextImpl.java</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="java_层">java 层</h2>
<p>其实 aidl 这个东西只能在 java 成使用，native 层是用另外一个类似的东西。但是前面也好说了，这个东西就是一个代码自动生成器，你自己手动写，不用也是可以的。我们就来看下 SystemServer（SS）中的典型吧。</p>
<h3 id="纯手工打造">纯手工打造</h3>
<p>SS 中手动写 binder 接口代码的典型是 ActivityManagerService（AMS）。binder 接口需要实现什么东西，前面原理篇讲得很清楚了，忘记了的回去看下。</p>
<p>ActivityManager 是 sdk 提供给上层 app 使用的接口。ActivityManagerNative （AMN）接口这边的实现（接口端也是要写代码的，调用 binder 接口向服务端发送请求）。IActiviyManager 就是 AMS 继承 binder 定义的接口。最后服务端实现不止 ActivityManagerService.java 这一个文件，有一个专门的 am 包咧，这里不是分析 AMS ，所以列个代表。</p>
<p>ActivitManager.java 不说啥了，就是 sdk 公开的那些接口，它里面的接口实现全都是通过 ActivityManagerNative.getDefault() 转向 AMN 了。所以 interface 端的主要实现在 AMN 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActivityManager.java ===============================</span></div><div class="line"></div><div class="line">    <span class="comment">// 挂马甲，真正的实现在 AMN 里面</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveTaskToFront</span>(<span class="keyword">int</span> taskId, <span class="keyword">int</span> flags, Bundle options) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ActivityManagerNative.getDefault().moveTaskToFront(taskId, flags, options);</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) { </div><div class="line">            <span class="comment">// System dead, we will be dead too soon!</span></div><div class="line">        }    </div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ActivityManagerNative.java ===========================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Retrieve the system's default/global activity manager.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span>() {</div><div class="line">        <span class="keyword">return</span> gDefault.get();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 单例的实现方式，节省内存，速度也更快</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() {</div><div class="line">        <span class="keyword">protected</span> IActivityManager <span class="title">create</span>() {</div><div class="line">            <span class="comment">// 向 SM 取 AM 的 binder 对象</span></div><div class="line">            <span class="comment">// AM向SM注册的名字就是 "activity"，不过不用 static 变量不好吧</span></div><div class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</div><div class="line">            }    </div><div class="line">            IActivityManager am = asInterface(b);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am); </div><div class="line">            }    </div><div class="line">            <span class="keyword">return</span> am;</div><div class="line">        }    </div><div class="line">    };</div><div class="line"></div></pre></td></tr></table></figure>

<p>ActivityManagerNative 采用单列设计模式，保证一个进程中只有一份 Bp。这个做应该是提高效率，因为 app 里面先不说应用自己，framework 里面经常随手 Context.getSystemService(“activity”)，如果每次都创建新实例，很浪费内存的，而且慢。</p>
<p>来看下 ActivityManagerNative 的继承关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span> </span>{}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>{}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActivityManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>{}</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMN 继承自 Binder （实现 IBinder 接口，所有的远程接口都是这个），实现 IActivityManager， IActivityManager 继承自 IInterface 这个东西就是 binder 提供给客户端的接口，使用者通过继承这个类定义自己的接口。</p>
<p>来看下 AMS 定义的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActivityManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>{</div><div class="line"></div><div class="line">    <span class="comment">// 定义的接口</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span>(IApplicationThread caller,</div><div class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho,</div><div class="line">            <span class="keyword">int</span> requestCode, <span class="keyword">int</span> flags, String profileFile,</div><div class="line">            ParcelFileDescriptor profileFd, Bundle options) <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span>(IApplicationThread caller,</div><div class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho,</div><div class="line">            <span class="keyword">int</span> requestCode, <span class="keyword">int</span> flags, String profileFile,</div><div class="line">            ParcelFileDescriptor profileFd, Bundle options, <span class="keyword">int</span> userId) <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> WaitResult <span class="title">startActivityAndWait</span>(IApplicationThread caller,</div><div class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho,</div><div class="line">            <span class="keyword">int</span> requestCode, <span class="keyword">int</span> flags, String profileFile,</div><div class="line">            ParcelFileDescriptor profileFd, Bundle options, <span class="keyword">int</span> userId) <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivityWithConfig</span>(IApplicationThread caller,</div><div class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho,</div><div class="line">            <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, Configuration newConfig,</div><div class="line">            Bundle options, <span class="keyword">int</span> userId) <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivityIntentSender</span>(IApplicationThread caller,</div><div class="line">            IntentSender intent, Intent fillInIntent, String resolvedType,</div><div class="line">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</div><div class="line">            <span class="keyword">int</span> flagsMask, <span class="keyword">int</span> flagsValues, Bundle options) <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNextMatchingActivity</span>(IBinder callingActivity,</div><div class="line">            Intent intent, Bundle options) <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">... ....</div><div class="line"></div><div class="line">    String descriptor = <span class="string">"android.app.IActivityManager"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 这个其实和上面的接口对应，一般一个接口对应一个 transaction code 。</span></div><div class="line">    <span class="comment">// 在 interface 的实现 onTransact 中就能看到这些东西的用处了。 </span></div><div class="line">    <span class="comment">// Please keep these transaction codes the same -- they are also</span></div><div class="line">    <span class="comment">// sent by C++ code.</span></div><div class="line">    <span class="keyword">int</span> START_RUNNING_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</div><div class="line">    <span class="keyword">int</span> HANDLE_APPLICATION_CRASH_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> START_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> UNHANDLED_BACK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> OPEN_CONTENT_URI_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Remaining non-native transaction codes.</span></div><div class="line">    <span class="keyword">int</span> FINISH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">10</span>;</div><div class="line">    <span class="keyword">int</span> REGISTER_RECEIVER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">11</span>;</div><div class="line">    <span class="keyword">int</span> UNREGISTER_RECEIVER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">12</span>;</div><div class="line">    <span class="keyword">int</span> BROADCAST_INTENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">13</span>;</div><div class="line">    <span class="keyword">int</span> UNBROADCAST_INTENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">14</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMN 实现上面的接口定义，里面还又个 ActivityManagerProxy（AMP），Proxy，Binder Proxy 啊，Bp 端的实现。android 喜欢把 Bp 端和 Bn 端的接口放在一起实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span></div><div class="line"><span class="class"></span>{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Cast a Binder object into an activity manager interface, generating</span></div><div class="line"><span class="comment">     * a proxy if needed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span>(IBinder obj) {</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        IActivityManager in =</div><div class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</div><div class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> in;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 返回的是内部类 Proxy，这才能叫 Bp 么 </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj); </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这部分代码是 service 实现，上面 IActivityManager 定义那一堆</span></div><div class="line">    <span class="comment">// transcation code 就是用在这里了， switch case 用的 -_-||</span></div><div class="line">    <span class="comment">// 注意这里的代码是运行在 service 端的，所以里面的调用的函数是 service</span></div><div class="line">    <span class="comment">// 里面真正实现命令的函数（看后面的分析）。</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException {</div><div class="line">        <span class="keyword">switch</span> (code) {</div><div class="line">        <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</div><div class="line">        {</div><div class="line">            <span class="comment">// 读的顺序要和下面写的一样，parcel 篇有说到的</span></div><div class="line">            data.enforceInterface(IActivityManager.descriptor);</div><div class="line">            IBinder b = data.readStrongBinder();</div><div class="line">            IApplicationThread app = ApplicationThreadNative.asInterface(b);</div><div class="line">            Intent intent = Intent.CREATOR.createFromParcel(data);</div><div class="line">            String resolvedType = data.readString();</div><div class="line">            IBinder resultTo = data.readStrongBinder();</div><div class="line">            String resultWho = data.readString();</div><div class="line">            <span class="keyword">int</span> requestCode = data.readInt();</div><div class="line">            <span class="keyword">int</span> startFlags = data.readInt();</div><div class="line">            String profileFile = data.readString();</div><div class="line">            ParcelFileDescriptor profileFd = data.readInt() != <span class="number">0</span></div><div class="line">                    ? data.readFileDescriptor() : <span class="keyword">null</span>;</div><div class="line">            Bundle options = data.readInt() != <span class="number">0</span></div><div class="line">                    ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">int</span> result = startActivity(app, intent, resolvedType,</div><div class="line">                    resultTo, resultWho, requestCode, startFlags,</div><div class="line">                    profileFile, profileFd, options);</div><div class="line">            reply.writeNoException();</div><div class="line">            reply.writeInt(result);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">... ....</div><div class="line">        }   </div><div class="line">                    </div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">class ActivityManagerProxy implements IActivityManager</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// 这部分的代码是 interface 的现实，通过 binder 向 service 发送请求</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span>(IApplicationThread caller, Intent intent,</div><div class="line">            String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</div><div class="line">            <span class="keyword">int</span> startFlags, String profileFile,</div><div class="line">            ParcelFileDescriptor profileFd, Bundle options) <span class="keyword">throws</span> RemoteException {</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</div><div class="line">        intent.writeToParcel(data, <span class="number">0</span>);</div><div class="line">        data.writeString(resolvedType);</div><div class="line">        data.writeStrongBinder(resultTo);</div><div class="line">        data.writeString(resultWho);</div><div class="line">        data.writeInt(requestCode);</div><div class="line">        data.writeInt(startFlags);</div><div class="line">        data.writeString(profileFile);</div><div class="line">        <span class="keyword">if</span> (profileFd != <span class="keyword">null</span>) {</div><div class="line">            data.writeInt(<span class="number">1</span>);</div><div class="line">            profileFd.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            data.writeInt(<span class="number">0</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) {</div><div class="line">            data.writeInt(<span class="number">1</span>);</div><div class="line">            options.writeToParcel(data, <span class="number">0</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            data.writeInt(<span class="number">0</span>);</div><div class="line">        }</div><div class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        <span class="keyword">int</span> result = reply.readInt();</div><div class="line">        reply.recycle();</div><div class="line">        data.recycle();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后来看看 Bn 端这边的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里直接就继承 AMN 了，后面对比下 WMS 就发现继承的不一样</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>{</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException { </div><div class="line">        <span class="comment">// 针对特殊请求要做下处理</span></div><div class="line">        <span class="keyword">if</span> (code == SYSPROPS_TRANSACTION) {</div><div class="line">            <span class="comment">// We need to tell all apps about the system property change.</span></div><div class="line">            ArrayList&lt;IBinder&gt; procs = <span class="keyword">new</span> ArrayList&lt;IBinder&gt;();</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">                <span class="keyword">for</span> (SparseArray&lt;ProcessRecord&gt; apps : mProcessNames.getMap().values()) {</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> NA = apps.size();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> ia=<span class="number">0</span>; ia&lt;NA; ia++) {</div><div class="line">                        ProcessRecord app = apps.valueAt(ia);</div><div class="line">                        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) {</div><div class="line">                            procs.add(app.thread.asBinder());</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">    </div><div class="line">            <span class="keyword">int</span> N = procs.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                Parcel data2 = Parcel.obtain();</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    procs.get(i).transact(IBinder.SYSPROPS_TRANSACTION, data2, <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">                } <span class="keyword">catch</span> (RemoteException e) { </div><div class="line">                }</div><div class="line">                data2.recycle();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 其余的直接调用父类的处理，就是上面 AMN 里的实现</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">        } <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">            <span class="comment">// The activity manager only throws security exceptions, so let's</span></div><div class="line">            <span class="comment">// log all others.</span></div><div class="line">            <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> SecurityException)) {</div><div class="line">                Slog.e(TAG, <span class="string">"Activity Manager Crash"</span>, e);</div><div class="line">            }</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面只是列举了 AM 中的一个接口的实现，剩下那一堆一个一个手动写吧。很麻烦是不是，所以就可以使用代码自动生成工具了（aidl）：</p>
<h3 id="代码自动生成">代码自动生成</h3>
<p>看了上面的 binder 接口的实现方法，感觉对很麻烦。仔细观察上面的 AMS 的代码，会发现其实有不少东西可以由机器来完成的。aidl 就是干这个事情的，下面来看看 SS （其实 SS 中大部分 Servier 是用 aidl 来写接口的）中使用 aidl 的典型： WindowManagerServices （WMS）。</p>
<p>WindowManager.java 这个 sdk 对上层应用提供的接口。然后这里有个 IWindowManager.aidl 的文件。虽然说是代码自动生成，但是开发者还是要写点东西的，人家好歹叫一个语言咧，不写点代码怎么行（傻瓜相机还要按快门咧）。只要在这个 aidl 文件中把要公开的接口按照一定的格式写就行了，那个格式感觉和 java 代码基本一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * System private interface to the window manager.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * {@hide}</span></div><div class="line"><span class="comment"> */</span></div><div class="line">interface IWindowManager</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * ===== NOTICE =====</span></div><div class="line"><span class="comment">     * The first three methods must remain the first three methods. Scripts</span></div><div class="line"><span class="comment">     * and tools rely on their transaction number to work properly.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">// This is used for debugging</span></div><div class="line">    <span class="keyword">boolean</span> startViewServer(<span class="keyword">int</span> port);   <span class="comment">// Transaction #1</span></div><div class="line">    <span class="keyword">boolean</span> stopViewServer();            <span class="comment">// Transaction #2</span></div><div class="line">    <span class="keyword">boolean</span> isViewServerRunning();       <span class="comment">// Transaction #3</span></div><div class="line"></div><div class="line">    IWindowSession openSession(in IInputMethodClient client,</div><div class="line">            in IInputContext inputContext);</div><div class="line">    <span class="keyword">boolean</span> inputMethodClientHasFocus(IInputMethodClient client);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> setForcedDisplaySize(<span class="keyword">int</span> displayId, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</div><div class="line">    <span class="keyword">void</span> clearForcedDisplaySize(<span class="keyword">int</span> displayId);</div><div class="line">    <span class="keyword">void</span> setForcedDisplayDensity(<span class="keyword">int</span> displayId, <span class="keyword">int</span> density);</div><div class="line">    <span class="keyword">void</span> clearForcedDisplayDensity(<span class="keyword">int</span> displayId);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> setOverscan(<span class="keyword">int</span> displayId, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom);</div><div class="line"></div><div class="line">    <span class="comment">// These can only be called when holding the MANAGE_APP_TOKENS permission.</span></div><div class="line">    <span class="keyword">void</span> pauseKeyDispatching(IBinder token);</div><div class="line">    <span class="keyword">void</span> resumeKeyDispatching(IBinder token);</div><div class="line">    <span class="keyword">void</span> setEventDispatching(<span class="keyword">boolean</span> enabled);</div><div class="line">    <span class="keyword">void</span> addWindowToken(IBinder token, <span class="keyword">int</span> type);</div><div class="line">    <span class="keyword">void</span> removeWindowToken(IBinder token);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>和上面 AM 的代码对比下，这简直太简单了。然后 Bn 端（WindowManagerService.java）实现真正的业务就可以了（AM 除了要实现 binder 接口，这一步也是不能少的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意继承的类 IWindowManager.Stub</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerService</span> <span class="keyword">extends</span> <span class="title">IWindowManager</span>.<span class="title">Stub</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">WindowManagerPolicy</span>.<span class="title">WindowManagerFuncs</span>,</span></div><div class="line"><span class="class">                <span class="title">DisplayManagerService</span>.<span class="title">WindowManagerFuncs</span>, <span class="title">DisplayManager</span>.<span class="title">DisplayListener</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 实现接口业务</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Starts the view server on the specified port.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param port The port to listener to.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @return True if the server was successfully started, false otherwise.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @see com.android.server.wm.ViewServer</span></div><div class="line"><span class="comment">     * @see com.android.server.wm.ViewServer#VIEW_SERVER_DEFAULT_PORT</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startViewServer</span>(<span class="keyword">int</span> port) {</div><div class="line">        <span class="keyword">if</span> (isSystemSecure()) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!checkCallingPermission(Manifest.permission.DUMP, <span class="string">"startViewServer"</span>)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (port &lt; <span class="number">1024</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mViewServer != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (!mViewServer.isRunning()) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="keyword">return</span> mViewServer.start();</div><div class="line">                } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"View server did not start"</span>);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            mViewServer = <span class="keyword">new</span> ViewServer(<span class="keyword">this</span>, port);</div><div class="line">            <span class="keyword">return</span> mViewServer.start();</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            Slog.w(TAG, <span class="string">"View server did not start"</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">... ... </div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWindowToken</span>(IBinder token) {</div><div class="line">        <span class="keyword">if</span> (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,</div><div class="line">                <span class="string">"removeWindowToken()"</span>)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Requires MANAGE_APP_TOKENS permission"</span>);</div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>自动生成的 java 代码在 framework 的源码是找不到的，是编译的时候 aidl 工具动态生成的（这里不分析这个工具），在 <code>out/target/common/obj/JAVA_LIBRARIES/framework-base_intermediates/src</code> 下面，和放 aidl 文件位置对应（WM 的是在 src/core/java/android/view/IWindowManager.java）。然后 IWindowManager.Stub 就在这个文件里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">IWindowManager</span></span></div><div class="line"><span class="class"></span>{</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"android.view.IWindowManager"</span>;</div><div class="line"><span class="javadoc">/** Construct the stub at attach it to the interface. */</span></div><div class="line"><span class="keyword">public</span> <span class="title">Stub</span>()</div><div class="line">{</div><div class="line"><span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Cast an IBinder object into an android.view.IWindowManager interface,</span></div><div class="line"><span class="comment"> * generating a proxy if needed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.view.IWindowManager <span class="title">asInterface</span>(android.os.IBinder obj) </div><div class="line">{</div><div class="line"><span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) {</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">}</div><div class="line">android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line"><span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&&(iin <span class="keyword">instanceof</span> android.view.IWindowManager))) {</div><div class="line"><span class="keyword">return</span> ((android.view.IWindowManager)iin);</div><div class="line">}</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> android.view.IWindowManager.Stub.Proxy(obj);</div><div class="line">}</div><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title">asBinder</span>()</div><div class="line">{</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags) <span class="keyword">throws</span> android.os.RemoteException</div><div class="line">{</div><div class="line"><span class="keyword">switch</span> (code)</div><div class="line">{</div><div class="line"><span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">{</div><div class="line">reply.writeString(DESCRIPTOR);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">case</span> TRANSACTION_startViewServer:</div><div class="line">{</div><div class="line"><span class="comment">// 机器生成的代码顺序肯定不会出错</span></div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line"><span class="keyword">int</span> _arg0;</div><div class="line">_arg0 = data.readInt();</div><div class="line"><span class="keyword">boolean</span> _result = <span class="keyword">this</span>.startViewServer(_arg0);</div><div class="line">reply.writeNoException();</div><div class="line">reply.writeInt(((_result)?(<span class="number">1</span>):(<span class="number">0</span>)));</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line">... ... </div><div class="line"></div><div class="line"><span class="keyword">case</span> TRANSACTION_removeWindowToken:</div><div class="line">{</div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line">android.os.IBinder _arg0;</div><div class="line"><span class="comment">// 会根据不同的参数类型调用 parcel 对应的打包函数</span></div><div class="line">_arg0 = data.readStrongBinder();</div><div class="line"><span class="keyword">this</span>.removeWindowToken(_arg0);</div><div class="line">reply.writeNoException();</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">IWindowManager</span></span></div><div class="line"><span class="class"></span>{</div><div class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</div><div class="line">Proxy(android.os.IBinder remote)</div><div class="line">{</div><div class="line">mRemote = remote;</div><div class="line">}</div><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title">asBinder</span>()</div><div class="line">{</div><div class="line"><span class="keyword">return</span> mRemote;</div><div class="line">}</div><div class="line"><span class="keyword">public</span> java.lang.String <span class="title">getInterfaceDescriptor</span>()</div><div class="line">{</div><div class="line"><span class="keyword">return</span> DESCRIPTOR;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">     * ===== NOTICE =====</span></div><div class="line"><span class="comment">     * The first three methods must remain the first three methods. Scripts</span></div><div class="line"><span class="comment">     * and tools rely on their transaction number to work properly.</span></div><div class="line"><span class="comment">     */</span><span class="comment">// This is used for debugging</span></div><div class="line"></div><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startViewServer</span>(<span class="keyword">int</span> port) <span class="keyword">throws</span> android.os.RemoteException</div><div class="line">{</div><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line"><span class="keyword">boolean</span> _result;</div><div class="line"><span class="keyword">try</span> {</div><div class="line">_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">_data.writeInt(port);</div><div class="line">mRemote.transact(Stub.TRANSACTION_startViewServer, _data, _reply, <span class="number">0</span>);</div><div class="line">_reply.readException();</div><div class="line">_result = (<span class="number">0</span>!=_reply.readInt());</div><div class="line">}</div><div class="line"><span class="keyword">finally</span> {</div><div class="line">_reply.recycle();</div><div class="line">_data.recycle();</div><div class="line">}</div><div class="line"><span class="keyword">return</span> _result;</div><div class="line">}</div><div class="line"><span class="comment">// Transaction #1</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWindowToken</span>(android.os.IBinder token, <span class="keyword">int</span> type) <span class="keyword">throws</span> android.os.RemoteException</div><div class="line">{</div><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line"><span class="keyword">try</span> {</div><div class="line">_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">_data.writeStrongBinder(token);</div><div class="line">_data.writeInt(type);</div><div class="line">mRemote.transact(Stub.TRANSACTION_addWindowToken, _data, _reply, <span class="number">0</span>);</div><div class="line">_reply.readException();</div><div class="line">}</div><div class="line"><span class="keyword">finally</span> {</div><div class="line">_reply.recycle();</div><div class="line">_data.recycle();</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 自动计数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_startViewServer = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_stopViewServer = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_isViewServerRunning = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">2</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_openSession = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">3</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_inputMethodClientHasFocus = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">4</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_setForcedDisplaySize = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">5</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_clearForcedDisplaySize = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">6</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_setForcedDisplayDensity = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">7</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_clearForcedDisplayDensity = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">8</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个东西除了机器生成的排版比较抱歉以外，其它和上面的 AMS 的 AMN 基本上是一个模子印出来的。aidl 自动生成的代码能够根据参数的类型自动调用 parcel 对应的数据打包函数。基本类型都支持，IBinder 类型的也有特殊的函数。如果是自定义类型的话，需要自己实现 Parcelable 接口。</p>
<p>aidl 的参数定义有2个比较有意思的关键字 in 和 out。如果参数前面加了 in 则表示这是个输入型参数，aidl 生成的代码会先通过 Parcelable 接口读取 Bp 端传过来的对象数据，然后调用对应类型的 Parcelable 接口的 CREATOR.createFromParcel 重新示例化对象，达到跨进程传递自定义类型数据的目的。</p>
<p>如果是 out 则表示这个是输出型参数，aidl 生成的代码会调用该类的默认构造参数创建一个对象，然后传递给 Bn 端的真正函数， Bn 端的这个函数的实现，要负责填充对应的数据，然后调用完成后， aidl 的代码会调用 Parcelable 的接口，写入 binder，返回给 Bp 端调用者。来看下 WMS 里面的例子就比较好理解了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">interface IWindowManager</div><div class="line">{</div><div class="line"></div><div class="line">... ...</div><div class="line">   </div><div class="line">    <span class="comment">// 第一个 Bitmap 是 in 类型的</span></div><div class="line">    <span class="keyword">void</span> overridePendingAppTransitionThumb(in Bitmap srcThumb, <span class="keyword">int</span> startX, <span class="keyword">int</span> startY,</div><div class="line">            IRemoteCallback startedCallback, <span class="keyword">boolean</span> scaleUp);</div><div class="line"></div><div class="line">    <span class="comment">// 第二 List 数组是 out 类型的</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Gets the infos for all visible windows.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">void</span> getVisibleWindowsForDisplay(<span class="keyword">int</span> displayId, out List&lt;WindowInfo&gt; outInfos);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWindowManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span></div><div class="line"><span class="class"></span>{</div><div class="line"><span class="javadoc">/** Local-side IPC implementation stub class. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">IWindowManager</span></span></div><div class="line"><span class="class"></span>{</div><div class="line"></div><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags) <span class="keyword">throws</span> android.os.RemoteException</div><div class="line">{</div><div class="line"><span class="keyword">switch</span> (code)</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">case</span> TRANSACTION_overridePendingAppTransitionThumb:</div><div class="line">{</div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line">android.graphics.Bitmap _arg0;</div><div class="line"><span class="comment">// 通过 Parcel 先读取 Bp 端传过来的参数</span></div><div class="line"><span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) {</div><div class="line"><span class="comment">// 然后再根据对象的 Parcel 接口，用刚刚的数据重新实例化对象，达到跨进程传递 Object 的目的</span></div><div class="line">_arg0 = android.graphics.Bitmap.CREATOR.createFromParcel(data);</div><div class="line">}</div><div class="line"><span class="keyword">else</span> {</div><div class="line">_arg0 = <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> _arg1;</div><div class="line">_arg1 = data.readInt();</div><div class="line"><span class="keyword">int</span> _arg2;</div><div class="line">_arg2 = data.readInt();</div><div class="line">android.os.IRemoteCallback _arg3;</div><div class="line">_arg3 = android.os.IRemoteCallback.Stub.asInterface(data.readStrongBinder());</div><div class="line"><span class="keyword">boolean</span> _arg4;</div><div class="line">_arg4 = (<span class="number">0</span>!=data.readInt());</div><div class="line"><span class="keyword">this</span>.overridePendingAppTransitionThumb(_arg0, _arg1, _arg2, _arg3, _arg4);</div><div class="line">reply.writeNoException();</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">case</span> TRANSACTION_getVisibleWindowsForDisplay:</div><div class="line">{</div><div class="line">data.enforceInterface(DESCRIPTOR);</div><div class="line"><span class="keyword">int</span> _arg0;</div><div class="line">_arg0 = data.readInt();</div><div class="line"><span class="comment">// 创建新对象以便 Bn 端实现函数能填充数据</span></div><div class="line">java.util.List&lt;android.view.WindowInfo&gt; _arg1;</div><div class="line">_arg1 = <span class="keyword">new</span> java.util.ArrayList&lt;android.view.WindowInfo&gt;();</div><div class="line"><span class="keyword">this</span>.getVisibleWindowsForDisplay(_arg0, _arg1);</div><div class="line">reply.writeNoException();</div><div class="line"><span class="comment">// 通过 Parcel 接口，把填充好的输入返回给 Bp 端</span></div><div class="line">reply.writeTypedList(_arg1);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">}</div><div class="line"></div><div class="line">.... ....</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面那些东西用机械化的代码自动生成比手写第一快、第二不会出错。SS 中大部分是用 aidl 来实现接口的，除了少数的几个（有可能就是手工写那个几个太麻烦了，才诞生了 aidl 吧）。上层第三应用的服务应该也是可用手工写的，但是估计比 framework 还要麻烦，因为好像有一些接口是 hide 的。</p>
<hr>
<p>这里说个小插曲，在 core/java/com/android/internal/statusbar/IStatusBar.aidl 中有 <strong>oneway</strong> 这一个声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @hide */</span></div><div class="line">oneway interface IStatusBar</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> setIcon(<span class="keyword">int</span> index, in StatusBarIcon icon);</div><div class="line">    <span class="keyword">void</span> removeIcon(<span class="keyword">int</span> index);</div><div class="line">    <span class="keyword">void</span> addNotification(IBinder key, in StatusBarNotification notification);</div><div class="line">    <span class="keyword">void</span> updateNotification(IBinder key, in StatusBarNotification notification);</div><div class="line">    <span class="keyword">void</span> removeNotification(IBinder key);</div><div class="line">    <span class="keyword">void</span> disable(<span class="keyword">int</span> state);</div><div class="line">    <span class="keyword">void</span> animateExpandNotificationsPanel();</div><div class="line">    <span class="keyword">void</span> animateExpandSettingsPanel();</div><div class="line">    <span class="keyword">void</span> animateCollapsePanels();</div><div class="line">    <span class="keyword">void</span> setSystemUiVisibility(<span class="keyword">int</span> vis, <span class="keyword">int</span> mask);</div><div class="line">    <span class="keyword">void</span> topAppWindowChanged(<span class="keyword">boolean</span> menuVisible);</div><div class="line">    <span class="keyword">void</span> setImeWindowStatus(in IBinder token, <span class="keyword">int</span> vis, <span class="keyword">int</span> backDisposition);</div><div class="line">    <span class="keyword">void</span> setHardKeyboardStatus(<span class="keyword">boolean</span> available, <span class="keyword">boolean</span> enabled);</div><div class="line">    <span class="keyword">void</span> toggleRecentApps();</div><div class="line">    <span class="keyword">void</span> preloadRecentApps();</div><div class="line">    <span class="keyword">void</span> cancelPreloadRecentApps();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得前面说 binder 传送过程中有一种 no reply 的情况么。如果声明了这个关键字，那么 aidl 什么的代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIcon</span>(<span class="keyword">int</span> index, com.android.internal.statusbar.StatusBarIcon icon) <span class="keyword">throws</span> android.os.RemoteException</div><div class="line">{</div><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line"><span class="keyword">try</span> {</div><div class="line">_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">_data.writeInt(index);</div><div class="line"><span class="keyword">if</span> ((icon!=<span class="keyword">null</span>)) {</div><div class="line">_data.writeInt(<span class="number">1</span>);</div><div class="line">icon.writeToParcel(_data, <span class="number">0</span>); </div><div class="line">}</div><div class="line"><span class="keyword">else</span> {</div><div class="line">_data.writeInt(<span class="number">0</span>);</div><div class="line">}</div><div class="line"><span class="comment">// 发现和上面没加 oneway 的区别了没， reply 传过去是 null </span></div><div class="line">mRemote.transact(Stub.TRANSACTION_setIcon, _data, <span class="keyword">null</span>, android.os.IBinder.FLAG_ONEWAY);</div><div class="line">}</div><div class="line"><span class="keyword">finally</span> {</div><div class="line">_data.recycle();</div><div class="line">}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>如果你的 binder 接口不需要返回值，oneway 声明会快一点，<strong>当然如果你的 binder 接口需要返回值，记得把这个声明去掉，否则会编译报错的（生成的代码 reply 这个变量会没初始化就当返回值用了）</strong>。目前 framework 中我就看到 IStatusBar 加这个声明。</p>
<hr>
<p>这里 aidl 自动生成代码还忽略了一点。上面手工写的，不是搞了个单例模式么，但是 aidl 生成没用这种模式，是不是自动生成的代码，效率就低了些呢。这里从我们经常用的 Context 接口 getSystemService 说起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ContextImpl.java ==============================</span></div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> Object <span class="title">getSystemService</span>(String name) {</div><div class="line">        ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</div><div class="line">        <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>



<p>我们先来看下 ServiceFetcher 是什么东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// The system service cache for the system services that are</span></div><div class="line"><span class="comment">// cached per-ContextImpl.  Package-scoped to avoid accessor</span></div><div class="line"><span class="comment">// methods.</span></div><div class="line"><span class="keyword">final</span> ArrayList&lt;Object&gt; mServiceCache = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Override this class when the system service constructor needs a</span></div><div class="line"><span class="comment"> * ContextImpl.  Else, use StaticServiceFetcher below.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> class ServiceFetcher {</div><div class="line">    <span class="keyword">int</span> mContextCacheIndex = -<span class="number">1</span>;   </div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Main entrypoint; only override if you don't need caching.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> Object <span class="title">getService</span>(ContextImpl ctx) {</div><div class="line">        <span class="comment">// 原来是缓存啊</span></div><div class="line">        ArrayList&lt;Object&gt; cache = ctx.mServiceCache;</div><div class="line">        Object service;</div><div class="line">        <span class="keyword">synchronized</span> (cache) {</div><div class="line">            <span class="comment">// 刚开始拿 null 的来占位         </span></div><div class="line">            <span class="keyword">if</span> (cache.size() == <span class="number">0</span>) {       </div><div class="line">                <span class="comment">// Initialize the cache vector on first access.</span></div><div class="line">                <span class="comment">// At this point sNextPerContextServiceCacheIndex</span></div><div class="line">                <span class="comment">// is the number of potential services that are</span></div><div class="line">                <span class="comment">// cached per-Context.         </span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sNextPerContextServiceCacheIndex; i++) {</div><div class="line">                    cache.add(<span class="keyword">null</span>);               </div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 在缓存中取 SS 的 Bp</span></div><div class="line">                service = cache.get(mContextCacheIndex);</div><div class="line">                <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                    <span class="keyword">return</span> service;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">// 取不到的话，new 一个出来，然后保存在缓存中</span></div><div class="line">            service = createService(ctx);</div><div class="line">            cache.set(mContextCacheIndex, service);</div><div class="line">            <span class="keyword">return</span> service;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Override this to create a new per-Context instance of the</span></div><div class="line"><span class="comment">     * service.  getService() will handle locking and caching.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> Object <span class="title">createService</span>(ContextImpl ctx) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not implemented"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到上就差不多能明白了，aidl 的 get Bp 的优化是在 Context 中做的。然后继续看那个 <code>SYSTEM_SERVICE_MAP</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// static 变量来的，一个进程一个</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP =</div><div class="line">            <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&gt;();</div><div class="line">        </div><div class="line">    <span class="comment">// 这个 registerService 就是往 SYSTEM_SERVICE_MAP 中加东西</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sNextPerContextServiceCacheIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span>(String serviceName, ServiceFetcher fetcher) {</div><div class="line">        <span class="keyword">if</span> (!(fetcher <span class="keyword">instanceof</span> StaticServiceFetcher)) {</div><div class="line">            fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++;</div><div class="line">        }   </div><div class="line">        SYSTEM_SERVICE_MAP.put(serviceName, fetcher);</div><div class="line">    }</div><div class="line">                    </div><div class="line">    <span class="comment">// This one's defined separately and given a variable name so it</span></div><div class="line">    <span class="comment">// can be re-used by getWallpaperManager(), avoiding a HashMap</span></div><div class="line">    <span class="comment">// lookup.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServiceFetcher WALLPAPER_FETCHER = <span class="keyword">new</span> ServiceFetcher() {</div><div class="line">            <span class="keyword">public</span> Object <span class="title">createService</span>(ContextImpl ctx) {</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WallpaperManager(ctx.getOuterContext(),</div><div class="line">                        ctx.mMainThread.getHandler());</div><div class="line">            }};    </div><div class="line"></div><div class="line">    <span class="comment">// static 代码块，类只要加载就会跑这段。</span></div><div class="line">    <span class="comment">// 这里就把那一堆 SS 都添加到 SYSTEM_SERVICE_MAP 的 map 中去了。</span></div><div class="line">    <span class="comment">// 下面还有一堆，我只贴一部分。</span></div><div class="line">    <span class="keyword">static</span> {</div><div class="line">        registerService(ACCESSIBILITY_SERVICE, <span class="keyword">new</span> ServiceFetcher() {</div><div class="line">                <span class="keyword">public</span> Object <span class="title">getService</span>(ContextImpl ctx) {</div><div class="line">                    <span class="keyword">return</span> AccessibilityManager.getInstance(ctx);</div><div class="line">                }});</div><div class="line">                </div><div class="line">        registerService(CAPTIONING_SERVICE, <span class="keyword">new</span> ServiceFetcher() {</div><div class="line">                <span class="keyword">public</span> Object <span class="title">getService</span>(ContextImpl ctx) {</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CaptioningManager(ctx);</div><div class="line">                }});</div><div class="line"></div><div class="line">        registerService(ACCOUNT_SERVICE, <span class="keyword">new</span> ServiceFetcher() {</div><div class="line">                <span class="keyword">public</span> Object <span class="title">createService</span>(ContextImpl ctx) {</div><div class="line">                    IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);</div><div class="line">                    IAccountManager service = IAccountManager.Stub.asInterface(b);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> AccountManager(ctx, service);</div><div class="line">                }});</div><div class="line"></div><div class="line">        registerService(ACTIVITY_SERVICE, <span class="keyword">new</span> ServiceFetcher() {</div><div class="line">                <span class="keyword">public</span> Object <span class="title">createService</span>(ContextImpl ctx) {</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</div><div class="line">                }});</div><div class="line">                </div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到这里就能放心在 Activity 中尽情的调用 getSystemService 了，因为不管你调用多少次，一个进程就只会有一个服务的 Bp 实例而已。</p>
<h2 id="native_层">native 层</h2>
<p>前面说了 aidl 是 java 层才有的东西。那么 native 是不是就要手动写那一堆麻烦的 binder 接口实现啦。基本上是，但是有点改善，因为 C++ 有宏和模板函数这2个东西。回去看下原理篇中说的 native 层 binder 库中 IInterface.h 中的那几个宏：</p>
<pre config="brush:bash;toolbar:false;">
DECLARE_META_INTERFACE
IMPLEMENT_META_INTERFACE
CHECK_INTERFACE
</pre>

<p>以及衍生出来的 BpInterface 和 BnInterface 这2个模板类。至少提供了一些模板，让子类省了点事。这几个东西回去看原理篇吧，这里不重复说了。</p>
<p>native 层的 SS 本身就不多，4.4 目前就下面几个吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-aidl/1.png" alt=""></p>
<p>然后，普通应用直接不开放 native 层服务的接口。所以估计 android 就拿宏和模板函数凑活下了。</p>
<h2 id="总结">总结</h2>
<p>aidl 这个东西还是不错的，原来要写一堆无聊重复的代码，现在只要列一个 aidl 的清单文件就行了。我又要啰嗦一句：android 干了很多事。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/03/06/%E4%B8%8B%E8%BD%BD%20Android%20%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-03-06T09:15:16.000Z</lastmod>
    <data>
        <display>
        <title>下载 Android 源码问题总结</title>
        <pubTime>2015-03-06T09:15:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<h2 id="多余临时文件">多余临时文件</h2>
<p>目前下载源码，最好找个稳定点的 VPN 和稳定点的网络环境下载。因为如果中途断掉的话，好像是没断点续传的。repo 会一个一个的下 git 仓库，但是如果某个仓库下载到一半断掉了，好像下次就得重新下这个仓库。所以这里又会导致另一个问题，如果你 repo sync 的时候经常中断，你会发先的你的源码文件夹最变得很大。那是因为目前的 android 源码的 repo 在下载 git 仓库的时候在创建一个 <code>tmp_pack_XXXX</code> 的 临时文件，然后在这个仓库下载完成后删除。但是由于前面说的仓库下载中断的话，会重头开始下，这个临时文件也会重新创建（2次的名字不一样， XXXX 那里不同），所以如果经常中断的话，这些临时文件会越来越多。可以在 repo sync 完成后，手动删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find . -iname tmp_pack_* | xargs rm</div><div class="line"></div></pre></td></tr></table></figure>

<p>顺带说下这些 tmp_pack 文件在每个仓库的 objects/pack/ 下面，例如： device/lge/hammerhead-kernel.git/objects/pack/，可以直接 repo 的根目录敲上面的命令。再顺带提一下，如果过了几个大版本的话，可以考虑重新下载 android 的 mirror，因为可能会有比较大的文件结构调整，但是在老版本的基础上 repo sync 不会把以前一些不用的文件删掉，也是导致 repo 仓库变得很大。</p>
<h2 id="mirror_缺少某一个仓库">mirror 缺少某一个仓库</h2>
<p>google 的人感觉有些时候也会犯一些错误。在使用最近新下载的 5.0 mirror 的时候报某几个仓库不存在。打开 mirror 的 .repo/manifests/default.xml 和指定 android 版本的（5.0.2-r1）的仓库的 .repo/manifests/default.xml 对比，发现 mirror 确实少了一些仓库。感觉应该是 google 的漏了几个仓库吧。不过还好我以前 4.4 的 mirror 还没删掉，去 4.4 的 mirror 的 .repo/manifests/default.xml 能找到缺少仓库以前的地址和分支，照着地址去 gogole 的源码服务器看一下，发现 git 仓库还在，那应该是漏写在 repo 的 xml 里面了。</p>
<p>那咋们还是有曲线救国的方法的：找出缺少的仓库后，然后去 4.4 的 mirror 的 .repo/manifests/default.xml 依葫芦画瓢的把地址和分支抄过来，然后再在 5.0 的仓库中 repo sync 一下就下载到缺少的仓库了。当然既然 4.4 的 mirror 还在，还可以利用下以前下载好的资源，可以去 4.4 的 mirror 把缺少的仓库整个 .git 文件夹 copy 到 5.0 的 mirror 对应的路径下。我发现 5.0 缺少的这几个仓库，好像和 4.4 是一样的，repo sync 并没多下载东西。下面附上我找到的 5.0.2-r1 缺少 git 仓库：</p>
<pre>
platform/bootable/bootloader/legacy.git
platform/external/arduino.git
platform/external/chromium_org/third_party/openssl.git
platform/external/gcc-demangle.git
platform/external/google-diff-match-patch.git
platform/external/openfst.git
platform/external/qemu.git
platform/external/qemu-pc-bios.git
platform/external/smack.git
platform/external/stressapptest.git
platform/external/yaffs2.git
platform/prebuilts/gcc/darwin-x86/mips/mipsel-linux-android-4.8.git
platform/prebuilts/gcc/darwin-x86/mips/mips64el-linux-android-4.8.git
platform/prebuilts/gcc/linux-x86/mips/mipsel-linux-android-4.8.git
platform/prebuilts/gcc/linux-x86/mips/mips64el-linux-android-4.8.git
platform/prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.6.git
platform/tools/tradefederation.git
</pre>

<p>既然我们可以手动修复 mirror 缺少 git 仓库的问题，这里又引申出解决另外一个问题的办法。就是前面说的 git 仓库下载中断，又要从头开始下，如果 VPN 或是网络不稳定，下载某些很大的 git 仓库会十分痛苦，但是某些 git 仓库其实你并不会用到。例如上面说的那个 lg 的 kernel 的 git 仓库，有 10G 左右，但是如果你的 nexus 设备并不是 lg 的话，根本不需要这个仓库。所以如果实在下不下来的话，可以在 mirror 的 .repo/manifests/default.xml 中删掉这个 git 仓库。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/03/04/Android%20SystemUI%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A0%8F%E5%9B%BE%E6%A0%87/</loc>
    <lastmod>2015-03-04T02:20:16.000Z</lastmod>
    <data>
        <display>
        <title>Android SystemUI 分析——状态栏图标</title>
        <pubTime>2015-03-04T02:20:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>通知篇说了一下有关 Notification 相关的东西，其中 Notification 有一个 UI 表现就是状态栏的图标，不过这篇说的是另外一种东西，虽然 UI 表现上和 Notification 的状态栏图标一样，但是使用上是不一样的。还是先照例把相关代码位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 应用接口相关代码</span></div><div class="line">frameworks/base/core/java/android/app/StatusBarManager.java</div><div class="line"></div><div class="line"><span class="comment"># 系统内部接口相关代码</span></div><div class="line">frameworks/base/core/java/com/android/internal/statusbar/IStatusBarService.aidl</div><div class="line">frameworks/base/core/java/com/android/internal/statusbar/IStatusBar.aidl</div><div class="line">frameworks/base/core/java/com/android/internal/statusbar/StatusBarIcon.java</div><div class="line"></div><div class="line"><span class="comment"># System Server 相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/StatusBarManagerService.java</div><div class="line"></div><div class="line"><span class="comment"># SystemUI 相关代码</span></div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="区分">区分</h2>
<p>我们先来看一张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/SystemUI-status-bar-icon/status-icon.png" alt=""></p>
<p>图中状态栏左边那一堆图标是通知篇说的 Notification 的小图标，右边那一堆就是这篇要说的系统状态图标。虽然这篇的名字是状态栏图标，但是因为通知篇说过 Notification 的了，所以这里只说系统的状态图标。通知的图标是每一个通知一个，然后如果通知太多的话，后面会显示一个 “+” 的图标代表有更多的通知图标，所以说左边通知的图标是不确定的，是由运行不同的程序来决定的。而系统状态图标是固定的，在 framework 中代码写死一共有多少种系统状态，然后系统运行不同功能的时候显示某个状态的图标，完成后，图标消失。例如说，设置（关闭）闹钟、开启（关闭）飞行模式、开启（关闭）静音。这里稍微注意下，只有图上右边框出来的部分（只是一小部分而已）才是系统状态，wifi、电量信息和时间不属于系统状态图标的。</p>
<h2 id="接口">接口</h2>
<p>我们先来看系统状态图标的接口，接口依旧在 StatusBarManager（SBM） 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @hide */</span></div><div class="line">interface IStatusBarService</div><div class="line">{</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">void</span> setIcon(String slot, String iconPackage, <span class="keyword">int</span> iconId, <span class="keyword">int</span> iconLevel, String contentDescription);</div><div class="line">    <span class="keyword">void</span> setIconVisibility(String slot, <span class="keyword">boolean</span> visible);</div><div class="line">    <span class="keyword">void</span> removeIcon(String slot);</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>对外接口很简单就3个：</p>
<ul>
<li><strong>setIcon</strong>: 设置一个状态图标，主要参数是图标</li>
<li><strong>setIconVisibility</strong>: 设置一个状态图标显示（隐藏）</li>
<li><strong>removeIcon</strong>: 移除一个状态图标</li>
</ul>
<p>值得一提的是，这些接口都是系统内部使用的，因为整个 SBM 都是 hide 的（aidl、java 都是）。应用只能通过一些别的方法间接的去改变系统状态图标，无法直接更改。例如要让系统状态显示设置了闹钟，就要发送 android.intent.action.ALARM_CHANGED 广播（SystemUI 中有接收这个广播的地方，然后调用上面的接口来改变系统状态图标显示）。</p>
<p>这个设计还是必须的，因为如果随便开放接口给第三方应用直接改系统状态显示，有些捣乱的应用就要乱来了。不过虽然是 hide 的，java 有反射可以干坏事，不过下面会说到，接口里面权限检测的，所以反射也干不了坏事。</p>
<h2 id="固定的数据">固定的数据</h2>
<p>看完上面接口，是不是觉得 setIcon 为什么不叫 addIcon，来看下系统的实现（设计）就明白了。我们直接去 StatusBarManagerService（SBMS）里去看，不看 Bp 端的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// slot 是标示</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIcon</span>(String slot, String iconPackage, <span class="keyword">int</span> iconId, <span class="keyword">int</span> iconLevel,</div><div class="line">        String contentDescription) {</div><div class="line">    <span class="comment">// 检测调用者的权限</span></div><div class="line">    enforceStatusBar();</div><div class="line"></div><div class="line">    <span class="comment">// 喜闻乐见的 binder 业务函数同步锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mIcons) {</div><div class="line">        <span class="comment">// 通过 slot 来查找 status bar icon 的数据索引</span></div><div class="line">        <span class="keyword">int</span> index = mIcons.getSlotIndex(slot);</div><div class="line">        <span class="comment">// 找不到的话，报异常</span></div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"invalid status bar icon slot: "</span> + slot);</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// new 数据对象</span></div><div class="line">        StatusBarIcon icon = <span class="keyword">new</span> StatusBarIcon(iconPackage, UserHandle.OWNER, iconId,</div><div class="line">                iconLevel, <span class="number">0</span>,</div><div class="line">                contentDescription);</div><div class="line">        <span class="comment">//Slog.d(TAG, "setIcon slot=" + slot + " index=" + index + " icon=" + icon);</span></div><div class="line">        mIcons.setIcon(index, icon);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mBar != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 最后还得通过 IPC 调用到 UI（SystemUI）通知下 UI 更新数据</span></div><div class="line">                mBar.setIcon(index, icon);</div><div class="line">            } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">            }   </div><div class="line">        }   </div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最开始有前面说的权限检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enforceStatusBar</span>() {</div><div class="line">    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR,</div><div class="line">            <span class="string">"StatusBarManagerService"</span>);    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>检测下调用者是否有权限调用 SBMS，估计应该是要 system app 才行吧。然后有一个叫 StatusBarIconList mIcons 的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusBarIconList</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</div><div class="line">    <span class="comment">// 主要是封装了一个 StatusBarIcon 数组，然后对应一个 Slots 的 String 数组</span></div><div class="line">    <span class="keyword">private</span> String[] mSlots;</div><div class="line">    <span class="keyword">private</span> StatusBarIcon[] mIcons;</div><div class="line">   </div><div class="line">    <span class="keyword">public</span> <span class="title">StatusBarIconList</span>() {</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defineSlots</span>(String[] slots) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = slots.length;    </div><div class="line">        String[] s = mSlots = <span class="keyword">new</span> String[N];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {      </div><div class="line">            s[i] = slots[i];</div><div class="line">        }</div><div class="line">        mIcons = <span class="keyword">new</span> StatusBarIcon[N]; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSlotIndex</span>(String slot) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = mSlots.length;   </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {      </div><div class="line">            <span class="keyword">if</span> (slot.equals(mSlots[i])) {  </div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIcon</span>(<span class="keyword">int</span> index, StatusBarIcon icon) {</div><div class="line">        mIcons[index] = icon.clone();  </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIcon</span>(<span class="keyword">int</span> index) {</div><div class="line">        mIcons[index] = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>名字也很形象，内部是用一个数组封装了下 StatusBarIcon，然后以 String 为标志（我觉得内部用 HashMap<string, statusbaricon=""> 会更好一些）。这里数据用得和 Notification 是一样的，都是 StatusBarIcon。然后关键点的方法也贴出来了，都比较简单一些贴这，后面提到的话翻回来看吧。前面说到系统状态图标是固定的，所以这里没有任何动态添加 StatusBarIcon 的接口，只有一个 defineSlots 的接口。之后，这个数组长度就固定了，哦，我收回我前面说用 HashMap 更好的话，长度固定的话，用数组最快。</string,></p>
<p>然后这个数组是在 SBMS 构造函数那里初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Construct the service, add the status bar view to the window manager</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="title">StatusBarManagerService</span>(Context context, WindowManagerService windowManager) {</div><div class="line">    mContext = context;</div><div class="line">    mWindowManager = windowManager;</div><div class="line">    mWindowManager.setOnHardKeyboardStatusChangeListener(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Resources res = context.getResources();</div><div class="line">    mIcons.defineSlots(res.getStringArray(com.android.internal.R.array.config_statusBarIcons));</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>xml 中的数组在这：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Do not translate. Defines the slots for the right-hand side icons.  That is to say, the</span></div><div class="line"><span class="comment">     icons in the status bar that are not notifications. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string-array</span> <span class="attribute">name</span>=<span class="value">"config_statusBarIcons"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>ime<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>sync_failing<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>sync_active<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>gps<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>bluetooth<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>nfc<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>tty<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>speakerphone<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>mute<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>volume<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>wifi<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>cdma_eri<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>data_connection<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>phone_evdo_signal<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>phone_signal<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>battery<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>alarm_clock<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>secure<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">item</span>&gt;</span><span class="tag">&lt;<span class="title">xliff:g</span> <span class="attribute">id</span>=<span class="value">"id"</span>&gt;</span>clock<span class="tag">&lt;/<span class="title">xliff:g</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">string-array</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>4.2 的原生系统有上面 19 个系统状态图标。我们接下来把剩下2个接口也看完：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setIconVisibility 其实是通过 setIcon 改变 StatusBarIcon 中的一个属性而已</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIconVisibility</span>(String slot, <span class="keyword">boolean</span> visible) {</div><div class="line">    enforceStatusBar();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mIcons) {        </div><div class="line">        <span class="keyword">int</span> index = mIcons.getSlotIndex(slot);</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"invalid status bar icon slot: "</span> + slot);</div><div class="line">        }</div><div class="line"></div><div class="line">        StatusBarIcon icon = mIcons.getIcon(index);</div><div class="line">        <span class="keyword">if</span> (icon == <span class="keyword">null</span>) {            </div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (icon.visible != visible) { </div><div class="line">            icon.visible = visible;        </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mBar != <span class="keyword">null</span>) {            </div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    mBar.setIcon(index, icon);     </div><div class="line">                } <span class="keyword">catch</span> (RemoteException ex) { </div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个是从 StatusBarIconList 找到对应的数据，然后置 NULL</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIcon</span>(String slot) { </div><div class="line">    enforceStatusBar();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mIcons) {        </div><div class="line">        <span class="keyword">int</span> index = mIcons.getSlotIndex(slot);</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"invalid status bar icon slot: "</span> + slot);</div><div class="line">        }</div><div class="line"></div><div class="line">        mIcons.removeIcon(index);      </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mBar != <span class="keyword">null</span>) {            </div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                mBar.removeIcon(index);        </div><div class="line">            } <span class="keyword">catch</span> (RemoteException ex) { </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="SystemUI_的处理">SystemUI 的处理</h2>
<p>上面 SBMS 虽然有3个接口，但是 UI 这边就只有2个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @hide */</span></div><div class="line">oneway interface IStatusBar</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> setIcon(<span class="keyword">int</span> index, in StatusBarIcon icon);</div><div class="line">    <span class="keyword">void</span> removeIcon(<span class="keyword">int</span> index);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面 SBMS 的实现也看到了，也只是用到 UI 这边2个接口。前面通知篇分析了 SystemUI 状态栏的一些设计和 UI 和 SS 那些关系的，这里就省略了（忘了的回去看一下）。桥接依旧在 CommandQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIcon</span>(<span class="keyword">int</span> index, StatusBarIcon icon) {</div><div class="line">        <span class="keyword">synchronized</span> (mList) {</div><div class="line">            <span class="keyword">int</span> what = MSG_ICON | index;</div><div class="line">            mHandler.removeMessages(what);</div><div class="line">            mHandler.obtainMessage(what, OP_SET_ICON, <span class="number">0</span>, icon.clone()).sendToTarget();</div><div class="line">        }   </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIcon</span>(<span class="keyword">int</span> index) {</div><div class="line">        <span class="keyword">synchronized</span> (mList) {</div><div class="line">            <span class="keyword">int</span> what = MSG_ICON | index;</div><div class="line">            mHandler.removeMessages(what);</div><div class="line">            mHandler.obtainMessage(what, OP_REMOVE_ICON, <span class="number">0</span>, <span class="keyword">null</span>).sendToTarget();</div><div class="line">        }   </div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> what = msg.what & MSG_MASK;</div><div class="line">            <span class="keyword">switch</span> (what) {</div><div class="line">                <span class="keyword">case</span> MSG_ICON: {</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> index = msg.what & INDEX_MASK;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> viewIndex = mList.getViewIndex(index);</div><div class="line">                    <span class="keyword">switch</span> (msg.arg1) {</div><div class="line">                        <span class="keyword">case</span> OP_SET_ICON: {</div><div class="line">                            StatusBarIcon icon = (StatusBarIcon)msg.obj;</div><div class="line">                            StatusBarIcon old = mList.getIcon(index);</div><div class="line">                            <span class="keyword">if</span> (old == <span class="keyword">null</span>) {</div><div class="line">                                mList.setIcon(index, icon);</div><div class="line">                                mCallbacks.addIcon(mList.getSlot(index), index, viewIndex, icon);</div><div class="line">                            } <span class="keyword">else</span> {</div><div class="line">                                mList.setIcon(index, icon);</div><div class="line">                                mCallbacks.updateIcon(mList.getSlot(index), index, viewIndex,</div><div class="line">                                        old, icon);</div><div class="line">                            }</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">case</span> OP_REMOVE_ICON:</div><div class="line">                            <span class="keyword">if</span> (mList.getIcon(index) != <span class="keyword">null</span>) {</div><div class="line">                                mList.removeIcon(index);</div><div class="line">                                mCallbacks.removeIcon(mList.getSlot(index), index, viewIndex);</div><div class="line">                            }</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                    }</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">... ...</div><div class="line"></div><div class="line">            }           </div><div class="line">        }                   </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>经过桥接的 CommandQueue 最后交给 UI 实现的接口又变成3个了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * These methods are called back on the main thread.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callbacks</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex, StatusBarIcon icon);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex,</div><div class="line">                StatusBarIcon old, StatusBarIcon icon);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 UI 这边又有一个 StatusBarIconList 的 mList，最后这个 list 是在这的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =================== BaseStatusBar.java ===================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>() {</div><div class="line">        mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">        mWindowManagerService = WindowManagerGlobal.getWindowManagerService();</div><div class="line">        mDisplay = mWindowManager.getDefaultDisplay();</div><div class="line"></div><div class="line">        mProvisioningObserver.onChange(<span class="keyword">false</span>); <span class="comment">// set up</span></div><div class="line">        mContext.getContentResolver().registerContentObserver(</div><div class="line">                Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONED), <span class="keyword">true</span>,</div><div class="line">                mProvisioningObserver);</div><div class="line"></div><div class="line">        mBarService = IStatusBarService.Stub.asInterface(</div><div class="line">                ServiceManager.getService(Context.STATUS_BAR_SERVICE));</div><div class="line"></div><div class="line">        <span class="comment">// 在 SystemUI 这里又 new 了一个 StatusBarIconList 出来</span></div><div class="line">        <span class="comment">// Connect in to the status bar manager service</span></div><div class="line">        StatusBarIconList iconList = <span class="keyword">new</span> StatusBarIconList();</div><div class="line">        ArrayList&lt;IBinder&gt; notificationKeys = <span class="keyword">new</span> ArrayList&lt;IBinder&gt;();</div><div class="line">        ArrayList&lt;StatusBarNotification&gt; notifications = <span class="keyword">new</span> ArrayList&lt;StatusBarNotification&gt;();</div><div class="line">        mCommandQueue = <span class="keyword">new</span> CommandQueue(<span class="keyword">this</span>, iconList);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ================== CommandQueue.java =====================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">CommandQueue</span>(Callbacks callbacks, StatusBarIconList list) {</div><div class="line">        mCallbacks = callbacks;</div><div class="line">        mList = list;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>比起通知，系统状态数据只存了2份（SBMS，SystemUI），还算好的了（通知存了3份： NM，SBMS，SystemUI）。然后从上面的代码来看，3个接口主要是：</p>
<ul>
<li><strong>addIcon</strong>: 如果调用的 setIcon 的 slot 没有在 SystemUI 中的数据有记录，那么会调用这个，让 SystemUI 添加一个新的状态图标（StatusBarIconView）</li>
<li><strong>updateIcon</strong>: 如果调用的 setIcon 的 slot 在 SystemUI 中有记录，那么会调用这个，让 SystemUI 更新下已有的状态图标状态</li>
<li><strong>removeIcon</strong>: 让 SystemUI 移除一个已经添加的状态图标</li>
</ul>
<p>我们以 PhoneStatusBar 为例，来看下相关的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStatusBar</span> <span class="keyword">extends</span> <span class="title">BaseStatusBar</span> </span>{</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// mSystemIconArea 是包括 wifi、电量、时间和系统状态图标一起的容器（在右边那一大堆）</span></div><div class="line">    <span class="comment">// right-hand icons</span></div><div class="line">    LinearLayout mSystemIconArea;</div><div class="line">            </div><div class="line">    <span class="comment">// mStatusIcons 是单独系统状态图标，包含在上面的 mSystemIconArea 里面</span></div><div class="line">    <span class="comment">// left-hand icons</span></div><div class="line">    LinearLayout mStatusIcons;</div><div class="line">    <span class="comment">// mNotificationIcons 是左边的通知的图标</span></div><div class="line">    <span class="comment">// the icons themselves</span></div><div class="line">    IconMerger mNotificationIcons;</div><div class="line">    <span class="comment">// [+&gt;</span></div><div class="line">    View mMoreIcon; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ================================================================================</span></div><div class="line">    <span class="comment">// Constructing the view</span></div><div class="line">    <span class="comment">// ================================================================================</span></div><div class="line">    <span class="keyword">protected</span> PhoneStatusBarView <span class="title">makeStatusBarView</span>() {</div><div class="line">... ...</div><div class="line"></div><div class="line">        mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);</div><div class="line">        mStatusIcons = (LinearLayout)mStatusBarView.findViewById(R.id.statusIcons);</div><div class="line">        mNotificationIcons = (IconMerger)mStatusBarView.findViewById(R.id.notificationIcons);</div><div class="line">        mNotificationIcons.setOverflowIndicator(mMoreIcon);</div><div class="line">        mStatusBarContents = (LinearLayout)mStatusBarView.findViewById(R.id.status_bar_contents);</div><div class="line">        mTickerView = mStatusBarView.findViewById(R.id.ticker);</div><div class="line"></div><div class="line">... ...</div><div class="line">        <span class="keyword">return</span> mStatusBarView;</div><div class="line">    }</div><div class="line"></div><div class="line">... ....</div><div class="line"></div><div class="line">    <span class="comment">// 实现比较简单就是 new 一个 view（StatusBarIconView）出来，然后添加到 parent 里面</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex, StatusBarIcon icon) {</div><div class="line">        <span class="keyword">if</span> (SPEW) Slog.d(TAG, <span class="string">"addIcon slot="</span> + slot + <span class="string">" index="</span> + index + <span class="string">" viewIndex="</span> + viewIndex</div><div class="line">                + <span class="string">" icon="</span> + icon);</div><div class="line">        StatusBarIconView view = <span class="keyword">new</span> StatusBarIconView(mContext, slot, <span class="keyword">null</span>);</div><div class="line">        view.set(icon);</div><div class="line">        mStatusIcons.addView(view, viewIndex, <span class="keyword">new</span> LinearLayout.LayoutParams(mIconSize, mIconSize));</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="comment">// 更新状态的还要去 StatusBarIconView 里面去看</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex,</div><div class="line">            StatusBarIcon old, StatusBarIcon icon) {</div><div class="line">        <span class="keyword">if</span> (SPEW) Slog.d(TAG, <span class="string">"updateIcon slot="</span> + slot + <span class="string">" index="</span> + index + <span class="string">" viewIndex="</span> + viewIndex</div><div class="line">                + <span class="string">" old="</span> + old + <span class="string">" icon="</span> + icon);</div><div class="line">        StatusBarIconView view = (StatusBarIconView)mStatusIcons.getChildAt(viewIndex);</div><div class="line">        view.set(icon);</div><div class="line">    }</div><div class="line">            </div><div class="line">    <span class="comment">// 移除的，就是 removeView 而已</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex) {</div><div class="line">        <span class="keyword">if</span> (SPEW) Slog.d(TAG, <span class="string">"removeIcon slot="</span> + slot + <span class="string">" index="</span> + index + <span class="string">" viewIndex="</span> + viewIndex);</div><div class="line">        mStatusIcons.removeViewAt(viewIndex);</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>实现都比较简单，然后去 StatusBarIconView 里面看看更新状态的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Returns whether the set succeeded.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span>(StatusBarIcon icon) {</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> iconEquals = mIcon != <span class="keyword">null</span></div><div class="line">            && streq(mIcon.iconPackage, icon.iconPackage)</div><div class="line">            && mIcon.iconId == icon.iconId;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> levelEquals = iconEquals</div><div class="line">            && mIcon.iconLevel == icon.iconLevel;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> visibilityEquals = mIcon != <span class="keyword">null</span></div><div class="line">            && mIcon.visible == icon.visible;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> numberEquals = mIcon != <span class="keyword">null</span></div><div class="line">            && mIcon.number == icon.number;</div><div class="line">    mIcon = icon.clone();</div><div class="line">    setContentDescription(icon.contentDescription);</div><div class="line">    <span class="comment">// 图标变化</span></div><div class="line">    <span class="keyword">if</span> (!iconEquals) {</div><div class="line">        Drawable drawable = getIcon(icon);</div><div class="line">        <span class="keyword">if</span> (drawable == <span class="keyword">null</span>) {</div><div class="line">            Slog.w(TAG, <span class="string">"No icon for slot "</span> + mSlot);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }   </div><div class="line">        setImageDrawable(drawable);</div><div class="line">    }   </div><div class="line">    <span class="comment">// 图标索引变化</span></div><div class="line">    <span class="keyword">if</span> (!levelEquals) {</div><div class="line">        setImageLevel(icon.iconLevel);</div><div class="line">    }   </div><div class="line"></div><div class="line">    <span class="comment">// 这个 number 暂时没管是什么东西</span></div><div class="line">    <span class="keyword">if</span> (!numberEquals) {</div><div class="line">        <span class="keyword">if</span> (icon.number &gt; <span class="number">0</span> && mContext.getResources().getBoolean(</div><div class="line">                    R.bool.config_statusBarShowNumber)) {</div><div class="line">            <span class="keyword">if</span> (mNumberBackground == <span class="keyword">null</span>) {</div><div class="line">                mNumberBackground = getContext().getResources().getDrawable(</div><div class="line">                        R.drawable.ic_notification_overlay);</div><div class="line">            }   </div><div class="line">            placeNumber();</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mNumberBackground = <span class="keyword">null</span>;</div><div class="line">            mNumberText = <span class="keyword">null</span>;</div><div class="line">        }   </div><div class="line">        invalidate();</div><div class="line">    }   </div><div class="line">    <span class="comment">// 显示/隐藏状态变化</span></div><div class="line">    <span class="keyword">if</span> (!visibilityEquals) {</div><div class="line">        setVisibility(icon.visible ? VISIBLE : GONE);</div><div class="line">    }   </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>通过上面可以看到前面 SBMS 的 setIconVisibility 改变 StatusBarIcon 的 visible 属性，最后到 UI 这就是变成改变状态图标的 view 的 VISIBLE（GONE）属性。</p>
<p>然后前面说 4.2 系统的状态图标数组有 19 个，一般状态栏应该是放不下的。其实不用担心，因为虽然数据数组有 19 个，但是只是 NULL 的占位而已。要调用 SBMS 的 setIcon 才会正在填充数据进去，进而通知 UI 添加状态图标 view 到 WindowManager（WM）中（显示在界面上）。dumpsys 一下 SBMS 会发现 4.2 默认系统的状态图标有下面几个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Icon list:</div><div class="line">   <span class="number">0</span>: (ime) StatusBarIcon(pkg=com.sohu.inputmethod.sogouuser=<span class="number">0</span> id=<span class="number">0</span>x7f020076 level=<span class="number">0</span> visible=<span class="literal">true</span> num=<span class="number">0</span> )</div><div class="line">   <span class="number">1</span>: (sync_failing) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f020187 level=<span class="number">0</span> visible=<span class="literal">false</span> num=<span class="number">0</span> )</div><div class="line">   <span class="number">2</span>: (sync_active) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f020186 level=<span class="number">0</span> visible=<span class="literal">false</span> num=<span class="number">0</span> )</div><div class="line">   <span class="number">3</span>: (gps) null</div><div class="line">   <span class="number">4</span>: (bluetooth) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f020154 level=<span class="number">0</span> visible=<span class="literal">false</span> num=<span class="number">0</span> )</div><div class="line">   <span class="number">5</span>: (nfc) null</div><div class="line">   <span class="number">6</span>: (tty) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f020188 level=<span class="number">0</span> visible=<span class="literal">false</span> num=<span class="number">0</span> )</div><div class="line">   <span class="number">7</span>: (speakerphone) null</div><div class="line">   <span class="number">8</span>: (mute) null</div><div class="line">   <span class="number">9</span>: (volume) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f020171 level=<span class="number">0</span> visible=<span class="literal">true</span> num=<span class="number">0</span> )</div><div class="line">  <span class="number">10</span>: (wifi) null</div><div class="line">  <span class="number">11</span>: (cdma_eri) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f020173 level=<span class="number">0</span> visible=<span class="literal">false</span> num=<span class="number">0</span> )</div><div class="line">  <span class="number">12</span>: (data_connection) null</div><div class="line">  <span class="number">13</span>: (phone_evdo_signal) null</div><div class="line">  <span class="number">14</span>: (phone_signal) null</div><div class="line">  <span class="number">15</span>: (battery) null</div><div class="line">  <span class="number">16</span>: (alarm_clock) StatusBarIcon(pkg=com.android.systemuiuser=<span class="number">0</span> id=<span class="number">0</span>x7f02013a level=<span class="number">0</span> visible=<span class="literal">true</span> num=<span class="number">0</span> )</div><div class="line">  <span class="number">17</span>: (secure) null</div><div class="line">  <span class="number">18</span>: (clock) null</div><div class="line">Notification list:</div><div class="line">   <span class="number">0</span>: StatusBarNotification(pkg=com.android.systemui id=<span class="number">17303780</span> tag=null score=<span class="number">0</span> notn=Notification(pri=<span class="number">0</span> contentView=com.android.systemui/<span class="number">0</span>x1090099 vibrate=null sound=file:///system/media/audio/notificati</div><div class="line">  mDisabled=<span class="number">0</span>x3e10000</div><div class="line">  mDisableRecords.size=<span class="number">2</span></div><div class="line">    [<span class="number">0</span>] userId=<span class="number">0</span> what=<span class="number">0</span>x3010000 pkg=android token=android.os.Binder@<span class="number">4162</span>e520</div><div class="line">    [<span class="number">1</span>] userId=<span class="number">0</span> what=<span class="number">0</span>xe00000 pkg=WindowManager.LayoutParams token=android.os.Binder@<span class="number">419</span>f0da0</div><div class="line"></div></pre></td></tr></table></figure>

<p>19 个列表中有很多是空的（null）的，要让系统显示那些状态，需要调用 SBMS 的 setIcon 设置才会填充图标数据。4.2 中主要在 SystemUI 的 PhoneStatusBarPolicy 中设置的（以 Phone UI 为例子）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">PhoneStatusBarPolicy</span>(Context context) {</div><div class="line">    mContext = context;</div><div class="line">    mService = (StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);</div><div class="line"></div><div class="line">    <span class="comment">// listen for broadcasts</span></div><div class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter();</div><div class="line">    filter.addAction(Intent.ACTION_ALARM_CHANGED);</div><div class="line">    filter.addAction(Intent.ACTION_SYNC_STATE_CHANGED);</div><div class="line">    filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);</div><div class="line">    filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);</div><div class="line">    filter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);</div><div class="line">    filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);</div><div class="line">    filter.addAction(TtyIntent.TTY_ENABLED_CHANGE_ACTION);</div><div class="line">    mContext.registerReceiver(mIntentReceiver, filter, <span class="keyword">null</span>, mHandler);</div><div class="line"></div><div class="line">    <span class="comment">// storage</span></div><div class="line">    mStorageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);</div><div class="line">    mStorageManager.registerListener(</div><div class="line">            <span class="keyword">new</span> com.android.systemui.usb.StorageNotification(context));</div><div class="line"></div><div class="line">    <span class="comment">// TTY status</span></div><div class="line">    mService.setIcon(<span class="string">"tty"</span>,  R.drawable.stat_sys_tty_mode, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"tty"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Cdma Roaming Indicator, ERI</span></div><div class="line">    mService.setIcon(<span class="string">"cdma_eri"</span>, R.drawable.stat_sys_roaming_cdma_0, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"cdma_eri"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// bluetooth status</span></div><div class="line">    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();</div><div class="line">    <span class="keyword">int</span> bluetoothIcon = R.drawable.stat_sys_data_bluetooth;</div><div class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) {</div><div class="line">        mBluetoothEnabled = (adapter.getState() == BluetoothAdapter.STATE_ON);</div><div class="line">        <span class="keyword">if</span> (adapter.getConnectionState() == BluetoothAdapter.STATE_CONNECTED) {</div><div class="line">            bluetoothIcon = R.drawable.stat_sys_data_bluetooth_connected;</div><div class="line">        }   </div><div class="line">    }   </div><div class="line">    mService.setIcon(<span class="string">"bluetooth"</span>, bluetoothIcon, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"bluetooth"</span>, mBluetoothEnabled);</div><div class="line"></div><div class="line">    <span class="comment">// Alarm clock</span></div><div class="line">    mService.setIcon(<span class="string">"alarm_clock"</span>, R.drawable.stat_sys_alarm, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"alarm_clock"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Sync state</span></div><div class="line">    mService.setIcon(<span class="string">"sync_active"</span>, R.drawable.stat_sys_sync, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIcon(<span class="string">"sync_failing"</span>, R.drawable.stat_sys_sync_error, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"sync_active"</span>, <span class="keyword">false</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"sync_failing"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// volume</span></div><div class="line">    mService.setIcon(<span class="string">"volume"</span>, R.drawable.stat_sys_ringer_silent, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    mService.setIconVisibility(<span class="string">"volume"</span>, <span class="keyword">false</span>);</div><div class="line">    updateVolume();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后稍微贴一下 PhoneStatusBarPolicy 中更新这些状态的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> BroadcastReceiver mIntentReceiver = <span class="keyword">new</span> BroadcastReceiver() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Context context, Intent intent) {</div><div class="line">            String action = intent.getAction();</div><div class="line">            <span class="comment">// 前面的说的 SystemUI 注册闹钟状态设置的广播，间接对外提供接口</span></div><div class="line">            <span class="keyword">if</span> (action.equals(Intent.ACTION_ALARM_CHANGED)) {</div><div class="line">                updateAlarm(intent);           </div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(Intent.ACTION_SYNC_STATE_CHANGED)) {</div><div class="line">                updateSyncState(intent);       </div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED) ||</div><div class="line">                    action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {</div><div class="line">                updateBluetooth(intent);       </div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(AudioManager.RINGER_MODE_CHANGED_ACTION)) {</div><div class="line">                updateVolume();                </div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {</div><div class="line">                updateSimState(intent);        </div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(TtyIntent.TTY_ENABLED_CHANGE_ACTION)) {</div><div class="line">                updateTTY(intent);             </div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 贴一个就行了，其他的差不多的</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAlarm</span>(Intent intent) {</div><div class="line">        <span class="keyword">boolean</span> alarmSet = intent.getBooleanExtra(<span class="string">"alarmSet"</span>, <span class="keyword">false</span>);</div><div class="line">        mService.setIconVisibility(<span class="string">"alarm_clock"</span>, alarmSet);</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>还有一个输入法的在这里（InputMethodManagerService.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStatusIcon</span>(IBinder token, String packageName, <span class="keyword">int</span> iconId) {</div><div class="line">    <span class="keyword">int</span> uid = Binder.getCallingUid();</div><div class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> || mCurToken != token) {</div><div class="line">            Slog.w(TAG, <span class="string">"Ignoring setInputMethod of uid "</span> + uid + <span class="string">" token: "</span> + token);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">synchronized</span> (mMethodMap) {</div><div class="line">            <span class="keyword">if</span> (iconId == <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"hide the small icon for the input method"</span>);</div><div class="line">                <span class="keyword">if</span> (mStatusBar != <span class="keyword">null</span>) {</div><div class="line">                    mStatusBar.setIconVisibility(<span class="string">"ime"</span>, <span class="keyword">false</span>);</div><div class="line">                }   </div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (packageName != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"show a small icon for the input method"</span>);</div><div class="line">                CharSequence contentDescription = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="comment">// Use PackageManager to load label</span></div><div class="line">                    <span class="keyword">final</span> PackageManager packageManager = mContext.getPackageManager();</div><div class="line">                    contentDescription = packageManager.getApplicationLabel(</div><div class="line">                            mIPackageManager.getApplicationInfo(packageName, <span class="number">0</span>,</div><div class="line">                                    mSettings.getCurrentUserId()));</div><div class="line">                } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                    <span class="comment">/* ignore */</span> </div><div class="line">                }   </div><div class="line">                <span class="keyword">if</span> (mStatusBar != <span class="keyword">null</span>) {</div><div class="line">                    mStatusBar.setIcon(<span class="string">"ime"</span>, packageName, iconId, <span class="number">0</span>,</div><div class="line">                            contentDescription  != <span class="keyword">null</span></div><div class="line">                                    ? contentDescription.toString() : <span class="keyword">null</span>);</div><div class="line">                    mStatusBar.setIconVisibility(<span class="string">"ime"</span>, <span class="keyword">true</span>);</div><div class="line">                }</div><div class="line">            }   </div><div class="line">        }               </div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(ident);</div><div class="line">    }       </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>这篇内容比较简单。系统状态图标数据和通知的状态栏图标是一样的，都是 StautsBarIcon，视图也是一样的（StatusBarIconView），因为它们 UI 表现是一样的。只不过一个是显示应用的信息，一个是显示系统的状态信息；一个可以动态改变数量，一个固定数量而已。不过还是这2种不同系统 UI 元素还是要区分一些，不然有些时候搞混了，就找不到在哪定制这些东西了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/02/06/Android%20SystemUI%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%80%9A%E7%9F%A5/</loc>
    <lastmod>2015-02-09T01:15:16.000Z</lastmod>
    <data>
        <display>
        <title>Android SystemUI 分析——通知</title>
        <pubTime>2015-02-06T02:17:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Notification 作为 android 系统中的一种提醒类的 UI，其实不是很复杂。但是过了些时候又有点忘记了，又要去翻代码，所以还是稍微总结记录一下比较好。这里不会说得太深，就是一些 Notification 比较基本的东西（浅析一下吧），<br>我们先照例把相关代码位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 应用接口相关代码</span></div><div class="line">frameworks/base/core/java/android/app/Notification.java</div><div class="line">frameworks/base/core/java/android/app/NotificationManager.java</div><div class="line"></div><div class="line"><span class="comment"># 系统内部接口相关代码</span></div><div class="line">frameworks/base/core/java/com/android/internal/statusbar/StatusBarNotification.java</div><div class="line">frameworks/base/core/java/com/android/internal/statusbar/StatusBarIcon.java</div><div class="line"></div><div class="line"><span class="comment"># System Server 相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/NotificationManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/StatusBarManagerService.java</div><div class="line"></div><div class="line"><span class="comment"># SystemUI 相关代码</span></div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/StatusBarIconView.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</div><div class="line">frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="UI_表现">UI 表现</h2>
<p>目前 android 系统中的通知 UI 表现有3种：</p>
<ul>
<li><p><strong>Ticker</strong><br>就是刚发送一条通知的时候，通知栏上会有 一个小图标 + 一条文本 伴随一个滚动动画滚动出来，过一小段时间（3s）后会消失。作用是用一个动态效果告诉用户有一条通知来了。</p>
</li>
<li><p><strong>StatusBar Icon</strong><br>当 Ticker 消失后，状态栏的左上角就会多一个小图标（和刚刚 Ticker 的小图标一样），告诉用户已经有一条通知了。</p>
</li>
<li><p><strong>Notification Row</strong><br>发送一条通知后，下拉通知面板中的通知列表中会多一条通知行。上面那2个相当于是预览信息，这里的就是通知的完整信息了（不过话说本来通知就是应用程序的预览信息）。</p>
</li>
</ul>
<p>所以说应用要对系统发送一条通知，显示上可以设置的就是这3大块（效果图见后面的系统分析那里），还有一个可以设置的是不可见的部分——PendingIntent：点击通知要完成的动作，一般是启动某个程序的 Activity 界面（还可以设置一个通知被删除时候的动作）。</p>
<p>通知分为2种：</p>
<ol>
<li>可删除的：这种可以在通知面板上由用户用手动删除，删除后，状态栏上对应的这条通知的小图标也会被删除掉（一般的通知类通知可以用这种）。</li>
<li>不可删除的：这种通知用户无法手动删除，只能由发送通知的程序用代码取消掉（一些工具类的挂在通知面板上的快捷方式可以用这种，例如音乐播放器）。当然这种方式可能会被一些流氓应用利用，长按这条通知，然后可以查看到发送这条通知的应用（系统设置中），强制终止掉发送通知的 apk（在系统设置中强制终止 apk 或是进程自己挂掉了，发送的通知会被清楚掉）。当然还可以更狠点，直接禁止这个 apk 发送通知。</li>
</ol>
<p>上面那2种类型可以通过设置 Notification 的 flags <code>FLAG_NO_CLEAR</code> 来表示。同时还有一个容易和这个搞混的标志叫： <code>FLAG_ONGOING_EVENT</code> 这个表示发送这条通知的应用正在进行某些工作。设置了这个正在进行的标志，效果和设置不可删除的是一样的，用户同样无法手动去删除这条通知。在老的 android 版本（好像应该是 4.0 以前），通知面板上显示通知是分2组显示的，一组叫“正在进行的”，一组叫“通知”。设置了 <code>FLAG_ONGOING_EVENT</code> 会被分到“正在进行的”那组，其他的在“通知”组。不过从 4.0 开始，android 改了设计了，全都归到一组去显示了。所以 4.0 以后，<code>FLAG_ONGOING_EVENT</code> 从视觉上看不出和没设置的有啥区别的（当然如果你自己定制的 framework 你可以继续改回分组的显示方式）。</p>
<h2 id="通知标示">通知标示</h2>
<p>应用 new 一个 Notification 之后，获取 NotificationManager(NM) 之后，调用相应的接口就可以发送通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================== NotificationManager.java =====================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Post a notification to be shown in the status bar. If a notification with</span></div><div class="line"><span class="comment">     * the same id has already been posted by your application and has not yet been canceled, it</span></div><div class="line"><span class="comment">     * will be replaced by the updated information.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param id An identifier for this notification unique within your</span></div><div class="line"><span class="comment">     *        application.</span></div><div class="line"><span class="comment">     * @param notification A {@link Notification} object describing what to show the user. Must not</span></div><div class="line"><span class="comment">     *        be null.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span>(<span class="keyword">int</span> id, Notification notification) {</div><div class="line">        notify(<span class="keyword">null</span>, id, notification);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Post a notification to be shown in the status bar. If a notification with</span></div><div class="line"><span class="comment">     * the same tag and id has already been posted by your application and has not yet been</span></div><div class="line"><span class="comment">     * canceled, it will be replaced by the updated information.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param tag A string identifier for this notification.  May be {@code null}.</span></div><div class="line"><span class="comment">     * @param id An identifier for this notification.  The pair (tag, id) must be unique</span></div><div class="line"><span class="comment">     *        within your application.</span></div><div class="line"><span class="comment">     * @param notification A {@link Notification} object describing what to</span></div><div class="line"><span class="comment">     *        show the user. Must not be null.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span>(String tag, <span class="keyword">int</span> id, Notification notification) {</div><div class="line">        <span class="keyword">int</span>[] idOut = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</div><div class="line">        INotificationManager service = getService();</div><div class="line">        String pkg = mContext.getPackageName();</div><div class="line">        <span class="keyword">if</span> (notification.sound != <span class="keyword">null</span>) {</div><div class="line">            notification.sound = notification.sound.getCanonicalUri();</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, pkg + <span class="string">": notify("</span> + id + <span class="string">", "</span> + notification + <span class="string">")"</span>);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            service.enqueueNotificationWithTag(pkg, tag, id, notification, idOut,</div><div class="line">                    user.getIdentifier());</div><div class="line">            <span class="keyword">if</span> (id != idOut[<span class="number">0</span>]) {</div><div class="line">                Slog.w(TAG, <span class="string">"notify: id corrupted: sent "</span> + id + <span class="string">", got back "</span> + idOut[<span class="number">0</span>]);</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Cancel a previously shown notification.  If it's transient, the view</span></div><div class="line"><span class="comment">     * will be hidden.  If it's persistent, it will be removed from the status</span></div><div class="line"><span class="comment">     * bar.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span>(<span class="keyword">int</span> id) {</div><div class="line">        cancel(<span class="keyword">null</span>, id);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Cancel a previously shown notification.  If it's transient, the view</span></div><div class="line"><span class="comment">     * will be hidden.  If it's persistent, it will be removed from the status</span></div><div class="line"><span class="comment">     * bar.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span>(String tag, <span class="keyword">int</span> id) {</div><div class="line">        INotificationManager service = getService();</div><div class="line">        String pkg = mContext.getPackageName();</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, pkg + <span class="string">": cancel("</span> + id + <span class="string">")"</span>);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            service.cancelNotificationWithTag(pkg, tag, id, UserHandle.myUserId());</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Cancel all previously shown notifications. See {@link #cancel} for the</span></div><div class="line"><span class="comment">     * detailed behavior.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span>() {</div><div class="line">        INotificationManager service = getService();</div><div class="line">        String pkg = mContext.getPackageName();</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, pkg + <span class="string">": cancelAll()"</span>);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            service.cancelAllNotifications(pkg, UserHandle.myUserId());</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        }      </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>NMS 中有几种方式可以用来标示一条通知。首先说说为什么要标示一条通知。因为发送一条通知，之后可以更新它的状态（显示的信息），取消它（删除），所以要有一个东西能唯一表示一条通知。首先有一个原则，那就是除了系统以外，<strong>一个应用只能操作自己发送的通知</strong>。所以对于普通应用，虽然说有几种标示，但是都在 pkg（包名）这个大的标示下（其实还有一个大的标示，就是用户，不过我们这里先不讨论多用户）。所以看 NM 接口的实现，都自动把调用接口的应用的 pkg 发给 NMS，不让应用自己设置（免得有些应用故意写别人的包名，干坏事）。</p>
<p>然后我们看到接口，有 id（int） 和 tag（String） 这2种标示。一般应用开发中 id 用得比较多，然后我们看下 NMS 中识别的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================== NotificationManagerService.java =====================</span></div><div class="line"></div><div class="line">    <span class="comment">// lock on mNotificationList</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfNotificationLocked</span>(String pkg, String tag, <span class="keyword">int</span> id, <span class="keyword">int</span> userId)</div><div class="line">    {</div><div class="line">        ArrayList&lt;NotificationRecord&gt; list = mNotificationList;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = list.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) {</div><div class="line">            NotificationRecord r = list.get(i);</div><div class="line">            <span class="keyword">if</span> (!notificationMatchesUserId(r, userId) || r.id != id) {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }    </div><div class="line">            <span class="keyword">if</span> (tag == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (r.tag != <span class="keyword">null</span>) {</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }    </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (!tag.equals(r.tag)) {</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }    </div><div class="line">            }    </div><div class="line">            <span class="keyword">if</span> (r.pkg.equals(pkg)) {</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            }    </div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>发现优先匹配 id，然后才是 tag（最后包名那来个保险，确保你只能操作自己发的通知）。所以说要自己设计通知的 id 话，可以随意点，因为系统帮你确保你的 id 只在你的 pkg 中有效了，android 系统里面是直接拿图标的 R 资源的 id 来做 id 用的。也有一些用 tag，不过那个用得少。</p>
<h2 id="Content">Content</h2>
<p>接下来介绍下通知的显示内容。通知的 Content 一般来说是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/SystemUI-notification/normal_notification_callouts.png" alt="normal view 模式" title="normal view 模式"></p>
<p>从 4.0 开始多了一个 big view 的模式，是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/SystemUI-notification/bigpicture_notification_callouts.png" alt="big view 模式" title="big view 模式"></p>
<p>前面看了通知的接口。应用需要构造出一个 Notification 对象出来。在 2.x 的时候是直接设置 Notification 的字段的（里面的字段都是 public 的），后面 android 本着封装的设计感觉原来的不太好，所以搞了一个 Notification.Builder 出来，之后建议开发者用这个 Builder 来构造 Notification。其实2个原理上基本上是一样的，但是某些地方有点点不一样。就算是新的 sdk，你仍然可以坚持直接设置 Notification。所以我们来分开说一下：</p>
<h3 id="直接设置_Notification">直接设置 Notification</h3>
<p>我们来列一下 Notification 中我们需要设置的一些数据。</p>
<ul>
<li><p><strong>icon(int)</strong><br>通知图标的资源 id。是上面 normal 模式的 2。</p>
</li>
<li><p><strong>iconLevel(int)</strong><br>上面那个 icon 可以设成 LevelListDrawable 的，然后可以通过设置 iconLevel 来改变 icon 的图标 level，如果定时改变的话，可以形成一些下载通知图标的动态效果。</p>
</li>
<li><p><strong>setLatestEventInfo</strong><br>这是个接口，参数如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ============== Notification.java =====================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Sets the {@link #contentView} field to be a view with the standard "Latest Event"</span></div><div class="line"><span class="comment">     * layout.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * &lt;p&gt;Uses the {@link #icon} and {@link #when} fields to set the icon and time fields</span></div><div class="line"><span class="comment">     * in the view.&lt;/p&gt;</span></div><div class="line"><span class="comment">     * @param context       The context for your application / activity.</span></div><div class="line"><span class="comment">     * @param contentTitle The title that goes in the expanded entry.</span></div><div class="line"><span class="comment">     * @param contentText  The text that goes in the expanded entry.</span></div><div class="line"><span class="comment">     * @param contentIntent The intent to launch when the user clicks the expanded notification.</span></div><div class="line"><span class="comment">     * If this is an activity, it must include the</span></div><div class="line"><span class="comment">     * {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requires</span></div><div class="line"><span class="comment">     * that you take care of task management as described in the</span></div><div class="line"><span class="comment">     * &lt;a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"&gt;Tasks and Back</span></div><div class="line"><span class="comment">     * Stack&lt;/a&gt; document.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @deprecated Use {@link Builder} instead.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="annotation">@Deprecated</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLatestEventInfo</span>(Context context,</div><div class="line">            CharSequence contentTitle, CharSequence contentText, PendingIntent contentIntent) {</div><div class="line">        <span class="comment">// TODO: rewrite this to use Builder</span></div><div class="line">        RemoteViews contentView = <span class="keyword">new</span> RemoteViews(context.getPackageName(),</div><div class="line">                R.layout.notification_template_base);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.icon != <span class="number">0</span>) { </div><div class="line">            contentView.setImageViewResource(R.id.icon, <span class="keyword">this</span>.icon);</div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (priority &lt; PRIORITY_LOW) {</div><div class="line">            contentView.setInt(R.id.icon,</div><div class="line">                    <span class="string">"setBackgroundResource"</span>, R.drawable.notification_template_icon_low_bg);</div><div class="line">            contentView.setInt(R.id.status_bar_latest_event_content,</div><div class="line">                    <span class="string">"setBackgroundResource"</span>, R.drawable.notification_bg_low);</div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (contentTitle != <span class="keyword">null</span>) {</div><div class="line">            contentView.setTextViewText(R.id.title, contentTitle);</div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (contentText != <span class="keyword">null</span>) {</div><div class="line">            contentView.setTextViewText(R.id.text, contentText);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.when != <span class="number">0</span>) {</div><div class="line">            contentView.setViewVisibility(R.id.time, View.VISIBLE);</div><div class="line">            contentView.setLong(R.id.time, <span class="string">"setTime"</span>, when);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.number != <span class="number">0</span>) {</div><div class="line">            NumberFormat f = NumberFormat.getIntegerInstance();</div><div class="line">            contentView.setTextViewText(R.id.info, f.format(<span class="keyword">this</span>.number));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.contentView = contentView;</div><div class="line">        <span class="keyword">this</span>.contentIntent = contentIntent;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个可以说以前（4.0 之前）通知的最主要的部分了。看这个函数里面的实现知道，系统帮我们提供了一个通知的模板（xml 在 frameworks/base/core/res/res 下面），帮我们 new 了一个 RemoteViews 来当作通知的 ContentView。一个通知必须要有的2个元素，一个是 id，另外一个就是 contentView。这个 RemoteViews 是跨进程的 UI 组件，这个东西以后再分析，这里先不管它。系统的模板弄出来的样子就和上面的 normal view 那样。这里参数可以让你设置通知的标题（title）和内容（text）。分别对应 normal view 的 1 和 3。</p>
<p>这里除了 UI 元素设置，最后还有一个 PendingIntent 的参数（contentIntent），算是功能性设置。注释中说是用户点击通知的时候对应完成的功能。可以是 activity（点击时 launch），也可以是 broadcast（点击时发送）。可以说还是挺灵活的，这里就不展开分析了。</p>
<ul>
<li><p><strong>number(int)</strong><br>标准模板中的右下角显示一个小数字（一些消息、邮件类的通知很有用），对应 normal view 的 4。注意如果不想显示把这个设置 0 就可以了（默认是 0，上面 setLatestEventInfo 处理那里代码能看得出的）。</p>
</li>
<li><p><strong>when(long)</strong><br>标志模板中右上角显示发送通知的时间，对应 normal view 的 6。看到类型是 long 的就知道这个时间是自从 1970-01-01 00:00:00.0 的 UTC，可以通过 System.currentTimeMillis() 取当前的时间，当然你也可以故意设置成别的时间。顺带一提，如果你不想显示时间，把这个设置成 0 就行了（和 number 一样的）。</p>
</li>
<li><p><strong>contentView(RemoteViews)</strong><br>其实上面 setLatestEventInfo 是让系统帮你生成一个标准的通知模板。但是你会发现一些音乐播放器和一些手机助手，在通知栏上有一些比较高级的通知，这些是通过自定义的 content view 来实现的。不要用系统的模板，自己写 content view 就行了，这个是 RemoteViews，和写 widget 差不多的。</p>
</li>
<li><p><strong>bigContentView(RemoteViews)</strong><br>这个是 Notification 新增的 big view 模式，和 contentView 一样，可以自定义，详见下面 Builder 的说明。</p>
</li>
<li><p><strong>deleteIntent</strong><br>上面那个 contentIntent 是点击通知时候的动作。这个顾名思义，是通知被删除的时候的动作，例如说通知被删掉了，可以做一些清除发送通知相关的数据的操作。</p>
</li>
<li><p><strong>fullScreenIntent</strong><br>这个看名字不是太直白（但是也有点沾边），这个是指发送通知的时候做的动作，例如说闹钟来了，对通知栏发送一条通知，顺带 launch 闹钟界面的 activity（系统闹钟的做法）；或者是插入 usb，发送 usb 连接通知，顺带 launch usb storage 操作界面。</p>
</li>
<li><p><strong>tickerText(Char CharSequence)</strong><br>设置前面说的那个 ticker 显示的文本信息。这个也是系统有一个标准模板的，左边一个 icon，右边是文本。模板中 ticker 的 icon 是取 Notification 的 icon（源码中本着封装的原则，不同模块搞了一堆数据结构，又绕了半天，这篇侧重应用，代码这里不分析了）。所以 ticker 图标是和状态栏上的显示的图标是一样的，独立的只能设置文本。如果你没设 tickerText（为 null），那你发通知的时间就没 ticker 显示了（就是没那段通知滚动的动画了）。</p>
</li>
<li><p><strong>tickerView(RemoteViews)</strong><br>看到前面 tickerText 那里提到模板就能猜到 ticker 也是可以自定义的。但是注意一点原生的 android 系统只有 Tablet UI 才允许你自定义 ticker view，因为只有 Tablet UI 才会使用 Notification 中设置的 tickerView。这里顺带说下 android SystemUI 的一些策略问题：</p>
</li>
</ul>
<p>SystemUI 的状态栏（包括虚拟按键、通知面板）以分为好几种 UI 风格，目前已有的是 phone、table、tv。它共同继续只同一个父类 BaseStatusBar。然后实现不同的 UI 风格。在 frameworks/base/package/SystemUI/src/com/android/systemui/statusbar 下面有对应的包。framework 中可以在 xml 中指定要运行的 UI 风格。要想知道自己的设备状态用的是哪一种风格，拿 hierarchyviewer 看下状态栏的包名和类名就行了。</p>
<p>当然这是原生定的，你也可以改成 phone 也可以使用自定义的 tickerView，或者你自己都可以完全搞一套状态栏 UI 风格（只要实现了父类抽象的功能即可）。不过 android 内部也是矛盾不断，4.0 ~ 4.2 的时候原生还是有 phone 和 table 2种风格的（tv 的现在基本上是摆设），到了 4.4 之后 android 就把 table 给干掉了，然后全部只有 phone 的（也许是想统一手机和平板的风格吧）。所以说现在这个接口在原生系统上就是摆设，老老实实用系统标准的模板。 </p>
<p>经过上面的介绍，你会发现前面 normal view 下的通知栏，好像还有一个元素（6）没哪个接口可以设置。对的，在直接使用 Notification 设置是没办法设置右边那个小图标的（我不知道这个小图标是不是后面新加入的新元素）。因为这种方法已经被系统标记为过时的（deprecated），新的 sdk 推荐你使用 Notification.Builder 来设置通知。当然系统为了兼容性还保留着以前的接口，你要坚持使用老接口也可以，就是功能没那么全而已。 </p>
<h3 id="使用_Notification-Builder">使用 Notification.Builder</h3>
<p>自从 4.0（应该是吧，我就不具体去考查版本了）通知新加入了一种模式，就出现了这个 Builder 的辅助类。我们先来说下新加入的这种通知模式。这模式官方叫 big view。一般通知的表现是在通知面板上一条一条的，虽然可以自定义 content view，但是系统规定死了 normal view 下每一条通知的高度的，所以所有 normal view 的通知的大小都是一样的（这样才好看）。但是你会发现某些音乐播放器的通知栏上的控制工具会比普通的通知要大，这个就是 big view 模式：</p>
<ol>
<li>big view 高度没有限制（我看代码是，具体没试过），可以比 normal view 高很多（宽是不可能了，屏幕就那么宽），效果见上面的 big view 图。</li>
<li>一个 Notification 可以有 normal view 和 big view。</li>
<li>通知普通情况下显示 normal view，可以通过双指滑动展开 big view（隐藏 normal view），双指缩放关闭 big view（显示 normal view），其实好像不是双指，但是我实在没明白官方怎么个操作法的，但是双指很容易能搞出来。</li>
</ol>
<p>big view 系统也是提供了若干模板，通过 new 不同的 Notiifcation.Style 可以设置不同风格的 big view 模板，当然也可以自定义（自己设置 bigContentView）。这就不细说 Builder、Style 有哪些接口了，自己去看下官方文档一目了然（其中包括上面说的设置右边的那个小图标的接口）。这里稍微看下系统是在 Builder 和 Style 中怎么帮我们创建 Notification 的 content view 的。</p>
<ul>
<li><strong>不使用风格</strong><br>如果直接 new Notification.Builder 然后设置一堆东西，然后调用 builder 的话，会是这样的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ============== Notification.java =====================</span></div><div class="line"></div><div class="line">        <span class="comment">/*  </span></div><div class="line"><span class="comment">         * Combine all of the options that have been set and return a new {@link Notification}</span></div><div class="line"><span class="comment">         * object.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">public</span> Notification <span class="title">build</span>() {</div><div class="line">            <span class="keyword">if</span> (mStyle != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">return</span> mStyle.build();</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">return</span> buildUnstyled();</div><div class="line">            }    </div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>你如果没有调用 setStyle 设置任何风格的话，使用的是 buildUnstyled：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ============== Notification.java =====================</span></div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Apply the unstyled operations and return a new {@link Notification} object.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> Notification <span class="title">buildUnstyled</span>() { </div><div class="line">            Notification n = <span class="keyword">new</span> Notification();</div><div class="line">            n.when = mWhen;</div><div class="line">            n.icon = mSmallIcon;           </div><div class="line">            n.iconLevel = mSmallIconLevel; </div><div class="line">            n.number = mNumber;            </div><div class="line">            <span class="comment">// 创建 normal view 的 content view</span></div><div class="line">            n.contentView = makeContentView();</div><div class="line">            n.contentIntent = mContentIntent;</div><div class="line">            n.deleteIntent = mDeleteIntent;</div><div class="line">            n.fullScreenIntent = mFullScreenIntent;</div><div class="line">            n.tickerText = mTickerText;</div><div class="line">            <span class="comment">// 创建 ticker view    </span></div><div class="line">            n.tickerView = makeTickerView();</div><div class="line">            n.largeIcon = mLargeIcon;      </div><div class="line">            n.sound = mSound;</div><div class="line">            n.audioStreamType = mAudioStreamType;</div><div class="line">            n.vibrate = mVibrate;          </div><div class="line">            n.ledARGB = mLedArgb;          </div><div class="line">            n.ledOnMS = mLedOnMs;          </div><div class="line">            n.ledOffMS = mLedOffMs;        </div><div class="line">            n.defaults = mDefaults;        </div><div class="line">            n.flags = mFlags;</div><div class="line">            <span class="comment">// 创建 big view 的 content view</span></div><div class="line">            n.bigContentView = makeBigContentView();</div><div class="line">            <span class="keyword">if</span> (mLedOnMs != <span class="number">0</span> && mLedOffMs != <span class="number">0</span>) {</div><div class="line">                n.flags |= FLAG_SHOW_LIGHTS;   </div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> ((mDefaults & DEFAULT_LIGHTS) != <span class="number">0</span>) {</div><div class="line">                n.flags |= FLAG_SHOW_LIGHTS;   </div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mKindList.size() &gt; <span class="number">0</span>) {    </div><div class="line">                n.kind = <span class="keyword">new</span> String[mKindList.size()];</div><div class="line">                mKindList.toArray(n.kind);     </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                n.kind = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            n.priority = mPriority;        </div><div class="line">            n.extras = mExtras != <span class="keyword">null</span> ? <span class="keyword">new</span> Bundle(mExtras) : <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (mActions.size() &gt; <span class="number">0</span>) {     </div><div class="line">                n.actions = <span class="keyword">new</span> Action[mActions.size()]; </div><div class="line">                mActions.toArray(n.actions);   </div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> n;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们稍微看下 normal view 和 big view 的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ============== Notification.java =====================</span></div><div class="line"></div><div class="line">        <span class="keyword">private</span> RemoteViews <span class="title">makeContentView</span>() {</div><div class="line">            <span class="keyword">if</span> (mContentView != <span class="keyword">null</span>) {    </div><div class="line">                <span class="keyword">return</span> mContentView;           </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">return</span> applyStandardTemplate(R.layout.notification_template_base, <span class="keyword">true</span>); <span class="comment">// no more special large_icon flavor</span></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">private</span> RemoteViews <span class="title">applyStandardTemplate</span>(<span class="keyword">int</span> resId, <span class="keyword">boolean</span> fitIn1U) {</div><div class="line">            RemoteViews contentView = <span class="keyword">new</span> RemoteViews(mContext.getPackageName(), resId);</div><div class="line">            <span class="keyword">boolean</span> showLine3 = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">boolean</span> showLine2 = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">int</span> smallIconImageViewId = R.id.icon;</div><div class="line">            <span class="keyword">if</span> (mLargeIcon != <span class="keyword">null</span>) {</div><div class="line">                contentView.setImageViewBitmap(R.id.icon, mLargeIcon);</div><div class="line">                smallIconImageViewId = R.id.right_icon;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mPriority &lt; PRIORITY_LOW) {</div><div class="line">                contentView.setInt(R.id.icon,</div><div class="line">                        <span class="string">"setBackgroundResource"</span>, R.drawable.notification_template_icon_low_bg);</div><div class="line">                contentView.setInt(R.id.status_bar_latest_event_content,</div><div class="line">                        <span class="string">"setBackgroundResource"</span>, R.drawable.notification_bg_low);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mSmallIcon != <span class="number">0</span>) {</div><div class="line">                contentView.setImageViewResource(smallIconImageViewId, mSmallIcon);</div><div class="line">                contentView.setViewVisibility(smallIconImageViewId, View.VISIBLE);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                contentView.setViewVisibility(smallIconImageViewId, View.GONE);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mContentTitle != <span class="keyword">null</span>) {</div><div class="line">                contentView.setTextViewText(R.id.title, mContentTitle);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mContentText != <span class="keyword">null</span>) {</div><div class="line">                contentView.setTextViewText(R.id.text, mContentText);</div><div class="line">                showLine3 = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mContentInfo != <span class="keyword">null</span>) {</div><div class="line">                contentView.setTextViewText(R.id.info, mContentInfo);</div><div class="line">                contentView.setViewVisibility(R.id.info, View.VISIBLE);</div><div class="line">                showLine3 = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (mNumber &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> tooBig = mContext.getResources().getInteger(</div><div class="line">                        R.integer.status_bar_notification_info_maxnum);</div><div class="line">                <span class="keyword">if</span> (mNumber &gt; tooBig) {</div><div class="line">                    contentView.setTextViewText(R.id.info, mContext.getResources().getString(</div><div class="line">                                R.string.status_bar_notification_info_overflow));</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    NumberFormat f = NumberFormat.getIntegerInstance();</div><div class="line">                    contentView.setTextViewText(R.id.info, f.format(mNumber));</div><div class="line">                }</div><div class="line">                contentView.setViewVisibility(R.id.info, View.VISIBLE);</div><div class="line">                showLine3 = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                contentView.setViewVisibility(R.id.info, View.GONE);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Need to show three lines?</span></div><div class="line">            <span class="keyword">if</span> (mSubText != <span class="keyword">null</span>) {</div><div class="line">                contentView.setTextViewText(R.id.text, mSubText);</div><div class="line">                <span class="keyword">if</span> (mContentText != <span class="keyword">null</span>) {</div><div class="line">                    contentView.setTextViewText(R.id.text2, mContentText);</div><div class="line">                    contentView.setViewVisibility(R.id.text2, View.VISIBLE);</div><div class="line">                    showLine2 = <span class="keyword">true</span>;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    contentView.setViewVisibility(R.id.text2, View.GONE);</div><div class="line">                }  </div><div class="line">            } <span class="keyword">else</span> {   </div><div class="line">                contentView.setViewVisibility(R.id.text2, View.GONE);</div><div class="line">                <span class="keyword">if</span> (mProgressMax != <span class="number">0</span> || mProgressIndeterminate) {</div><div class="line">                    contentView.setProgressBar(</div><div class="line">                            R.id.progress, mProgressMax, mProgress, mProgressIndeterminate);</div><div class="line">                    contentView.setViewVisibility(R.id.progress, View.VISIBLE);</div><div class="line">                    showLine2 = <span class="keyword">true</span>;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    contentView.setViewVisibility(R.id.progress, View.GONE);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (showLine2) { </div><div class="line">                <span class="keyword">if</span> (fitIn1U) {</div><div class="line">                    <span class="comment">// need to shrink all the type to make sure everything fits</span></div><div class="line">                    <span class="keyword">final</span> Resources res = mContext.getResources();</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> subTextSize = res.getDimensionPixelSize(</div><div class="line">                            R.dimen.notification_subtext_size);</div><div class="line">                    contentView.setTextViewTextSize(R.id.text, TypedValue.COMPLEX_UNIT_PX, subTextSize);</div><div class="line">                }</div><div class="line">                <span class="comment">// vertical centering</span></div><div class="line">                contentView.setViewPadding(R.id.line1, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (mWhen != <span class="number">0</span> && mShowWhen) {</div><div class="line">                <span class="keyword">if</span> (mUseChronometer) {</div><div class="line">                    contentView.setViewVisibility(R.id.chronometer, View.VISIBLE);</div><div class="line">                    contentView.setLong(R.id.chronometer, <span class="string">"setBase"</span>,</div><div class="line">                            mWhen + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));</div><div class="line">                    contentView.setBoolean(R.id.chronometer, <span class="string">"setStarted"</span>, <span class="keyword">true</span>);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    contentView.setViewVisibility(R.id.time, View.VISIBLE);</div><div class="line">                    contentView.setLong(R.id.time, <span class="string">"setTime"</span>, mWhen);</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                contentView.setViewVisibility(R.id.time, View.GONE);</div><div class="line">            }</div><div class="line"></div><div class="line">            contentView.setViewVisibility(R.id.line3, showLine3 ? View.VISIBLE : View.GONE);</div><div class="line">            contentView.setViewVisibility(R.id.overflow_divider, showLine3 ? View.VISIBLE : View.GONE);</div><div class="line">            <span class="keyword">return</span> contentView;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>具体细节不看了，就是根据 Builder 设置的参数设置 R.layout.notification_template_base 中的界面元素。从这里能看出使用 Builder 比上面使用 Notification.setLatestEventInfo 创建的模板多很多东西。所以要想更多的控制自己程序发送的通知样式还是使用 sdk 推荐的接口比较好。</p>
<p>然后看下 big view 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ============== Notification.java =====================</span></div><div class="line"></div><div class="line">        <span class="keyword">private</span> RemoteViews <span class="title">makeBigContentView</span>() {</div><div class="line">            <span class="keyword">if</span> (mActions.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> applyStandardTemplateWithActions(R.layout.notification_template_big_base);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">private</span> RemoteViews <span class="title">applyStandardTemplateWithActions</span>(<span class="keyword">int</span> layoutId) {</div><div class="line">            RemoteViews big = applyStandardTemplate(layoutId, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">            <span class="keyword">int</span> N = mActions.size();       </div><div class="line">            <span class="keyword">if</span> (N &gt; <span class="number">0</span>) {</div><div class="line">                <span class="comment">// Log.d("Notification", "has actions: " + mContentText);</span></div><div class="line">                big.setViewVisibility(R.id.actions, View.VISIBLE);</div><div class="line">                big.setViewVisibility(R.id.action_divider, View.VISIBLE);</div><div class="line">                <span class="keyword">if</span> (N&gt;MAX_ACTION_BUTTONS) N=MAX_ACTION_BUTTONS;</div><div class="line">                big.removeAllViews(R.id.actions);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {      </div><div class="line">                    <span class="keyword">final</span> RemoteViews button = generateActionButton(mActions.get(i));</div><div class="line">                    <span class="comment">//Log.d("Notification", "adding action " + i + ": " + mActions.get(i).title);</span></div><div class="line">                    big.addView(R.id.actions, button);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> big;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>不设置任何风格的 Builder，并且又没设置任何 Actions，是没有 big view 的。</p>
<ul>
<li><strong>使用风格</strong><br>Builder 有一个 setStyle 的接口，可以设置一个风格，系统 Notification 目前提供了下面几种风格：</li>
</ul>
<ol>
<li>BigPictureStyle: 就是能设置很大一张的</li>
<li>BigTextStyle: 有很大的空间（高度）显示一大串文本</li>
<li>InboxStyle： 就是上面贴图的那个 big view</li>
</ol>
<p>我这里偷下懒就不一个一个上效果图了（自己试一下就能看到效果了）。然后这里的风格的区别主要是在 big view 上，这几个风格分别提供了3种 big view 的风格，设置也是设置相应的 big view 的模板元素。我们来稍微看下源码，还记得上面那个 Builder 的 build 函数么，如果 mStyle 不是 null 的话，那么就调用相应 Style 的 build 函数，我们这里稍微看下 BigPictureStyle 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ============== Notification.java =====================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Helper class for generating large-format notifications that include a large image attachment.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This class is a "rebuilder": It consumes a Builder object and modifies its behavior, like so:</span></div><div class="line"><span class="comment">     * &lt;pre class="prettyprint"&gt;</span></div><div class="line"><span class="comment">     * Notification noti = new Notification.BigPictureStyle(</span></div><div class="line"><span class="comment">     *      new Notification.Builder()</span></div><div class="line"><span class="comment">     *         .setContentTitle(&quot;New photo from &quot; + sender.toString())</span></div><div class="line"><span class="comment">     *         .setContentText(subject)</span></div><div class="line"><span class="comment">     *         .setSmallIcon(R.drawable.new_post)</span></div><div class="line"><span class="comment">     *         .setLargeIcon(aBitmap))</span></div><div class="line"><span class="comment">     *      .bigPicture(aBigBitmap)</span></div><div class="line"><span class="comment">     *      .build();</span></div><div class="line"><span class="comment">     * &lt;/pre&gt;</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @see Notification#bigContentView</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigPictureStyle</span> <span class="keyword">extends</span> <span class="title">Style</span> </span>{</div><div class="line">        <span class="keyword">private</span> Bitmap mPicture;       </div><div class="line">        <span class="keyword">private</span> Bitmap mBigLargeIcon;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mBigLargeIconSet = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="title">BigPictureStyle</span>() {     </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="title">BigPictureStyle</span>(Builder builder) {</div><div class="line">            setBuilder(builder);           </div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">private</span> RemoteViews <span class="title">makeBigContentView</span>() {</div><div class="line">            RemoteViews contentView = getStandardView(R.layout.notification_template_big_picture);</div><div class="line"></div><div class="line">            contentView.setImageViewBitmap(R.id.big_picture, mPicture);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> contentView;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> Notification <span class="title">build</span>() {</div><div class="line">            checkBuilder();</div><div class="line">            Notification wip = mBuilder.buildUnstyled();</div><div class="line">            <span class="keyword">if</span> (mBigLargeIconSet ) {</div><div class="line">                mBuilder.mLargeIcon = mBigLargeIcon;</div><div class="line">            }</div><div class="line">            wip.bigContentView = makeBigContentView();</div><div class="line">            <span class="keyword">return</span> wip;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>从代码中看，这些 Style 就是先调用 Builder 的无风格 build 函数，然后再重新把 bigContentView 自己生成一个，覆盖以前的而已。其他2个我就不贴代码了，套路基本上是一样的。通知栏智能机时代是 android 发明的（IOS 的在后面，android 在界面设计方面有领先 IOS 的地方了哟），加入了 big view 之后 UI 更加灵活了，好像 5.0 又多了一个新功能，以后有时间再看看。</p>
<h2 id="系统处理流程">系统处理流程</h2>
<p>上面说了一些 Notification 的基本用法，也稍微分析下源代码的一些实现。这些稍微说下，应用对 NM 发送一条通知，framework 中会对应生成什么数据，然后通知的 content view 是怎么加到 SystemUI 的状态栏和通知面板中的。先是上一张图先：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/SystemUI-notification/Send-notification.png" alt="流程图" title="流程图"></p>
<p>从图中可以看到一个通知从 app 自己构造通知然后调用 NotificationManager（NM）的接口发送，经过了 NotificationManagerService（NMS）到 StatusBarManagerService(SBMS) 最后到添加 Notification 的 UI 元素到 SystemUI 中。好像也有点麻烦的样子，然后图中蓝色的部分是每个模块（NMS、SBMS、SystemUI）保存通知的相关数据（前面说了每个模块都不一样，还真是不一样）。然后我们再贴下通知相关的 UI 元素最后在 SystemUI 中的表现：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/SystemUI-notification/notification-ui.jpeg" alt="UI 效果" title="UI 效果"><br>(PS: 这不是 android 原生的 SystemUI，是被我定制过的，通知没分组了)</p>
<p>上面我们稍微注意下每个模块对应的数据结构，和最后扔到 SystemUI 中的 view 就差不多能摸清系统处理通知的流程了。下面开始跟流程：</p>
<ul>
<li><strong>1.App</strong><br>首先是构造 Notification，前面分析过了，然后获取 NM 调用 notify 的接口，把 id 和 Notificaiton 传给 NM。这里代码前面贴过了，回去看看就行。</li>
</ul>
<ul>
<li><strong>2.NotificationManagerService</strong><br>然后 NM 会调用 NMS 的 enqueueNotificationInternal（Notification 是 Parcelable 所以可以当作 Binder 的参数传给 NMS）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// Not exposed via Binder; for system use only (otherwise malicious apps could spoof the</span></div><div class="line">    <span class="comment">// uid/pid of another application)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueNotificationInternal</span>(String pkg, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> callingPid,</div><div class="line">            String tag, <span class="keyword">int</span> id, Notification notification, <span class="keyword">int</span>[] idOut, <span class="keyword">int</span> userId)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span> (DBG) {</div><div class="line">            Slog.v(TAG, <span class="string">"enqueueNotificationInternal: pkg="</span> + pkg + <span class="string">" id="</span> + id + <span class="string">" notification="</span> + notification);</div><div class="line">        }</div><div class="line">        <span class="comment">// 判断是不是当前用户应用发出来的通知</span></div><div class="line">        checkCallerIsSystemOrSameApp(pkg);</div><div class="line">        <span class="comment">// 判断是不是系统应用发出来的通知</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemNotification = isUidSystem(callingUid) || (<span class="string">"android"</span>.equals(pkg));</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = ActivityManager.handleIncomingUser(callingPid,</div><div class="line">                callingUid, incomingUserId, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"enqueueNotification"</span>, pkg);</div><div class="line">        <span class="keyword">final</span> UserHandle user = <span class="keyword">new</span> UserHandle(userId);</div><div class="line"></div><div class="line">        <span class="comment">// 如果不是系统应用的话，限制一下一个包发送总共应用的条数，原生限制 50 条</span></div><div class="line">        <span class="comment">// 通过统计 NotificationRecord 的 list 包名一样的通知记录 </span></div><div class="line">        <span class="comment">// Limit the number of notifications that any given package except the android</span></div><div class="line">        <span class="comment">// package can enqueue.  Prevents DOS attacks and deals with leaks.</span></div><div class="line">        <span class="keyword">if</span> (!isSystemNotification) {</div><div class="line">            <span class="keyword">synchronized</span> (mNotificationList) {</div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>; </div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = mNotificationList.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                    <span class="keyword">final</span> NotificationRecord r = mNotificationList.get(i);</div><div class="line">                    <span class="keyword">if</span> (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {</div><div class="line">                        count++;</div><div class="line">                        <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) {</div><div class="line">                            Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</div><div class="line">                                    + <span class="string">" notifications.  Not showing more.  package="</span> + pkg);</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// This conditional is a dirty hack to limit the logging done on</span></div><div class="line">        <span class="comment">//     behalf of the download manager without affecting other apps.</span></div><div class="line">        <span class="keyword">if</span> (!pkg.equals(<span class="string">"com.android.providers.downloads"</span>)</div><div class="line">                || Log.isLoggable(<span class="string">"DownloadManager"</span>, Log.VERBOSE)) {</div><div class="line">            EventLog.writeEvent(EventLogTags.NOTIFICATION_ENQUEUE, pkg, id, tag, userId,</div><div class="line">                    notification.toString());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span> || notification == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null not allowed: pkg="</span> + pkg</div><div class="line">                    + <span class="string">" id="</span> + id + <span class="string">" notification="</span> + notification);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (notification.icon != <span class="number">0</span>) {</div><div class="line">            <span class="comment">// content view 必须要有</span></div><div class="line">            <span class="keyword">if</span> (notification.contentView == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"contentView required: pkg="</span> + pkg</div><div class="line">                        + <span class="string">" id="</span> + id + <span class="string">" notification="</span> + notification);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// === Scoring ===</span></div><div class="line"></div><div class="line">        <span class="comment">// 通知有个分数排序的，分数高的排在列表前面，在 SystemUI 的显示通知列表中也靠前，我们以后再分析这个分数怎么算的</span></div><div class="line">        <span class="comment">// 0. Sanitize inputs</span></div><div class="line">        notification.priority = clamp(notification.priority, Notification.PRIORITY_MIN, Notification.PRIORITY_MAX);</div><div class="line">        <span class="comment">// Migrate notification flags to scores</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {</div><div class="line">            <span class="keyword">if</span> (notification.priority &lt; Notification.PRIORITY_MAX) notification.priority = Notification.PRIORITY_MAX;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (SCORE_ONGOING_HIGHER && <span class="number">0</span> != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {</div><div class="line">            <span class="keyword">if</span> (notification.priority &lt; Notification.PRIORITY_HIGH) notification.priority = Notification.PRIORITY_HIGH;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 1. initial score: buckets of 10, around the app </span></div><div class="line">        <span class="keyword">int</span> score = notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER; <span class="comment">//[-20..20]</span></div><div class="line"></div><div class="line">        <span class="comment">// 2. Consult external heuristics (TBD)</span></div><div class="line"></div><div class="line">        <span class="comment">// 3. Apply local rules</span></div><div class="line"></div><div class="line">        <span class="comment">// 在系统设置中，可以屏蔽掉某一个应用的通知</span></div><div class="line">        <span class="comment">// blocked apps</span></div><div class="line">        <span class="keyword">if</span> (ENABLE_BLOCKED_NOTIFICATIONS && !isSystemNotification && !areNotificationsEnabledForPackageInt(pkg)) {</div><div class="line">            score = JUNK_SCORE;</div><div class="line">            Slog.e(TAG, <span class="string">"Suppressing notification from package "</span> + pkg + <span class="string">" by user request."</span>);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (DBG) {</div><div class="line">            Slog.v(TAG, <span class="string">"Assigned score="</span> + score + <span class="string">" to "</span> + notification);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (score &lt; SCORE_DISPLAY_THRESHOLD) {</div><div class="line">            <span class="comment">// Notification will be blocked because the score is too low.</span></div><div class="line">            Slog.i(TAG, <span class="string">"Notification="</span> + notification + <span class="string">" score is low than display threshold, we don't show it."</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Should this notification make noise, vibe, or use the LED?</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canInterrupt = (score &gt;= SCORE_INTERRUPTION_THRESHOLD);</div><div class="line"></div><div class="line">        <span class="comment">// 喜闻乐见的 SS 业务函数多线程同步锁</span></div><div class="line">        <span class="keyword">synchronized</span> (mNotificationList) {</div><div class="line">            <span class="comment">// 这里用发通知 app的包名、通知的 tag、id、app 的 uid、app 的 pid、</span></div><div class="line">            <span class="comment">// app 的用户 id 和 Notiifcaiton 构造出一个 NotiifcationRecord（nr）</span></div><div class="line">            NotificationRecord r = <span class="keyword">new</span> NotificationRecord(pkg, tag, id,  </div><div class="line">                    callingUid, callingPid, userId,</div><div class="line">                    score,</div><div class="line">                    notification);</div><div class="line">            NotificationRecord old = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 这里去看之前应用有没有发送过相同的通知（通过前面的标示区分）</span></div><div class="line">            <span class="keyword">int</span> index = indexOfNotificationLocked(pkg, tag, id, userId);</div><div class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) { </div><div class="line">                <span class="comment">// 如果是新通知就加入到 NR 列表中</span></div><div class="line">                mNotificationList.add(r);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 如果原来有，取出来原来的，顺带把原来的从 list 删掉，再把新的加进去 -_-||</span></div><div class="line">                old = mNotificationList.remove(index);</div><div class="line">                mNotificationList.add(index, r);</div><div class="line">                <span class="comment">// Make sure we don't lose the foreground service state.</span></div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span>) {</div><div class="line">                    notification.flags |=</div><div class="line">                        old.notification.flags&Notification.FLAG_FOREGROUND_SERVICE;</div><div class="line">                }    </div><div class="line">            }   </div><div class="line">            </div><div class="line">            <span class="comment">// Ensure if this is a foreground service that the proper additional</span></div><div class="line">            <span class="comment">// flags are set.</span></div><div class="line">            <span class="keyword">if</span> ((notification.flags&Notification.FLAG_FOREGROUND_SERVICE) != <span class="number">0</span>) {</div><div class="line">                notification.flags |= Notification.FLAG_ONGOING_EVENT</div><div class="line">                        | Notification.FLAG_NO_CLEAR;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> currentUser;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                currentUser = ActivityManager.getCurrentUser();</div><div class="line">            } <span class="keyword">finally</span> {</div><div class="line">                Binder.restoreCallingIdentity(token);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (notification.icon != <span class="number">0</span>) {</div><div class="line">                <span class="comment">// 通过和构造 NR 差不多的东西构造出一个 StatusBarNotification(sbn)</span></div><div class="line">                <span class="keyword">final</span> StatusBarNotification n = <span class="keyword">new</span> StatusBarNotification(</div><div class="line">                        pkg, id, tag, r.uid, r.initialPid, score, notification, user);</div><div class="line">                <span class="comment">// 判断下原来的和新的是不是同一样，通过以前通知保存的 SBMS 返回的 IBinder 来判断</span></div><div class="line">                <span class="comment">// 如果是一样的话那么调用 SBMS 的 updateNotification</span></div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span> && old.statusBarKey != <span class="keyword">null</span>) {</div><div class="line">                    r.statusBarKey = old.statusBarKey;</div><div class="line">                    <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        mStatusBar.updateNotification(r.statusBarKey, n);</div><div class="line">                    }</div><div class="line">                    <span class="keyword">finally</span> {</div><div class="line">                        Binder.restoreCallingIdentity(identity);</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// 如果是新发送的通知，那么调用 SBMS 的 addNotification 添加通知</span></div><div class="line">                    <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        <span class="comment">// NR 保存一下 SBMS 返回的 IBinder(Bp)</span></div><div class="line">                        r.statusBarKey = mStatusBar.addNotification(n);</div><div class="line">                        <span class="keyword">if</span> ((n.notification.flags & Notification.FLAG_SHOW_LIGHTS) != <span class="number">0</span></div><div class="line">                                && canInterrupt) {</div><div class="line">                            mAttentionLight.pulse();</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                    <span class="keyword">finally</span> {</div><div class="line">                        Binder.restoreCallingIdentity(identity);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="comment">// Send accessibility events only for the current user.</span></div><div class="line">                <span class="keyword">if</span> (currentUser == userId) {</div><div class="line">                    sendAccessibilityEvent(notification, pkg);</div><div class="line">                }  </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 对于没有设置 icon 的通知，当作 cancel 来处理（删掉通知）</span></div><div class="line">                Slog.e(TAG, <span class="string">"Ignoring notification with icon==0: "</span> + notification);</div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span> && old.statusBarKey != <span class="keyword">null</span>) {</div><div class="line">                    <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        mStatusBar.removeNotification(old.statusBarKey);</div><div class="line">                    }</div><div class="line">                    <span class="keyword">finally</span> {</div><div class="line">                        Binder.restoreCallingIdentity(identity);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"><span class="comment">// 下面还有一串，不过和发送关系不太大，我们先忽略</span></div><div class="line">... ...</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">        idOut[<span class="number">0</span>] = id;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>NMS 处理通知的函数一开始是一些检测性的工作（其实很多 SS 的业务函数一开始都是一些检测工作）。我们稍微看下 checkCallerIsSystemOrSameApp：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> checkCallerIsSystemOrSameApp(String pkg) {</div><div class="line">    <span class="comment">// 获取 IPC 调用者（发送通知的应用）的 uid</span></div><div class="line">    <span class="keyword">int</span> uid = Binder.getCallingUid();</div><div class="line">    <span class="comment">// 如果是系统应用（uid 0 是 root 组），那么可以向所有用户发送通知</span></div><div class="line">    <span class="keyword">if</span> (UserHandle.getAppId(uid) == Process.SYSTEM_UID || uid == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 如果发送通知的应用（普通应用）的 uid 不属于当前用户，那么不允许发送</span></div><div class="line">        ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(</div><div class="line">                pkg, <span class="number">0</span>, UserHandle.getCallingUserId());</div><div class="line">        <span class="keyword">if</span> (!UserHandle.isSameApp(ai.uid, uid)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Calling uid "</span> + uid + <span class="string">" gave package"</span></div><div class="line">                    + pkg + <span class="string">" which is owned by uid "</span> + ai.uid);</div><div class="line">        }</div><div class="line">    } <span class="keyword">catch</span> (RemoteException re) { </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unknown package "</span> + pkg + <span class="string">"\n"</span> + re);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里可以看得出系统在多用户方面做的一些限制操作。然后 NMS 这里使用的数据结构是 NotificationRecrod，然后 NMS 是用一个 ArrayList 来保存的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* {@hide} */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">INotificationManager</span>.<span class="title">Stub</span></span></div><div class="line"><span class="class"></span>{</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;NotificationRecord&gt; mNotificationList =</div><div class="line">            <span class="keyword">new</span> ArrayList&lt;NotificationRecord&gt;();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationRecord</span></span></div><div class="line"><span class="class">    </span>{</div><div class="line">        <span class="keyword">final</span> String pkg;</div><div class="line">        <span class="keyword">final</span> String tag;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> uid;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> initialPid;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId;</div><div class="line">        <span class="keyword">final</span> Notification notification;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> score;</div><div class="line">        IBinder statusBarKey;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里会判断一下之前应用有没有发送相同标志的通知（indexOfNotificationLocked 前面有贴代码），如果有的话从 NR list 中删掉原来的，再插入新的，如果没有的话直接插入新的。然后再构造出一个 StatusBarNotifcation。注意一下这个数据结构虽然在 NMS 中 new 了出来，但是是在 SBMS 中使用的，这里只是为了传递给 SBMS 而已（SBMS 提供的接口的参数是 sbn），所以 NMS 中只是持有 NR 的数据而已，sbn 在这里这是临时数据。然后根据 indexOfNotificationLocked 的结果是否已经存在 NR 记录会调用 SBMS 不同的接口，如果有会调用 updateNotification，新通知的话会调用 addNotification。这里我们先以新通知来分析，所以到这里就到 SBMS 中了去。细心的会发现在我流程图中 NMS 到 SBMS 那里没有标 IPC 而是标了 Bn（表示本地）。这是因为 NMS 和 SBMS 都是在 SS（SystemServer）进程中的（忘记了的去 Binder 篇复习下），所以它之间可以直接持有对方的对象直接调用相关的接口，无需跨进程。同时 SBMS 提供的 IPC 接口只是占本身接口的一小部分的（aidl 中的），这里调用的接口是没在 aidl 中申明的，所以别的进程只能使用 SMBS 很有限的一部分功能。可以说这里 NMS 转到 SBMS 属于 SS 内部的功能。</p>
<ul>
<li><strong>3.StatusBarManagerService</strong><br>现在从 NMS 转到 SBMS 中的 addNotification 中了：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusBarManagerService</span> <span class="keyword">extends</span> <span class="title">IStatusBarService</span>.<span class="title">Stub</span> </span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">WindowManagerService</span>.<span class="title">OnHardKeyboardStatusChangeListener</span></span></div><div class="line"><span class="class"></span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"StatusBarManagerService"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SPEW = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Context mContext;</div><div class="line">    <span class="keyword">final</span> WindowManagerService mWindowManager;</div><div class="line">    Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line">    NotificationCallbacks mNotificationCallbacks;</div><div class="line">    <span class="keyword">volatile</span> IStatusBar mBar;</div><div class="line">    StatusBarIconList mIcons = <span class="keyword">new</span> StatusBarIconList();</div><div class="line">    <span class="comment">// 保存数据结构的是一个 HashMap</span></div><div class="line">    HashMap&lt;IBinder,StatusBarNotification&gt; mNotifications</div><div class="line">            = <span class="keyword">new</span> HashMap&lt;IBinder,StatusBarNotification&gt;();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> IBinder <span class="title">addNotification</span>(StatusBarNotification notification) {</div><div class="line">        <span class="keyword">synchronized</span> (mNotifications) {</div><div class="line">            <span class="comment">// 生成 NotificationRecord 的 Binder 对象</span></div><div class="line">            IBinder key = <span class="keyword">new</span> Binder();    </div><div class="line">            mNotifications.put(key, notification);</div><div class="line">            <span class="keyword">if</span> (mBar != <span class="keyword">null</span>) {            </div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    mBar.addNotification(key, notification);</div><div class="line">                } <span class="keyword">catch</span> (RemoteException ex) { </div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> key;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数非常简单，因为这里的 SBMS 其实只是起到一个桥接作用，大部分工作在提供了 IStatusBar 接口的 SystemUI 中。不过虽然简单这里 SBMS 还是持有了一个数据结构：StatusBarNotification：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Class encapsulating a Notification. Sent by the NotificationManagerService to the IStatusBar (in System UI).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusBarNotification</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String pkg;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> id; </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String tag;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> uid;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> initialPid;</div><div class="line">    <span class="comment">// TODO: make this field private and move callers to an accessor that</span></div><div class="line">    <span class="comment">// ensures sourceUser is applied.</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Notification notification;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> score;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> UserHandle user;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看到这里 StatusBarNotification 也是支持 Parcelable，不过构造的地方是在 NMS 中（前面 NMS 那里传过来的）。然后 SBMS 保存 sbn 的是一个 HashMap，以这条新通知的 IBinder 对象作为 key。这里的 IBinder 在 SBMS 这里本地生成，所以是 Bn，所以通知的 IBinder 对象在 SS 中都是 Bn 来的。这个 key 被返回给 NMS 同时保存在这条记录对应的 NotificationRecord 的 statusBarKey 中。到后面 SystemUI 中标示通知 view 相关对象的时候也是拿一个 IBinder 对象区分的。 </p>
<p>然后直接调用 SBMS 的 IstatusBar 对象的 addNotification 函数去 SystemUI 中去处理通知 UI 表现相关的东西去了。</p>
<ul>
<li><strong>4.SystemUI</strong></li>
</ul>
<p>上面说到 SBMS 有一个 IStatusBar 对象。前面说了 SystemUI 的多 UI 风格，这里就是抽象地方表现之一。SystemUI 抽象了一个状态栏的抽象基类： BaseStatusBar 然后定义了一系列状态栏的功能接口，只要实现了这些接口，那么可以表现出不同的 UI 风格（”小屏”手机，大屏平板，超大屏电视等）。其中抽象出一个 IStatusBar 的 IBinder 接口提供 SS 中的服务调用 SystemUI 相关的接口，让 SystemUI 在 UI 上展现一条通知。然后 BaseStatusBar 的具体子类只要能满足 SS 中（具体是 SBMS）的接口需求就行。所以 BaseStatusBar 中在状态栏初始化的时候会向 SBMS 注册当前实现 IStatusBar 接口的对象（当前使用的 UI 风格）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================= BaseStatusBar.java ========================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>() {</div><div class="line">        mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">        mWindowManagerService = WindowManagerGlobal.getWindowManagerService();</div><div class="line">        mDisplay = mWindowManager.getDefaultDisplay();</div><div class="line">        </div><div class="line">        <span class="comment">// 向 SM 获取 SBMS</span></div><div class="line">        mBarService = IStatusBarService.Stub.asInterface(</div><div class="line">                ServiceManager.getService(Context.STATUS_BAR_SERVICE));</div><div class="line"></div><div class="line">        <span class="comment">// Connect in to the status bar manager service</span></div><div class="line">        StatusBarIconList iconList = <span class="keyword">new</span> StatusBarIconList();</div><div class="line">        ArrayList&lt;IBinder&gt; notificationKeys = <span class="keyword">new</span> ArrayList&lt;IBinder&gt;();</div><div class="line">        ArrayList&lt;StatusBarNotification&gt; notifications = <span class="keyword">new</span> ArrayList&lt;StatusBarNotification&gt;();</div><div class="line">        mCommandQueue = <span class="keyword">new</span> CommandQueue(<span class="keyword">this</span>, iconList);</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] switches = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</div><div class="line">        ArrayList&lt;IBinder&gt; binders = <span class="keyword">new</span> ArrayList&lt;IBinder&gt;();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 调用 SBMS 的注册接口注册</span></div><div class="line">            mBarService.registerStatusBar(mCommandQueue, iconList, notificationKeys, notifications,</div><div class="line">                    switches, binders);</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">            <span class="comment">// If the system process isn't there we're doomed anyway.</span></div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后你发现其实注册的不是 BaseStatusBar 自己，而是一个叫 CommandQueue 的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================= CommandQueue.java ========================</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This class takes the functions from IStatusBar that come in on</span></div><div class="line"><span class="comment"> * binder pool threads and posts messages to get them onto the main</span></div><div class="line"><span class="comment"> * thread, and calls onto Callbacks.  It also takes care of</span></div><div class="line"><span class="comment"> * coalescing these calls so they don't stack up.  For the calls</span></div><div class="line"><span class="comment"> * are coalesced, note that they are all idempotent.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandQueue</span> <span class="keyword">extends</span> <span class="title">IStatusBar</span>.<span class="title">Stub</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_MASK = <span class="number">0xffff</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SHIFT  = <span class="number">16</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_MASK   = <span class="number">0xffff</span> &lt;&lt; MSG_SHIFT;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_SET_ICON    = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_REMOVE_ICON = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_ICON                       = <span class="number">1</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_ADD_NOTIFICATION           = <span class="number">2</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_UPDATE_NOTIFICATION        = <span class="number">3</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_REMOVE_NOTIFICATION        = <span class="number">4</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_DISABLE                    = <span class="number">5</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_EXPAND_NOTIFICATIONS       = <span class="number">6</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_COLLAPSE_PANELS            = <span class="number">7</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_EXPAND_SETTINGS            = <span class="number">8</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SET_SYSTEMUI_VISIBILITY    = <span class="number">9</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_TOP_APP_WINDOW_CHANGED     = <span class="number">10</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SHOW_IME_BUTTON            = <span class="number">11</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SET_HARD_KEYBOARD_STATUS   = <span class="number">12</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_TOGGLE_RECENT_APPS         = <span class="number">13</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_PRELOAD_RECENT_APPS        = <span class="number">14</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_CANCEL_PRELOAD_RECENT_APPS = <span class="number">15</span> &lt;&lt; MSG_SHIFT;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SET_NAVIGATION_ICON_HINTS  = <span class="number">16</span> &lt;&lt; MSG_SHIFT;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> StatusBarIconList mList;</div><div class="line">    <span class="keyword">private</span> Callbacks mCallbacks;</div><div class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> H();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 这里的 interface 的接口，正好全是 IStatusBar.aidl 中的接口</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * These methods are called back on the main thread.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callbacks</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex, StatusBarIcon icon);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex,</div><div class="line">                StatusBarIcon old, StatusBarIcon icon);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIcon</span>(String slot, <span class="keyword">int</span> index, <span class="keyword">int</span> viewIndex);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNotification</span>(IBinder key, StatusBarNotification notification);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNotification</span>(IBinder key, StatusBarNotification notification);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNotification</span>(IBinder key);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disable</span>(<span class="keyword">int</span> state);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animateExpandNotificationsPanel</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animateCollapsePanels</span>(<span class="keyword">int</span> flags);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animateExpandSettingsPanel</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemUiVisibility</span>(<span class="keyword">int</span> vis, <span class="keyword">int</span> mask);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topAppWindowChanged</span>(<span class="keyword">boolean</span> visible);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImeWindowStatus</span>(IBinder token, <span class="keyword">int</span> vis, <span class="keyword">int</span> backDisposition);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardKeyboardStatus</span>(<span class="keyword">boolean</span> available, <span class="keyword">boolean</span> enabled);</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toggleRecentApps</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preloadRecentApps</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showSearchPanel</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideSearchPanel</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelPreloadRecentApps</span>();</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNavigationIconHints</span>(<span class="keyword">int</span> hints);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">CommandQueue</span>(Callbacks callbacks, StatusBarIconList list) {</div><div class="line">        mCallbacks = callbacks;</div><div class="line">        mList = list;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNotification</span>(IBinder key, StatusBarNotification notification) {</div><div class="line">        <span class="keyword">synchronized</span> (mList) {</div><div class="line">            NotificationQueueEntry ne = <span class="keyword">new</span> NotificationQueueEntry();</div><div class="line">            ne.key = key;</div><div class="line">            ne.notification = notification;</div><div class="line">            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_ADD_NOTIFICATION, <span class="number">0</span>, <span class="number">0</span>, ne), <span class="number">300</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> what = msg.what & MSG_MASK;</div><div class="line">            <span class="keyword">switch</span> (what) {</div><div class="line">... ...</div><div class="line">                <span class="keyword">case</span> MSG_ADD_NOTIFICATION: {   </div><div class="line">                    <span class="keyword">final</span> NotificationQueueEntry ne = (NotificationQueueEntry)msg.obj;</div><div class="line">                    mCallbacks.addNotification(ne.key, ne.notification);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">... ...</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ================= BaseStatusBar.java ========================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatusBar</span> <span class="keyword">extends</span> <span class="title">SystemUI</span> <span class="keyword">implements</span></span></div><div class="line"><span class="class">        <span class="title">CommandQueue</span>.<span class="title">Callbacks</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看完上面的代码，就知道 SystemUI 中状态栏的设计架构了吧。就是说 IStatusBar.aidl 定义一系列接口给 SS 用，然后 BaseStatusBar 完成一些状态栏公用的工作（例如生成 notification row 的模板），其他的接口交由子类实现。这里我们以 PhoneStatusBar（好像 4.4 之后 android 原生的 UI 都是用这个了，想看 Tablet UI 的可以拿 4.2 玩一下） 来说明一下 addNotification 的流程。</p>
<p>SBMS IPC 调用 addNotification 之后把通知的 IBinder key 和 sbn 传了过来，我们来看下 PhoneStatusBar 中的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNotification</span>(IBinder key, StatusBarNotification notification) {</div><div class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"addNotification score="</span> + notification.score);</div><div class="line">    <span class="comment">// 大部分工作在这里</span></div><div class="line">    StatusBarIconView iconView = addNotificationViews(key, notification);</div><div class="line">    <span class="keyword">if</span> (iconView == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> immersive = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        immersive = ActivityManagerNative.getDefault().isTopActivityImmersive();</div><div class="line">        <span class="keyword">if</span> (DEBUG) {</div><div class="line">            Slog.d(TAG, <span class="string">"Top activity is "</span> + (immersive?<span class="string">"immersive"</span>:<span class="string">"not immersive"</span>));</div><div class="line">        }    </div><div class="line">    } <span class="keyword">catch</span> (RemoteException ex) {}</div><div class="line"></div><div class="line">    <span class="comment">// 如果通知设置了 fullScreenIntent，执行 fullScreenIntent 中设置的动作</span></div><div class="line">    <span class="comment">//（启动相应的 activity 或是发送相应的广播）</span></div><div class="line">    <span class="keyword">if</span> (notification.notification.fullScreenIntent != <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// Stop screensaver if the notification has a full-screen intent.</span></div><div class="line">        <span class="comment">// (like an incoming phone call)</span></div><div class="line">        awakenDreams();</div><div class="line"></div><div class="line">        <span class="comment">// not immersive & a full-screen alert should be shown</span></div><div class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Notification has fullScreenIntent; sending fullScreenIntent"</span>);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            notification.notification.fullScreenIntent.send();</div><div class="line">        } <span class="keyword">catch</span> (PendingIntent.CanceledException e) { </div><div class="line">        }    </div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// usual case: status bar visible & not immersive</span></div><div class="line"></div><div class="line">        <span class="comment">// 如果没指定 fullScreenIntent 那么在状态栏上展现一下 ticker 动画</span></div><div class="line">        <span class="comment">// show the ticker if there isn't an intruder too</span></div><div class="line">        <span class="keyword">if</span> (mCurrentlyIntrudingNotification == <span class="keyword">null</span>) {</div><div class="line">            tick(<span class="keyword">null</span>, notification, <span class="keyword">true</span>);</div><div class="line">        }    </div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="comment">// Recalculate the position of the sliding windows and the titles.</span></div><div class="line">    setAreThereNotifications();</div><div class="line">    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里一开始就调用了基类 BaseStatusBar 中的 addNotificationViews 函数，这个函数就属于状态栏的共用函数之一，通知在 SystemUI 上的 UI 元素基本上都由这个函数生成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> StatusBarIconView <span class="title">addNotificationViews</span>(IBinder key,</div><div class="line">        StatusBarNotification notification) {</div><div class="line">    <span class="keyword">if</span> (DEBUG) {</div><div class="line">        Slog.d(TAG, <span class="string">"addNotificationViews(key="</span> + key + <span class="string">", notification="</span> + notification);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 构造状态栏小图标</span></div><div class="line">    <span class="comment">// Construct the icon.</span></div><div class="line">    <span class="keyword">final</span> StatusBarIconView iconView = <span class="keyword">new</span> StatusBarIconView(mContext,</div><div class="line">            notification.pkg + <span class="string">"/0x"</span> + Integer.toHexString(notification.id),</div><div class="line">            notification.notification);</div><div class="line">    iconView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);</div><div class="line">    </div><div class="line">    <span class="comment">// 构造状态栏小图标对应数据 -_-||            </span></div><div class="line">    <span class="keyword">final</span> StatusBarIcon ic = <span class="keyword">new</span> StatusBarIcon(notification.pkg,</div><div class="line">                notification.user,</div><div class="line">                notification.notification.icon,</div><div class="line">                notification.notification.iconLevel,</div><div class="line">                notification.notification.number,</div><div class="line">                notification.notification.tickerText);</div><div class="line">    <span class="comment">// 把数据设置给状态栏小图标</span></div><div class="line">    <span class="keyword">if</span> (!iconView.set(ic)) {</div><div class="line">        handleNotificationError(key, notification, <span class="string">"Couldn't create icon: "</span> + ic);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 构造 SystemUI 通知数据结构</span></div><div class="line">    <span class="comment">// Construct the expanded view.</span></div><div class="line">    NotificationData.Entry entry = <span class="keyword">new</span> NotificationData.Entry(key, notification, iconView);</div><div class="line">    <span class="comment">// 构造通知面板上的通知 view，并将其加入通知面板上 </span></div><div class="line">    <span class="keyword">if</span> (!inflateViews(entry, mPile)) {</div><div class="line">        handleNotificationError(key, notification, <span class="string">"Couldn't expand RemoteViews for: "</span></div><div class="line">                + notification);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 保存通知数据</span></div><div class="line">    <span class="comment">// Add the expanded view and icon.</span></div><div class="line">    <span class="keyword">int</span> pos = mNotificationData.add(entry);</div><div class="line">    <span class="keyword">if</span> (DEBUG) {</div><div class="line">        Slog.d(TAG, <span class="string">"addNotificationViews: added at "</span> + pos);</div><div class="line">    }</div><div class="line">    updateExpansionStates();</div><div class="line">    <span class="comment">// 更新状态栏上的通知小图标（新的加入到状态栏上去）</span></div><div class="line">    updateNotificationIcons();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> iconView;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 StatusBarIconView 别看是继承了 AnimatedImageView，其实最后 AnimatedImageView 最后是继承了 ImageView，也就是说状态栏上左上角那一排通知的小图标就是一堆 ImageView（右边那一排也是一样的，不过那一排叫 Status Icon，系统状态图标，和通知小图标是不一样的东西，刚开始容易搞混，这个东西后面我单独开一篇来说）。然后后面这里就是 framework 中最后一个模块 SystemUI 中持有的通知的数据结构了 NotificationData：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The list of currently displaying notifications.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationData</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>{</div><div class="line">        <span class="keyword">public</span> IBinder key;</div><div class="line">        <span class="keyword">public</span> StatusBarNotification notification;</div><div class="line">        <span class="keyword">public</span> StatusBarIconView icon;</div><div class="line">        <span class="keyword">public</span> View row; <span class="comment">// the outer expanded view</span></div><div class="line">        <span class="keyword">public</span> View content; <span class="comment">// takes the click events and sends the PendingIntent</span></div><div class="line">        <span class="keyword">public</span> View expanded; <span class="comment">// the inflated RemoteViews</span></div><div class="line">        <span class="keyword">public</span> ImageView largeIcon;</div><div class="line">        <span class="keyword">protected</span> View expandedLarge;</div><div class="line">        <span class="keyword">public</span> <span class="title">Entry</span>() {}</div><div class="line">        <span class="keyword">public</span> <span class="title">Entry</span>(IBinder key, StatusBarNotification n, StatusBarIconView ic) {</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.notification = n;</div><div class="line">            <span class="keyword">this</span>.icon = ic; </div><div class="line">        } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 保存的数据的最后是一个 ArrayList</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Entry&gt; mEntries = <span class="keyword">new</span> ArrayList&lt;Entry&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;Entry&gt; mEntryCmp = <span class="keyword">new</span> Comparator&lt;Entry&gt;() {</div><div class="line">        <span class="comment">// sort first by score, then by when</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Entry a, Entry b) {</div><div class="line">            <span class="keyword">final</span> StatusBarNotification na = a.notification;</div><div class="line">            <span class="keyword">final</span> StatusBarNotification nb = b.notification;</div><div class="line">            <span class="keyword">int</span> d = na.score - nb.score;</div><div class="line">            <span class="keyword">return</span> (d != <span class="number">0</span>)</div><div class="line">                ? d</div><div class="line">                : (<span class="keyword">int</span>)(na.notification.when - nb.notification.when);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 它的大多数接口都是封装对上面那个 ArrayList 的操作 </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span>(Entry entry) {</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">int</span> N = mEntries.size();</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">            <span class="keyword">if</span> (mEntryCmp.compare(mEntries.get(i), entry) &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        mEntries.add(i, entry);</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个数据结构内部还有一个 Entry 类，可以看到 Entry 中不光有 sbn，还有好几个 view，这几个 view 就是 SystemUI 中一个通知的 UI 元素了。然后它的插入啊，删除啊都通过一个 Entry 的 ArrayList 来实现的。回到 addNotificationViews 中，后面有一个 inflateViews</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span>  <span class="keyword">boolean</span> <span class="title">inflateViews</span>(NotificationData.Entry entry, ViewGroup parent) {</div><div class="line">    <span class="keyword">int</span> minHeight =</div><div class="line">            mContext.getResources().getDimensionPixelSize(R.dimen.notification_min_height);</div><div class="line">    <span class="keyword">int</span> maxHeight =</div><div class="line">            mContext.getResources().getDimensionPixelSize(R.dimen.notification_max_height);</div><div class="line">    StatusBarNotification sbn = entry.notification;</div><div class="line">    <span class="comment">// oneU 是通知 normal view</span></div><div class="line">    <span class="comment">// large 是通知 big view</span></div><div class="line">    RemoteViews oneU = sbn.notification.contentView;</div><div class="line">    RemoteViews large = sbn.notification.bigContentView;</div><div class="line">    <span class="keyword">if</span> (oneU == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create the row view</span></div><div class="line">    LayoutInflater inflater = (LayoutInflater)mContext.getSystemService(</div><div class="line">            Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    <span class="comment">// new 通知的容器（notiifcation row），这个容器是模板来的。</span></div><div class="line">    <span class="comment">// 这个是用来装通知的 content view 和 big content view 的。</span></div><div class="line">    <span class="comment">// 这里注意一点：LayoutInflater 的第二参数 ViewGroup 如果不是 null 的话，那么 new 出来的 view </span></div><div class="line">    <span class="comment">// 会自动 add 到传递的 ViewGroup 中，所以这里在 new 出 notification row 后，</span></div><div class="line">    <span class="comment">// 就自动添加到前面传递过来的 mPile 中去了（这个是通知面板中显示通知的容器）。</span></div><div class="line">    View row = inflater.inflate(R.layout.status_bar_notification_row, parent, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// for blaming (see SwipeHelper.setLongPressListener)</span></div><div class="line">    row.setTag(sbn.pkg);</div><div class="line"></div><div class="line">    workAroundBadLayerDrawableOpacity(row);</div><div class="line">    View vetoButton = updateNotificationVetoButton(row, sbn);</div><div class="line">    vetoButton.setContentDescription(mContext.getString(</div><div class="line">            R.string.accessibility_remove_notification));</div><div class="line"></div><div class="line">    <span class="comment">// NB: the large icon is now handled entirely by the template</span></div><div class="line"></div><div class="line">    <span class="comment">// bind the click event to the content area</span></div><div class="line">    ViewGroup content = (ViewGroup)row.findViewById(R.id.content);</div><div class="line">    ViewGroup adaptive = (ViewGroup)row.findViewById(R.id.adaptive);</div><div class="line"></div><div class="line">    content.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);</div><div class="line"></div><div class="line">    <span class="comment">// 如果通知设置了点击动作，那么设置到通知的 view OnClick 时间中去</span></div><div class="line">    PendingIntent contentIntent = sbn.notification.contentIntent;</div><div class="line">    <span class="keyword">if</span> (contentIntent != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">final</span> View.OnClickListener listener = <span class="keyword">new</span> NotificationClicker(contentIntent,</div><div class="line">                sbn.pkg, sbn.tag, sbn.id);</div><div class="line">        content.setOnClickListener(listener);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        content.setOnClickListener(<span class="keyword">null</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// TODO(cwren) normalize variable names with those in updateNotification</span></div><div class="line">    View expandedOneU = <span class="keyword">null</span>;</div><div class="line">    View expandedLarge = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 把通知的 content view（RemoteViews）加入到 notification row</span></div><div class="line">        expandedOneU = oneU.apply(mContext, adaptive, mOnClickHandler);</div><div class="line">        <span class="comment">// 如果通知有 big content view（RemoteViews） 也一起加入 notification row</span></div><div class="line">        <span class="keyword">if</span> (large != <span class="keyword">null</span>) {</div><div class="line">            expandedLarge = large.apply(mContext, adaptive, mOnClickHandler);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">        <span class="keyword">final</span> String ident = sbn.pkg + <span class="string">"/0x"</span> + Integer.toHexString(sbn.id);</div><div class="line">        Slog.e(TAG, <span class="string">"couldn't inflate view for notification "</span> + ident, e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (expandedOneU != <span class="keyword">null</span>) {</div><div class="line">        SizeAdaptiveLayout.LayoutParams params =</div><div class="line">                <span class="keyword">new</span> SizeAdaptiveLayout.LayoutParams(expandedOneU.getLayoutParams());</div><div class="line">        params.minHeight = minHeight;</div><div class="line">        params.maxHeight = minHeight;</div><div class="line">        adaptive.addView(expandedOneU, params);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (expandedLarge != <span class="keyword">null</span>) {</div><div class="line">        SizeAdaptiveLayout.LayoutParams params =</div><div class="line">                <span class="keyword">new</span> SizeAdaptiveLayout.LayoutParams(expandedLarge.getLayoutParams());</div><div class="line">        params.minHeight = minHeight+<span class="number">1</span>;</div><div class="line">        params.maxHeight = maxHeight;</div><div class="line">        adaptive.addView(expandedLarge, params);</div><div class="line">    }</div><div class="line">    row.setDrawingCacheEnabled(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    applyLegacyRowBackground(sbn, content);</div><div class="line"></div><div class="line">    row.setTag(R.id.expandable_tag, Boolean.valueOf(large != <span class="keyword">null</span>));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (MULTIUSER_DEBUG) { </div><div class="line">        TextView debug = (TextView) row.findViewById(R.id.debug_info);</div><div class="line">        <span class="keyword">if</span> (debug != <span class="keyword">null</span>) {</div><div class="line">            debug.setVisibility(View.VISIBLE);</div><div class="line">            debug.setText(<span class="string">"U "</span> + entry.notification.getUserId());</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 设置一下 SystemUI 的通知数据</span></div><div class="line">    entry.row = row;</div><div class="line">    entry.content = content;</div><div class="line">    entry.expanded = expandedOneU;</div><div class="line">    entry.setLargeView(expandedLarge);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>要讲解的我都注释在代码里面了，这里就是稍微注意下 LayoutInflater.inflate 那里会自动把生成的 view 添加到通知面板上的通知容器中，如果第一次不注意会觉得奇怪，不知道在哪里把 notification row 加到通知面板中去的。可以看到其实 BaseStatusBar 又给通知做了一个模板套套，然后才是把应用设置（其实大多时候也是用 Notification 生成的模板）的通知的 content view 加到这个模板套套中，因为这个可以控制每一个 notification row 的大小。这样可以由系统控制最终通知显示的 UI 效果（notification row 的最后大小是由 SystemUI 决定的）。</p>
<p>这样通知面板上的 notification row 就弄好了，然后回到 addNotificationViews 中最后 updateNotificationIcons ，这个虽然不是 IStatusBar 的接口，但是 BaseStatusBar 中的抽象接口，留给子类实现的，BaseStatusBar 有好几这样的抽象几个，基本都是 UI 相关的（毕竟子类要实现不同的 UI 风格么）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">haltTicker</span>();</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setAreThereNotifications</span>();</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">updateNotificationIcons</span>();</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tick</span>(IBinder key, StatusBarNotification n, <span class="keyword">boolean</span> firstTime);</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">updateExpandedViewPos</span>(<span class="keyword">int</span> expandedPosition);</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getExpandedViewMaxHeight</span>();</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldDisableNavbarGestures</span>();</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们去 PhoneStatusBar 中看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateNotificationIcons</span>() {</div><div class="line">    <span class="keyword">if</span> (mNotificationIcons == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    loadNotificationShade();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> LinearLayout.LayoutParams params</div><div class="line">        = <span class="keyword">new</span> LinearLayout.LayoutParams(mIconSize + <span class="number">2</span>*mIconHPadding, mNaturalBarHeight);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> N = mNotificationData.size();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG) {</div><div class="line">        Slog.d(TAG, <span class="string">"refreshing icons: "</span> + N + <span class="string">" notifications, mNotificationIcons="</span> + mNotificationIcons);</div><div class="line">    }    </div><div class="line"></div><div class="line">    ArrayList&lt;View&gt; toShow = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> provisioned = isDeviceProvisioned();</div><div class="line">    <span class="comment">// If the device hasn't been through Setup, we only show system notifications</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">        Entry ent = mNotificationData.get(N-i-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (!((provisioned && ent.notification.score &gt;= HIDE_ICONS_BELOW_SCORE)</div><div class="line">                || showNotificationEvenIfUnprovisioned(ent.notification))) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span> (!notificationIsForCurrentUser(ent.notification)) <span class="keyword">continue</span>;</div><div class="line">        toShow.add(ent.icon);</div><div class="line">    }    </div><div class="line"></div><div class="line">    ArrayList&lt;View&gt; toRemove = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mNotificationIcons.getChildCount(); i++) {</div><div class="line">        View child = mNotificationIcons.getChildAt(i);</div><div class="line">        <span class="keyword">if</span> (!toShow.contains(child)) {</div><div class="line">            toRemove.add(child);</div><div class="line">        }    </div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="keyword">for</span> (View remove : toRemove) {</div><div class="line">        mNotificationIcons.removeView(remove);</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;toShow.size(); i++) {</div><div class="line">        View v = toShow.get(i);</div><div class="line">        <span class="keyword">if</span> (v.getParent() == <span class="keyword">null</span>) {</div><div class="line">            mNotificationIcons.addView(v, i, params);</div><div class="line">        }    </div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>PhoneStatusBar 中的 mNotificationIcons 是一个叫 IconMerger 的东西，这个是继承自 LinearLayout 的一个自定义的布局。叫 IconMerger 是因为它有一个功能，当通知很多（状态栏的小图标很多）的情况下，它会把显示不下的图标合并显示成一个类似 “+” 号的图标表示显示不下了。这里我们就不去细看了。然后这里也不用细说什么就是玩 ViewGroup（mNotificationIcons）添加（删除）子 view（StatusBarIconView） 而已。然后到这里 BaseStatusBar 中的 addNotificationViews 就处理完了。然后最后回到 PhoneStatusBar 的 addNotification 最后那里，如果通知设置了 fullScreenIntent 就执行相应的操作，否则展现 ticker 动画效果（效果见前面的效果的那个 ticker view）。</p>
<p>到这里一条通知的发送流程就走完了。然后这里是以发送一条新通知来说的，前面看到系统有判断如果发送的这条通知前面已经在系统中存在了，那么就会更新对应的数据（NMS，SBMS中）和对应的 SystemUI 中的 UI 元素（会去通知容器中去找），鉴于这篇已经很长了，后面单独开一篇来说更新的事吧。</p>
<p>然后最后总结一下：这里涉及到系统里面的3个模块：NMS，SBMS 和 SystemUI。其中 NMS 直接是管理通知服务的，SBMS 是界面（SystemUI）系统功能（通知等）桥接，应用通过系统功能的接口（例如 NMS）使用系统提供的一系列 UI 接口。然后这些系统接口再通过系统界面的桥接（SBMS）让界面系统（SystemUI）展现相关 UI 元素（视图和控制分工明确，可以学习一下 android 的设计）。最后我们来列下相关模块的对应的数据结构（第一次看还是有点晕的）：</p>
<pre>
App                        --> Notification
NotificationManagerService --> mNotificationList (ArrayList<notificationrecord>)
StatusBarManagerService    --> mNotifications (HashMap<ibinder, statusbarnotification="">)
SystemUI                   --> mNotificationData(NotificationData.Entry[ArrayList])
                            |--> StatusBarIconView(StatusBarIcon)
                            |--> notification row
                            |--> Ticker
</ibinder,></notificationrecord></pre>

<h2 id="小技巧">小技巧</h2>
<p>看完上面流程分析，大家应该会发现默认状态栏的小图标和通知 content view 那个显示的图标都是用 Notification 的 icon 的，就是默认是一样的。但是有些时候想让它们不一样，没有没办法咧，仔细看上面的代码会发现方法是用的。因为 content view 在 Notification build 那里创建，而且 SystemUI 状态栏上的 StatusBarIconView 是在 SystemUI 这边创建的（NM 发送 notify 后），那么我们就有曲线救国的方法了：那就是在构造 Notification 的 content view 前把 icon 设置为 content view 想要的图标（如果不使用 Builder 就是在调用 setLatestEventInfo 前，如果使用 Builder 的话在 Builder 的接口中设），然后再改为状态栏想要的图标，最后再调用 notify 就行咯（大家看到我贴的效果图的这2个图标是不一样的了没，这里我可是没改系统实现的哦）。哎，还是上下代码比较直接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NotificationManager nm = (NotificationManager)getSystemService(</div><div class="line">    Context.NOTIFICATION_SERVICE);</div><div class="line">Notification n = <span class="keyword">new</span> Notification(</div><div class="line">    <span class="comment">// 这里先设置通知面板那通知要显示的图标</span></div><div class="line">    R.drawable.stat_sys_data_usb, </div><div class="line">    label, System.currentTimeMillis());</div><div class="line"><span class="comment">// 然后构造 content view 设置 notification row 那的图标</span></div><div class="line">n.setLatestEventInfo(<span class="keyword">this</span>, label, </div><div class="line">    <span class="string">"No. "</span> + ID + <span class="string">": info This is just for test notification bar info"</span>,</div><div class="line">    intent);</div><div class="line"><span class="comment">// 然后马上把 icon 改成状态栏想要显示的小图标</span></div><div class="line">n.icon = R.drawable.stat_sys_data_usb_small;</div><div class="line"><span class="comment">// 最后用 NM 发送通知，这样在 SystemUI 那生成的 StatusBarIcon 就和通知面板上的图标不一样了</span></div><div class="line">nm.notify(ID, n);</div><div class="line"></div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/02/06/Android%20SystemUI%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%9C%80%E8%BF%91%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/</loc>
    <lastmod>2015-02-06T02:15:16.000Z</lastmod>
    <data>
        <display>
        <title>Android SystemUI 分析——最近任务列表</title>
        <pubTime>2015-02-06T02:15:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Android 4.1 SystemUI 的最近任务列表和 4.2 的区别还是很大的。4.1 的是一个 BAR_PANEL，是一个 view 添加到 window manager 里面 show 出来的。4.2 变成了依附一个 Activity 了（其实都是 window）。功能上的影响的话，由于 4.2 最近任务列表是 activity ，所以当前的 activity 会 onPause。视觉上的不一样， 4.2 如果在非桌面调用最近任务列表，会有一个当前 activity 缩小到最近任务列表的动画（旁边的 icon 也会有一个跳动的动画）。还有一点，4.2 最近任务列表 activity 设置了 wallpaper 属性，所以背景是 wallpaper，不再像以前一样能透过看下当前的任务了，另外如果当前设置的是动态壁纸，背景就是黑的（不仅仅动态壁纸在 wallpaper 属性的 activity 背景有问题，在代码里都地方检测了，如果是动态壁纸，就强制设为黑色）。列下源码位置： framework/base/packages/SystemUI/src/com/android/systemui/recent 这个文件夹下， 对应的 xml 文件在代码里也能看得出。</p>
<h2 id="UI">UI</h2>
<p>4.2 虽然包了一层 activity 但是主要功能还是和 4.1 类似，在原来的 RecentsPanelView.java 中。</p>
<ul>
<li><p><strong>RecentsPanelView.java</strong><br>这个 view 就是最近任务列表的主界面。里面主要是有一个自定义的 ScrollView 。这个 view 里面会负责完成一些动画（上面说那个图标跳动动画，注意那个当前任务缩小的动画不是在这里做的）， 自定义 ScrollView adapter 的实现（这个自定义 ScrollView 有点仿 ListView，使用到了 adapter），一些后台数据加载的回调（刷新界面），一些交互回调的实现（点击、长按、滑动删除 item），提供一些 show、hide、refresh 接口给 activity 使用。</p>
</li>
<li><p><strong>RecentsVerticalScrollView.java</strong><br>这个自定义 ScrollView 主要是为了下面一些定制：滑动删除，类似 ListView 的优化（adapter 机制），自定义的 overscroll fade 效果。滑动删除是类似 webos 的卡片式任务列表的操作。android 为了做这个效果，在 xml 中把 android:clipChildren 和 android:clipToPadding 这2个属性设置为 false 了。这样 ScrollView 的 item 就能超出自身的 view 范围，能够“滑”出去了。还有一个 RecentsHorizontalScrollView.java 和这个是类似的，只不过是横屏的而已。</p>
</li>
<li><p><strong>RecentsScrollViewPerformanceHelper.java</strong><br>这个是给自定义的 ScrollView 画 over scroll 的 fade 效果的。在 drawCallback 里面。不过好像也有一些绘制上的优化，还没具体分析。</p>
</li>
<li><p><strong>StatusBarTouchProxy.java</strong><br>这个东西挺无聊的。android 在 RecentsPanelView 的顶部（navigation bar 在底部）加了一条和 navigation bar 一样高的 view（看不到，但是也可以点得到），然后把在这个 view 上 touch event 转发到 navigation bar 上去，这样点击上面也就相当于点击 navigation bar。所以叫 touch proxy，是挺无聊的。</p>
</li>
</ul>
<h2 id="数据">数据</h2>
<p>未完，待续 … … （估计不会填这个坑鸟）</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/22/Android%20Broadcast%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8F%91%E9%80%81%E3%80%81%E5%A4%84%E7%90%86/</loc>
    <lastmod>2015-02-05T02:15:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Broadcast 分析——发送、处理</title>
        <pubTime>2015-01-22T02:15:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>上一篇分析了广播的注册流程，这篇来分析下广播的发送、处理流程。这里为什么把发送和处理和来一起说咧，那是因为其实这是一个过程，发送接口里面差不多就是处理过程了。我们先照例把相关代码位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Content 广播相关的代码</span></div><div class="line">frameworks/base/core/java/android/app/ContextImpl.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line">frameworks/base/core/java/android/app/ActivityThread.java</div><div class="line"></div><div class="line">frameworks/base/core/java/android/content/Intent.java</div><div class="line">frameworks/base/core/java/android/content/IntentFilter.java</div><div class="line">frameworks/base/core/java/android/content/BroadcastReceiver.java</div><div class="line">frameworks/base/core/java/android/content/IIntentReceiver.aidl</div><div class="line"></div><div class="line"><span class="comment"># 广播解析相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/IntentResolver.java</div><div class="line"></div><div class="line"><span class="comment"># AM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/RecevierList.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastQueue.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastFilter.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastRecord.java</div><div class="line"></div><div class="line"><span class="comment"># PM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后把处理流程贴张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Broadcast-send/broadcast-send.png" alt=""><br>(这个图很夸张吧，拉一下本篇的滚动条就知道为啥这么夸张了；本来想分情况画几张的，画到后面还是合在一起了)</p>
<h2 id="发送接口">发送接口</h2>
<h3 id="应用接口">应用接口</h3>
<p>普通应用发送广播的接口和注册篇注册的一样，都在 Context 里面，但是实现在 ContextImpl 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span>(Intent intent) { </div><div class="line">    warnIfCallingFromSystemProcess();</div><div class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        intent.setAllowFds(<span class="keyword">false</span>);     </div><div class="line">        ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">            mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</div><div class="line">            Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</div><div class="line">            getUserId());</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里我们看最简单，也是最常见的那种，直接一个 Intent 发出去的。其实最后是调用到 AMS 里面的同名接口（前面一篇说过了，广播的处理是在 AMS 中的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span>(IApplicationThread caller,</div><div class="line">        Intent intent, String resolvedType, IIntentReceiver resultTo,</div><div class="line">        <span class="keyword">int</span> resultCode, String resultData, Bundle map,</div><div class="line">        String requiredPermission, <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId) {</div><div class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">        intent = verifyBroadcastLocked(intent);</div><div class="line"></div><div class="line">        <span class="comment">// 获取调用者的进程相关信息</span></div><div class="line">        <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">        <span class="comment">// 下面这个带 Locked 的函数才是关键</span></div><div class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</div><div class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>, </div><div class="line">                intent, resolvedType, resultTo,</div><div class="line">                resultCode, resultData, map, requiredPermission, serialized, sticky,</div><div class="line">                callingPid, callingUid, userId);</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    }     </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 里面的这个接口，有一个 boolean 参数 serialized（还有个 sticky 的，我们不管这个 stciky）。true 的话，表示发送的串行广播，false 表示发送并行广播。串行广播就是说，一个广播来了，有一对接收器， AMS 会等前一个执行完，才会发给下一个处理，<strong>接收器处理广播是一个接着一个处理的</strong>。并行的就是 AMS 把广播发给一个接收器之后，会马上返回，然后再发给下一个，直到发送完，<strong>接收器处理广播是并行的（同时处理）</strong>。用简单参数的接口，<strong>默认发送的是并行广播</strong>。</p>
<p>回到接口上，加了多线程互斥锁之后，调用 broadcastIntentLocked 处理。这个函数就是看名字是发送广播（Intent），其实就是处理过程，而且非常长，我们发到后面慢慢说。</p>
<h3 id="系统发送接口">系统发送接口</h3>
<p>我们来看看系统是怎么发送的。我们以前面说的 BOOT_COMPLETED 广播来看。这个广播是 AMS 中发出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> finishBooting() {</div><div class="line">        IntentFilter pkgFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">        pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</div><div class="line">        pkgFilter.addDataScheme(<span class="string">"package"</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="comment">// Ensure that any processes we had put on hold are now started</span></div><div class="line">            <span class="comment">// up.</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {</div><div class="line">                <span class="comment">// Start looking for apps that are abusing wake locks.</span></div><div class="line">                Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</div><div class="line">                mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</div><div class="line">                <span class="comment">// Tell anyone interested that we are done booting!</span></div><div class="line">                SystemProperties.set(<span class="string">"sys.boot_completed"</span>, <span class="string">"1"</span>);</div><div class="line">                SystemProperties.set(<span class="string">"dev.bootcomplete"</span>, <span class="string">"1"</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mStartedUsers.size(); i++) {</div><div class="line">                    UserStartedState uss = mStartedUsers.valueAt(i);</div><div class="line">                    <span class="keyword">if</span> (uss.mState == UserStartedState.STATE_BOOTING) {</div><div class="line">                        uss.mState = UserStartedState.STATE_RUNNING;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> userId = mStartedUsers.keyAt(i);</div><div class="line">                        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_BOOT_COMPLETED, <span class="keyword">null</span>);</div><div class="line">                        intent.putExtra(Intent.EXTRA_USER_HANDLE, userId);</div><div class="line">                        <span class="comment">// AMS 里面自己发，直接调用这个函数了</span></div><div class="line">                        <span class="comment">// serialized 是 false，这个是一个并行广播</span></div><div class="line">                        broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</div><div class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                                android.Manifest.permission.RECEIVE_BOOT_COMPLETED,</div><div class="line">                                <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, userId);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 里面自己发广播，直接调用 broadcastIntentLocked 了。估计其他系统服务里面还是调用 AMS 的 broadcastIntent 接口的吧。</p>
<p>接下来说下广播处理流程。AMS 中处理广播的流程就是 broadcastIntentLocked 这个函数，这个函数也是非常长的（差不多6、7百行），我们分段慢慢来（会跳过一些非重要的部分）：</p>
<h2 id="a-_收集广播接收器">a. 收集广播接收器</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span>(ProcessRecord callerApp,</div><div class="line">            String callerPackage, Intent intent, String resolvedType,</div><div class="line">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">            Bundle map, String requiredPermission,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</div><div class="line">            <span class="keyword">int</span> userId) {</div><div class="line">        intent = <span class="keyword">new</span> Intent(intent);</div><div class="line"></div><div class="line">        <span class="comment">// By default broadcasts do not go to stopped apps.</span></div><div class="line">        intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(</div><div class="line">            TAG, (sticky ? <span class="string">"Broadcast sticky: "</span>: <span class="string">"Broadcast: "</span>) + intent</div><div class="line">            + <span class="string">" ordered="</span> + ordered + <span class="string">" userid="</span> + userId);</div><div class="line">        <span class="keyword">if</span> ((resultTo != <span class="keyword">null</span>) && !ordered) {</div><div class="line">            Slog.w(TAG, <span class="string">"Broadcast "</span> + intent + <span class="string">" not ordered but result callback requested!"</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 获取用户信息（用户中，不同用户的广播是分开的）</span></div><div class="line">        userId = handleIncomingUser(callingPid, callingUid, userId,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"broadcast"</span>, callerPackage);</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that the user who is receiving this broadcast is started.</span></div><div class="line">        <span class="comment">// If not, we will just skip it.</span></div><div class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (callingUid != Process.SYSTEM_UID || (intent.getFlags()</div><div class="line">                    & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) {</div><div class="line">                Slog.w(TAG, <span class="string">"Skipping broadcast of "</span> + intent</div><div class="line">                        + <span class="string">": user "</span> + userId + <span class="string">" is stopped"</span>);</div><div class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">            }     </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// 这里是一些发送权限，检测和 sticky 功能，我们通通跳过 </span></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] users;</div><div class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL) {</div><div class="line">            <span class="comment">// Caller wants broadcast to go to all started users.</span></div><div class="line">            users = mStartedUserArray;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// Caller wants broadcast to go to one specific user.</span></div><div class="line">            users = <span class="keyword">new</span> <span class="keyword">int</span>[] {userId};</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Figure out who all will receive this broadcast.</span></div><div class="line">        List receivers = <span class="keyword">null</span>;</div><div class="line">        List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// Need to resolve the intent to interested receivers...</span></div><div class="line">        <span class="comment">// 这里还有个判断，如果发送的广播并不是只能动态注册的才跑下面的（也是说静态的可以，真绕口）</span></div><div class="line">        <span class="keyword">if</span> ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)</div><div class="line">                 == <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 收集静态注册的接收器</span></div><div class="line">            receivers = collectReceiverComponents(intent, resolvedType, users);</div><div class="line">        }</div><div class="line">        <span class="comment">// 看样子发一条动态注册接收器能处理的广播，发的 Intent 必须要包含 Component 信息</span></div><div class="line">        <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 收集动态注册的接收器</span></div><div class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</div><div class="line">                    resolvedType, <span class="keyword">false</span>, userId);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</div><div class="line">                (intent.getFlags()&Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Enqueing broadcast: "</span> + intent.getAction()</div><div class="line">                + <span class="string">" replacePending="</span> + replacePending);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>一个广播发出来了，AMS 要做的第一步，首先是要找到有哪些接收器要接收这条广播。前面一篇说了，注册接收器有动态注册和静态注册2种。这里看代码果然也是分开2步来收集的。我们先来看收集静态的：</p>
<h3 id="a-a_收集静态注册接收器">a.a 收集静态注册接收器</h3>
<p>静态注册接收器收集由 collectReceiverComponents 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> List&lt;ResolveInfo&gt; <span class="title">collectReceiverComponents</span>(Intent intent, String resolvedType,</div><div class="line">            <span class="keyword">int</span>[] users) {</div><div class="line">        List&lt;ResolveInfo&gt; receivers = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            HashSet&lt;ComponentName&gt; singleUserReceivers = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">boolean</span> scannedFirstReceivers = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> user : users) {</div><div class="line">                <span class="comment">// 去 PM 中取静态注册的接收器列表</span></div><div class="line">                List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</div><div class="line">                        .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);</div><div class="line"></div><div class="line">                <span class="comment">// 下面那一堆是关于多用户处理的，我们不管它们</span></div><div class="line">... ...</div><div class="line"></div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">            <span class="comment">// pm is in same process, this will never happen.</span></div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> receivers;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数虽然有 100 多行，但是我们关心的只有调用 PM 的那句 queryIntentReceivers 而已。前面一篇说了，静态注册的广播数据保存在 PMS 中，所以这里要调用 PM 的接口去 PMS 里面去取。所以我去 PMS 里面去看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntentReceivers</span>(Intent intent, String resolvedType, <span class="keyword">int</span> flags,</div><div class="line">        <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> Collections.emptyList(); </div><div class="line">    ComponentName comp = intent.getComponent();</div><div class="line">    <span class="keyword">if</span> (comp == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">if</span> (intent.getSelector() != <span class="keyword">null</span>) {    </div><div class="line">            intent = intent.getSelector();</div><div class="line">            comp = intent.getComponent();  </div><div class="line">        }       </div><div class="line">    }</div><div class="line">    <span class="comment">// 如果发送的广播带 ComponentName 信息，差不多就是显式广播了（指定了接收器包名、类名的）</span></div><div class="line">    <span class="comment">// 所以只要有一个接收器就行了</span></div><div class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) {</div><div class="line">        List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</div><div class="line">        ActivityInfo ai = getReceiverInfo(comp, flags, userId);</div><div class="line">        <span class="keyword">if</span> (ai != <span class="keyword">null</span>) {</div><div class="line">            ResolveInfo ri = <span class="keyword">new</span> ResolveInfo();</div><div class="line">            ri.activityInfo = ai;</div><div class="line">            list.add(ri);</div><div class="line">        }           </div><div class="line">        <span class="keyword">return</span> list;    </div><div class="line">    }                   </div><div class="line">                            </div><div class="line">    <span class="comment">// 但是一般的都是走下面这里的</span></div><div class="line">    <span class="comment">// 我们的例子 BOOT_COMPLETED 属于这种</span></div><div class="line">    <span class="comment">// reader                       </span></div><div class="line">    <span class="keyword">synchronized</span> (mPackages) { </div><div class="line">        String pkgName = intent.getPackage();</div><div class="line">        <span class="comment">// 一般隐式的也是不指定包名的</span></div><div class="line">        <span class="comment">// 我们的例子 BOOT_COMPLETED 属于这种</span></div><div class="line">        <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 所以一般是用这个收集静态注册接收器的                             </span></div><div class="line">            <span class="keyword">return</span> mReceivers.queryIntent(intent, resolvedType, flags, userId);</div><div class="line">        }</div><div class="line">        <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pkg != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers,</div><div class="line">                    userId);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们在说之前先看看 ResolveInfo 这个东西，好歹返回的列表里面是这个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Information that is returned from resolving an intent</span></div><div class="line"><span class="comment"> * against an IntentFilter. This partially corresponds to</span></div><div class="line"><span class="comment"> * information collected from the AndroidManifest.xml's</span></div><div class="line"><span class="comment"> * &lt;intent&gt; tags.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolveInfo</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>里面的具体东西我们就不看了，看下注释，是说一个 ResolverInfo 对应一个 IntentFilter。然后就是 mReceivers 这个 ActivityIntentResolver，注册篇已经提及过了。PMS 中就是它保存了静态注册的接收器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntent</span>(Intent intent, String resolvedType, <span class="keyword">int</span> flags,</div><div class="line">        <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    mFlags = flags;</div><div class="line">    <span class="comment">// 这个差不多就是直接调用父类的同名函数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.queryIntent(intent, resolvedType,</div><div class="line">            (flags & PackageManager.MATCH_DEFAULT_ONLY) != <span class="number">0</span>, userId);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们去看父类（IntentResolver）的 queryIntent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前面注册篇说了么，R 是输出类型</span></div><div class="line"><span class="keyword">public</span> List&lt;R&gt; <span class="title">queryIntent</span>(Intent intent, String resolvedType, <span class="keyword">boolean</span> defaultOnly,</div><div class="line">        <span class="keyword">int</span> userId) {</div><div class="line">    String scheme = intent.getScheme();</div><div class="line"></div><div class="line">    ArrayList&lt;R&gt; finalList = <span class="keyword">new</span> ArrayList&lt;R&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = localLOGV ||</div><div class="line">            ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (debug) Slog.v(</div><div class="line">        TAG, <span class="string">"Resolving type "</span> + resolvedType + <span class="string">" scheme "</span> + scheme</div><div class="line">        + <span class="string">" of intent "</span> + intent);</div><div class="line"></div><div class="line">    <span class="comment">// F 是输入，这几个数组分别对应注册篇说的 IntentResovler 中的那几个保存的 HashMap（Set）</span></div><div class="line">    F[] firstTypeCut = <span class="keyword">null</span>;</div><div class="line">    F[] secondTypeCut = <span class="keyword">null</span>;</div><div class="line">    F[] thirdTypeCut = <span class="keyword">null</span>;</div><div class="line">    F[] schemeCut = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// MIME type，我们的例子 BOOT_COMPLETED 是 null</span></div><div class="line">    <span class="comment">// If the intent includes a MIME type, then we want to collect all of</span></div><div class="line">    <span class="comment">// the filters that match that MIME type.</span></div><div class="line">    <span class="keyword">if</span> (resolvedType != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> slashpos = resolvedType.indexOf(<span class="string">'/'</span>);</div><div class="line">        <span class="keyword">if</span> (slashpos &gt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">final</span> String baseType = resolvedType.substring(<span class="number">0</span>, slashpos);</div><div class="line">            <span class="keyword">if</span> (!baseType.equals(<span class="string">"*"</span>)) {</div><div class="line">                <span class="keyword">if</span> (resolvedType.length() != slashpos+<span class="number">2</span></div><div class="line">                        || resolvedType.charAt(slashpos+<span class="number">1</span>) != <span class="string">'*'</span>) {</div><div class="line">                    <span class="comment">// Not a wild card, so we can just look for all filters that</span></div><div class="line">                    <span class="comment">// completely match or wildcards whose base type matches.</span></div><div class="line">                    firstTypeCut = mTypeToFilter.get(resolvedType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"First type cut: "</span> + firstTypeCut);</div><div class="line">                    secondTypeCut = mWildTypeToFilter.get(baseType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Second type cut: "</span> + secondTypeCut);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// We can match anything with our base type.</span></div><div class="line">                    firstTypeCut = mBaseTypeToFilter.get(baseType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"First type cut: "</span> + firstTypeCut);</div><div class="line">                    secondTypeCut = mWildTypeToFilter.get(baseType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Second type cut: "</span> + secondTypeCut);</div><div class="line">                }</div><div class="line">                <span class="comment">// Any */* types always apply, but we only need to do this</span></div><div class="line">                <span class="comment">// if the intent type was not already */*.</span></div><div class="line">                thirdTypeCut = mWildTypeToFilter.get(<span class="string">"*"</span>);</div><div class="line">                <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Third type cut: "</span> + thirdTypeCut);</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (intent.getAction() != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// The intent specified any type ({@literal *}/*).  This</span></div><div class="line">                <span class="comment">// can be a whole heck of a lot of things, so as a first</span></div><div class="line">                <span class="comment">// cut let's use the action instead.</span></div><div class="line">                firstTypeCut = mTypedActionToFilter.get(intent.getAction());</div><div class="line">                <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Typed Action list: "</span> + firstTypeCut);</div><div class="line">            }   </div><div class="line">        }           </div><div class="line">    }   </div><div class="line">                    </div><div class="line">    <span class="comment">// Scheme，我们的例子 BOOT_COMPLETED 也是 null</span></div><div class="line">    <span class="comment">// If the intent includes a data URI, then we want to collect all of</span></div><div class="line">    <span class="comment">// the filters that match its scheme (we will further refine matches</span></div><div class="line">    <span class="comment">// on the authority and path by directly matching each resulting filter).</span></div><div class="line">    <span class="keyword">if</span> (scheme != <span class="keyword">null</span>) {   </div><div class="line">        schemeCut = mSchemeToFilter.get(scheme);</div><div class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Scheme list: "</span> + schemeCut);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Action，我们的例子 BOOT_COMPLETED 本身就是 Action 啦</span></div><div class="line">    <span class="comment">// 所以这里 firstTypeCut 就是取前面注册篇中保存 Action 的列表了</span></div><div class="line">    <span class="comment">// If the intent does not specify any data -- either a MIME type or</span></div><div class="line">    <span class="comment">// a URI -- then we will only be looking for matches against empty</span></div><div class="line">    <span class="comment">// data.</span></div><div class="line">    <span class="keyword">if</span> (resolvedType == <span class="keyword">null</span> && scheme == <span class="keyword">null</span> && intent.getAction() != <span class="keyword">null</span>) {</div><div class="line">        firstTypeCut = mActionToFilter.get(intent.getAction());</div><div class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Action list: "</span> + firstTypeCut);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这个 Categories，我们也暂时不管先</span></div><div class="line">    FastImmutableArraySet&lt;String&gt; categories = getFastIntentCategories(intent);</div><div class="line">    <span class="comment">// 然后按照顺序依次从匹配的 F 列表中构造出要查询的 R 返回给调用者</span></div><div class="line">    <span class="keyword">if</span> (firstTypeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, firstTypeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (secondTypeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, secondTypeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (thirdTypeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, thirdTypeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (schemeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, schemeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="comment">// 对匹配的结果进行排序</span></div><div class="line">    sortResults(finalList);</div><div class="line"></div><div class="line">    <span class="comment">// 兼容老版本的，无视 ... ...</span></div><div class="line">    <span class="keyword">if</span> (VALIDATE) {</div><div class="line">        List&lt;R&gt; oldList = mOldResolver.queryIntent(intent, resolvedType, defaultOnly, userId);</div><div class="line">        <span class="keyword">if</span> (oldList.size() != finalList.size()) {</div><div class="line">            ValidationFailure here = <span class="keyword">new</span> ValidationFailure();</div><div class="line">            here.fillInStackTrace();</div><div class="line">            Log.wtf(TAG, <span class="string">"Query result "</span> + intent + <span class="string">" size is "</span> + finalList.size()</div><div class="line">                    + <span class="string">"; old implementation is "</span> + oldList.size(), here);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (debug) {</div><div class="line">        Slog.v(TAG, <span class="string">"Final result list:"</span>);</div><div class="line">        <span class="keyword">for</span> (R r : finalList) {</div><div class="line">            Slog.v(TAG, <span class="string">"  "</span> + r);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> finalList;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数前面是通过传过来的 Intent 从 IntentResolver 那一堆保存注册接收器数据的列表中选出匹配的 F（PMS 中的静态注册的 F 是 PackageParser.ActivityIntentInfo），一般来说匹配条件就是注册广播中 IntentFilter 可以设置的那一堆条件了：MIME type、Scheme、Action 等等（到这里的都是隐式的，显式的前面直接给解析好了）。然后我们就得去看看 buildResolveList 这个函数是怎么构造 R 出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildResolveList</span>(Intent intent, FastImmutableArraySet&lt;String&gt; categories,</div><div class="line">        <span class="keyword">boolean</span> debug, <span class="keyword">boolean</span> defaultOnly,</div><div class="line">        String resolvedType, String scheme, F[] src, List&lt;R&gt; dest, <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">final</span> String action = intent.getAction();</div><div class="line">    <span class="keyword">final</span> Uri data = intent.getData();</div><div class="line">    <span class="keyword">final</span> String packageName = intent.getPackage();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> excludingStopped = intent.isExcludingStopped();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = src != <span class="keyword">null</span> ? src.length : <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> hasNonDefaults = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    F filter;</div><div class="line">    <span class="comment">// 在选出的 F 数组里，循环根据 F 构造出 R</span></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N && (filter=src[i]) != <span class="keyword">null</span>; i++) {</div><div class="line">        <span class="keyword">int</span> match;</div><div class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Matching against filter "</span> + filter);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (excludingStopped && isFilterStopped(filter, userId)) {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter's target is stopped; skipping"</span>);</div><div class="line">            }   </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// Is delivery being limited to filters owned by a particular package?</span></div><div class="line">        <span class="keyword">if</span> (packageName != <span class="keyword">null</span> && !packageName.equals(packageForFilter(filter))) {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter is not from package "</span> + packageName + <span class="string">"; skipping"</span>);</div><div class="line">            }   </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// 这个 allowFilterResult 是由之类实现的，不过和我们这里的关系不大，不理它先</span></div><div class="line">        <span class="comment">// Do we already have this one?</span></div><div class="line">        <span class="keyword">if</span> (!allowFilterResult(filter, dest)) {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter's target already added"</span>);</div><div class="line">            }   </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// IntentFilter 里面的匹配函数，我们也先忽略一下（就是拿上面几种类型匹配一下而已）</span></div><div class="line">        match = filter.match(action, resolvedType, scheme, data, categories, TAG);</div><div class="line">        <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"  Filter matched!  match=0x"</span> +</div><div class="line">                    Integer.toHexString(match));</div><div class="line">            <span class="keyword">if</span> (!defaultOnly || filter.hasCategory(Intent.CATEGORY_DEFAULT)) {</div><div class="line">                <span class="comment">// 这里 new R 出来的 newResult 也是由子类实现的，我们待会去看一下</span></div><div class="line">                <span class="keyword">final</span> R oneResult = newResult(filter, match, userId);</div><div class="line">                <span class="keyword">if</span> (oneResult != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">// 把 R 添加到输出列表中</span></div><div class="line">                    dest.add(oneResult);</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                hasNonDefaults = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                String reason;</div><div class="line">                <span class="keyword">switch</span> (match) {</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_ACTION: reason = <span class="string">"action"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_CATEGORY: reason = <span class="string">"category"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_DATA: reason = <span class="string">"data"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_TYPE: reason = <span class="string">"type"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">default</span>: reason = <span class="string">"unknown reason"</span>; <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter did not match: "</span> + reason);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dest.size() == <span class="number">0</span> && hasNonDefaults) {</div><div class="line">        Slog.w(TAG, <span class="string">"resolveIntent failed: found match, but none with Intent.CATEGORY_DEFAULT"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 buildResolveList 中就是循环从输入的 F 数组中取出 F，然后传给一个叫 newResult 的函数构造 R。这个 newResult 是由不同的 IntentResovler 之类实现的。我们来看看 PMS 中的 ActivityIntentResolver newResult 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> ResolveInfo <span class="title">newResult</span>(PackageParser.ActivityIntentInfo info,</div><div class="line">        <span class="keyword">int</span> match, <span class="keyword">int</span> userId) {       </div><div class="line">    <span class="comment">// 下面一堆判断可以不用管先</span></div><div class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (!mSettings.isEnabledLPr(info.activity.info, mFlags, userId)) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">final</span> PackageParser.Activity activity = info.activity;</div><div class="line">    <span class="keyword">if</span> (mSafeMode && (activity.info.applicationInfo.flags</div><div class="line">            &ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    PackageSetting ps = (PackageSetting) activity.owner.mExtras;</div><div class="line">    <span class="keyword">if</span> (ps == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    ActivityInfo ai = PackageParser.generateActivityInfo(activity, mFlags,</div><div class="line">            ps.readUserState(userId), userId);</div><div class="line">    <span class="keyword">if</span> (ai == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 下面就是构造 R（ResolverInfo） 的过程</span></div><div class="line">    <span class="keyword">final</span> ResolveInfo res = <span class="keyword">new</span> ResolveInfo();</div><div class="line">    res.activityInfo = ai;         </div><div class="line">    <span class="keyword">if</span> ((mFlags&PackageManager.GET_RESOLVED_FILTER) != <span class="number">0</span>) {</div><div class="line">        res.filter = info;             </div><div class="line">    }</div><div class="line">    <span class="comment">// 接收器的优先级在这里复制的哦</span></div><div class="line">    res.priority = info.getPriority();</div><div class="line">    res.preferredOrder = activity.owner.mPreferredOrder;</div><div class="line">    <span class="comment">//System.out.println("Result: " + res.activityInfo.className +</span></div><div class="line">    <span class="comment">//                   " = " + res.priority);</span></div><div class="line">    res.match = match;</div><div class="line">    res.isDefault = info.hasDefault;</div><div class="line">    res.labelRes = info.labelRes;</div><div class="line">    res.nonLocalizedLabel = info.nonLocalizedLabel;</div><div class="line">    res.icon = info.icon;</div><div class="line">    res.system = isSystemApp(res.activityInfo.applicationInfo);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面就是 new 了一个 ResolverInfo（R），然后用 F（PackageParser.ActivityIntentInfo） 中相应的字段填充自己的字段而已。后面 AMS 从自己那里收集动态注册的接收器，也是差不多的。所以说注册的时候保存的数据，差不多可以说就是接收器数据。</p>
<p>构造完 R 之后，queryIntent 最后对匹配的 R 进行了一下排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sortResults</span>(List&lt;R&gt; results) {</div><div class="line">    Collections.sort(results, mResolvePrioritySorter);</div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">// 注释说得很清楚了，按照优先级进行排序</span></div><div class="line"><span class="comment">// Sorts a List of IntentFilter objects into descending priority order.</span></div><div class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator mResolvePrioritySorter = <span class="keyword">new</span> Comparator() {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Object o1, Object o2) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> q1 = ((IntentFilter) o1).getPriority();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> q2 = ((IntentFilter) o2).getPriority();</div><div class="line">        <span class="keyword">return</span> (q1 &gt; q2) ? -<span class="number">1</span> : ((q1 &lt; q2) ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个优先级在注册篇说过了，在 manifest 里面声明 receiver 的 filter 那里设置的（只有系统应用有权限设置）。</p>
<h3 id="a-b_收集动态注册接收器">a.b 收集动态注册接收器</h3>
<p>上面看过收集静态的过程，下面我们来看看收集动态注册的接收器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">registeredReceivers = mReceiverResolver.queryIntent(intent,</div><div class="line">        resolvedType, <span class="keyword">false</span>, userId);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个其实和上面静态流程是一样的，只不过 IntentResolver 的实现子类是 AMS 的匿名的一个类而已，我们就直接看看关键的 newResult 就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">protected</span> BroadcastFilter <span class="title">newResult</span>(BroadcastFilter filter, <span class="keyword">int</span> match, <span class="keyword">int</span> userId) {</div><div class="line">            <span class="keyword">if</span> (userId == UserHandle.USER_ALL || filter.owningUserId == UserHandle.USER_ALL</div><div class="line">                    || userId == filter.owningUserId) {</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.newResult(filter, match, userId);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line"><span class="comment">// ================ IntentResovler.java ============================</span></div><div class="line"></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">protected</span> R <span class="title">newResult</span>(F filter, <span class="keyword">int</span> match, <span class="keyword">int</span> userId) { </div><div class="line">        <span class="keyword">return</span> (R)filter;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 里面的除去前面那个判断，就是直接 new 了一个 R，也难怪，AMS 里面的 F 和 R 都是 BroadcastFilter。到这里 AMS 的 broadcastIntentLocked 就收集到了2个 List：</p>
<pre>
List receivers = null;
List<broadcastfilter> registeredReceivers = null;
</broadcastfilter></pre>

<p>分别是静态注册的接收器（ResolveInfo）和动态注册的接收器（BoradcastFilter）。</p>
<h2 id="b-_分发广播给动态注册接收器">b. 分发广播给动态注册接收器</h2>
<p>收集完广播匹配的接收器（静态和动态），就要开始分发了。我们接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span>(ProcessRecord callerApp,</div><div class="line">            String callerPackage, Intent intent, String resolvedType,</div><div class="line">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">            Bundle map, String requiredPermission,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</div><div class="line">            <span class="keyword">int</span> userId) {</div><div class="line">... ...</div><div class="line">            </div><div class="line">        <span class="keyword">int</span> NR = registeredReceivers != <span class="keyword">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</div><div class="line">        <span class="comment">// 判断如果不是串行广播并且有动态注册的接收器，就走下面的代码</span></div><div class="line">        <span class="comment">// 我们的例子（BOOT_COMPLETED）是并行广播，并且有不少动态注册的接收器的</span></div><div class="line">        <span class="keyword">if</span> (!ordered && NR &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// If we are not serializing this broadcast, then send the</span></div><div class="line">            <span class="comment">// registered receivers separately so they don't wait for the</span></div><div class="line">            <span class="comment">// components to be launched.</span></div><div class="line">            <span class="comment">// 取广播对应的广播队列：分为前台广播队列和后台广播队列</span></div><div class="line">            <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">            <span class="comment">// new 一个 BroadcastRecord，注意有传动态注册接收器的列表进去</span></div><div class="line">            BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</div><div class="line">                    callerPackage, callingPid, callingUid, requiredPermission,</div><div class="line">                    registeredReceivers, resultTo, resultCode, resultData, map,</div><div class="line">                    ordered, sticky, <span class="keyword">false</span>, userId);</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                    TAG, <span class="string">"Enqueueing parallel broadcast "</span> + r);</div><div class="line">            <span class="comment">// 这个 replaced 大概就是检测下现在发的这个 Intent 是不是和广播队列中的有一样的，</span></div><div class="line">            <span class="comment">// 如果有的话，说明之前发过一次了，但是还没处理，所以就忽略这次发送（代码不贴了）</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> replaced = replacePending && queue.replaceParallelBroadcastLocked(r);</div><div class="line">            <span class="keyword">if</span> (!replaced) {</div><div class="line">                <span class="comment">// 把前面 new 出来的 BroadcastRecord 送去并行的广播队列排队，然后执行发送</span></div><div class="line">                queue.enqueueParallelBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            }</div><div class="line">            registeredReceivers = <span class="keyword">null</span>;</div><div class="line">            NR = <span class="number">0</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ....</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里出现了2个新的数据结构：BroadcastQueue 和 BroadcastRecord。我们来一个一个看，首先是 BroadcastQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * BROADCASTS</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We keep two broadcast queues and associated bookkeeping, one for those at</span></div><div class="line"><span class="comment"> * foreground priority, and one for normal (background-priority) broadcasts.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastQueue</span> </span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BroadcastQueue"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG_MU = ActivityManagerService.TAG_MU;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_BROADCAST = ActivityManagerService.DEBUG_BROADCAST;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_BROADCAST_LIGHT = ActivityManagerService.DEBUG_BROADCAST_LIGHT;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_MU = ActivityManagerService.DEBUG_MU;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BROADCAST_HISTORY = <span class="number">25</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BROADCAST_SUMMARY_HISTORY = <span class="number">100</span>; </div><div class="line"></div><div class="line">    <span class="keyword">final</span> ActivityManagerService mService;</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Recognizable moniker for this queue</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> String mQueueName;</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Timeout period for this queue's broadcasts</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> mTimeoutPeriod;</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Lists of all active broadcasts that are to be executed immediately</span></div><div class="line"><span class="javadoc">     * (without waiting for another broadcast to finish).  Currently this only</span></div><div class="line"><span class="javadoc">     * contains broadcasts to registered receivers, to avoid spinning up</span></div><div class="line"><span class="javadoc">     * a bunch of processes to execute IntentReceiver components.  Background-</span></div><div class="line"><span class="javadoc">     * and foreground-priority broadcasts are queued separately.</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts</div><div class="line">            = <span class="keyword">new</span> ArrayList&lt;BroadcastRecord&gt;();</div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * List of all active broadcasts that are to be executed one at a time.</span></div><div class="line"><span class="javadoc">     * The object at the top of the list is the currently activity broadcasts;</span></div><div class="line"><span class="javadoc">     * those after it are waiting for the top to finish.  As with parallel</span></div><div class="line"><span class="javadoc">     * broadcasts, separate background- and foreground-priority queues are</span></div><div class="line"><span class="javadoc">     * maintained.</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts</div><div class="line">            = <span class="keyword">new</span> ArrayList&lt;BroadcastRecord&gt;();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释，说 AMS 中有2个这种 BroacastQueue，一个是前台的，一个是后台的，前台的处理优先级比后台的高一些。然后里面有2个比较重要的 ArrayList：mParallelBroadcasts 和 mOrderedBroadcasts。看名字就很明显了，一个是串行广播记录的，一个是并行广播记录的。然后我们再来看下 BroadcastRecord 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * An active intent broadcast.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">class BroadcastRecord extends Binder {</div><div class="line">    <span class="keyword">final</span> Intent intent;    <span class="comment">// the original intent that generated us</span></div><div class="line">    <span class="keyword">final</span> ProcessRecord callerApp; <span class="comment">// process that sent this</span></div><div class="line">    <span class="keyword">final</span> String callerPackage; <span class="comment">// who sent this</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingPid;   <span class="comment">// the pid of who sent this</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid;   <span class="comment">// the uid of who sent this</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;  <span class="comment">// serialize the send to receivers?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;   <span class="comment">// originated from existing sticky data?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> initialSticky; <span class="comment">// initial broadcast from register to sticky?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId;       <span class="comment">// user id this broadcast was for</span></div><div class="line">    <span class="keyword">final</span> String requiredPermission; <span class="comment">// a permission the caller has required</span></div><div class="line">    <span class="keyword">final</span> List receivers;   <span class="comment">// contains BroadcastFilter and ResolveInfo</span></div><div class="line">    IIntentReceiver resultTo; <span class="comment">// who receives final result if non-null</span></div><div class="line">    <span class="keyword">long</span> dispatchTime;      <span class="comment">// when dispatch started on this set of receivers</span></div><div class="line">    <span class="keyword">long</span> dispatchClockTime; <span class="comment">// the clock time the dispatch started</span></div><div class="line">    <span class="keyword">long</span> receiverTime;      <span class="comment">// when current receiver started for timeouts.</span></div><div class="line">    <span class="keyword">long</span> finishTime;        <span class="comment">// when we finished the broadcast.</span></div><div class="line">    <span class="keyword">int</span> resultCode;         <span class="comment">// current result code value.</span></div><div class="line">    String resultData;      <span class="comment">// current result data value.</span></div><div class="line">    Bundle resultExtras;    <span class="comment">// current result extra data values.</span></div><div class="line">    <span class="keyword">boolean</span> resultAbort;    <span class="comment">// current result abortBroadcast value.</span></div><div class="line">    <span class="keyword">int</span> nextReceiver;       <span class="comment">// next receiver to be executed.</span></div><div class="line">    IBinder receiver;       <span class="comment">// who is currently running, null if none.</span></div><div class="line">    <span class="keyword">int</span> state;</div><div class="line">    <span class="keyword">int</span> anrCount;           <span class="comment">// has this broadcast record hit any ANRs?</span></div><div class="line">    BroadcastQueue queue;   <span class="comment">// the outbound queue handling this broadcast</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个类很简单，除了构造函数给上面一堆字段赋值以外，就没别的的啥操作了。然后上面注意那个 List 记录了 AMS 收集到的广播接收器的信息。接下来我们回到 broadcastIntentLocked 中看看 broadcastQueueForIntent 是怎么决定用哪个广播队列的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 顺带把初始化的地方贴出来</span></div><div class="line">    <span class="keyword">private</span> <span class="title">ActivityManagerService</span>() {</div><div class="line">        Slog.i(TAG, <span class="string">"Memory class: "</span> + ActivityManager.staticGetMemoryClass());</div><div class="line">                    </div><div class="line">        <span class="comment">// 这里创建广播队列的时候就设置好了广播超时时间（这个时间的作用，后面再说）</span></div><div class="line">        mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT);</div><div class="line">        mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT);</div><div class="line">        mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</div><div class="line">        mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</div><div class="line">... ...</div><div class="line">       </div><div class="line">    } </div><div class="line"></div><div class="line">    BroadcastQueue broadcastQueueForIntent(Intent intent) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() & Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (DEBUG_BACKGROUND_BROADCAST) {</div><div class="line">            Slog.i(TAG, <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></div><div class="line">                    + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>)</div><div class="line">                    + <span class="string">" queue"</span>);</div><div class="line">        }   </div><div class="line">        <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子是根据发广播的时候的 Intent 的 flags 来决定的，默认不设置就是后台广播队列。我搜了下代码，发现就只有 AMS 中会发几个是前台的。我们确定了我们的列子 BOOT_COMPLETED 是用后台广播队列之后，就来看看 BroadcastQueue 中的加入队列和执行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueParallelBroadcastLocked</span>(BroadcastRecord r) {</div><div class="line">    mParallelBroadcasts.add(r);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>入队操作很简单，直接插入到并行广播记录的列表中。排好队之后就到执行广播了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span>() {</div><div class="line">    RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</div><div class="line">    here.fillInStackTrace();</div><div class="line">    Slog.d(TAG, <span class="string">"call statck is"</span>, here);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Schedule broadcasts ["</span></div><div class="line">            + mQueueName + <span class="string">"]: current="</span></div><div class="line">            + mBroadcastsScheduled);</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前队列正在执行广播操作，则返回</span></div><div class="line">    <span class="comment">// 也就是说一个广播队列要等上一次广播操作执行完才会接收新的执行命令</span></div><div class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }    </div><div class="line">    <span class="comment">// 发了一个消息去 Handler 里面</span></div><div class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</div><div class="line">    <span class="comment">// 把正在执行的标志设置为 true</span></div><div class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个 Handler 没有使用额外的线程，</span></div><div class="line"><span class="comment">// 所以这里的作用应该是为了能够马上返回吧</span></div><div class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() {</div><div class="line">    <span class="comment">//public Handler() {</span></div><div class="line">    <span class="comment">//    if (localLOGV) Slog.v(TAG, "Handler started!");</span></div><div class="line">    <span class="comment">//}</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">        <span class="keyword">switch</span> (msg.what) {</div><div class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: {</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                        TAG, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</div><div class="line">                processNextBroadcast(<span class="keyword">true</span>);</div><div class="line">            } <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: {</div><div class="line">                <span class="keyword">synchronized</span> (mService) {</div><div class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</div><div class="line">                }</div><div class="line">            } <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后执行操作是由 processNextBroadcast 这个函数来完成的。这个函数非常的长（将近 500 行），我们得分功能一段一段来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {</div><div class="line">            BroadcastRecord r;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"processNextBroadcast ["</span></div><div class="line">                    + mQueueName + <span class="string">"]: "</span></div><div class="line">                    + mParallelBroadcasts.size() + <span class="string">" broadcasts, "</span></div><div class="line">                    + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</div><div class="line"></div><div class="line">            mService.updateCpuStats();</div><div class="line"></div><div class="line">            <span class="comment">// 如果从 scheduleBroadcastsLocked 发 Handler 过来的，</span></div><div class="line">            <span class="comment">// 这里就把正在执行的标志设置为 false 了。</span></div><div class="line">            <span class="comment">// Handler 处理了一个就可以让下一个在 Handler 的消息队列里面排队了</span></div><div class="line">            <span class="keyword">if</span> (fromMsg) {</div><div class="line">                mBroadcastsScheduled = <span class="keyword">false</span>;</div><div class="line">            }    </div><div class="line"></div><div class="line">            <span class="comment">// 这里一个循环把并行广播列表中的广播记录全部处理了</span></div><div class="line">            <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></div><div class="line">            <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) { </div><div class="line">                r = mParallelBroadcasts.remove(<span class="number">0</span>);</div><div class="line">                r.dispatchTime = SystemClock.uptimeMillis();</div><div class="line">                r.dispatchClockTime = System.currentTimeMillis();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Processing parallel broadcast ["</span></div><div class="line">                        + mQueueName + <span class="string">"] "</span> + r);</div><div class="line">                <span class="comment">// 一个广播会有多个接收器（前面 AMS 收集的 List），一个一个的分发</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                    Object target = r.receivers.get(i);</div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG,</div><div class="line">                            <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></div><div class="line">                            + target + <span class="string">": "</span> + r);</div><div class="line">                    <span class="comment">// 分发广播给接收器</span></div><div class="line">                    <span class="comment">// 看样子在并行列表里面的必须是动态注册的，因为这里写死认为是 BroadcastFilter 了</span></div><div class="line">                    <span class="comment">// 静态注册的是 ResolveInfo</span></div><div class="line">                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</div><div class="line">                }    </div><div class="line">                addBroadcastToHistoryLocked(r);</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Done with parallel broadcast ["</span></div><div class="line">                        + mQueueName + <span class="string">"] "</span> + r);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接下去看 deliverToRegisteredReceiverLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span>(BroadcastRecord r,</div><div class="line">        BroadcastFilter filter, <span class="keyword">boolean</span> ordered) {</div><div class="line">    <span class="comment">// 权限检测，有些广播只能有权限的接收器（进程）才能接收的</span></div><div class="line">    <span class="comment">// 我们先不管这些</span></div><div class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(filter.requiredPermission,</div><div class="line">                r.callingPid, r.callingUid, -<span class="number">1</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">            Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></div><div class="line">                    + r.intent.toString()</div><div class="line">                    + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></div><div class="line">                    + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></div><div class="line">                    + <span class="string">" requires "</span> + filter.requiredPermission</div><div class="line">                    + <span class="string">" due to registered receiver "</span> + filter);</div><div class="line">            skip = <span class="keyword">true</span>;</div><div class="line">        }    </div><div class="line">    }    </div><div class="line">    <span class="keyword">if</span> (!skip && r.requiredPermission != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(r.requiredPermission,</div><div class="line">                filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">            Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></div><div class="line">                    + r.intent.toString()</div><div class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</div><div class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</div><div class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></div><div class="line">                    + <span class="string">" requires "</span> + r.requiredPermission</div><div class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</div><div class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</div><div class="line">            skip = <span class="keyword">true</span>;</div><div class="line">        }    </div><div class="line">    }   </div><div class="line"></div><div class="line">    <span class="comment">// 我们就当有权限的情况</span></div><div class="line">    <span class="keyword">if</span> (!skip) {</div><div class="line">        <span class="comment">// 串行广播好像会保持原来的什么状态，先不管这个先</span></div><div class="line">        <span class="comment">// If this is not being sent as an ordered broadcast, then we</span></div><div class="line">        <span class="comment">// don't want to touch the fields that keep track of the current</span></div><div class="line">        <span class="comment">// state of ordered broadcasts.</span></div><div class="line">        <span class="keyword">if</span> (ordered) {</div><div class="line">            r.receiver = filter.receiverList.receiver.asBinder();</div><div class="line">            r.curFilter = filter;</div><div class="line">            filter.receiverList.curBroadcast = r; </div><div class="line">            r.state = BroadcastRecord.CALL_IN_RECEIVE;</div><div class="line">            <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// Bump hosting application to no longer be in background</span></div><div class="line">                <span class="comment">// scheduling class.  Note that we can't do that if there</span></div><div class="line">                <span class="comment">// isn't an app...  but we can only be in that case for</span></div><div class="line">                <span class="comment">// things that directly call the IActivityManager API, which</span></div><div class="line">                <span class="comment">// are already core system stuff so don't matter for this.</span></div><div class="line">                r.curApp = filter.receiverList.app;</div><div class="line">                filter.receiverList.app.curReceiver = r;</div><div class="line">                mService.updateOomAdjLocked();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) {</div><div class="line">                <span class="keyword">int</span> seq = r.intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">                Slog.i(TAG, <span class="string">"Delivering to "</span> + filter</div><div class="line">                        + <span class="string">" (seq="</span> + seq + <span class="string">"): "</span> + r);</div><div class="line">            }</div><div class="line">            <span class="comment">// 这个才是真正的执行操作</span></div><div class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</div><div class="line">                <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData,</div><div class="line">                r.resultExtras, r.ordered, r.initialSticky, r.userId);</div><div class="line">            <span class="keyword">if</span> (ordered) {</div><div class="line">                r.state = BroadcastRecord.CALL_DONE_RECEIVE;</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Slog.w(TAG, <span class="string">"Failure sending broadcast "</span> + r.intent, e);</div><div class="line">            <span class="keyword">if</span> (ordered) {</div><div class="line">                r.receiver = <span class="keyword">null</span>;</div><div class="line">                r.curFilter = <span class="keyword">null</span>;</div><div class="line">                filter.receiverList.curBroadcast = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) {</div><div class="line">                    filter.receiverList.app.curReceiver = <span class="keyword">null</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个分发函数把前面的权限检测和那个串行处理忽略掉之后，就剩下 performReceiveLocked 这个处理了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performReceiveLocked</span>(ProcessRecord app, IIntentReceiver receiver,</div><div class="line">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</div><div class="line">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></div><div class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> && app.thread != <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// If we have an app thread, do the call through that so it is</span></div><div class="line">        <span class="comment">// correctly ordered with other one-way calls.</span></div><div class="line">        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class="line">                data, extras, ordered, sticky, sendingUser);</div><div class="line">    } <span class="keyword">else</span> {    </div><div class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class="line">                sticky, sendingUser);</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里首先，我们复习下传过来的参数： ProcessRecord 是动态注册的时候构造 ReceiverList 保存的接收器注册者的进程记录信息；IIntentReceiver 这个东西也是在动态注册的时候构造 BroadcastFilter 保存的接收器注册者的 LoadedApk.ReceiverDispatcher.InnerReceiver 这个对象的 Bp 端（这个的 Bn 端就有接收器最终的 onReceiver 回调，忘记了去注册篇复习下）。这里虽然分了2种情况：</p>
<ol>
<li>接收器进程还在运行（app != null &amp;&amp; app.thread != null）</li>
<li>接收器进程已经挂了</li>
</ol>
<p>我个人认为正常情况，只有会第一种，第二种是不会有的，就算有这次的广播也无法正常发送。为什么呢，下面来解释一下（这里我没做验证，是光看代码的，但是感觉应该没错）：</p>
<p>第一，如果发生了第二种情况，IIntentReceiver 这个接口的实现是用 aidl 弄的，自己去 out 下翻一下，会发现这个接口没有判断 Bn 不在的情况下，启动进程的情况，也就是说如果接收器进程挂了，调用这个 IPC 接口，根本不会重新启动接收器进程。那就是说这种情况下 IPC 通信是会失败的，因为 Bn 没了。</p>
<p>第二，其实正常情况下，上面那种情况不会出现。去注册篇仔细看下 AMS 的 registerReceiver 注册了一个 IIntentReceiver 的死亡通知回调：</p>
<pre>
receiver.asBinder().linkToDeath(rl, 0);
</pre>

<p>当动态动态的接收器进程挂了，会调用这个一个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class ReceiverList extends ArrayList&lt;BroadcastFilter&gt;</div><div class="line">        implements IBinder.DeathRecipient {</div><div class="line">    <span class="keyword">final</span> ActivityManagerService owner;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IIntentReceiver receiver;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>() {</div><div class="line">        linkedToDeath = <span class="keyword">false</span>;</div><div class="line">        owner.unregisterReceiver(receiver);</div><div class="line">    }</div><div class="line"></div><div class="line">... ....</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>就相当于如果动态注册的接收器进程挂了，AMS 会自动注销它的，我们稍微看下 AMS 的 unregisterReceiver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span>(IIntentReceiver receiver) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Unregister receiver: "</span> + receiver);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> { </div><div class="line">        <span class="keyword">boolean</span> doTrim = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">            ReceiverList rl</div><div class="line">            = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</div><div class="line">            <span class="keyword">if</span> (rl != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// 这里是后面串行广播处理相关的，这里可以不用管先</span></div><div class="line">                <span class="keyword">if</span> (rl.curBroadcast != <span class="keyword">null</span>) {</div><div class="line">                    BroadcastRecord r = rl.curBroadcast;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> doNext = finishReceiverLocked(</div><div class="line">                            receiver.asBinder(), r.resultCode, r.resultData,</div><div class="line">                            r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">if</span> (doNext) {</div><div class="line">                        doTrim = <span class="keyword">true</span>; </div><div class="line">                        r.queue.processNextBroadcast(<span class="keyword">false</span>);</div><div class="line">                    }     </div><div class="line">                }     </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) {</div><div class="line">                    rl.app.receivers.remove(rl);</div><div class="line">                }     </div><div class="line">                <span class="comment">// 接下去看下这个 remove 函数</span></div><div class="line">                removeReceiverLocked(rl);</div><div class="line">                <span class="keyword">if</span> (rl.linkedToDeath) {</div><div class="line">                    rl.linkedToDeath = <span class="keyword">false</span>;</div><div class="line">                    rl.receiver.asBinder().unlinkToDeath(rl, <span class="number">0</span>);</div><div class="line">                }     </div><div class="line">            }     </div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="comment">// If we actually concluded any broadcasts, we might now be able</span></div><div class="line">        <span class="comment">// to trim the recipients' apps from our working set</span></div><div class="line">        <span class="keyword">if</span> (doTrim) {</div><div class="line">            trimApplications();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> removeReceiverLocked(ReceiverList rl) {</div><div class="line">    mRegisteredReceivers.remove(rl.receiver.asBinder());</div><div class="line">    <span class="keyword">int</span> N = rl.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">        <span class="comment">// 调用 IntentResolver 的 removeFilter 去删除</span></div><div class="line">        <span class="comment">// 和 addFilter 对应的，这里不多分析这个了，</span></div><div class="line">        <span class="comment">// 反正就是删掉之后，查询的时候就查不到这个接收器的 filter 了</span></div><div class="line">        mReceiverResolver.removeFilter(rl.get(i));</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以说正常情况下，动态注册的接收器进程挂了，broadcastIntentLocked 的时候根本就查询不到有这个接收器的。所以第二种情况基本上不会发生吧。这里我们直接看第一种情况，就是接收器进程正在运行（这才是正常情况，要不然怎么叫动态注册咧）。这个时候就可以直接调用 IApplicationThread 的 scheduleRegisteredReceiver 函数执行接收器函数。看这个名字就知道 IPC 调用了，这个是当然的，接收器在另外的进程里面（广播处理的是在 AMS 中，system_server 进程）。然后我们去 Bn 端看看（这个时候我们是在接收器的进程了，）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================== ActivityThread.java =======================</span></div><div class="line"></div><div class="line">    <span class="comment">// 看这个继承类的名字，没有用 aidl，Bp 和 Interface 实现都是自己写的</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// This function exists to make sure all receiver dispatching is</span></div><div class="line">        <span class="comment">// correctly ordered, since these are one-way calls and the binder driver</span></div><div class="line">        <span class="comment">// applies transaction ordering per object for such calls.</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span>(IIntentReceiver receiver, Intent intent,</div><div class="line">                <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</div><div class="line">                <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) <span class="keyword">throws</span> RemoteException {</div><div class="line">            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class="line">                    sticky, sendingUser);</div><div class="line">        }  </div><div class="line"></div><div class="line">... ... </div><div class="line">                </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>IIntentReceiver 再经过 IPC 传到接收器进程，已经是 Bn 端了，我们终于可以去看注册篇里面那个 LoadedApk 的内部类的内部类的 InnerReceiver 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> class InnerReceiver extends IIntentReceiver.Stub { </div><div class="line">    <span class="keyword">final</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</div><div class="line">    <span class="keyword">final</span> LoadedApk.ReceiverDispatcher mStrongRef;</div><div class="line"></div><div class="line">    InnerReceiver(LoadedApk.ReceiverDispatcher rd, <span class="keyword">boolean</span> strong) {</div><div class="line">        mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</div><div class="line">        mStrongRef = strong ? rd : <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span>(Intent intent, <span class="keyword">int</span> resultCode, String data,</div><div class="line">            Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">        LoadedApk.ReceiverDispatcher rd = mDispatcher.get();</div><div class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) {</div><div class="line">            <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>); </div><div class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Receiving broadcast "</span> + intent.getAction() + <span class="string">" seq="</span> + seq</div><div class="line">                    + <span class="string">" to "</span> + (rd != <span class="keyword">null</span> ? rd.mReceiver : <span class="keyword">null</span>));</div><div class="line">        }</div><div class="line">        <span class="comment">// 还得绕一下</span></div><div class="line">        <span class="keyword">if</span> (rd != <span class="keyword">null</span>) {              </div><div class="line">            rd.performReceive(intent, resultCode, data, extras,</div><div class="line">                    ordered, sticky, sendingUser); </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 看注释，可能在 AMS 分发广播给这个接收器之前，这个接收器就被注销了</span></div><div class="line">            <span class="comment">// 所以这里发送完成消息，注意这个完成消息对于串行广播的处理很关键的</span></div><div class="line">            <span class="comment">// The activity manager dispatched a broadcast to a registered</span></div><div class="line">            <span class="comment">// receiver in this process, but before it could be delivered the</span></div><div class="line">            <span class="comment">// receiver was unregistered.  Acknowledge the broadcast on its</span></div><div class="line">            <span class="comment">// behalf so that the system's broadcast sequence can continue.</span></div><div class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing broadcast to unregistered receiver"</span>);</div><div class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="keyword">if</span> (extras != <span class="keyword">null</span>) {          </div><div class="line">                    extras.setAllowFds(<span class="keyword">false</span>);     </div><div class="line">                }</div><div class="line">                mgr.finishReceiver(<span class="keyword">this</span>, resultCode, data, extras, <span class="keyword">false</span>);</div><div class="line">            } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">                Slog.w(ActivityThread.TAG, <span class="string">"Couldn't finish broadcast to unregistered receiver"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里继续去看 LoadedApk.ReceiverDispatcher 的 performReceive：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span>(Intent intent, <span class="keyword">int</span> resultCode, String data,</div><div class="line">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) {</div><div class="line">        <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>); </div><div class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Enqueueing broadcast "</span> + intent.getAction() + <span class="string">" seq="</span> + seq</div><div class="line">                + <span class="string">" to "</span> + mReceiver);         </div><div class="line">    }</div><div class="line">    <span class="comment">// 这里 post 了一个 Runnable（Args 实现了 Runnable）</span></div><div class="line">    Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</div><div class="line">            sticky, sendingUser);          </div><div class="line">    <span class="keyword">if</span> (!mActivityThread.post(args)) {</div><div class="line">        <span class="keyword">if</span> (mRegistered && ordered) {  </div><div class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</div><div class="line">            <span class="comment">// 对于注册的接收器并且是串行广播的话</span></div><div class="line">            <span class="comment">// 如果 post 失败，发送完成消息，前面说这个对于串行广播很关键的</span></div><div class="line">            args.sendFinished(mgr);        </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得注册篇中注册的接口时候有一个 Handler 的可选参数的么，那个是可以让调用者指定接收器运行的线程（Handler 所运行的线程，如果没指定的话，默认使用调用者所在进程的主线程）。这个 mActivityThread 就是保存了注册时候的那个 Handler：</p>
<pre>
final Handler mActivityThread; 
</pre>

<p>叫 mActivityThread 其实是一个 Handler，所以这里其实是<strong>把接收器扔到注册的时候指定的线程去执行去了</strong>。然后我们接下去看 Args 这个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 果然是实现了 Runnable</span></div><div class="line"><span class="keyword">final</span> class Args extends BroadcastReceiver.PendingResult implements Runnable {</div><div class="line">    <span class="keyword">private</span> Intent mCurIntent;     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mOrdered;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Args</span>(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras,</div><div class="line">                mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED,</div><div class="line">                ordered, sticky, mIIntentReceiver.asBinder(), sendingUser);</div><div class="line">        mCurIntent = intent;           </div><div class="line">        mOrdered = ordered;            </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {            </div><div class="line">        <span class="comment">// Args 是 LoadedApk.ReceiverDispatcher 的内部类</span></div><div class="line">        <span class="comment">// 这个 mReceiver 就是当初注册接收器的时候 new LoadedApk.ReceiverDispatcher </span></div><div class="line">        <span class="comment">// 保存传过来的 BroadcastRecevier 对象</span></div><div class="line">        <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) {</div><div class="line">            <span class="keyword">int</span> seq = mCurIntent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Dispatching broadcast "</span> + mCurIntent.getAction()</div><div class="line">                    + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</div><div class="line">            Slog.i(ActivityThread.TAG, <span class="string">"  mRegistered="</span> + mRegistered </div><div class="line">                    + <span class="string">" mOrderedHint="</span> + ordered); </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        <span class="keyword">final</span> Intent intent = mCurIntent;</div><div class="line">        mCurIntent = <span class="keyword">null</span>;             </div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || mForgotten) {</div><div class="line">            <span class="keyword">if</span> (mRegistered && ordered) {</div><div class="line">                <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                        <span class="string">"Finishing null broadcast to "</span> + mReceiver);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveReg"</span>);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 暂时没明白这里保存接收器的 ClassLoader 有什么用</span></div><div class="line">            <span class="comment">// 可能要 new 什么东西出来吧，这里先不管这么多了</span></div><div class="line">            ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class="line">            intent.setExtrasClassLoader(cl);</div><div class="line">            setExtrasClassLoader(cl);</div><div class="line">            <span class="comment">// 广播好像可以带返回信息的，这里也先不管先</span></div><div class="line">            receiver.setPendingResult(<span class="keyword">this</span>);</div><div class="line">            <span class="comment">// 反正最后终于调用到接收器的 onReceive 了</span></div><div class="line">            receiver.onReceive(mContext, intent);</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            <span class="comment">// 如果前面执行出了什么异常，记得要发送完成信息</span></div><div class="line">            <span class="keyword">if</span> (mRegistered && ordered) {</div><div class="line">                <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                        <span class="string">"Finishing failed broadcast to "</span> + mReceiver);</div><div class="line">                sendFinished(mgr);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</div><div class="line">                    !mInstrumentation.onException(mReceiver, e)) {</div><div class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Error receiving broadcast "</span> + intent</div><div class="line">                    + <span class="string">" in "</span> + mReceiver, e);</div><div class="line">            } </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) {</div><div class="line">            finish();</div><div class="line">        }</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">    }               </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>LoadedApk.ReceiverDispatcher 的 mReceiver 就是注册广播接收器的时候 new LoadedApk.ReceiverDispatcher 传进来那个 BroadcastReceiver 对象（忘记的回去注册篇看看）。这里在执行的线程中跑 run 函数，最终调用到了注册者实现的 BroadcastReceiver 的 onReceive 回调。到这里一个动态注册的广播接收器就算处理完成了。</p>
<p>这里回到前面 performReceive 的 mActivityThread.post 那里。前面说了现在是处理并行广播，怎么体现出来是并行的咧。再回去远一点，从接收器进程回到 AMS 的 processNextBroadcast 的那个 while 循环那里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {</div><div class="line">            <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) { </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</div><div class="line">                }    </div><div class="line">            }</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>因为 performReceive 那里是 post 了一个 Runnable（LoadedApk.ReceiverDispatcher.Args）到一个 Handler 中，所以会马上返回（不会等待接收器的执行），所以 IPC 也会马上从接收器进程返回到 AMS 这边，所以 while（for）循环就会继续往下执行下一个接收器的处理。从精确的角度说虽然还是会有先后，但是广播这的东西本身不是什么太精准的东西，所以约等于是并行处理了。</p>
<p>这里我们从 processNextBroadcast 分段那里直接返回，因为后面是串行广播的处理（静态注册的接收器），然后我们就可以回到 AMS 的 broadcastIntentLocked 继续往下走了。</p>
<h2 id="c-_分发广播给静态注册接收器">c. 分发广播给静态注册接收器</h2>
<p>我们接着往下看 broadcastIntentLocked，下面是这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里是将前面还没处理的动态接收器和静态接收器合并为一个接收器列表</span></div><div class="line"><span class="comment">// 这里是合并到 receivers（之前是收集了静态的接收器）</span></div><div class="line"><span class="comment">// 这里知道为什么 receivers 要声明为 List 了，因为里面可能存2种类型的数据</span></div><div class="line"><span class="comment">// Merge into one list.</span></div><div class="line"><span class="keyword">int</span> ir = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (receivers != <span class="keyword">null</span>) {</div><div class="line">    <span class="comment">// 这段是说，如果一个应该刚安装上，还没被用户运行，那么将它静态注册的接收器排除掉</span></div><div class="line">    <span class="comment">// 这么做的目的是防止应用一刚装上就能够接收广播，然后被偷偷摸摸的启动起来</span></div><div class="line">    <span class="comment">// 可以预防一些恶意软件偷偷摸摸干坏事</span></div><div class="line">    <span class="comment">// A special case for PACKAGE_ADDED: do not allow the package</span></div><div class="line">    <span class="comment">// being added to see this broadcast.  This prevents them from</span></div><div class="line">    <span class="comment">// using this as a back door to get run as soon as they are</span></div><div class="line">    <span class="comment">// installed.  Maybe in the future we want to have a special install</span></div><div class="line">    <span class="comment">// broadcast or such for apps, but we'd like to deliberately make</span></div><div class="line">    <span class="comment">// this decision.</span></div><div class="line">    String skipPackages[] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</div><div class="line">            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</div><div class="line">            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {</div><div class="line">        Uri data = intent.getData();</div><div class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) {</div><div class="line">            String pkgName = data.getSchemeSpecificPart();</div><div class="line">            <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>) {</div><div class="line">                skipPackages = <span class="keyword">new</span> String[] { pkgName };</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {</div><div class="line">        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (skipPackages != <span class="keyword">null</span> && (skipPackages.length &gt; <span class="number">0</span>)) {</div><div class="line">        <span class="keyword">for</span> (String skipPackage : skipPackages) {</div><div class="line">            <span class="keyword">if</span> (skipPackage != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">int</span> NT = receivers.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> it=<span class="number">0</span>; it&lt;NT; it++) {</div><div class="line">                    ResolveInfo curt = (ResolveInfo)receivers.get(it);</div><div class="line">                    <span class="keyword">if</span> (curt.activityInfo.packageName.equals(skipPackage)) {</div><div class="line">                        receivers.remove(it);</div><div class="line">                        it--;</div><div class="line">                        NT--;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 下面这段是取前面剩下的动态注册的接收器。为什么说剩下，因为前面如果动态注册的接收器处理了，</span></div><div class="line">    <span class="comment">// NR 是 0，registeredReceivers 也会变成 null。</span></div><div class="line">    <span class="comment">// 但是如果发送的是串行广播，那前面处理动态注册接收器的并行处理就不会执行，</span></div><div class="line">    <span class="comment">// 动态注册的接收器就只能留到下面和静态注册的接收一起串行处理进行。</span></div><div class="line">    <span class="keyword">int</span> NT = receivers != <span class="keyword">null</span> ? receivers.size() : <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> it = <span class="number">0</span>;</div><div class="line">    ResolveInfo curt = <span class="keyword">null</span>;</div><div class="line">    BroadcastFilter curr = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (it &lt; NT && ir &lt; NR) {</div><div class="line">        <span class="keyword">if</span> (curt == <span class="keyword">null</span>) {</div><div class="line">            curt = (ResolveInfo)receivers.get(it);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (curr == <span class="keyword">null</span>) {</div><div class="line">            curr = registeredReceivers.get(ir);</div><div class="line">        }</div><div class="line">        <span class="comment">// 这里判断一下剩下的动态注册的接收器的优先级是否比静态注册的要高</span></div><div class="line">        <span class="comment">// 如果高的话，就插到 list 的前面， it 计数是从 0 开始的。</span></div><div class="line">        <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) {</div><div class="line">            <span class="comment">// Insert this broadcast record into the final list.</span></div><div class="line">            receivers.add(it, curr);</div><div class="line">            ir++;</div><div class="line">            curr = <span class="keyword">null</span>;</div><div class="line">            it++;</div><div class="line">            NT++;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// Skip to the next ResolveInfo in the final list.</span></div><div class="line">            it++;</div><div class="line">            curt = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// 经过上面的筛选，剩下的动态注册的接收器优先级都是没静态注册的优先级高的，</span></div><div class="line"><span class="comment">// 全部插到 list 的最后。</span></div><div class="line"><span class="keyword">while</span> (ir &lt; NR) {</div><div class="line">    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) {</div><div class="line">        receivers = <span class="keyword">new</span> ArrayList();</div><div class="line">    }</div><div class="line">    receivers.add(registeredReceivers.get(ir));</div><div class="line">    ir++;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这段就是将剩下还没处理的动态注册的接收器合并到静态注册接收器的 list 里面去了，然后下面是 broadcastIntentLocked 的最后一段，串行处理静态注册接收器（包括强制发串行广播的动态注册的接收器）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span>(ProcessRecord callerApp,</div><div class="line">            String callerPackage, Intent intent, String resolvedType,</div><div class="line">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">            Bundle map, String requiredPermission,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</div><div class="line">            <span class="keyword">int</span> userId) {</div><div class="line">... ...</div><div class="line">        </div><div class="line">        <span class="comment">// 这段代码和前面处理动态注册接收器那几乎是一样的 ... ...</span></div><div class="line">        <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> && receivers.size() &gt; <span class="number">0</span>)</div><div class="line">                || resultTo != <span class="keyword">null</span>) {</div><div class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">            <span class="comment">// 区别一：这里传给 BroadcastRecord 是 receivers（合并过的接收器列表，可以说是静态接收器吧）</span></div><div class="line">            <span class="comment">// 前面是 registeredReceivers，动态注册接收器</span></div><div class="line">            BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</div><div class="line">                    callerPackage, callingPid, callingUid, requiredPermission,</div><div class="line">                    receivers, resultTo, resultCode, resultData, map, ordered,</div><div class="line">                    sticky, <span class="keyword">false</span>, userId);</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                    TAG, <span class="string">"Enqueueing ordered broadcast "</span> + r</div><div class="line">                    + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) {</div><div class="line">                <span class="keyword">int</span> seq = r.intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">                Slog.i(TAG, <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction() + <span class="string">" seq="</span> + seq);</div><div class="line">            }</div><div class="line">            <span class="keyword">boolean</span> replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);</div><div class="line">            <span class="keyword">if</span> (!replaced) {</div><div class="line">                <span class="comment">// 区别二：前面是插入并行队列，这里是串行队列</span></div><div class="line">                queue.enqueueOrderedBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里唯一和前面的区别就是处理的接收器的列表不一样，然后在 BroadcastQueue 中排队的队列也不一样。我们可以直接跳到前面的 processNextBroadcast 返回那里（前面那些流程都是一样的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Now take care of the next serialized one...</span></div><div class="line"></div><div class="line"><span class="comment">// 看到这个 Pending 命名的是不是有点眼熟，去看下 Binder 普通服务对象篇，</span></div><div class="line"><span class="comment">// 目标进程没启动，就是使用了一个叫 mPendingService 的来保存需要等待目标</span></div><div class="line"><span class="comment">// 进程启动来做一些事情的。这里也是一样的，不过这里留到后面去分析</span></div><div class="line"><span class="comment">// If we are waiting for a process to come up to handle the next</span></div><div class="line"><span class="comment">// broadcast, then do nothing at this point.  Just in case, we</span></div><div class="line"><span class="comment">// check that the process we're waiting for still exists.</span></div><div class="line"><span class="keyword">if</span> (mPendingBroadcast != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) {</div><div class="line">        Slog.v(TAG, <span class="string">"processNextBroadcast ["</span></div><div class="line">                + mQueueName + <span class="string">"]: waiting for "</span></div><div class="line">                + mPendingBroadcast.curApp);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> isDead;</div><div class="line">    <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) {</div><div class="line">        isDead = (mService.mPidsSelfLocked.get(</div><div class="line">                mPendingBroadcast.curApp.pid) == <span class="keyword">null</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!isDead) {</div><div class="line">        <span class="comment">// It's still alive, so keep waiting</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Slog.w(TAG, <span class="string">"pending app  ["</span></div><div class="line">                + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</div><div class="line">                + <span class="string">" died before responding to broadcast"</span>);</div><div class="line">        mPendingBroadcast.state = BroadcastRecord.IDLE;</div><div class="line">        mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</div><div class="line">        mPendingBroadcast = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> looped = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">do { </div><div class="line">    <span class="comment">// 前面处理并行的不说后面可以直接返回么，就是这个判断了，</span></div><div class="line">    <span class="comment">// 如果串行队列里没数据，就直接 return，不过现在有数据了。</span></div><div class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) { </div><div class="line">        <span class="comment">// No more broadcasts pending, so all done!</span></div><div class="line">        mService.scheduleAppGcsLocked();</div><div class="line">        <span class="keyword">if</span> (looped) {</div><div class="line">            <span class="comment">// If we had finished the last ordered broadcast, then</span></div><div class="line">            <span class="comment">// make sure all processes have correct oom and sched</span></div><div class="line">            <span class="comment">// adjustments.</span></div><div class="line">            mService.updateOomAdjLocked();</div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }    </div><div class="line">    r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">    <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 下面这段我们留到后面讲串行广播的实现的时候再说</span></div><div class="line">    ... ...</div><div class="line">    </div><div class="line">} <span class="keyword">while</span> (r == <span class="keyword">null</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的简单过过就行，一些东西我们这里不去深究，继续看下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意这个 nextReceiver++，后面会知道这个的作用</span></div><div class="line"><span class="comment">// Get the next receiver...    </span></div><div class="line"><span class="keyword">int</span> recIdx = r.nextReceiver++; </div><div class="line"></div><div class="line"><span class="comment">// 这里设置接收器接收到广播的时间为当前的系统时间，</span></div><div class="line"><span class="comment">// 然后设置一个超时等待（为什么要设置超时等待后面再说）</span></div><div class="line"><span class="comment">// Keep track of when this receiver started, and make sure there</span></div><div class="line"><span class="comment">// is a timeout message pending to kill it if need be.</span></div><div class="line">r.receiverTime = SystemClock.uptimeMillis();</div><div class="line"><span class="keyword">if</span> (recIdx == <span class="number">0</span>) {</div><div class="line">    r.dispatchTime = r.receiverTime;</div><div class="line">    r.dispatchClockTime = System.currentTimeMillis();</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Processing ordered broadcast ["</span></div><div class="line">            + mQueueName + <span class="string">"] "</span> + r);           </div><div class="line">}</div><div class="line"><span class="comment">// 如果没有设置超时的话，设置一个超时（这个超时的作用后面再说）</span></div><div class="line"><span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) {</div><div class="line">    <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG,</div><div class="line">            <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></div><div class="line">            + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</div><div class="line">    setBroadcastTimeoutLocked(timeoutTime);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面这种情况很简单，其实就是前面的动态注册接收器推迟到这里处理而已。</span></div><div class="line"><span class="comment">// (BroadcastFilter 是动态注册的类型 AMS 里面的，ResolveInfo 是静态的， PMS 里面的)</span></div><div class="line"><span class="comment">// 如果发送串行广播，动态注册接收器就无法并行执行，所以放到这里串行执行。</span></div><div class="line">Object nextReceiver = r.receivers.get(recIdx);</div><div class="line"><span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) {</div><div class="line">    <span class="comment">// Simple case: this is a registered receiver who gets</span></div><div class="line">    <span class="comment">// a direct call.              </span></div><div class="line">    BroadcastFilter filter = (BroadcastFilter)nextReceiver; </div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">            <span class="string">"Delivering ordered ["</span>         </div><div class="line">            + mQueueName + <span class="string">"] to registered "</span></div><div class="line">            + filter + <span class="string">": "</span> + r);                 </div><div class="line">    deliverToRegisteredReceiverLocked(r, filter, r.ordered);</div><div class="line">    <span class="keyword">if</span> (r.receiver == <span class="keyword">null</span> || !r.ordered) {</div><div class="line">        <span class="comment">// The receiver has already finished, so schedule to</span></div><div class="line">        <span class="comment">// process the next one.       </span></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Quick finishing ["</span></div><div class="line">                + mQueueName + <span class="string">"]: ordered="</span>   </div><div class="line">                + r.ordered + <span class="string">" receiver="</span> + r.receiver);</div><div class="line">        r.state = BroadcastRecord.IDLE;</div><div class="line">        scheduleBroadcastsLocked();</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>到这里其实都还不是静态注册接收器的处理，只是把前面动态注册的接收器串行处理了而已，流程前面说过了。现在我们继续往下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Hard case: need to instantiate the receiver, possibly</span></div><div class="line"><span class="comment">// starting its application process to host it.</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的是静态注册的接收器了，ResolverInfo PMS 中的</span></div><div class="line">ResolveInfo info =</div><div class="line">    (ResolveInfo)nextReceiver;</div><div class="line">ComponentName component = <span class="keyword">new</span> ComponentName(</div><div class="line">        info.activityInfo.applicationInfo.packageName,</div><div class="line">        info.activityInfo.name);</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">int</span> perm = mService.checkComponentPermission(info.activityInfo.permission,</div><div class="line">        r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</div><div class="line">        info.activityInfo.exported);</div><div class="line"><span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">    <span class="keyword">if</span> (!info.activityInfo.exported) {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></div><div class="line">                + r.intent.toString()</div><div class="line">                + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</div><div class="line">                + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></div><div class="line">                + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</div><div class="line">                + <span class="string">" due to receiver "</span> + component.flattenToShortString());</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></div><div class="line">                + r.intent.toString()</div><div class="line">                + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</div><div class="line">                + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></div><div class="line">                + <span class="string">" requires "</span> + info.activityInfo.permission</div><div class="line">                + <span class="string">" due to receiver "</span> + component.flattenToShortString());</div><div class="line">    }</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &&</div><div class="line">    r.requiredPermission != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        perm = AppGlobals.getPackageManager().</div><div class="line">                checkPermission(r.requiredPermission,</div><div class="line">                        info.activityInfo.applicationInfo.packageName);</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        perm = PackageManager.PERMISSION_DENIED;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></div><div class="line">                + r.intent + <span class="string">" to "</span></div><div class="line">                + component.flattenToShortString()</div><div class="line">                + <span class="string">" requires "</span> + r.requiredPermission</div><div class="line">                + <span class="string">" due to sender "</span> + r.callerPackage</div><div class="line">                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</div><div class="line">        skip = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">boolean</span> isSingleton = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">try</span> {</div><div class="line">    isSingleton = mService.isSingleton(info.activityInfo.processName,</div><div class="line">            info.activityInfo.applicationInfo,</div><div class="line">            info.activityInfo.name, info.activityInfo.flags);</div><div class="line">} <span class="keyword">catch</span> (SecurityException e) {</div><div class="line">    Slog.w(TAG, e.getMessage());</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ((info.activityInfo.flags&ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) {</div><div class="line">    <span class="keyword">if</span> (ActivityManager.checkUidPermission(</div><div class="line">            android.Manifest.permission.INTERACT_ACROSS_USERS,</div><div class="line">            info.activityInfo.applicationInfo.uid)</div><div class="line">                    != PackageManager.PERMISSION_GRANTED) {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</div><div class="line">                + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></div><div class="line">                + android.Manifest.permission.INTERACT_ACROSS_USERS);</div><div class="line">        skip = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> && r.curApp.crashing) {</div><div class="line">    <span class="comment">// If the target process is crashing, just skip it.</span></div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG,</div><div class="line">            <span class="string">"Skipping deliver ordered ["</span></div><div class="line">            + mQueueName + <span class="string">"] "</span> + r + <span class="string">" to "</span> + r.curApp</div><div class="line">            + <span class="string">": process crashing"</span>);</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> (skip) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG,</div><div class="line">            <span class="string">"Skipping delivery of ordered ["</span></div><div class="line">            + mQueueName + <span class="string">"] "</span> + r + <span class="string">" for whatever reason"</span>);</div><div class="line">    r.receiver = <span class="keyword">null</span>;</div><div class="line">    r.curFilter = <span class="keyword">null</span>;</div><div class="line">    r.state = BroadcastRecord.IDLE;</div><div class="line">    scheduleBroadcastsLocked();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面这一段我们也可以简单略过，就是权限检测，检测当前这个接收器有没有权限处理这次的广播，如果没有就忽略这个接收器；还有判断了接收器所在的进程是不是挂掉了，挂掉了也忽略这个接收器。我们接下来继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意一下，这里处理的时候把状态设置为了 APP_RECEIVE</span></div><div class="line">r.state = BroadcastRecord.APP_RECEIVE;</div><div class="line"><span class="comment">// 获取接收器进程信息</span></div><div class="line">String targetProcess = info.activityInfo.processName;</div><div class="line">r.curComponent = component;</div><div class="line"><span class="keyword">if</span> (r.callingUid != Process.SYSTEM_UID && isSingleton) {</div><div class="line">    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, <span class="number">0</span>);</div><div class="line">}</div><div class="line"><span class="comment">// 这个 info 就是 AMS 从 PMS 那查询到匹配的静态注册的接收器的数据结构 ResolveInfo</span></div><div class="line"><span class="comment">// 把这个关键信息保存到 BroadcastRecord 的 curReceiver 中</span></div><div class="line">r.curReceiver = info.activityInfo;</div><div class="line"><span class="keyword">if</span> (DEBUG_MU && r.callingUid &gt; UserHandle.PER_USER_RANGE) {</div><div class="line">    Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></div><div class="line">            + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></div><div class="line">            + info.activityInfo.applicationInfo.uid);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这里估计是禁止去把接收器的 apk 设置为 stop 状态吧</span></div><div class="line"><span class="comment">// Broadcast is being executed, its package can't be stopped.</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</div><div class="line">            r.curComponent.getPackageName(), <span class="keyword">false</span>, UserHandle.getUserId(r.callingUid));</div><div class="line">} <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">} <span class="keyword">catch</span> (IllegalArgumentException e) {</div><div class="line">    Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></div><div class="line">            + r.curComponent.getPackageName() + <span class="string">": "</span> + e);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面就要分2种情况来讨论。还记得 <a href="http://light3moon.com/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递" title="Android Binder 分析——普通服务 Binder 对象的传递" target="_blank" rel="external">Android Binder 分析——普通服务 Binder 对象的传递</a>  中分了3种情况来讨论启动普通应用的服务，这里也是同样的道理。要分为接收器的进程是否已经启动在讨论：</p>
<h3 id="接收器进程已经启动">接收器进程已经启动</h3>
<p>我们先来看简单的情况，接收器的进程已经启动。这种情况不需要等待接收器进程启动，可以直接发起 IPC 调用，在接收器进程中跑处理广播的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 取接收器进程的记录（这个 ProcessRecord 经过 Binder 篇应该不陌生了）</span></div><div class="line"><span class="comment">// Is this receiver's application already running?</span></div><div class="line">ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</div><div class="line">        info.activityInfo.applicationInfo.uid);</div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">if</span> (app != <span class="keyword">null</span> && app.thread != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 这个 addPackage 有啥用我们先不管</span></div><div class="line">        app.addPackage(info.activityInfo.packageName);</div><div class="line">        <span class="comment">// 到下面这个函数了，然后后面直接返回</span></div><div class="line">        processCurBroadcastLocked(r, app);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></div><div class="line">              + r.curComponent, e);</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">        <span class="comment">// 注意下这里的出错处理也是比较关键的，我们后面再说</span></div><div class="line">        Log.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></div><div class="line">                + r.curComponent + <span class="string">" with "</span> + r.intent, e);</div><div class="line">        <span class="comment">// If some unexpected exception happened, just skip</span></div><div class="line">        <span class="comment">// this broadcast.  At this point we are not in the call</span></div><div class="line">        <span class="comment">// from a client, so throwing an exception out from here</span></div><div class="line">        <span class="comment">// will crash the entire system instead of just whoever</span></div><div class="line">        <span class="comment">// sent the broadcast.</span></div><div class="line">        logBroadcastReceiverDiscardLocked(r);</div><div class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">                r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">        scheduleBroadcastsLocked();</div><div class="line">        <span class="comment">// We need to reset the state if we failed to start the receiver.</span></div><div class="line">        r.state = BroadcastRecord.IDLE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// If a dead object exception was thrown -- fall through to</span></div><div class="line">    <span class="comment">// restart the application.</span></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接着去看 processCurBroadcastLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processCurBroadcastLocked</span>(BroadcastRecord r,</div><div class="line">        ProcessRecord app) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">            <span class="string">"Process cur broadcast "</span> + r + <span class="string">" for app "</span> + app);</div><div class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) {      </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();   </div><div class="line">    }</div><div class="line">    <span class="comment">// 取得接收器进程 IBinder 对象</span></div><div class="line">    r.receiver = app.thread.asBinder();</div><div class="line">    r.curApp = app;</div><div class="line">    app.curReceiver = r;</div><div class="line">    mService.updateLruProcessLocked(app, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Tell the application to launch this receiver.</span></div><div class="line">    r.intent.setComponent(r.curComponent);</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;       </div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG,</div><div class="line">                <span class="string">"Delivering to component "</span> + r.curComponent</div><div class="line">                + <span class="string">": "</span> + r);                                    </div><div class="line">        mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());</div><div class="line">        <span class="comment">// 这个和前面动态注册的调用的 IApplicationThread 接口有点像，但是不是同一个</span></div><div class="line">        <span class="comment">// （动态注册调用的是 scheduleRegisteredReceiver）</span></div><div class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> Intent(r.intent), r.curReceiver,</div><div class="line">                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),</div><div class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId);</div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">                <span class="string">"Process cur broadcast "</span> + r + <span class="string">" DELIVERED for app "</span> + app);</div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        <span class="keyword">if</span> (!started) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">                    <span class="string">"Process cur broadcast "</span> + r + <span class="string">": NOT STARTED!"</span>);</div><div class="line">            r.receiver = <span class="keyword">null</span>;             </div><div class="line">            r.curApp = <span class="keyword">null</span>;               </div><div class="line">            app.curReceiver = <span class="keyword">null</span>;        </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>和前面动态注册的一样，经过 IPC 调用，我们得跑到接收器的进程中去了，还是 ActivityThread.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleReceiver</span>(Intent intent, ActivityInfo info,</div><div class="line">                CompatibilityInfo compatInfo, <span class="keyword">int</span> resultCode, String data, Bundle extras,</div><div class="line">                <span class="keyword">boolean</span> sync, <span class="keyword">int</span> sendingUser) {</div><div class="line">            <span class="comment">// 这里的 ActivityInfo 是 AMS 那里传过来的，是 AMS 从 PMS 那里查询到的</span></div><div class="line">            <span class="comment">// （忘记了的去看看前面的代码）</span></div><div class="line">            <span class="comment">// 然后 new 了一个 ReceiverData 出来，把这个 info 赋值给了 ReceiverData</span></div><div class="line">            ReceiverData r = <span class="keyword">new</span> ReceiverData(intent, resultCode, data, extras,</div><div class="line">                    sync, <span class="keyword">false</span>, mAppThread.asBinder(), sendingUser);</div><div class="line">            r.info = info;</div><div class="line">            r.compatInfo = compatInfo;     </div><div class="line">            queueOrSendMessage(H.RECEIVER, r);</div><div class="line">        }</div><div class="line">... ... </div><div class="line">                </div><div class="line">    }</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里其实就是用了一个 Handler 又绕了半天，最终的处理函数是 handleReceiver： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// if the thread hasn't started yet, we don't have the handler, so just</span></div><div class="line">    <span class="comment">// save the messages until we're ready.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueOrSendMessage</span>(<span class="keyword">int</span> what, Object obj) {</div><div class="line">        queueOrSendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">            </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueOrSendMessage</span>(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2) {</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(</div><div class="line">                TAG, <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what)</div><div class="line">                + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</div><div class="line">            Message msg = Message.obtain();</div><div class="line">            msg.what = what;</div><div class="line">            msg.obj = obj;</div><div class="line">            msg.arg1 = arg1;</div><div class="line">            msg.arg2 = arg2;</div><div class="line">            mH.sendMessage(msg);</div><div class="line">        }   </div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</div><div class="line">... ...</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVER                = <span class="number">113</span>; </div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_SERVICE          = <span class="number">114</span>; </div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</div><div class="line">            <span class="keyword">switch</span> (msg.what) {</div><div class="line">... ...</div><div class="line">                <span class="keyword">case</span> RECEIVER:</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveComp"</span>);</div><div class="line">                    handleReceiver((ReceiverData)msg.obj);</div><div class="line">                    maybeSnapshot();</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">... ...</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&lt;&lt;&lt; done: "</span> + codeToString(msg.what));</div><div class="line">        }</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleReceiver</span>(ReceiverData data) {</div><div class="line">        <span class="comment">// If we are getting ready to gc after going to the background, well</span></div><div class="line">        <span class="comment">// we are back active so skip it.</span></div><div class="line">        unscheduleGcIdler();</div><div class="line"></div><div class="line">        String component = data.intent.getComponent().getClassName();</div><div class="line"></div><div class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class="line">                data.info.applicationInfo, data.compatInfo);</div><div class="line"></div><div class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line"></div><div class="line">        BroadcastReceiver receiver;    </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 这里的 ClassLoader 是用来 new BroadcastReceiver 用的</span></div><div class="line">            <span class="comment">// 为什么前面动态注册的接收器通过 IPC 传递过来，然后直接调用，这里的需要 new</span></div><div class="line">            <span class="comment">// 那是因为动态注册的是把 BroadcastReceiver 保存在了 ReceiverDispatcher 中，</span></div><div class="line">            <span class="comment">// 然后 AMS IPC 调到接收器进程这边直接从 ReceiverDispatcher 中取的。</span></div><div class="line">            <span class="comment">// 这里静态注册的，注册进程这边就没有 BroadcastRecevier，所以现在要 new 出来</span></div><div class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class="line">            data.intent.setExtrasClassLoader(cl);</div><div class="line">            data.setExtrasClassLoader(cl); </div><div class="line">            receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</div><div class="line">                    <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent()); </div><div class="line">            <span class="comment">// 注意出错了，又发送 finish 消息</span></div><div class="line">            data.sendFinished(mgr);        </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Unable to instantiate receiver "</span> + component</div><div class="line">                + <span class="string">": "</span> + e.toString(), e);     </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(         </div><div class="line">                TAG, <span class="string">"Performing receive of "</span> + data.intent</div><div class="line">                + <span class="string">": app="</span> + app               </div><div class="line">                + <span class="string">", appName="</span> + app.getPackageName()</div><div class="line">                + <span class="string">", pkg="</span> + packageInfo.getPackageName() </div><div class="line">                + <span class="string">", comp="</span> + data.intent.getComponent().toShortString()</div><div class="line">                + <span class="string">", dir="</span> + packageInfo.getAppDir());</div><div class="line"></div><div class="line">            ContextImpl context = (ContextImpl)app.getBaseContext();</div><div class="line">            sCurrentBroadcastIntent.set(data.intent);</div><div class="line">            receiver.setPendingResult(data);</div><div class="line">            <span class="comment">// 这里也调用到 BroadcastReceiver 的 onReceive 回调了</span></div><div class="line">            receiver.onReceive(context.getReceiverRestrictedContext(),</div><div class="line">                    data.intent);                  </div><div class="line">        } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</div><div class="line">                    <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent());</div><div class="line">            <span class="comment">// 出错还是会发送 finish 消息</span></div><div class="line">            data.sendFinished(mgr);</div><div class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(receiver, e)) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Unable to start receiver "</span> + component</div><div class="line">                    + <span class="string">": "</span> + e.toString(), e);</div><div class="line">            }</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            sCurrentBroadcastIntent.set(<span class="keyword">null</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 这里很关键，有一个 finish 的调用</span></div><div class="line">            data.finish();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的处理最终调到 onReceiver 了。但是想想看，还是有一个地方没搞明白。前面说了静态注册的接收器是串行执行广播处理的，就是等到当前的那个执行完，才能执行下一个。好了，现在我们来解释下这个串行执行是怎么实现的。回到 AMS 那边的 processNextBroadcast 调用 processCurBroadcastLocked 那里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> {</div><div class="line">    app.addPackage(info.activityInfo.packageName);</div><div class="line">    processCurBroadcastLocked(r, app);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">} <span class="keyword">catch</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就是刚刚我们上面分析的流程，IPC 调用到接收器进程的 onReceive 回调。然后这里 processNextBroadcast 就返回了。AMS 执行 BroadcastQueue.scheduleBroadcastsLocked() 早就返回了，因为 BroadcastQueue 里面是发到 Handler 里面处理 processNextBroadcast 的，然后 processNextBroadcast 结束后， AMS 好像这次广播处理就结束了。可是这才执行了第一个静态注册的接收器而已啊。这个时候去看接收器 handleReceiver 最后有一个：</p>
<pre>
data.finish()
</pre>

<p>这个 finish 是要等到 onReceive 执行完才会调用的（也就是说这个接收器处理完了）。前面说了这个 finish 很关键的，我们来看看 finish 里面做了什么事情。在这里之前得先看看 ReceiverData 这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> class ReceiverData extends BroadcastReceiver.PendingResult {</div><div class="line">    <span class="keyword">public</span> <span class="title">ReceiverData</span>(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, IBinder token, <span class="keyword">int</span> sendingUser) {</div><div class="line">        <span class="comment">// 注意这里传给父类的是 TYPE_COMPONENT</span></div><div class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras, TYPE_COMPONENT, ordered, sticky,</div><div class="line">                token, sendingUser);           </div><div class="line">        <span class="keyword">this</span>.intent = intent;          </div><div class="line">    }</div><div class="line"></div><div class="line">    Intent intent;</div><div class="line">    ActivityInfo info;</div><div class="line">    CompatibilityInfo compatInfo;  </div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {     </div><div class="line">        <span class="keyword">return</span> <span class="string">"ReceiverData{intent="</span> + intent + <span class="string">" packageName="</span> +</div><div class="line">                info.packageName + <span class="string">" resultCode="</span> + getResultCode()</div><div class="line">                + <span class="string">" resultData="</span> + getResultData() + <span class="string">" resultExtras="</span></div><div class="line">                + getResultExtras(<span class="keyword">false</span>) + <span class="string">"}"</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 ReceiverData 是前面 scheduleReceiver 那里 new 出来的，它是继承自 BroadcastReceiver.PendingResult，这得去父类里面去看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Finish the broadcast.  The current result will be sent and the</span></div><div class="line"><span class="comment"> * next broadcast will proceed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finish</span>() {</div><div class="line">    <span class="keyword">if</span> (mType == TYPE_COMPONENT) {</div><div class="line">        <span class="comment">// 这里走的是这里</span></div><div class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        <span class="comment">// 我们先不管下面这个 PendingWork</span></div><div class="line">        <span class="keyword">if</span> (QueuedWork.hasPendingWork()) {</div><div class="line">            <span class="comment">// If this is a broadcast component, we need to make sure any</span></div><div class="line">            <span class="comment">// queued work is complete before telling AM we are done, so</span></div><div class="line">            <span class="comment">// we don't have our process killed before that.  We now know</span></div><div class="line">            <span class="comment">// there is pending work; put another piece of work at the end</span></div><div class="line">            <span class="comment">// of the list to finish the broadcast, so we don't block this</span></div><div class="line">            <span class="comment">// thread (which may be the main thread) to have it finished.</span></div><div class="line">            <span class="comment">//  </span></div><div class="line">            <span class="comment">// Note that we don't need to use QueuedWork.add() with the</span></div><div class="line">            <span class="comment">// runnable, since we know the AM is waiting for us until the</span></div><div class="line">            <span class="comment">// executor gets to it.</span></div><div class="line">            QueuedWork.singleThreadExecutor().execute( <span class="keyword">new</span> Runnable() {</div><div class="line">                <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                            <span class="string">"Finishing broadcast after work to component "</span> + mToken);</div><div class="line">                    Slog.i(ActivityThread.TAG,</div><div class="line">                            <span class="string">"Finishing broadcast after work to component "</span> + mToken);</div><div class="line">                    sendFinished(mgr);</div><div class="line">                }   </div><div class="line">            }); </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing broadcast to component "</span> + mToken);</div><div class="line">            Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing broadcast to component "</span> + mToken);</div><div class="line">            <span class="comment">// 这里最后调用这个函数</span></div><div class="line">            sendFinished(mgr);</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mOrderedHint && mType != TYPE_UNREGISTERED) {</div><div class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                <span class="string">"Finishing broadcast to "</span> + mToken);</div><div class="line">        Slog.i(ActivityThread.TAG,</div><div class="line">                <span class="string">"Finishing broadcast to "</span> + mToken);</div><div class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        sendFinished(mgr);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续去看 sendFinished：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @hide */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFinished</span>(IActivityManager am) {</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">if</span> (mFinished) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Broadcast already finished"</span>);</div><div class="line">        }</div><div class="line">        mFinished = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (mResultExtras != <span class="keyword">null</span>) {</div><div class="line">                mResultExtras.setAllowFds(<span class="keyword">false</span>);</div><div class="line">            }</div><div class="line">            <span class="comment">// 这个 mOrderedHint 如果是串行广播就是 true，这里是 true</span></div><div class="line">            <span class="keyword">if</span> (mOrderedHint) {</div><div class="line">                <span class="comment">// 最后这里果然调用 AMS 里面去了</span></div><div class="line">                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,</div><div class="line">                        mAbortBroadcast);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// This broadcast was sent to a component; it is not ordered,</span></div><div class="line">                <span class="comment">// but we still need to tell the activity manager we are done.</span></div><div class="line">                am.finishReceiver(mToken, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>好，这里接收器进程处理完广播之后，finish 最后有调回 AMS 里面，看到这里是不是猜到了什么呢。对的，没错，串行广播一个接一个的执行是<strong>靠前一个接收器执行完，通知 AMS 把广播发给下一个接收器接着处理来实现的</strong>。虽然猜到了，但是我们还是继续去 AMS 里面看完流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishReceiver</span>(IBinder who, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">        Bundle resultExtras, <span class="keyword">boolean</span> resultAbort) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Finish receiver: "</span> + who);</div><div class="line"></div><div class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></div><div class="line">    <span class="keyword">if</span> (resultExtras != <span class="keyword">null</span> && resultExtras.hasFileDescriptors()) {  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Bundle"</span>);</div><div class="line">    }   </div><div class="line">    </div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">boolean</span> doNext = <span class="keyword">false</span>;</div><div class="line">        BroadcastRecord r = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">            <span class="comment">// 这里先去取上次处理完的 BroadcastRecord</span></div><div class="line">            r = broadcastRecordForReceiverLocked(who);</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// 这里先调用 BroadcastQueue 的 finishReceiverLocked</span></div><div class="line">                <span class="comment">// 来判断是否需要继续往下处理</span></div><div class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</div><div class="line">                    resultData, resultExtras, resultAbort, <span class="keyword">true</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 如果需要继续处理的话，就调用 BroadcastQueue 的 processNextBroadcast</span></div><div class="line">        <span class="keyword">if</span> (doNext) {</div><div class="line">            <span class="comment">// 注意这里参数是 false</span></div><div class="line">            r.queue.processNextBroadcast(<span class="keyword">false</span>);</div><div class="line">        }</div><div class="line">        trimApplications();</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们先来看看怎么取上次处理完成的 BroadcastRecord 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    BroadcastRecord broadcastRecordForReceiverLocked(IBinder receiver) {</div><div class="line">        <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) {</div><div class="line">            BroadcastRecord r = queue.getMatchingOrderedReceiver(receiver);</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    } </div><div class="line"></div><div class="line"><span class="comment">// ========== BroadcastQueue.java ===============</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> BroadcastRecord <span class="title">getMatchingOrderedReceiver</span>(IBinder receiver) {</div><div class="line">        <span class="comment">// 这里只认串行广播的（并行的并不需要这种处理）</span></div><div class="line">        <span class="keyword">if</span> (mOrderedBroadcasts.size() &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 这里只认第一个（上一个处理的就是第一个）</span></div><div class="line">            <span class="keyword">final</span> BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">            <span class="comment">// 还是要判断下 IBinder 对象是不是同一个</span></div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> && r.receiver == receiver) {</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里取到了上一个接收器的 BroadcastRecord，接着去 BroadcastQueue 中看看 finishReceiverLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span>(BroadcastRecord r, <span class="keyword">int</span> resultCode,</div><div class="line">        String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort,</div><div class="line">        <span class="keyword">boolean</span> explicit) {   </div><div class="line">    <span class="comment">// 这里取上一个接收器的 state         </span></div><div class="line">    <span class="keyword">int</span> state = r.state;</div><div class="line">    <span class="comment">// 然后把 state 设置为 IDLE 状态</span></div><div class="line">    r.state = BroadcastRecord.IDLE;</div><div class="line">    <span class="comment">// 正常来说上一个的 state 应该是 APP_RECEIVE 的</span></div><div class="line">    <span class="comment">// 如果不是的话，说明有异常，打印一下警告</span></div><div class="line">    <span class="keyword">if</span> (state == BroadcastRecord.IDLE) {</div><div class="line">        <span class="keyword">if</span> (explicit) {</div><div class="line">            Slog.w(TAG, <span class="string">"finishReceiver ["</span> + mQueueName + <span class="string">"] called but state is IDLE"</span>); </div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 然后下面基本上都设置为 null</span></div><div class="line">    r.receiver = <span class="keyword">null</span>;</div><div class="line">    r.intent.setComponent(<span class="keyword">null</span>);   </div><div class="line">    <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span>) {        </div><div class="line">        r.curApp.curReceiver = <span class="keyword">null</span>;   </div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (r.curFilter != <span class="keyword">null</span>) {     </div><div class="line">        r.curFilter.receiverList.curBroadcast = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    r.curFilter = <span class="keyword">null</span>;</div><div class="line">    r.curApp = <span class="keyword">null</span>;</div><div class="line">    r.curComponent = <span class="keyword">null</span>;</div><div class="line">    r.curReceiver = <span class="keyword">null</span>;</div><div class="line">    mPendingBroadcast = <span class="keyword">null</span>;      </div><div class="line"></div><div class="line">    r.resultCode = resultCode;</div><div class="line">    r.resultData = resultData;</div><div class="line">    r.resultExtras = resultExtras;</div><div class="line">    r.resultAbort = resultAbort;</div><div class="line"></div><div class="line">    <span class="comment">// 最后这里正常来说上一个 state 是 APP_RECEIVE 的，所以一般是返回 true 的</span></div><div class="line">    <span class="comment">// We will process the next receiver right now if this is finishing</span></div><div class="line">    <span class="comment">// an app receiver (which is always asynchronous) or after we have</span></div><div class="line">    <span class="comment">// come back from calling a receiver.</span></div><div class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</div><div class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 BroadcastRecord 的 state，待会我们再讨论。这里正常 finishReceiverLocked 返回 true，就意味着 AMS 会继续调用 BroadcastQueue 的 processNextBroadcast 继续处理。这个 processNextBroadcast 我们前面分析了好久了，不过这里和前面不太一样，首先传过去的参数为 false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {       </div><div class="line">            BroadcastRecord r;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// false 说明不会强制把这个标志设置为 false</span></div><div class="line">            <span class="comment">// 也就是 BroadcastQueue 会继续保持正在执行广播的状态</span></div><div class="line">            <span class="keyword">if</span> (fromMsg) {</div><div class="line">                mBroadcastsScheduled = <span class="keyword">false</span>;  </div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// Now take care of the next serialized one...</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// 现在我们可以来说说前面略过的这一段了</span></div><div class="line">            do {</div><div class="line">                <span class="comment">// 串行广播列表 size 为0，说明已经没有匹配的接收器了</span></div><div class="line">                <span class="comment">// 可以结束本次广播处理了， return 返回。 </span></div><div class="line">                <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) { </div><div class="line">                    <span class="comment">// No more broadcasts pending, so all done!</span></div><div class="line">                    mService.scheduleAppGcsLocked();</div><div class="line">                    <span class="keyword">if</span> (looped) {</div><div class="line">                        <span class="comment">// If we had finished the last ordered broadcast, then</span></div><div class="line">                        <span class="comment">// make sure all processes have correct oom and sched</span></div><div class="line">                        <span class="comment">// adjustments.</span></div><div class="line">                        mService.updateOomAdjLocked();</div><div class="line">                    }    </div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">                <span class="comment">// 这里取到的还是上一个处理完的接收器的 BroadcastRecord</span></div><div class="line">                r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">                <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 下面这里是判断下这个接收器是不是超时了。</span></div><div class="line">                <span class="comment">// dispatchTime 前面有一个地方记录了广播发到这个接收器的时间。</span></div><div class="line">                <span class="comment">// 然后拿之前记录的时候和现在对比，看是不是超过了特定的时间，</span></div><div class="line">                <span class="comment">// 是的话就执行广播超时处理</span></div><div class="line">                <span class="comment">// Ensure that even if something goes awry with the timeout</span></div><div class="line">                <span class="comment">// detection, we catch "hung" broadcasts here, discard them,</span></div><div class="line">                <span class="comment">// and continue to make progress.</span></div><div class="line">                <span class="comment">//   </span></div><div class="line">                <span class="comment">// This is only done if the system is ready so that PRE_BOOT_COMPLETED</span></div><div class="line">                <span class="comment">// receivers don't get executed with timeouts. They're intended for</span></div><div class="line">                <span class="comment">// one time heavy lifting after system upgrades and can take</span></div><div class="line">                <span class="comment">// significant amounts of time.</span></div><div class="line">                <span class="keyword">int</span> numReceivers = (r.receivers != <span class="keyword">null</span>) ? r.receivers.size() : <span class="number">0</span>; </div><div class="line">                <span class="keyword">if</span> (mService.mProcessesReady && r.dispatchTime &gt; <span class="number">0</span>) { </div><div class="line">                    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                    <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &&</div><div class="line">                            (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) {</div><div class="line">                        Slog.w(TAG, <span class="string">"Hung broadcast ["</span></div><div class="line">                                + mQueueName + <span class="string">"] discarded after timeout failure:"</span></div><div class="line">                                + <span class="string">" now="</span> + now</div><div class="line">                                + <span class="string">" dispatchTime="</span> + r.dispatchTime</div><div class="line">                                + <span class="string">" startTime="</span> + r.receiverTime</div><div class="line">                                + <span class="string">" intent="</span> + r.intent</div><div class="line">                                + <span class="string">" numReceivers="</span> + numReceivers</div><div class="line">                                + <span class="string">" nextReceiver="</span> + r.nextReceiver</div><div class="line">                                + <span class="string">" state="</span> + r.state);</div><div class="line"></div><div class="line">                        broadcastTimeoutLocked(<span class="keyword">false</span>); <span class="comment">// forcibly finish this broadcast</span></div><div class="line">                        forceReceive = <span class="keyword">true</span>;</div><div class="line">                        r.state = BroadcastRecord.IDLE;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                </div><div class="line">                <span class="comment">// BroadcastRecord 初始 state 是 IDLE，后面接到广播的时候会变成 APP_RECEIVE</span></div><div class="line">                <span class="comment">// 最后完成的时候（finishReceiver）又会变成 IDLE。</span></div><div class="line">                <span class="comment">// 这里如果不是 IDLE 的话，说明状态异常</span></div><div class="line">                <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) {</div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG,</div><div class="line">                            <span class="string">"processNextBroadcast("</span></div><div class="line">                            + mQueueName + <span class="string">") called when not idle (state="</span></div><div class="line">                            + r.state + <span class="string">")"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 这里是判断的关键，numReceivers 上面取的这个 BroadcastRecord 的 receiver list 有多少个 receiver。</span></div><div class="line">                <span class="comment">// BroadcastRecord 的 nextReceiver 初始值是 0，下面处理一个 receiver 会加 1</span></div><div class="line">                <span class="comment">// 然后我们这里以 receiver list 1 为例子，那么这个 BroadcastRecord 处理完一次后，</span></div><div class="line">                <span class="comment">// r.nextReceiver &gt;= numReceivers 这个判断就会成立，就会跑下面的代码</span></div><div class="line">                <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</div><div class="line">                        || r.resultAbort || forceReceive) {</div><div class="line">                    <span class="comment">// No more receivers for this broadcast!  Send the final</span></div><div class="line">                    <span class="comment">// result if requested...</span></div><div class="line">                    <span class="comment">// 我们先不管带返回信息的广播</span></div><div class="line">                    <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) {</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="keyword">if</span> (DEBUG_BROADCAST) {</div><div class="line">                                <span class="keyword">int</span> seq = r.intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">                                Slog.i(TAG, <span class="string">"Finishing broadcast ["</span></div><div class="line">                                        + mQueueName + <span class="string">"] "</span> + r.intent.getAction()</div><div class="line">                                        + <span class="string">" seq="</span> + seq + <span class="string">" app="</span> + r.callerApp);</div><div class="line">                            }</div><div class="line">                            performReceiveLocked(r.callerApp, r.resultTo,</div><div class="line">                                <span class="keyword">new</span> Intent(r.intent), r.resultCode,</div><div class="line">                                r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</div><div class="line">                            <span class="comment">// Set this to null so that the reference</span></div><div class="line">                            <span class="comment">// (local and remote) isnt kept in the mBroadcastHistory.</span></div><div class="line">                            r.resultTo = <span class="keyword">null</span>;</div><div class="line">                        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                            Slog.w(TAG, <span class="string">"Failure ["</span></div><div class="line">                                    + mQueueName + <span class="string">"] sending broadcast result of "</span></div><div class="line">                                    + r.intent, e);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="comment">// 这里上一个接收器算是正式处理完了，所以把上次设置的超时取消掉（到下一个接收器重新设一个）</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Cancelling BROADCAST_TIMEOUT_MSG"</span>);</div><div class="line">                    cancelBroadcastTimeoutLocked();</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Finished with ordered broadcast "</span></div><div class="line">                            + r);</div><div class="line"></div><div class="line">                    <span class="comment">// ... and on to the next...</span></div><div class="line">                    addBroadcastToHistoryLocked(r);</div><div class="line">                    <span class="comment">// 上一个接收器处理完了，所以就把它从串行列表中删掉</span></div><div class="line">                    mOrderedBroadcasts.remove(<span class="number">0</span>);</div><div class="line">                    r = <span class="keyword">null</span>;</div><div class="line">                    looped = <span class="keyword">true</span>;</div><div class="line">                    <span class="comment">// 结束本循环，去前面取串行队列的下一个 BroadcastRecord</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">            } <span class="keyword">while</span> (r == <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 这里其实应该是上一轮的代码， nextReceiver++（顺带贴这里了）</span></div><div class="line">            <span class="comment">// Get the next receiver...</span></div><div class="line">            <span class="keyword">int</span> recIdx = r.nextReceiver++;</div><div class="line"></div></pre></td></tr></table></figure>

<p>解释基本上代码的注释中，然后贴下 BroadcastRecord 初始化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">BroadcastRecord(BroadcastQueue _queue,</div><div class="line">        Intent _intent, ProcessRecord _callerApp, String _callerPackage,</div><div class="line">        <span class="keyword">int</span> _callingPid, <span class="keyword">int</span> _callingUid, String _requiredPermission,</div><div class="line">        List _receivers, IIntentReceiver _resultTo, <span class="keyword">int</span> _resultCode,</div><div class="line">        String _resultData, Bundle _resultExtras, <span class="keyword">boolean</span> _serialized,</div><div class="line">        <span class="keyword">boolean</span> _sticky, <span class="keyword">boolean</span> _initialSticky,</div><div class="line">        <span class="keyword">int</span> _userId) {</div><div class="line">    queue = _queue;</div><div class="line">    intent = _intent;</div><div class="line">    callerApp = _callerApp;</div><div class="line">    callerPackage = _callerPackage;</div><div class="line">    callingPid = _callingPid;</div><div class="line">    callingUid = _callingUid;</div><div class="line">    requiredPermission = _requiredPermission;</div><div class="line">    receivers = _receivers;</div><div class="line">    resultTo = _resultTo;</div><div class="line">    resultCode = _resultCode;</div><div class="line">    resultData = _resultData;</div><div class="line">    resultExtras = _resultExtras;</div><div class="line">    ordered = _serialized;</div><div class="line">    sticky = _sticky;</div><div class="line">    initialSticky = _initialSticky;</div><div class="line">    userId = _userId;</div><div class="line">    <span class="comment">// 注意下下面这个初始值</span></div><div class="line">    nextReceiver = <span class="number">0</span>;</div><div class="line">    state = IDLE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>APP_RECEIVE 的 state 在静态注册接收器分2种情况讨论那里设置的（文章有点长，有搜索倒回去看看吧）。这个 state 的变化流程是：</p>
<pre>
IDLE(init) --> APP_RECEIVE(handle) --> IDLE(finish)
</pre>

<p>然后后面处理下一个接收器就是和前面一样的了，然后直到 mOrderedBroadcasts 中没有待处理的接收器为止。这样就形成了静态注册接收器一个接一个的处理。不过细心的你应该发现了一点，这种实现有个很不靠谱的地方：那就是它要假设上一个接收器正常完成处理。那么如果上一个接收器在处理的过程中挂掉了，或是在处理的时候耗费了大量时间还没处理，是不是串行广播就没法发送到下一个接收器了呢。这个问题我们留在后面再讨论，我们得继续回去把静态注册接收器的第二种情况讨论完，再说这个问题（不然越扯越远，前面说的什么都忘记了）。</p>
<p>PS：头有点晕的回最开始看一下图。</p>
<h3 id="接收器进程还没启动">接收器进程还没启动</h3>
<p>好现在是比较复杂的情况了，接收器进程还没启动，经过之前 Binder 普通服务篇大致能猜到这里也是发请求给 AMS 去启动指定的进程，然后等待接收器进程启动，再做广播处理。我们先接着看 processNextBroadcast 最后的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not running -- get it started, to be executed when the app comes up.</span></div><div class="line"><span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">        <span class="string">"Need to start app ["</span>          </div><div class="line">        + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</div><div class="line"><span class="comment">// 果然是调用 AMS 去启动目标进程</span></div><div class="line"><span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</div><div class="line">        info.activityInfo.applicationInfo, <span class="keyword">true</span>,</div><div class="line">        r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND, </div><div class="line">        <span class="string">"broadcast"</span>, r.curComponent,   </div><div class="line">        (r.intent.getFlags()&Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>))</div><div class="line">                == <span class="keyword">null</span>) {                     </div><div class="line">    <span class="comment">// Ah, this recipient is unavailable.  Finish it if necessary,</span></div><div class="line">    <span class="comment">// and mark the broadcast record as ready for the next.</span></div><div class="line">    Slog.w(TAG, <span class="string">"Unable to launch app "</span></div><div class="line">            + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></div><div class="line">            + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></div><div class="line">            + r.intent + <span class="string">": process is bad"</span>);</div><div class="line">    logBroadcastReceiverDiscardLocked(r);</div><div class="line">    <span class="comment">// 经过上面的分析，下面这2个函数的调用是结束当前这个接收器的处理接着处理下一个，</span></div><div class="line">    <span class="comment">// 因为如果启动接收器进程失败了，就忽略这个，接着要处理下一个</span></div><div class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">            r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">    scheduleBroadcastsLocked();    </div><div class="line">    r.state = BroadcastRecord.IDLE;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这里保存一下等待接收器进程启动的广播对象和索引</span></div><div class="line">mPendingBroadcast = r;         </div><div class="line">mPendingBroadcastRecvIndex = recIdx;</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 启动进程的 startProcessLocked 接口这里不再多说，可以去 <a href="http://light3moon.com/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递/#服务进程没有启动，服务代码也还没执行" title="Binder 普通服务篇的相关章节" target="_blank" rel="external">Binder 普通服务篇的相关章节</a> 看一下。然后后面把当前这一次的 BroadcastRecord 保存到了 mPendingBroadcast 中。这个变量前面有看到过，但是没细说。不过经过 Binder 普通服务篇应该不陌生了，这就是要等候接收器进程启动起来，然后 AMS 接着处理的时候能找回之前等待进程启动的 BroadcastRecord（进程启动最后是会通知 AMS 做一些事情的）。虽然说基本流程我们已经猜得差不多了，但是还是继续把代码看完吧。</p>
<p>上面这里就是 processNextBroadcast 最后的部分了。发送启动接收器进程请求给 AMS 之后，这次的广播处理暂时就完了。然后如果接收器进程正常启动的话那么它的 ActivityThread 会调用 AMS 的 attachApplication：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span>(IApplicationThread thread) {</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity(); </div><div class="line">            attachApplicationLocked(thread, callingPid);</div><div class="line">            Binder.restoreCallingIdentity(origId);</div><div class="line">        }</div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span>(IApplicationThread thread,</div><div class="line">            <span class="keyword">int</span> pid) {</div><div class="line">        </div><div class="line">        <span class="comment">// Find the application record that is being attached...  either via</span></div><div class="line">        <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></div><div class="line">        <span class="comment">// next app record if we are emulating process with anonymous threads.</span></div><div class="line">        ProcessRecord app;</div><div class="line">        <span class="keyword">if</span> (pid != MY_PID && pid &gt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) {</div><div class="line">                app = mPidsSelfLocked.get(pid);</div><div class="line">            }   </div><div class="line">        } <span class="keyword">else</span> {    </div><div class="line">            app = <span class="keyword">null</span>; </div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 这里检测下是不是有广播在等待新启动的进程</span></div><div class="line">        <span class="comment">// Check if a next-broadcast receiver is in this process...</span></div><div class="line">        <span class="keyword">if</span> (!badApp && isPendingBroadcastProcessLocked(pid)) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 如果有的话就要继续执行广播处理</span></div><div class="line">                didSomething = sendPendingBroadcastsLocked(app);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></div><div class="line">                badApp = <span class="keyword">true</span>; </div><div class="line">            }     </div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="comment">// Check whether the next backup agent is in this process...</span></div><div class="line">        <span class="keyword">if</span> (!badApp && mBackupTarget != <span class="keyword">null</span> && mBackupTarget.appInfo.uid == app.uid) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG, <span class="string">"New app is backup target, launching agent for "</span> + app); </div><div class="line">            ensurePackageDexOpt(mBackupTarget.appInfo.packageName);</div><div class="line">            <span class="keyword">try</span> { </div><div class="line">                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</div><div class="line">                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</div><div class="line">                        mBackupTarget.backupMode);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                Slog.w(TAG, <span class="string">"Exception scheduling backup agent creation: "</span>);</div><div class="line">                e.printStackTrace();</div><div class="line">            }     </div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (badApp) {</div><div class="line">            <span class="comment">// todo: Also need to kill application to deal with all</span></div><div class="line">            <span class="comment">// kinds of exceptions.</span></div><div class="line">            handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!didSomething) {</div><div class="line">            updateOomAdjLocked();</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们来看是怎么检测的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">boolean</span> isPendingBroadcastProcessLocked(<span class="keyword">int</span> pid) {</div><div class="line">        <span class="keyword">return</span> mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid)</div><div class="line">                || mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ============== BroadcastQueue.java ====================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPendingBroadcastProcessLocked</span>(<span class="keyword">int</span> pid) {</div><div class="line">        <span class="keyword">return</span> mPendingBroadcast != <span class="keyword">null</span> && mPendingBroadcast.curApp.pid == pid;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然前面保存的 mPendingBroadcast 是要等着后面用的。然后我们继续看 AMS 的 sendPendingBroadcastsLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 这注释已经说得很清楚了</span></div><div class="line">    <span class="comment">// The app just attached; send any pending broadcasts that it should receive</span></div><div class="line">    <span class="keyword">boolean</span> sendPendingBroadcastsLocked(ProcessRecord app) { </div><div class="line">        <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) {</div><div class="line">            didSomething |= queue.sendPendingBroadcastsLocked(app);</div><div class="line">        }   </div><div class="line">        <span class="keyword">return</span> didSomething;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ============== BroadcastQueue.java ====================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendPendingBroadcastsLocked</span>(ProcessRecord app) {</div><div class="line">        <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 取之前等待接收器进程启动的 BroadcastRecord</span></div><div class="line">        <span class="keyword">final</span> BroadcastRecord br = mPendingBroadcast; </div><div class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span> && br.curApp.pid == app.pid) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 这里接上处理之后，就把 mPendingBroadcast 设置成 null</span></div><div class="line">                mPendingBroadcast = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">// 下面这个函数就接上接收器进程已经启动的流程了</span></div><div class="line">                processCurBroadcastLocked(br, app);</div><div class="line">                didSomething = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                Slog.w(TAG, <span class="string">"Exception in new application when starting receiver "</span></div><div class="line">                        + br.curComponent.flattenToShortString(), e);</div><div class="line">                logBroadcastReceiverDiscardLocked(br);</div><div class="line">                <span class="comment">// 出错了继续要把广播发给一下个接收器</span></div><div class="line">                finishReceiverLocked(br, br.resultCode, br.resultData,</div><div class="line">                        br.resultExtras, br.resultAbort, <span class="keyword">true</span>);</div><div class="line">                scheduleBroadcastsLocked();</div><div class="line">                <span class="comment">// We need to reset the state if we failed to start the receiver.</span></div><div class="line">                br.state = BroadcastRecord.IDLE;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</div><div class="line">            }       </div><div class="line">        }                   </div><div class="line">        <span class="keyword">return</span> didSomething;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到 processCurBroadcastLocked 就松了一口气，后面的流程就和上面静态接收器进程已经启动的情况一样了。好像有了之前的知识（Binder 普通服务篇），这种复杂的情况这里说起来也没多复杂的样子，果然稍微明白 android 的一些设计手法之后很多地方都通用的说。</p>
<p>然后这里补充一个细节，在前面在串行广播处理中有多出错的地方（例如说启动接收器进程失败，或者是接收器为 null 的情况）都会调用</p>
<pre>
finishReceiverLocked();
scheduleBroadcastsLocked();
</pre>

<p>这是为了能然广播能够分发下去，当前的出错了就跳过去，然后面的继续执行。</p>
<p>PS：头有点晕的继续回最开始看一下图。</p>
<h2 id="优先级问题">优先级问题</h2>
<p>到这里广播的发送、处理流程就差不多说完了。不过前面有说到优先级的问题，这里详细讨论一下。注册篇说到静态注册系统级应用可以在 manifest 的 ‘<intent-filter>‘ 设置优先级。这样在收集静态注册接收器的时候优先级高的能排在串行广播列表的前面，就会优先收到广播。但是从上面的处理流程来看，如果广播不是串行的（默认并行），那么动态注册的接收器优先级永远比静态注册的要高（并行处理的我们认为它们同一个时间接到广播）。</intent-filter></p>
<p>这里可以稍微理解下 android 的设计： 虽然说并行广播的本意是让所有接收器一起响应。但是通过前面的分析知道，动态注册的进程都是已经启动起来了的；静态注册的进程基本上都还需要启动。动态切换换字体那篇工作小笔记分析 zygote 的时候知道，启动一个进程在 android 中是十分巨大的一个操作。而且如果静态注册的接收器的进程全都没有启动，那么就需要启动很多个进程。如果同时在后台启动这么多个进程，会造成系统响应严重顿卡。所以 android 广播的处理原则是（并行广播）：优先让动态注册的接收器处理广播，然后再让静态注册的接收器串行一个接着一个的处理（这样一次只会启动一个进程）。</p>
<p>然后回来讨论优先级问题。静态注册的接收器按照 manifest 里声明的优先级排序。注册篇说到动态注册的接收器 IntentFilter 有一个 setPriority 可以设置（这个没限制系统应用才能设置），然后动态注册的时候 IntentResolver 也会根据这个优先级排序。前面说在并行广播中（默认）动态注册的接收器优先级肯定排在静态注册的前面，所以动态注册接收器的优先级在并行广播中用处不大。但是在串行广播中，动态注册的接收会合并到静态注册接收器的列表中（前面合有分析合并代码的）。这个时候动态注册接收器的优先级就有用了，合并操作对比动态注册接收器和静态注册接收器的优先级，然后决定动态注册接收器的插入位置（排在静态注册的前面还是后面）。</p>
<p>最后总结一下，前面话太多不直观，来几点：</p>
<ol>
<li>并行广播下，动态注册优先级 &gt; 静态注册，静态注册按自己的优先级排序</li>
<li>串行广播下，动态注册和静态注册按各自的优先级一起排序</li>
</ol>
<h2 id="总结">总结</h2>
<p>经过注册篇和本篇的讲解能看得出，广播是集中由 AMS 来处理的：</p>
<ol>
<li>通过 AMS 接口可以动态注册接收器到 AMS（存储在 AMS 中）</li>
<li>通过 manifest 声明可以静态注册，由 PMS 扫描（存储在 PMS 中）</li>
<li>通过 AMS 发送广播时，AMS 会收集（匹配）自己和 PMS 中的保存的接收器，获取接收器列表（BroadcastRecord）</li>
<li>将 BroadcastRecord 放入指定队列（前台 or 后台），执行广播队列（BroadcastQueue）处理</li>
<li>广播队列按照优先级将依次（或者并行）广播分发到接收器进程 BroadcastReceiver 回调</li>
</ol>
<p>前面还有一个讨论串行广播等待处理完成的问题（包括超时问题），鉴于本篇已经很长了，新开一篇来说吧。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/22/Android%20Broadcast%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E8%B6%85%E6%97%B6%E6%88%96%E5%BC%82%E5%B8%B8/</loc>
    <lastmod>2015-02-03T02:18:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Broadcast 分析——超时或异常</title>
        <pubTime>2015-01-22T02:17:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>上一篇（处理篇）最后留了一个问题：串行广播需要一个接着一个执行，如果其中某一个接收器处理的时候挂掉了，或者耗时很长还没处理完，是不是后面的接收器就无法处理了呢。我们在这里看一下 android 是不是已经想到这些了。我们先照例把相关代码位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># AM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastQueue.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastRecord.java</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="超时处理">超时处理</h2>
<p>在 BroadcastQueue 执行串行广播的时候，会设置一个超时广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {</div><div class="line">            BroadcastRecord r;</div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// 前面一点开始处理串行广播</span></div><div class="line">            <span class="comment">// 如果还没设置超时就设置一个</span></div><div class="line">            <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) {</div><div class="line">                <span class="comment">// 当前时间+设置的超时等待时间</span></div><div class="line">                <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG,</div><div class="line">                        <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></div><div class="line">                        + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</div><div class="line">                setBroadcastTimeoutLocked(timeoutTime);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们来看下 setBroadcastTimeoutLocked 这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">        <span class="keyword">switch</span> (msg.what) {</div><div class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: {</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                        TAG, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</div><div class="line">                processNextBroadcast(<span class="keyword">true</span>);</div><div class="line">            } <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: { </div><div class="line">                <span class="keyword">synchronized</span> (mService) {</div><div class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</div><div class="line">                }</div><div class="line">            } <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }   </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">void</span> setBroadcastTimeoutLocked(<span class="keyword">long</span> timeoutTime) {</div><div class="line">    <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) {</div><div class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</div><div class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</div><div class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>android framework 里面的很多超时都是通过发送延迟消息来实现的。其实感觉这个方法还是挺好用的，以后如果自己要实现一些超时功能可以借鉴一下。然后我们稍微去看下一个超时时间设置的是多少，在 AMS 初始化的时候设置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================ ActivityManagerService.java ===================</span></div><div class="line"></div><div class="line">    <span class="comment">// How long we allow a receiver to run before giving up on it.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_FG_TIMEOUT = <span class="number">10</span>*<span class="number">1000</span>; </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_BG_TIMEOUT = <span class="number">60</span>*<span class="number">1000</span>; </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="title">ActivityManagerService</span>() {</div><div class="line">        Slog.i(TAG, <span class="string">"Memory class: "</span> + ActivityManager.staticGetMemoryClass());</div><div class="line">    </div><div class="line">        mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT);</div><div class="line">        mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT);</div><div class="line">        mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</div><div class="line">        mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ================ BroadcastQueue.java ===================</span></div><div class="line"></div><div class="line">    BroadcastQueue(ActivityManagerService service, String name, <span class="keyword">long</span> timeoutPeriod) {</div><div class="line">        mService = service;</div><div class="line">        mQueueName = name;</div><div class="line">        mTimeoutPeriod = timeoutPeriod;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看到前台的广播超时只有 10s，后台的广播超时有 60s。我们这里以后台广播为例，如果在串行广播中（并行广播不需要超时）一个接收器霸占了 60s 还没处理完（对 AMS 发送 finishReceiver），那么接下来会怎么样咧，我们看看超时处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从上面 Handler 调用的 fromMsg 是 true</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">void</span> broadcastTimeoutLocked(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">    <span class="comment">// post 到 Handler 那的处理了，就可以标志关掉</span></div><div class="line">    <span class="keyword">if</span> (fromMsg) {</div><div class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="comment">// 如果没有串行广播就返回</span></div><div class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) { </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="comment">// 取当前时间和当前等待的接收器广播记录</span></div><div class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">    BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (fromMsg) {</div><div class="line">        <span class="keyword">if</span> (mService.mDidDexOpt) {</div><div class="line">            <span class="comment">// Delay timeouts until dexopt finishes.</span></div><div class="line">            mService.mDidDexOpt = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">long</span> timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod;</div><div class="line">            setBroadcastTimeoutLocked(timeoutTime);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (!mService.mProcessesReady) {</div><div class="line">            <span class="comment">// Only process broadcast timeouts if the system is ready. That way</span></div><div class="line">            <span class="comment">// PRE_BOOT_COMPLETED broadcasts can't timeout as they are intended</span></div><div class="line">            <span class="comment">// to do heavy lifting for system up.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }    </div><div class="line"></div><div class="line">        <span class="comment">// 这里下面有注释，可能其他地方也会触发这个超时操作，</span></div><div class="line">        <span class="comment">// 判断下如果超时时间还没到，重新设一个进去，然后忽略这次</span></div><div class="line">        <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</div><div class="line">        <span class="keyword">if</span> (timeoutTime &gt; now) {</div><div class="line">            <span class="comment">// We can observe premature timeouts because we do not cancel and reset the</span></div><div class="line">            <span class="comment">// broadcast timeout message after each receiver finishes.  Instead, we set up</span></div><div class="line">            <span class="comment">// an initial timeout then kick it down the road a little further as needed</span></div><div class="line">            <span class="comment">// when it expires.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG,</div><div class="line">                    <span class="string">"Premature timeout ["</span></div><div class="line">                    + mQueueName + <span class="string">"] @ "</span> + now + <span class="string">": resetting BROADCAST_TIMEOUT_MSG for "</span></div><div class="line">                    + timeoutTime);</div><div class="line">            setBroadcastTimeoutLocked(timeoutTime);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    r.receiverTime = now;</div><div class="line">    r.anrCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前的广播没接收器需要处理了，也返回</span></div><div class="line">    <span class="comment">// Current receiver has passed its expiration date.</span></div><div class="line">    <span class="keyword">if</span> (r.nextReceiver &lt;= <span class="number">0</span>) {</div><div class="line">        Slog.w(TAG, <span class="string">"Timeout on receiver with nextReceiver &lt;= 0"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    ProcessRecord app = <span class="keyword">null</span>;</div><div class="line">    String anrMessage = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 这里取当前接收器的进程信息</span></div><div class="line">    Object curReceiver = r.receivers.get(r.nextReceiver-<span class="number">1</span>);</div><div class="line">    Slog.w(TAG, <span class="string">"Receiver during timeout: "</span> + curReceiver);</div><div class="line">    logBroadcastReceiverDiscardLocked(r);</div><div class="line">    <span class="comment">// 这个是动态注册的接收器的进程信息（动态注册的接收器也可能串行处理的）</span></div><div class="line">    <span class="keyword">if</span> (curReceiver <span class="keyword">instanceof</span> BroadcastFilter) {</div><div class="line">        BroadcastFilter bf = (BroadcastFilter)curReceiver;</div><div class="line">        <span class="keyword">if</span> (bf.receiverList.pid != <span class="number">0</span></div><div class="line">                && bf.receiverList.pid != ActivityManagerService.MY_PID) {</div><div class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) {</div><div class="line">                app = mService.mPidsSelfLocked.get(</div><div class="line">                        bf.receiverList.pid);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这是静态注册的接收器的进程信息</span></div><div class="line">        app = r.curApp;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) {</div><div class="line">        anrMessage = <span class="string">"Broadcast of "</span> + r.intent.toString();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前接收器还在等待目标进程的启动，不用等了 -_-||</span></div><div class="line">    <span class="keyword">if</span> (mPendingBroadcast == r) {</div><div class="line">        mPendingBroadcast = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 经过处理篇的分析下面2个函数的调用就相当于认为当前的接收器已经处理了，</span></div><div class="line">    <span class="comment">// 让 BroadcastQueue 接着处理一下接收器</span></div><div class="line">    <span class="comment">// Move on to the next receiver.</span></div><div class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">            r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">    scheduleBroadcastsLocked();</div><div class="line"></div><div class="line">    <span class="comment">// 前面如果能够获取接收器的进程信息，</span></div><div class="line">    <span class="comment">// 给接收器所在进程发一个 ANR 消息（看样子后台处理也有可能有 ANR 的）</span></div><div class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// Post the ANR to the handler since we do not want to process ANRs while</span></div><div class="line">        <span class="comment">// potentially holding our lock.</span></div><div class="line">        mHandler.post(<span class="keyword">new</span> AppNotResponding(app, anrMessage));</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看上面的处理，如果当前接收器发生了超时（超过 60s 没给 AMS 发送 finishReceiver 消息），那么 AMS（BroadcastQueue）就会直接对当前的接收器进行处理完成操作，以便激发 BroadcastQueue 把广播分发给下一个等待处理的接收器（同时给接收器进程发 ANR 消息）。所以前面处理篇中担心的在串行广播中如果有某一个接收器搅屎，长时间不处理完广播，广播处理是不是就卡在那了是多余的。因为 AMS 会“等得不耐烦”直接不等，直接让下一个接收器处理（就算需要启动进程，60s 启动一个就没什么事）。</p>
<p>从上面可以看得出，某些靠静态注册广播启动进程的功能，有些时候发现某些事件发生了（例如网络可用），但是自己的代码好像很久还没跑，其实并不是广播没发出来，而已有可能前面有些应用长时间“占着茅坑”而已。然后自己程序的接收器优先级又低一点，就悲剧吧。</p>
<h2 id="异常处理">异常处理</h2>
<p>一开始接收器异常（例如说挂掉），我以为可以一起超时用处理的，但是 android 没这么干。其实也是可以的，但是有点不好，因为如果一起用超时来处理的，需要等待 60s 广播才能接着处理，可能接收器进程早就挂掉了。所以 android 单独考虑了这种情况。我们来一起看下这种情况的处理。</p>
<p>首先一个进程由 AMS startProcess 启动起来后，ActivityThread 会调用 AMS 的 attachApplication（我们这里跳过马甲，直接看真正做事的函数）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span>(IApplicationThread thread,</div><div class="line">            <span class="keyword">int</span> pid) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        String processName = app.processName;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            AppDeathRecipient adr = <span class="keyword">new</span> AppDeathRecipient(</div><div class="line">                    app, pid, thread);</div><div class="line">            thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</div><div class="line">            app.deathRecipient = adr;</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            app.resetPackageList();</div><div class="line">            startProcessLocked(app, <span class="string">"link fail"</span>, processName);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>binder 死亡通知篇里面知道对 IApplicationThread 的 Bp（Bn 是接收器进程）注册一个死亡通知回调，当这个 Bp 的 Bn 所在进程（接收器进程啦）挂掉的时候，这个 AMS 中的这个回调会被调用。我们先来看看这个回调是啥：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>{</div><div class="line">    <span class="keyword">final</span> ProcessRecord mApp;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mPid;</div><div class="line">    <span class="keyword">final</span> IApplicationThread mAppThread;</div><div class="line">    </div><div class="line">    <span class="comment">// 构造的时候保存了崩溃进程的 pid、IApplicationThread 接口</span></div><div class="line">    AppDeathRecipient(ProcessRecord app, <span class="keyword">int</span> pid,</div><div class="line">            IApplicationThread thread) {</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</div><div class="line">            TAG, <span class="string">"New death recipient "</span> + <span class="keyword">this</span></div><div class="line">            + <span class="string">" for thread "</span> + thread.asBinder());</div><div class="line">        mApp = app;</div><div class="line">        mPid = pid; </div><div class="line">        mAppThread = thread;</div><div class="line">    }   </div><div class="line">        </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>() {</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</div><div class="line">            TAG, <span class="string">"Death received in "</span> + <span class="keyword">this</span></div><div class="line">            + <span class="string">" for thread "</span> + mAppThread.asBinder());</div><div class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) {</div><div class="line">            appDiedLocked(mApp, mPid, mAppThread);</div><div class="line">        }</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 new AppDeathRecipient 的时候把 attachApplication 进程的 pid 和 IBinder 接口保存了一下，然后去看看 appDiedLocked 做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果一个进程挂了 AMS 要做不少工作的，这里我们只选和广播相关的</span></div><div class="line"><span class="comment">// 我是怎么挑选出这些函数的咧，加点 log 把函数调用堆栈打出来就行了 ... ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 从个这个函数开始</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> appDiedLocked(ProcessRecord app, <span class="keyword">int</span> pid,</div><div class="line">            IApplicationThread thread) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// Clean up already done if the process has been re-started.</span></div><div class="line">        <span class="keyword">if</span> (app.pid == pid && app.thread != <span class="keyword">null</span> &&</div><div class="line">                app.thread.asBinder() == thread.asBinder()) {</div><div class="line">            <span class="keyword">if</span> (!app.killedBackground) {</div><div class="line">                Slog.i(TAG, <span class="string">"Process "</span> + app.processName + <span class="string">" (pid "</span> + pid</div><div class="line">                        + <span class="string">") has died."</span>);</div><div class="line">            }</div><div class="line">            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);</div><div class="line">            <span class="keyword">if</span> (DEBUG_CLEANUP) Slog.v(</div><div class="line">                TAG, <span class="string">"Dying app: "</span> + app + <span class="string">", pid: "</span> + pid</div><div class="line">                + <span class="string">", thread: "</span> + thread.asBinder());</div><div class="line">            <span class="keyword">boolean</span> doLowMem = app.instrumentationClass == <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 然后是这里</span></div><div class="line">            handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (app.pid != pid) {</div><div class="line">            <span class="comment">// A new process has already been started.</span></div><div class="line">            Slog.i(TAG, <span class="string">"Process "</span> + app.processName + <span class="string">" (pid "</span> + pid</div><div class="line">                    + <span class="string">") has died and restarted (pid "</span> + app.pid + <span class="string">")."</span>);</div><div class="line">            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PROCESSES) {</div><div class="line">            Slog.d(TAG, <span class="string">"Received spurious death notification for thread "</span></div><div class="line">                    + thread.asBinder());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">            </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Main function for removing an existing process from the activity manager</span></div><div class="line"><span class="comment">     * as a result of that process going away.  Clears out all connections</span></div><div class="line"><span class="comment">     * to the process.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleAppDiedLocked</span>(ProcessRecord app,</div><div class="line">            <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart) {</div><div class="line">        <span class="comment">// 再然后是这里，清理程序的一些记录（里面就有广播记录）</span></div><div class="line">        cleanUpApplicationRecordLocked(app, restarting, allowRestart, -<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (!restarting) {</div><div class="line">            mLruProcesses.remove(app);</div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Main code for cleaning up a process when it has gone away.  This is</span></div><div class="line"><span class="comment">     * called both as a result of the process dying, or directly when stopping</span></div><div class="line"><span class="comment">     * a process when running in single process mode.</span></div><div class="line"><span class="comment">     */</span> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cleanUpApplicationRecordLocked</span>(ProcessRecord app,</div><div class="line">            <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index) {</div><div class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {</div><div class="line">            mLruProcesses.remove(index);</div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 接着是这里，名字很形象，跳过当前（这个进程的）的接收器</span></div><div class="line">        skipCurrentReceiverLocked(app);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">void</span> skipCurrentReceiverLocked(ProcessRecord app) {</div><div class="line">        <span class="comment">// 最后还是调用 BroadcastQueue 来处理的</span></div><div class="line">        <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) { </div><div class="line">            queue.skipCurrentReceiverLocked(app);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>好，到 BroadcastQueue 这里我们停一下（AMS 中和广播相关的操作，最后都是由 BroadcastQueue 处理的）。然后我们仔细来看看 BroadcastQueue 中 skipCurrentReceiverLocked 函数（为什么要仔细，后面会知道）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipCurrentReceiverLocked</span>(ProcessRecord app) {</div><div class="line">    <span class="keyword">boolean</span> reschedule = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 取异常进程当前正在执行的广播记录</span></div><div class="line">    BroadcastRecord r = app.curReceiver;</div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> ) {</div><div class="line">        <span class="comment">// The current broadcast is waiting for this app's receiver</span></div><div class="line">        <span class="comment">// to be finished.  Looks like that's not going to happen, so</span></div><div class="line">        <span class="comment">// let the broadcast continue.</span></div><div class="line">        logBroadcastReceiverDiscardLocked(r);</div><div class="line">        <span class="comment">// 把当前广播记录的状态设置为结束状态</span></div><div class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">                r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">        reschedule = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 上面那个是当前正在执行的，这里是等待这个进程启动的</span></div><div class="line">    <span class="comment">// （不巧这个进程挂了）</span></div><div class="line">    r = mPendingBroadcast;</div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> && r.curApp == app) {</div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG,</div><div class="line">                <span class="string">"["</span> + mQueueName + <span class="string">"] skip & discard pending app "</span> + r);</div><div class="line">        logBroadcastReceiverDiscardLocked(r);</div><div class="line">        <span class="comment">// 同样设置一下结束状态</span></div><div class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">                r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">        reschedule = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 然后如果上面任何一个有接收器的话，</span></div><div class="line">    <span class="comment">// 就要让 BroadcastQueue 接着去分发广播给下一个接收器</span></div><div class="line">    <span class="keyword">if</span> (reschedule) {</div><div class="line">        scheduleBroadcastsLocked();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的代码咋一看是 android 帮我们考虑到了接收器进程挂了的情况，让后面的接收器能更快速的收到广播。但是回到 AMS skipCurrentReceiverLocked 的仔细琢磨下那个 BroadcastQueue 队列的循环，就发现有点点不对劲的地方： 这个循环是，循环然 BroadcastQueue 执行 skipCurrentReceiverLocked，然后再执行看一下 BroadcastQueue 的 skipCurrentReceiverLocked，就会发现前面一部分是去取崩溃进程的当前的广播记录，那么问题来了，这里完全没判断这个 BroadcastRecord 记录是属于哪个广播队列的（AMS 里面有分前台广播队列和后台广播队列的），直接拿去给 finishReceiverLocked 处理了，然后 finishReceiverLocked 里有这么一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span>(BroadcastRecord r, <span class="keyword">int</span> resultCode,</div><div class="line">            String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort,</div><div class="line">            <span class="keyword">boolean</span> explicit) {            </div><div class="line">... ...</div><div class="line">        r.receiver = <span class="keyword">null</span>;    </div><div class="line">        r.intent.setComponent(<span class="keyword">null</span>);</div><div class="line">        <span class="comment">// 把这个广播所在进程当前处理的广播记录设置为 null</span></div><div class="line">        <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span>) {        </div><div class="line">            r.curApp.curReceiver = <span class="keyword">null</span>;   </div><div class="line">        }</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这会有什么问题咧。让我来举一个例子，其实就拿最开始背景里面那个 <code>BOOT_COMPLETED</code> 广播来说。很多应用都会静态注册开机广播的，假设有一个进程的接收器在处理开机广播的时候挂了。那么 AMS 执行到 skipCurrentReceiverLocked 那里。AMS 在构造函数那里初始化 mBroadcastQueues 的时候前台的广播队列在前面（0位置），后台广播在后面（1位置，代码前面说超时设置那里有）。那这里就会先执行前台广播队列的 skipCurrentReceiverLocked 处理。但是 BraodcastQueue 里面的 skipCurrentReceiverLocked 并没有判断挂掉进程当前的这个 BroadcastRecord 是属于谁的（这里是属于后台队列的），所以在前面队列中就处理起来了。然后调用了前台的 scheduleBroadcastsLocked（进而调用 processNextBroadcast），但是前台广播队列并没有正在处理的串行广播（假设没有），所以就啥事也没做。这里前台广播队列虽然啥事也没做，但是却把崩溃进程正在处理的 BroadcastRecord 扔给 finishReceiverLocked 设置结束状态去了，所以这里 app.curReceiver = null 。然后等循环到后台广播队列的时候，由于 app.curReceiver 被前面前台误设置为 null ， reschedule 这个标志就无法被设置为 true，所以无法调用后台广播队列的 scheduleBroadcastsLocked 接着把 BOOT_COMPLETED 的广播分发给后面的接收器处理。后面的接收器就收不到广播了（那个闹钟不响的问题就是前面有个应用捣乱导致闹钟接收不到开机广播了）。</p>
<p>所以说 android 在接收器异常处理这里有个小 bug，应该要在 BroadcastQueue skipCurrentReceiverLocked 那里判断下崩溃进程当前的这个 BroadcastRecord 是不是属于自己队列里面的，如果是才处理，否则就不处理。可以这样修复一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipCurrentReceiverLocked</span>(ProcessRecord app) {</div><div class="line">        <span class="keyword">boolean</span> reschedule = <span class="keyword">false</span>;    </div><div class="line">        BroadcastRecord r = app.curReceiver;</div><div class="line">        <span class="comment">// 这里判断下这个广播记录是否是属于自己队列里面的，不要把别人队列里面的处理了</span></div><div class="line">        <span class="comment">//if (r != null ) {</span></div><div class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> && <span class="keyword">this</span>.equals(r.queue)) {</div><div class="line">            <span class="comment">// The current broadcast is waiting for this app's receiver</span></div><div class="line">            <span class="comment">// to be finished.  Looks like that's not going to happen, so</span></div><div class="line">            <span class="comment">// let the broadcast continue. </span></div><div class="line">            logBroadcastReceiverDiscardLocked(r);</div><div class="line">            finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">                    r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">            reschedule = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>如果没这个 bug 的话，本来有接收器挂掉了，后面等待的接收器是能马上接着处理的。但是实际上，现在只要前面有接收器搅屎，歇菜了就悲剧了（其实也不一定，如果马上又有一个后台广播发过来，就又能激发上次的串行广播接着分发，因为接收器的记录还在 BroadcastQueue 里面排着队，所以这个 bug 是随机性的，查起来更加悲剧）。我看了下 4.2.2 和 4.4 这里的代码，都还没修复（没人给 google 反馈这个 bug 么），不知道 5.0 修复了没。</p>
<h2 id="解决问题">解决问题</h2>
<p>到了这里就可以解释情况开篇（注册篇）提到的那个我们的平板上开机闹钟为什么不响了。原因是这样的，我们自己有个应用（appA），也静态注册了开机广播，由于一开始不知道可以系统应用可以设置接收器优先级，所以都没设置，结果 PMS 扫描的结果是 appA 比闹钟靠前。所以开机广播就 appA 先处理，结果写这个 appA 的哥们在处理完之后直接在 onReceive 中写了一个 System.exit(0) ！！</p>
<p>我去，这就直接强制终于了接收器的进程，并且 log 里面报没有任何异常，只有一句 process xx has died （因为这个不是因为错误退出的，而是自己调用 System.exit 退出的）。然后上面分析了，正好 android 这里有个小 bug 就导致后面的接收器收不到开机广播了，所以闹钟没办法在 AlaramMananger 里面设置闹钟，所以设备虽然被 kernel 的 RTC 唤醒开机了，但是闹钟却没有响。而且这个问题还是随机的，前面说了如果后面正好来了一个后台广播，那么后面的接收器又能收到了。SQA 测试的时候开着 wifi 的情况下闹钟可以响，正好网络变得可以访问会发一个后台广播 -_-||。</p>
<p>所以这里根本的解决办法是修改 framework，改正这个 bug。但是这样要 OTA 升级系统才行，这边头头最头痛发放 OTA。所以还是有一个办法就是改应用：</p>
<ol>
<li>要么把 appA 给改了，onReceive 处理完之后不要强制退出进程</li>
<li>但是你改得了一个，却防不住全部的，指不定那个应用也抽风一下（现在应用注册开机广播和吃白菜一样），由于我们的应用是系统应用，所以我们可以改闹钟接收器的优先级，把优先级调高点就比较保险了（最后还是采用这个方案的）。</li>
</ol>
<h2 id="总结">总结</h2>
<p>这里正好趁查这个问题的机会把 Broadcast 流程摸一下，之前还有查过一个关不了机的问题的，是关机广播。那个时候就稍微看了下 AMS 中 Broadcast 的处理，但是那个时候没坚持记录一下，结果查这个问题的时候又要从头开始。这里记录一下，理解了 Broadcast 的原理就能更好的应用它。当然这里其实还忽略了 Broadcast 的别的一些功能，例如那个 Sticky 功能，以后有时间再补一下了。 </p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/22/Android%20Broadcast%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/</loc>
    <lastmod>2015-02-03T02:07:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Broadcast 分析——注册</title>
        <pubTime>2015-01-22T02:07:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="背景">背景</h2>
<p>我们的平板增加了一个关机闹钟的功能。就是设备在关机的情况也能唤醒然后响闹钟。实现方法是：在 kernel 中增加一个 RTC 时钟（关机情况下，板载的 RTC 时钟还在运行的，所以你关机一段时间发现电池会变少），然后提前一段时间开机（我们设定的是1分钟，得给点时间给开机，我们的平板开机要40多秒咧），然后闹钟模块接收开机广播（<code>ACTION_BOOT_COMPLETED</code>），然后把 android 应用层的闹钟设置下去，然后就能实现关机闹钟功能了。</p>
<p>但是最近遇到一个问题：说关机闹钟，到了时间设备能唤醒，但是闹钟不响。于是分析一下 android 广播的处理流程（这里以开机广播为例）。然后顺带记录下分析过程，以后忘记看几眼能捡起来。</p>
<p>android 广播的注册方式分为2种：一种是动态注册，一种是静态注册。哦，对了，在说之前，照例把相关源码位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Content 广播相关的代码</span></div><div class="line">frameworks/base/core/java/android/app/ContextImpl.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line"></div><div class="line">frameworks/base/core/java/android/content/Intent.java</div><div class="line">frameworks/base/core/java/android/content/IntentFilter.java</div><div class="line">frameworks/base/core/java/android/content/BroadcastReceiver.java</div><div class="line">frameworks/base/core/java/android/content/IIntentReceiver.aidl</div><div class="line"></div><div class="line"><span class="comment"># 广播解析相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/IntentResolver.java</div><div class="line"></div><div class="line"><span class="comment"># AM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/RecevierList.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastFilter.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastRecord.java</div><div class="line"></div><div class="line"><span class="comment"># PM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="动态注册">动态注册</h2>
<h3 id="接口端">接口端</h3>
<p>我们先来说说动态注册。动态注册是在程序当中调用 Context（ContextImpl）的接口来注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span>(BroadcastReceiver receiver, IntentFilter filter)</div><div class="line"></div></pre></td></tr></table></figure>

<p>其中一般自己要继承 BoradcastReceiver，然后实现里面的 onReceive 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Context 是运行该 receiver 所在在的 context</span></div><div class="line"><span class="comment">// Intent 是所接收到的广播发出的 intent </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Context context, Intent intent);</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后那个 IntentFilter 里面可以设置要接收的广播，可以设置好多种类型，具体的自己去翻 api 文档。一般简单的可以直接设一个 ACTION。然后因为这个是需要在程序运行中拿 Context 去注册的，所以这种注册就有一个特点：<strong>接收广播的进程已经运行起来了</strong>。</p>
<p>接下来我们就去看看这个注册过程是怎么样的。首先调用的是 Context（Activity、Service 里均可以调用）的 registerReceiver ，这个其实是挂 ContextImpl 里面的同名函数的马甲：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span>(BroadcastReceiver receiver, IntentFilter filter) {</div><div class="line">    <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span>(BroadcastReceiver receiver, IntentFilter filter,</div><div class="line">        String broadcastPermission, Handler scheduler) {</div><div class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</div><div class="line">            filter, broadcastPermission, scheduler, getOuterContext());</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看出最后是调用 registerReceiverInternal 这个函数的。然后我们用的那个没指定权限（我们先不管啥权限之类的），还有 Handler。传过去的是 null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span>(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</div><div class="line">        IntentFilter filter, String broadcastPermission,</div><div class="line">        Handler scheduler, Context context) {</div><div class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> && context != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// 默认使用的是当前注册进程的主线程来处理接收到的广播</span></div><div class="line">                scheduler = mMainThread.getHandler();</div><div class="line">            }    </div><div class="line">            <span class="comment">// 如果 mPackageInfo(LoadedApk) 不为空，去调用其中的方法取 IIntentReceiver</span></div><div class="line">            rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                receiver, context, scheduler,</div><div class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) {</div><div class="line">                scheduler = mMainThread.getHandler();</div><div class="line">            }</div><div class="line">            <span class="comment">// 否则直接 new 一个新的出来</span></div><div class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 最后还是要去 AM 里面去注册</span></div><div class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class="line">                rd, filter, broadcastPermission, userId);</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们得先说 IIntentReceiver 这个东西。这个是保存广播最基本的数据了。这个是以 II 开头的，就知道这个实现了 Binder 接口支持 IPC 访问的。这个是用 aidl 写的，接口只有一个： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个看注释就知道是接收到广播后触发处理的函数</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * System private API for dispatching intent broadcasts.  This is given to the </span></div><div class="line"><span class="comment"> * activity manager as part of registering for an intent broadcasts, and is</span></div><div class="line"><span class="comment"> * called when it receives intents.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * {@hide}</span></div><div class="line"><span class="comment"> */</span></div><div class="line">oneway interface IIntentReceiver {</div><div class="line">    <span class="keyword">void</span> performReceive(in Intent intent, <span class="keyword">int</span> resultCode, String data,</div><div class="line">            in Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 LoadApk 中的一个内部类的内部类(LoadedApk.ReceiverDispatcher.InnerReceiver)实现了这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> class ReceiverDispatcher {</div><div class="line">        </div><div class="line">        <span class="comment">// 这里是 Bn 端啦，注册的进程运行处理函数（Bp 端的实现 aidl 自动生成鸟）</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">static</span> class InnerReceiver extends IIntentReceiver.Stub {</div><div class="line">            <span class="keyword">final</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</div><div class="line">            <span class="keyword">final</span> LoadedApk.ReceiverDispatcher mStrongRef;</div><div class="line">            </div><div class="line">            InnerReceiver(LoadedApk.ReceiverDispatcher rd, <span class="keyword">boolean</span> strong) {</div><div class="line">                mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</div><div class="line">                mStrongRef = strong ? rd : <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span>(Intent intent, <span class="keyword">int</span> resultCode, String data,</div><div class="line">                    Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">                <span class="comment">// 这里我们先不分析处理过程，留到后面再说</span></div><div class="line">                ... ...</div><div class="line">            }</div><div class="line">        }</div><div class="line">        </div><div class="line">... ...</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> IIntentReceiver.Stub mIIntentReceiver;</div><div class="line">        <span class="keyword">final</span> BroadcastReceiver mReceiver;</div><div class="line">        <span class="keyword">final</span> Context mContext;</div><div class="line">        <span class="keyword">final</span> Handler mActivityThread;</div><div class="line">        <span class="keyword">final</span> Instrumentation mInstrumentation;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> mRegistered;</div><div class="line">        <span class="keyword">final</span> IntentReceiverLeaked mLocation;</div><div class="line">        RuntimeException mUnregisterLocation;</div><div class="line">        <span class="keyword">boolean</span> mForgotten;</div><div class="line">        </div><div class="line">... ...</div><div class="line">        </div><div class="line">        ReceiverDispatcher(BroadcastReceiver receiver, Context context,</div><div class="line">                Handler activityThread, Instrumentation instrumentation,</div><div class="line">                <span class="keyword">boolean</span> registered) {</div><div class="line">            <span class="keyword">if</span> (activityThread == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Handler must not be null"</span>);</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// new 这个 ReceiverDispatcher 的时候就会 new 一个 InnerReceiver</span></div><div class="line">            mIIntentReceiver = <span class="keyword">new</span> InnerReceiver(<span class="keyword">this</span>, !registered);</div><div class="line">            <span class="comment">// 保存广播接收器对象</span></div><div class="line">            mReceiver = receiver;</div><div class="line">            mContext = context;</div><div class="line">            <span class="comment">// 保存指定的处理广播的线程（Handler）</span></div><div class="line">            mActivityThread = activityThread;</div><div class="line">            mInstrumentation = instrumentation;</div><div class="line">            mRegistered = registered;</div><div class="line">            mLocation = <span class="keyword">new</span> IntentReceiverLeaked(<span class="keyword">null</span>);</div><div class="line">            mLocation.fillInStackTrace();</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> validate(Context context, Handler activityThread) {</div><div class="line">            <span class="keyword">if</span> (mContext != context) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Receiver "</span> + mReceiver +</div><div class="line">                    <span class="string">" registered with differing Context (was "</span> +</div><div class="line">                    mContext + <span class="string">" now "</span> + context + <span class="string">")"</span>);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mActivityThread != activityThread) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Receiver "</span> + mReceiver +</div><div class="line">                    <span class="string">" registered with differing handler (was "</span> +</div><div class="line">                    mActivityThread + <span class="string">" now "</span> + activityThread + <span class="string">")"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        IIntentReceiver getIIntentReceiver() {</div><div class="line">            <span class="keyword">return</span> mIIntentReceiver;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 LoadedApk 看名字，基本上就是和本应用程序包相关的东西（manifest 里面申明的那一堆东西基本上都在这里，当然扫描、解析是 PMS 干的）。然后它提供一个 IIntentReceiver 的 Bn 实现。它会保存调用者传递过来的 Handler，这个也就是说我们可以指定广播处理的线程（哪天有空把 Handler、Looper 也写下分析），如果我们没有指定的话，默认用注册进程的主线程（<strong>所以如果要在广播接收中做一些耗时的操作，请开一个后台线程作为接收的处理线程</strong>）。然后我们回到 ContextImpl 的注册函数那，有一个处理，如果 mPackageInfo 不为空，就去调用 LoadedApk 里的函数去取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> IIntentReceiver <span class="title">getReceiverDispatcher</span>(BroadcastReceiver r,</div><div class="line">        Context context, Handler handler,</div><div class="line">        Instrumentation instrumentation, <span class="keyword">boolean</span> registered) {</div><div class="line">    <span class="keyword">synchronized</span> (mReceivers) {</div><div class="line">        LoadedApk.ReceiverDispatcher rd = <span class="keyword">null</span>;</div><div class="line">        HashMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 动态注册传过来的是 true</span></div><div class="line">        <span class="keyword">if</span> (registered) { </div><div class="line">            <span class="comment">// 其实就是内部把之前注册过的保存了起来，如果后面重复注册一样的，可以不用重复处理</span></div><div class="line">            map = mReceivers.get(context);</div><div class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</div><div class="line">                rd = map.get(r);</div><div class="line">            }   </div><div class="line">        }           </div><div class="line">        <span class="keyword">if</span> (rd == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 如果之前没有注册过的话，还是要创建一个新的</span></div><div class="line">            rd = <span class="keyword">new</span> ReceiverDispatcher(r, context, handler,</div><div class="line">                    instrumentation, registered);</div><div class="line">            <span class="keyword">if</span> (registered) {</div><div class="line">                <span class="keyword">if</span> (map == <span class="keyword">null</span>) {</div><div class="line">                    map = <span class="keyword">new</span> HashMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</div><div class="line">                    mReceivers.put(context, map);</div><div class="line">                }</div><div class="line">                map.put(r, rd);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 这个验证代码去看前面，就是检测下是不是当前运行的环境和线程而已</span></div><div class="line">            rd.validate(context, handler);</div><div class="line">        }</div><div class="line">        rd.mForgotten = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> rd.getIIntentReceiver();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后后面就去 AMS 里面去注册了。其实 AMS 可以说是广播的中转站，应用程序通过 AMS 发送广播，然后 AMS 找到对应的接收器进行广播分发（咋感觉和消息分发差不多）。</p>
<h3 id="服务端">服务端</h3>
<p>来看下 AMS 中 registerReceiver ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// caller: 客户端传过来标示客户进程的</span></div><div class="line"><span class="comment">// receiver: 客户端准备好的接收广播的对象，这里传过来已经是 Bp 端了</span></div><div class="line"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span>(IApplicationThread caller, String callerPackage,</div><div class="line">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId) {</div><div class="line">    enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</div><div class="line">    <span class="keyword">int</span> callingUid;</div><div class="line">    <span class="keyword">int</span> callingPid;</div><div class="line">    <span class="comment">// IPC 服务端多线程，接口实现照例加锁</span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">        <span class="comment">// 这里是去取注册调用者的进程信息，pid、uid 之类的</span></div><div class="line">        ProcessRecord callerApp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) {</div><div class="line">            callerApp = getRecordForAppLocked(caller);</div><div class="line">            <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</div><div class="line">                        <span class="string">"Unable to find app for caller "</span> + caller</div><div class="line">                        + <span class="string">" (pid="</span> + Binder.getCallingPid()</div><div class="line">                        + <span class="string">") when registering receiver "</span> + receiver);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (callerApp.info.uid != Process.SYSTEM_UID &&</div><div class="line">                    !callerApp.pkgList.contains(callerPackage)) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Given caller package "</span> + callerPackage</div><div class="line">                        + <span class="string">" is not running in process "</span> + callerApp);</div><div class="line">            }</div><div class="line">            callingUid = callerApp.info.uid;</div><div class="line">            callingPid = callerApp.pid;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            callerPackage = <span class="keyword">null</span>;</div><div class="line">            callingUid = Binder.getCallingUid();</div><div class="line">            callingPid = Binder.getCallingPid();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 把用户 Id 也取到了，android 中多用户的广播是分开的，能够避免一些公共广播发出来，</span></div><div class="line">        <span class="comment">// 把其他用户安装的应用也启动起来</span></div><div class="line">        userId = <span class="keyword">this</span>.handleIncomingUser(callingPid, callingUid, userId,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="string">"registerReceiver"</span>, callerPackage);</div><div class="line"></div><div class="line">        List allSticky = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 这个和 sticky 功能相关我们不管先</span></div><div class="line">        <span class="comment">// Look for any matching sticky broadcasts...</span></div><div class="line">        Iterator actions = filter.actionsIterator();</div><div class="line">        <span class="keyword">if</span> (actions != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">while</span> (actions.hasNext()) {</div><div class="line">                String action = (String)actions.next();</div><div class="line">                allSticky = getStickiesLocked(action, filter, allSticky,</div><div class="line">                        UserHandle.USER_ALL);</div><div class="line">                allSticky = getStickiesLocked(action, filter, allSticky,</div><div class="line">                        UserHandle.getUserId(callingUid));</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            allSticky = getStickiesLocked(<span class="keyword">null</span>, filter, allSticky,</div><div class="line">                    UserHandle.USER_ALL);</div><div class="line">            allSticky = getStickiesLocked(<span class="keyword">null</span>, filter, allSticky,</div><div class="line">                    UserHandle.getUserId(callingUid));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// The first sticky in the list is returned directly back to</span></div><div class="line">        <span class="comment">// the client.</span></div><div class="line">        Intent sticky = allSticky != <span class="keyword">null</span> ? (Intent)allSticky.get(<span class="number">0</span>) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Register receiver "</span> + filter</div><div class="line">                + <span class="string">": "</span> + sticky);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> sticky;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这个根据传过来的 IIntentReceiver(receiver) 构造一个 ReceiverList</span></div><div class="line">        <span class="comment">// 这个其实一个数组，一个 receiver 可能可以对应多个 Intent（广播）</span></div><div class="line">        ReceiverList rl</div><div class="line">            = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</div><div class="line">        <span class="keyword">if</span> (rl == <span class="keyword">null</span>) {</div><div class="line">            rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,</div><div class="line">                    userId, receiver);</div><div class="line">            <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) {</div><div class="line">                rl.app.receivers.add(rl);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="comment">// 这里注册了这个 recevier 的死亡通知函数（后面会知道这个注册的用处的）</span></div><div class="line">                    receiver.asBinder().linkToDeath(rl, <span class="number">0</span>);</div><div class="line">                } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                    <span class="keyword">return</span> sticky;</div><div class="line">                }</div><div class="line">                rl.linkedToDeath = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (rl.uid != callingUid) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"Receiver requested to register for uid "</span> + callingUid</div><div class="line">                    + <span class="string">" was previously registered for uid "</span> + rl.uid);</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (rl.pid != callingPid) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"Receiver requested to register for pid "</span> + callingPid</div><div class="line">                    + <span class="string">" was previously registered for pid "</span> + rl.pid);</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (rl.userId != userId) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"Receiver requested to register for user "</span> + userId</div><div class="line">                    + <span class="string">" was previously registered for user "</span> + rl.userId);</div><div class="line">        }</div><div class="line">        <span class="comment">// 然后再根据上面的 ReceiverList 构造出一个 BroadcastFilter</span></div><div class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</div><div class="line">                permission, callingUid, userId);</div><div class="line">        rl.add(bf);</div><div class="line">        <span class="keyword">if</span> (!bf.debugCheck()) {</div><div class="line">            Slog.w(TAG, <span class="string">"==&gt; For Dynamic broadast"</span>);</div><div class="line">        }</div><div class="line">        <span class="comment">// 这里是关键步骤了，把上面那个 BroadcastFilter add 到 IntentResolver 这个对象中。</span></div><div class="line">        <span class="comment">// 这个东西后面分发广播的时候会用到（其实分发的时候查询这个里面的数据）。</span></div><div class="line">        mReceiverResolver.addFilter(bf);</div><div class="line"></div><div class="line">        <span class="comment">// sticky 相关的继续无视</span></div><div class="line">        <span class="comment">// Enqueue broadcasts for all existing stickies that match</span></div><div class="line">        <span class="comment">// this filter.</span></div><div class="line">        <span class="keyword">if</span> (allSticky != <span class="keyword">null</span>) {</div><div class="line">            ArrayList receivers = <span class="keyword">new</span> ArrayList();</div><div class="line">            receivers.add(bf);</div><div class="line"></div><div class="line">            <span class="keyword">int</span> N = allSticky.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                Intent intent = (Intent)allSticky.get(i);</div><div class="line">                BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">                BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, <span class="keyword">null</span>,</div><div class="line">                        <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="keyword">null</span>, receivers, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                        <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, -<span class="number">1</span>);</div><div class="line">                queue.enqueueParallelBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sticky;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们先说说参数，IIntentReceiver 是支持 Binder 的，传过来的是 Bp，IntentFilter 实现了 Parcelable 接口，也能 IPC 传过来。然后我们再开始说代码，一开始先获取注册调用者的进程记录（ProcessRecord，这个东西在 Binder 篇有说过，这里不多说）。然后广播有个 sticky 的功能，我们先不管这些花哨功能先。后面出现了一个 ReceiverList 的对象，我们来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * A receiver object that has registered for one or more broadcasts.</span></div><div class="line"><span class="comment"> * The ArrayList holds BroadcastFilter objects.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">class ReceiverList extends ArrayList&lt;BroadcastFilter&gt;</div><div class="line">        implements IBinder.DeathRecipient {</div><div class="line">    <span class="keyword">final</span> ActivityManagerService owner;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IIntentReceiver receiver;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ProcessRecord app;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> uid;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> userId;</div><div class="line">    BroadcastRecord curBroadcast = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> linkedToDeath = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    String stringName;</div><div class="line">        </div><div class="line">    ReceiverList(ActivityManagerService _owner, ProcessRecord _app,</div><div class="line">            <span class="keyword">int</span> _pid, <span class="keyword">int</span> _uid, <span class="keyword">int</span> _userId, IIntentReceiver _receiver) {</div><div class="line">        owner = _owner;</div><div class="line">        receiver = _receiver;</div><div class="line">        app = _app;</div><div class="line">        pid = _pid;</div><div class="line">        uid = _uid;</div><div class="line">        userId = _userId;</div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个是自己改造的一个 ArrayList，里面存放的是 BroadcastFilter，然后注意它保存了 IIntentReceiver（从 AMS 注册接口调用者那里得到）。然后上面的代码后面马上就构造出了一个 BroadcastFilter，添加到这个 ReceiverList 中去了。这个 BroadcastFilter 我们也来稍微看下它的结构吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class BroadcastFilter extends IntentFilter {</div><div class="line">    <span class="comment">// Back-pointer to the list this filter is in.</span></div><div class="line">    <span class="keyword">final</span> ReceiverList receiverList;</div><div class="line">    <span class="keyword">final</span> String packageName;</div><div class="line">    <span class="keyword">final</span> String requiredPermission;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> owningUid;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> owningUserId;</div><div class="line"></div><div class="line">    BroadcastFilter(IntentFilter _filter, ReceiverList _receiverList,</div><div class="line">            String _packageName, String _requiredPermission, <span class="keyword">int</span> _owningUid, <span class="keyword">int</span> _userId) {</div><div class="line">        <span class="keyword">super</span>(_filter);</div><div class="line">        receiverList = _receiverList;</div><div class="line">        packageName = _packageName;</div><div class="line">        requiredPermission = _requiredPermission;</div><div class="line">        owningUid = _owningUid;</div><div class="line">        owningUserId = _userId;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续自 IntentFilter（这个我就不多说了，注册广播的应该对这个很熟悉了）。上面代码 AMS 中还保存了已经注册过的 RecieverList(mRegisteredReceivers)，会先去以前的列表里面去找，看之前是不是注册过，这个可以防止多个重复的 broadcast recevier。然后到最后了， mReceiverResolver.addFilter(bf); 这里就很关键了。我们先来看看这个 mReceiverResolver 是什么东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// ================= ActivityManagerService.java ========================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Resolver for broadcast intents to registered receivers.</span></div><div class="line"><span class="comment">     * Holds BroadcastFilter (subclass of IntentFilter).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver</div><div class="line">            = <span class="keyword">new</span> IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt;() {</div><div class="line">        ... ...    </div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ================= IntentResolver.java ========================</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * {@hide}</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentResolver</span>&lt;<span class="title">F</span> <span class="keyword">extends</span> <span class="title">IntentFilter</span>, <span class="title">R</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; </span>{</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">"IntentResolver"</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> localLOGV = DEBUG || <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> VALIDATE = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 存数据的都在这里，基本不是 HashMap 就是 HashSet</span></div><div class="line">    <span class="comment">// 注释也写得很清楚是拿来存什么的</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * All filters that have been registered.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;F&gt; mFilters = <span class="keyword">new</span> HashSet&lt;F&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * All of the MIME types that have been registered, such as "image/jpeg",</span></div><div class="line"><span class="comment">     * "image/*", or "{@literal *}/*".</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, F[]&gt; mTypeToFilter = <span class="keyword">new</span> HashMap&lt;String, F[]&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The base names of all of all fully qualified MIME types that have been</span></div><div class="line"><span class="comment">     * registered, such as "image" or "*".  Wild card MIME types such as</span></div><div class="line"><span class="comment">     * "image/*" will not be here.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, F[]&gt; mBaseTypeToFilter = <span class="keyword">new</span> HashMap&lt;String, F[]&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The base names of all of the MIME types with a sub-type wildcard that</span></div><div class="line"><span class="comment">     * have been registered.  For example, a filter with "image/*" will be</span></div><div class="line"><span class="comment">     * included here as "image" but one with "image/jpeg" will not be</span></div><div class="line"><span class="comment">     * included here.  This also includes the "*" for the "{@literal *}/*"</span></div><div class="line"><span class="comment">     * MIME type.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, F[]&gt; mWildTypeToFilter = <span class="keyword">new</span> HashMap&lt;String, F[]&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * All of the URI schemes (such as http) that have been registered.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, F[]&gt; mSchemeToFilter = <span class="keyword">new</span> HashMap&lt;String, F[]&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * All of the actions that have been registered, but only those that did</span></div><div class="line"><span class="comment">     * not specify data.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, F[]&gt; mActionToFilter = <span class="keyword">new</span> HashMap&lt;String, F[]&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * All of the actions that have been registered and specified a MIME type.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, F[]&gt; mTypedActionToFilter = <span class="keyword">new</span> HashMap&lt;String, F[]&gt;();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>mReceiverResolver 继承自 IntentResolver 这个模板类。前面的 <strong>F</strong> 是传入类型，保存在列表（HashMap、HashSet）里面的，后面那个 <strong>R</strong> 是传出类型，后面 AMS 处理广播的时候要向 IntentResolver 查询的，那个时候返回的就是 R。然后2个模板都是 BroadcastFilter。我们先继续看它的 addFilter 里面是怎么处理的（在父类里面）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentResolver</span>&lt;<span class="title">F</span> <span class="keyword">extends</span> <span class="title">IntentFilter</span>, <span class="title">R</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span>(F f) {</div><div class="line">        <span class="keyword">if</span> (localLOGV) {</div><div class="line">            Slog.v(TAG, <span class="string">"Adding filter: "</span> + f);</div><div class="line">            f.dump(<span class="keyword">new</span> LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), <span class="string">"      "</span>);</div><div class="line">            Slog.v(TAG, <span class="string">"    Building Lookup Maps:"</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 先保存到 mFilters 里面，这个相当于是所有总类型的</span></div><div class="line">        mFilters.add(f);</div><div class="line">        <span class="comment">// 然后下面的是保 Scheme 的，IntentFilter 不是可以设置 Scheme 么</span></div><div class="line">        <span class="keyword">int</span> numS = register_intent_filter(f, f.schemesIterator(),</div><div class="line">                mSchemeToFilter, <span class="string">"      Scheme: "</span>);</div><div class="line">        <span class="comment">// 保存 Mime type 类型的，IntentFilter 也可以设置 Mime type</span></div><div class="line">        <span class="keyword">int</span> numT = register_mime_types(f, <span class="string">"      Type: "</span>);</div><div class="line">        <span class="keyword">if</span> (numS == <span class="number">0</span> && numT == <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 如果 IntentFiler 既没有设置 Scheme 也没有设置 Mime type 就保存 Action</span></div><div class="line">            <span class="comment">// IntentFiler 感觉还是 Action 用得多吧</span></div><div class="line">            register_intent_filter(f, f.actionsIterator(),</div><div class="line">                    mActionToFilter, <span class="string">"      Action: "</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (numT != <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 这个和上面的区别在于指定了 Action 的同时还指定了 Mime type</span></div><div class="line">            register_intent_filter(f, f.actionsIterator(),</div><div class="line">                    mTypedActionToFilter, <span class="string">"      TypedAction: "</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 下面的不用管，是兼容以前版本的格式的，VAILIDATE 设置为 false 的</span></div><div class="line">        <span class="keyword">if</span> (VALIDATE) {</div><div class="line">            mOldResolver.addFilter(f);</div><div class="line">            verifyDataStructures(f);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 addFilter 大意就是把传过来的 F（这里是 BroadcastFilter）保存到对应的列表里面。不过我们还是继续去看看 register_intent_filter 里面的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">register_intent_filter</span>(F filter, Iterator&lt;String&gt; i,</div><div class="line">        HashMap&lt;String, F[]&gt; dest, String prefix) {</div><div class="line">    <span class="keyword">if</span> (i == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 我们这里以 Action 为例，循环取出看看注册的 IntentFiler 里面包含多少个 Action</span></div><div class="line">    <span class="keyword">while</span> (i.hasNext()) {</div><div class="line">        String name = i.next();        </div><div class="line">        num++;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, prefix + name);</div><div class="line">        <span class="comment">// 这个 addFilter 是私有的，并且参数个数和上面的不一样</span></div><div class="line">        addFilter(dest, name, filter); </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addFilter</span>(HashMap&lt;String, F[]&gt; map, String name, F filter) {</div><div class="line">    <span class="comment">// 这个函数比较简单，就是把上面取到的 Action 和 传入的 filter 存到上面给定的 HashMap（HashSet） 中</span></div><div class="line">    F[] array = map.get(name);</div><div class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) {</div><div class="line">        array = newArray(<span class="number">2</span>);</div><div class="line">        map.put(name,  array);</div><div class="line">        array[<span class="number">0</span>] = filter;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = array.length;</div><div class="line">        <span class="keyword">int</span> i = N;</div><div class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> && array[i-<span class="number">1</span>] == <span class="keyword">null</span>) {</div><div class="line">            i--;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (i &lt; N) {</div><div class="line">            array[i] = filter;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            F[] newa = newArray((N*<span class="number">3</span>)/<span class="number">2</span>);</div><div class="line">            System.arraycopy(array, <span class="number">0</span>, newa, <span class="number">0</span>, N);</div><div class="line">            newa[N] = filter;</div><div class="line">            map.put(name, newa);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>处理比较简单，就是存下数据，不过注意这里 new 数据的时候函数 newArray， AMS 中的 mReceiverResolver 实现了这个函数（其实还实现了好个，这里先看这个）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> BroadcastFilter[] <span class="title">newArray</span>(<span class="keyword">int</span> size) {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BroadcastFilter[size];</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>也挺简单的，就是返回具体模板的对象的数组而已。到这里动态注册的服务端的流程就完了。简单来说就是把传过来的接收处理对象（IItnentRecevier）和要接收的广播（IntentFilter）保存到了 AMS 的一个叫 mReceiverResolver 里面去了。但是由于对象层层封装，容易一下子看多了忘记这个倒数是啥东西了。于是我整了一张，看一下应该就会好了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Broadcast-register/AMS-registerReceiver.png" alt="" title="AMS registerReceiver 数据流程"></p>
<h2 id="静态注册">静态注册</h2>
<p>上面说完了动态注册，我们来说下静态注册。和动态相对的，静态注册最大的特点就是： <strong>进程不需要运行，并且 AMS 在处理广播的时候还会帮你把接收器所在的进程启动起来</strong>。静态注册在 AndroidMainfest.xml 中声明一个 recevier 就可以了，例如像下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">receiver</span> <span class="attribute">android:name</span>=<span class="value">".service.AlarmInitReceiver"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">android:priority</span>=<span class="value">"90"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.TIME_SET"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.TIMEZONE_CHANGED"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.LOCALE_CHANGED"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">receiver</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>那静态广播是怎么注册到系统里面的去咧。其实看到在 mainfest 声明就应该猜到是 PMS 扫描，然后将扫描结果存了起来。实际就是这样的，我们来看看具体流程。首先在 PMS 的构造函数有这么一个调用（PMS 会在 SystemService 初始化的时候启动起来，具体的去看 Binder 多线程篇）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="title">PackageManagerService</span>(Context context, Installer installer,</div><div class="line">            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore) {</div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// SS 业务函数多线程支持照例加锁（话说这里还加了2把）</span></div><div class="line">        <span class="keyword">synchronized</span> (mInstallLock) {</div><div class="line">        <span class="comment">// writer</span></div><div class="line">        <span class="keyword">synchronized</span> (mPackages) {</div><div class="line">            mHandlerThread.start();</div><div class="line">            mHandler = <span class="keyword">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class="line"></div><div class="line">            <span class="comment">// 设置一些路径</span></div><div class="line">            File dataDir = Environment.getDataDirectory();</div><div class="line">            mAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"data"</span>);</div><div class="line">            mAppInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app"</span>);</div><div class="line">            mAppLibInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app-lib"</span>);</div><div class="line">            mAsecInternalPath = <span class="keyword">new</span> File(dataDir, <span class="string">"app-asec"</span>).getPath();</div><div class="line">            mUserAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"user"</span>);</div><div class="line">            mDrmAppPrivateInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app-private"</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// framework 的路径是 /system/framework</span></div><div class="line">            mFrameworkDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"framework"</span>);</div><div class="line">            mDalvikCacheDir = <span class="keyword">new</span> File(dataDir, <span class="string">"dalvik-cache"</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// Find base frameworks (resource packages without code).</span></div><div class="line">            mFrameworkInstallObserver = <span class="keyword">new</span> AppDirObserver(</div><div class="line">                mFrameworkDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</div><div class="line">            mFrameworkInstallObserver.startWatching();</div><div class="line">            scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR,</div><div class="line">                    scanMode | SCAN_NO_DEX, <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 系统应用的路径是 /system/app</span></div><div class="line">            <span class="comment">// Collect all system packages.</span></div><div class="line">            mSystemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"app"</span>);</div><div class="line">            mSystemInstallObserver = <span class="keyword">new</span> AppDirObserver(</div><div class="line">                mSystemAppDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</div><div class="line">            mSystemInstallObserver.startWatching();</div><div class="line">            <span class="comment">// 扫描系统应用</span></div><div class="line">            scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="comment">// /vendor/app 下面应该是留给 OEM 厂商定制的 app</span></div><div class="line">            <span class="comment">// 不过一些 OEM 厂商不买 google 账，自己乱放（例如步步高）</span></div><div class="line">            <span class="comment">// Collect all vendor packages.</span></div><div class="line">            mVendorAppDir = <span class="keyword">new</span> File(<span class="string">"/vendor/app"</span>);</div><div class="line">            mVendorInstallObserver = <span class="keyword">new</span> AppDirObserver(</div><div class="line">                mVendorAppDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</div><div class="line">            mVendorInstallObserver.startWatching();</div><div class="line">            <span class="comment">// 扫描 OEM 定制应用</span></div><div class="line">            scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// 这个 onlyCore 是运行在加密的设备上（"vold.decrypt" 被设置为 true）才是 true，</span></div><div class="line">            <span class="comment">// 一般的是 false</span></div><div class="line">            <span class="keyword">if</span> (!mOnlyCore) {</div><div class="line">                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class="line">                        SystemClock.uptimeMillis());</div><div class="line">                mAppInstallObserver = <span class="keyword">new</span> AppDirObserver(</div><div class="line">                    mAppInstallDir.getPath(), OBSERVER_EVENTS, <span class="keyword">false</span>);</div><div class="line">                mAppInstallObserver.startWatching();</div><div class="line">                <span class="comment">// 这个路径前面设置过了是 /data/data，这里扫描普通应用</span></div><div class="line">                scanDirLI(mAppInstallDir, <span class="number">0</span>, scanMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">                <span class="comment">// 这里是扫描受 DRM 保护的应用</span></div><div class="line">                mDrmAppInstallObserver = <span class="keyword">new</span> AppDirObserver(</div><div class="line">                    mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, <span class="keyword">false</span>);</div><div class="line">                mDrmAppInstallObserver.startWatching();</div><div class="line">                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class="line">                        scanMode, <span class="number">0</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mAppInstallObserver = <span class="keyword">null</span>;</div><div class="line">                mDrmAppInstallObserver = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        } <span class="comment">// synchronized (mPackages)</span></div><div class="line">        } <span class="comment">// synchronized (mInstallLock)</span></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>SS（PMS） 是开机启动的，也就是说在开机的时候 PMS 会去扫描一系列目录下的应用去收集一些应用的信息（稍微扯远点，注意看上面有一些文件 Observer（这个是 android 自己弄了一个监视文件变动的 Observer）设置，会在监视相应目录下的文件变动，一有变动，PMS 会扫描变动，这也就是为什么调试的时候直接 push apk 到 /system/app 或者 /data/app 下面也是能够正常安装的原因）。扫描函数是 scanDirLI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个是扫描目录的</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span>(File dir, <span class="keyword">int</span> flags, <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime) {</div><div class="line">    String[] files = dir.list();</div><div class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>) {</div><div class="line">        Log.d(TAG, <span class="string">"No files in app dir "</span> + dir);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }   </div><div class="line">        </div><div class="line">    <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) {</div><div class="line">        Log.d(TAG, <span class="string">"Scanning app dir "</span> + dir);</div><div class="line">    }   </div><div class="line">        </div><div class="line">    <span class="comment">// 这个写法，不支持递归目录咧（也不需要支持）</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;files.length; i++) {</div><div class="line">        File file = <span class="keyword">new</span> File(dir, files[i]);</div><div class="line">        <span class="comment">// 稍微判断下是不是 apk 文件（这里我们就不去看这个判断了）</span></div><div class="line">        <span class="keyword">if</span> (!isPackageFilename(files[i])) {</div><div class="line">            <span class="comment">// Ignore entries which are not apk's</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 罗列下指定目录下的 apk 文件，然后交给扫描文件的函数处理</span></div><div class="line">        PackageParser.Package pkg = scanPackageLI(file,</div><div class="line">                flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// Don't mess around with apps in system partition.</span></div><div class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span> && (flags & PackageParser.PARSE_IS_SYSTEM) == <span class="number">0</span> &&</div><div class="line">                mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) {</div><div class="line">            <span class="comment">// Delete the apk</span></div><div class="line">            Slog.w(TAG, <span class="string">"Cleaning up failed install of "</span> + file);</div><div class="line">            file.delete();</div><div class="line">        }</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里把扫描单个 apk 文件的任务交给 scanPackageLI 这个函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  Scan a package and return the newly parsed package.</span></div><div class="line"><span class="comment">     *  Returns null in case of errors and the error code is stored in mLastScanError</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> PackageParser.Package <span class="title">scanPackageLI</span>(File scanFile,</div><div class="line">            <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime, UserHandle user) {</div><div class="line">        mLastScanError = PackageManager.INSTALL_SUCCEEDED;</div><div class="line">        String scanPath = scanFile.getPath();</div><div class="line">        parseFlags |= mDefParseFlags;</div><div class="line">        PackageParser pp = <span class="keyword">new</span> PackageParser(scanPath);</div><div class="line">        pp.setSeparateProcesses(mSeparateProcesses);</div><div class="line">        pp.setOnlyCoreApps(mOnlyCore);</div><div class="line">        <span class="comment">// PMS 中有一个专门解析 apk 文件的东西（PackageParser），里面包括了很多文件的解析</span></div><div class="line">        <span class="comment">// 这里我们不去过多分析这个，以后有空再单独开一篇分析咯，这里就当它解析好了就行了</span></div><div class="line">        <span class="keyword">final</span> PackageParser.Package pkg = pp.parsePackage(scanFile,</div><div class="line">                scanPath, mMetrics, parseFlags);</div><div class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) {</div><div class="line">            mLastScanError = pp.getParseError();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        String codePath = <span class="keyword">null</span>; </div><div class="line">        String resPath = <span class="keyword">null</span>; </div><div class="line">        <span class="keyword">if</span> ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span> && ps.resourcePathString != <span class="keyword">null</span>) {</div><div class="line">                resPath = ps.resourcePathString;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// Should not happen at all. Just log an error.</span></div><div class="line">                Slog.e(TAG, <span class="string">"Resource path not set for pkg : "</span> + pkg.packageName);</div><div class="line">            }     </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            resPath = pkg.mScanPath;</div><div class="line">        }     </div><div class="line">        codePath = pkg.mScanPath;</div><div class="line">        <span class="comment">// Set application objects path explicitly.</span></div><div class="line">        setApplicationInfoPaths(pkg, codePath, resPath);</div><div class="line">        <span class="comment">// 这里又调用另外一个同名不同参数的函数去处理了</span></div><div class="line">        <span class="comment">// Note that we invoke the following method only if we are about to unpack an application</span></div><div class="line">        PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanMode</div><div class="line">                | SCAN_UPDATE_SIGNATURE, currentTime, user);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> scannedPkg;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>又调用到同名，不同参数的函数中去了，而且这个函数巨长无比，有将近 1000 行，我们只看关键部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> PackageParser.Package <span class="title">scanPackageLI</span>(PackageParser.Package pkg,</div><div class="line">            <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime, UserHandle user) {</div><div class="line">        File scanFile = <span class="keyword">new</span> File(pkg.mScanPath);</div><div class="line">        <span class="keyword">if</span> (scanFile == <span class="keyword">null</span> || pkg.applicationInfo.sourceDir == <span class="keyword">null</span> ||</div><div class="line">                pkg.applicationInfo.publicSourceDir == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Bail out. The resource and code paths haven't been set.</span></div><div class="line">            Slog.w(TAG, <span class="string">" Code and resource paths haven't been set correctly"</span>);</div><div class="line">            mLastScanError = PackageManager.INSTALL_FAILED_INVALID_APK;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }   </div><div class="line">        mScanningPath = scanFile;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// writer</span></div><div class="line">        <span class="keyword">synchronized</span> (mPackages) {</div><div class="line">            <span class="comment">// We don't expect installation to fail beyond this point,</span></div><div class="line">            <span class="keyword">if</span> ((scanMode&SCAN_MONITOR) != <span class="number">0</span>) {</div><div class="line">                mAppDirs.put(pkg.mPath, pkg);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// 取 PackageParser 解析 manifest 中有声明了的 receiver </span></div><div class="line">            N = pkg.receivers.size();</div><div class="line">            r = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                PackageParser.Activity a = pkg.receivers.get(i);</div><div class="line">                a.info.processName = fixProcessName(pkg.applicationInfo.processName,</div><div class="line">                        a.info.processName, pkg.applicationInfo.uid);</div><div class="line">                <span class="comment">// 这个 addActivity 是关键步骤了</span></div><div class="line">                mReceivers.addActivity(a, <span class="string">"receiver"</span>);</div><div class="line">                <span class="keyword">if</span> ((parseFlags&PackageParser.PARSE_CHATTY) != <span class="number">0</span>) {</div><div class="line">                    <span class="keyword">if</span> (r == <span class="keyword">null</span>) {</div><div class="line">                        r = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        r.append(<span class="string">' '</span>);</div><div class="line">                    }         </div><div class="line">                    r.append(a.info.name);</div><div class="line">                }                 </div><div class="line">            }                 </div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) Log.d(TAG, <span class="string">"  Receivers: "</span> + r);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line">            </div><div class="line">        }         </div><div class="line">                </div><div class="line">        <span class="keyword">return</span> pkg;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们先来看这个 mReceivers 是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// All available receivers, for your resolving pleasure.</span></div><div class="line">    <span class="keyword">final</span> ActivityIntentResolver mReceivers =</div><div class="line">            <span class="keyword">new</span> ActivityIntentResolver();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityIntentResolver</span></span></div><div class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">IntentResolver</span>&lt;<span class="title">PackageParser</span>.<span class="title">ActivityIntentInfo</span>, <span class="title">ResolveInfo</span>&gt; </span>{</div><div class="line">        ... ...</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>经过前面动态注册的分析，对于个 IntentResolver 模板类应该不陌生了吧。PMS 中也有一个，用来来保存静态的注册信息的（AMS 那个是保存动态的）。PMS 里面的 F 是 PackageParser.ActivityIntentInfo， R 是 ResolverInfo。我们来看下这个 F 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentInfo</span> <span class="keyword">extends</span> <span class="title">IntentFilter</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasDefault;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> labelRes;</div><div class="line">    <span class="keyword">public</span> CharSequence nonLocalizedLabel;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> icon;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> logo;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityIntentInfo</span> <span class="keyword">extends</span> <span class="title">IntentInfo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Activity activity;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">ActivityIntentInfo</span>(Activity _activity) {</div><div class="line">        activity = _activity;</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"ActivityIntentInfo{"</span></div><div class="line">            + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</div><div class="line">            + <span class="string">" "</span> + activity.info.name + <span class="string">"}"</span>; </div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还是得继承自 IntentFilter，只不过又多了一层，然后多了几个变量而已。然后 scanPackageLI 这个函数是传入 PackageParser.Activity 这个对象过去的，我们看看这个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span>&lt;<span class="title">II</span> <span class="keyword">extends</span> <span class="title">IntentInfo</span>&gt; </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Package owner;    </div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> ArrayList&lt;II&gt; intents;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String className; </div><div class="line">        <span class="keyword">public</span> Bundle metaData;        </div><div class="line"></div><div class="line">        ComponentName componentName;   </div><div class="line">        String componentShortName;  </div><div class="line">... ...</div><div class="line">        </div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ActivityIntentInfo</span>&gt; </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> ActivityInfo info;</div><div class="line">            </div><div class="line">        <span class="keyword">public</span> <span class="title">Activity</span>(<span class="keyword">final</span> ParseComponentArgs args, <span class="keyword">final</span> ActivityInfo _info) {</div><div class="line">            <span class="keyword">super</span>(args, _info);</div><div class="line">            info = _info; </div><div class="line">            info.applicationInfo = args.owner.applicationInfo;</div><div class="line">        }       </div><div class="line">            </div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPackageName</span>(String packageName) {</div><div class="line">            <span class="keyword">super</span>.setPackageName(packageName);</div><div class="line">            info.packageName = packageName;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">            <span class="keyword">return</span> <span class="string">"Activity{"</span></div><div class="line">                + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</div><div class="line">                + <span class="string">" "</span> + getComponentShortName() + <span class="string">"}"</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>绕了几下，反正是 ActivityIntentInfo 的子类。至于 ActivityIntentInfo 怎么从 PackageParser 解析出来的，前面说了我们这里不做分析。然后我们直接去看 ActivityIntentResolver 的 addActivity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// type 前面传入的是 "receiver"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addActivity</span>(PackageParser.Activity a, String type) {   </div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> systemApp = isSystemApp(a.info.applicationInfo);</div><div class="line">    mActivities.put(a.getComponentName(), a);</div><div class="line">    <span class="keyword">if</span> (DEBUG_SHOW_INFO)</div><div class="line">        Log.v(</div><div class="line">        TAG, <span class="string">"  "</span> + type + <span class="string">" "</span> +</div><div class="line">        (a.info.nonLocalizedLabel != <span class="keyword">null</span> ? a.info.nonLocalizedLabel : a.info.name) + <span class="string">":"</span>);</div><div class="line">    <span class="keyword">if</span> (DEBUG_SHOW_INFO)</div><div class="line">        Log.v(TAG, <span class="string">"    Class="</span> + a.info.name);</div><div class="line">    <span class="comment">// 前面 Activity 的父类的父类 Component 中有一个 ArrayList 保存了系列 ActivityIntentInfo</span></div><div class="line">    <span class="comment">// 然后就是 mainfest 里面声明了多少个 &lt;intent-filer&gt; 的标签，这里就有几个 ActivityIntentInfo</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NI = a.intents.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;NI; j++) {</div><div class="line">        PackageParser.ActivityIntentInfo intent = a.intents.get(j);</div><div class="line">        <span class="comment">// 这里有个优先级权限判断，如果不是系统应用，或者 type 类型是 activity（这里是 recevier）</span></div><div class="line">        <span class="comment">// 优先级设置大于 0 的话，强制变成0</span></div><div class="line">        <span class="comment">// 换句话说，只有系统应用能把 receiver 的优先级设置成大于 0</span></div><div class="line">        <span class="keyword">if</span> (!systemApp && intent.getPriority() &gt; <span class="number">0</span> && <span class="string">"activity"</span>.equals(type)) {</div><div class="line">            intent.setPriority(<span class="number">0</span>); </div><div class="line">            Log.w(TAG, <span class="string">"Package "</span> + a.info.applicationInfo.packageName + <span class="string">" has activity "</span></div><div class="line">                    + a.className + <span class="string">" with priority &gt; 0, forcing to 0"</span>);</div><div class="line">        }  </div><div class="line">        <span class="keyword">if</span> (DEBUG_SHOW_INFO) {</div><div class="line">            Log.v(TAG, <span class="string">"    IntentFilter:"</span>);</div><div class="line">            intent.dump(<span class="keyword">new</span> LogPrinter(Log.VERBOSE, TAG), <span class="string">"      "</span>);</div><div class="line">        }   </div><div class="line">        <span class="keyword">if</span> (!intent.debugCheck()) {</div><div class="line">            Log.w(TAG, <span class="string">"==&gt; For Activity "</span> + a.info.name);</div><div class="line">        }</div><div class="line">        <span class="comment">// 调用父类 IntentResolver 的 addFilter 添加 IntentFilter </span></div><div class="line">        addFilter(intent);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有个解决前面背景中关机闹钟不响问题的关键——广播 receiver 接收优先级的设置。在 mainfest 的 intent-filter 标签中可以声明一个优先级（看我前面的那个例子），这个是一个 int 类型，一般默认是 0。数值越大，优先级越高，这个优先级在哪里会用到，到后面一篇，广播处理那里就能看到了。这个数值是由 PackageParser 解析 mainfest 中的声明得到的，从这里的判断可以看出，普通应用的广播 receiver 无法声明高于 0。但是这点好像只对静态注册的广播有限制，动态的可以使用 IntentFilter.setPriority 设置，虽然 API 文档里告诉你不要让这个值高于 <code>SYSTEM_HIGH_PRIORITY(1000)</code> ，但是 AMS 里面没有任何限制判断，所以你要耍下流氓可以把这个值设得很高。不过动态注册的 recevier 在并行广播处理（后面那篇处理的会解释什么叫并行广播、什么叫串行广播）中和静态的 receiver 的优先级有本质的区别（后面能知道本质区别在哪），所以动态的流氓点好像关系也不大。</p>
<p>扯了下优先级的问题。最后还是调用父类 IntentResolver 的 addFilter 保存到列表中，然后 PMS 的 ActivityIntentResolver 的 newArray 是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> ActivityIntentInfo[] <span class="title">newArray</span>(<span class="keyword">int</span> size) {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityIntentInfo[size];</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 addFilter 就不重复说一遍了。</p>
<h2 id="总结">总结</h2>
<p>通过上面的分析，可以看到，虽然广播接收器注册分动态和静态。但是最后的流程都是一样的，<strong>只不过一个接收器的数据保存在 AMS 中（动态的）</strong>，<strong>一个接收器的数据保存在 PMS 中（静态的）</strong>。所以后面处理广播的时候查询动态的接收器直接用 AMS 自己的数据查，而查询静态的需要调用 PMS 的接口去查（不过它们2个都在一个进程里面，也算一家人啦）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20%E5%A6%82%E4%BD%95%E5%9C%A8%20github%20%E4%B8%8A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93/</loc>
    <lastmod>2015-01-31T11:56:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 如何在 github 上删除一个仓库</title>
        <pubTime>2015-01-31T11:56:16.000Z</pubTime>
        
        <tag>other </tag>
         
         <content><![CDATA[<p>删除功能很隐蔽，可能老外就不太想让你删除吧，毕竟这是一个开源的地方，但是偶尔创建了一些测试仓库在那里很碍眼。</p>
<p>首先点击进入你要删除的 repository，如下图，点击 setting：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/github-delete-git/1.jpeg" alt=""></p>
<p>将网页拉到下方，找到 Delete this repository 按钮，点击：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/github-delete-git/2.jpeg" alt=""></p>
<p>在弹出的对话框中根据上面的黑体字输入你的 repository 的名字：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/github-delete-git/3.jpeg" alt=""></p>
<p>最后点击下方的按钮就行了。</p>
<p><a href="http://blog.csdn.net/xdrt81y/article/details/21077297" title="原始出处" target="_blank" rel="external">原始出处</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-31T11:43:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 字符编码笔记</title>
        <pubTime>2015-01-31T11:43:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<h2 id="1、字符编码、内码，顺带介绍汉字编码">1、字符编码、内码，顺带介绍汉字编码</h2>
<p>字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。 </p>
<p>GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。 </p>
<p>从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。 </p>
<p>有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。 </p>
<p>这里还有一些细节： </p>
<ol>
<li>GB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。 </li>
<li>在DBCS中，GB内码的存储格式始终是big endian，即高位在前。 </li>
<li>GB2312的两个字节的最高位都是1。但符合这个条件的码位只有128*128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。 </li>
</ol>
<h2 id="2、Unicode、UCS和UTF">2、Unicode、UCS和UTF</h2>
<p>前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。 </p>
<p>Unicode也是一种字符编码方法，不过它是由国际组织设计，可以容纳全世界所有语言文字的编码方案。Unicode的学名是”Universal Multiple-Octet Coded Character Set”，简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。 </p>
<p>根据维基百科的记载：历史上存在两个试图独立设计Unicode的组织，即国际标准化组织（ISO）和一个软件制造商的协会（unicode.org）。ISO开发了ISO 10646项目，Unicode协会开发了Unicode项目。在1991年前后，双方都认识到世界不需要两个不兼容的字符集。于是它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode2.0开始，Unicode项目采用了与ISO 10646-1相同的字库和字码。目前两个项目仍都存在，并独立地公布各自的标准。Unicode协会现在的最新版本是2005年的Unicode 4.1.0。ISO的最新标准是10646-3:2003。 </p>
<p>UCS规定了怎么用多个字节表示各种文字。怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的，常见的UTF规范包括UTF-8、UTF-7、UTF-16。 </p>
<p>IETF的RFC2781和RFC3629以RFC的一贯风格，清晰、明快又不失严谨地描述了UTF-16和UTF-8的编码方法。我总是记不得IETF是Internet Engineering Task Force的缩写。但IETF负责维护的RFC是Internet上一切规范的基础。 </p>
<h2 id="3、ASCII码">3、ASCII码</h2>
<p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。 </p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。 </p>
<h2 id="4、非ASCII编码">4、非ASCII编码</h2>
<p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 </p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。 </p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256×256=65536个符号。 </p>
<p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。 </p>
<h2 id="5、Unicode">5、Unicode</h2>
<p>Unicode的学名是 “Universal   Multiple-Octet   Coded   Character   Set “，简称为UCS。 现在用的是UCS-2，即２个字节编码，而UCS-4是为了防止将来２个字节不够用才开发的。UCS-2也称为基本多文种平面。 UCS-2转换到UCS-4只是简单的在前面加２个字节0。 UCS-4则主要用于保存辅助平面</p>
<p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。 </p>
<p>Unicode当然是一个很大的集合，<strong>Unicode 默认就是 Little Endian 模式</strong>，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询<a href="http://www.unicode.org/" title="unicode.org" target="_blank" rel="external">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" title="汉字对应表" target="_blank" rel="external">汉字对应表</a>。 </p>
<h2 id="6、Unicode的问题">6、Unicode的问题</h2>
<p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 </p>
<p>比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 </p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 </p>
<p>它们造成的结果是：</p>
<ol>
<li>出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。</li>
<li>unicode在很长一段时间内无法推广，直到互联网的出现。</li>
</ol>
<h2 id="7、UTF-8">7、UTF-8</h2>
<p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一</strong>。 </p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有二条： </p>
<ol>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </li>
<li>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 </li>
</ol>
<p>下表总结了编码规则，字母x表示可用编码的位。</p>
<pre>
Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
——————–+———————————————
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 
</pre>

<p>下面，还是以汉字“严”为例，演示如何实现UTF-8编码。 </p>
<p>已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 </p>
<h2 id="8、Unicode与UTF-8之间的转换">8、Unicode与UTF-8之间的转换</h2>
<p>通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。 </p>
<p>在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击“文件”菜单中的“另存为”命令，会跳出一个对话框，在最底部有一个“编码”的下拉条。 </p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/basics/charset-encode-note/1.jpeg" alt=""></p>
<p>里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。 </p>
<ol>
<li>ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。 </li>
<li>Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。 </li>
<li>Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。</li>
<li>UTF-8编码，也就是上一节谈到的编码方法。 </li>
</ol>
<p>选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。</p>
<h2 id="9、Little_endian和Big_endian">9、Little endian和Big endian</h2>
<p>上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严“为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。 </p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 </p>
<p>因此，第一个字节在前，就是”大头方式“（Big endian），第二个字节在前就是”小头方式“（Little endian）。那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），用FEFF(U+FEFF)表示。这正好是两个字节，而且FEFF在UCS中是不存在的（所以数据中有这2个字节对显示没影响）。如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p>
<h2 id="10、UCS-2、UCS-4、BMP">10、UCS-2、UCS-4、BMP</h2>
<p>UCS有两种格式：UCS-2和UCS-4。顾名思义，UCS-2就是用两个字节编码，UCS-4就是用4个字节（实际上只用了31位，最高位必须为0）编码。下面让我们做一些简单的数学游戏： </p>
<ol>
<li>UCS-2有2^16=65536个码位，UCS-4有2^31=2147483648个码位。 </li>
<li>UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行 (rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。 </li>
<li>group 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。</li>
<li>将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。 </li>
</ol>
<h2 id="11、UTF的字节序和BOM">11、UTF的字节序和BOM</h2>
<p>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？ </p>
<p>Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法： </p>
<p>在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FEFF在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 </p>
<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>
<p>Windows就是使用BOM来标记文本文件的编码方式的。 </p>
<h2 id="12、实例">12、实例</h2>
<p>下面，举一个实例。 </p>
<p>打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。 </p>
<p>然后，用文本编辑软件UltraEdit中的”十六进制功能“，观察该文件的内部编码方式。 </p>
<ol>
<li>ANSI：文件的编码就是两个字节“D1 CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。 </li>
<li>Unicode：编码是四个字节“FF FE 25 4E”，其中“FF FE”表明是小头方式存储，真正的编码是4E25。 </li>
<li>Unicode big endian：编码是四个字节“FE FF 4E 25”，其中“FE FF”表明是大头方式存储。 </li>
<li>UTF-8：编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，<strong>它的存储顺序与编码顺序是一致的</strong>。</li>
</ol>
<p><a href="http://www.cnblogs.com/lidabo/archive/2013/11/27/3446518.html" title="原始出处" target="_blank" rel="external">原始出处</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20Java%20%E7%9A%84%E6%A8%A1%E7%89%88%E5%92%8C%20C++%20%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/</loc>
    <lastmod>2015-01-31T11:38:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Java 的模版和 C++ 模版的区别</title>
        <pubTime>2015-01-31T11:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>java 中的模版其实应该叫泛型。 泛型本质上是提供类型的”类型参数”，它们也被称为参数化类型（parameterized type）或参量多态（parametric polymorphism）。其实泛型思想并不是 Java 最先引入的，C++ 中的模板就是一个运用泛型的例子。泛型程序设计划分为三个熟练地级别。</p>
<ul>
<li><p>java 中没有 template 的关键字，c++ 中有。</p>
</li>
<li><p>java 语言中的泛型不能接受基本类型作为类型参数――它只能接受引用类型。这意味着可以定义 <code>List&lt;Integer&gt;</code>，但是不可以定义 <code>List&lt;int&gt;</code>。</p>
</li>
<li><p>在java中，尖括号通常放在方法名前，而c++则是放在方法名后，c++的方式容易产生歧义，例如<code>g(f&lt;a,b&gt;(c))</code>，这个则有两种解释，一种是f的泛型调用，c为参数，a，b为泛型参数。另一种解释，则是，g调用，两个bool类型的参数。</p>
</li>
<li><p>在 C++ 模板中，编译器使用提供的类型参数来扩充模板，因此，为 <code>List&lt;A&gt;</code> 生成的 C++ 代码不同于为 <code>List&lt;B&gt;</code> 生成的代码，<code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 实际上是两个不同的类。而 Java 中的泛型则以不同的方式实现，编译器仅仅对这些类型参数进行擦除和替换。类型 <code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 的对象共享相同的类，并且只存在一个 ArrayList 类。因此在c++中存在为每个模板的实例化产生不同的类型，这一现象被称为“模板代码膨胀”，而java则不存在这个问题的困扰。java中虚拟机中没有泛型，只有基本类型和类类型，泛型会被擦除，一般会修改为Object，如果有限制，例如 T extends Comparable,则会被修改为Comparable。而在C++中不能对模板参数的类型加以限制，如果程序员用一个不适当的类型实例化一个模板，将会在模板代码中报告一个错误信息。</p>
</li>
</ul>
<p><a href="http://blog.163.com/maravilla_evol/blog/static/139564699201061694833152/" title="原始出处" target="_blank" rel="external">原始出处</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20unicode%20%E7%BC%96%E7%A0%81%E8%A1%A8/</loc>
    <lastmod>2015-01-31T11:38:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) unicode 编码表</title>
        <pubTime>2015-01-31T11:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<h2 id="unicode_编码表">unicode 编码表</h2>
<p>Unicode 目前普遍采用的是 UCS-2，它用两个字节来编码一个字符, 比如汉字”经”的编码是 0x7ECF，注意字符编码一般用十六进制来表示,为了与十进制区分,十六进制以 0x 头，0x7ECF 转换成十进制就是 32463，UCS-2 用两个字节来编码字符，两个字节就是16位二进制，2的16次方等于 65536，所以 UCS-2 最多能编码 65536 个字符。编码从 0 到 127 的字符与 ASCII 编码的字符一样，比如字母 “a” 的 Unicode 编码是 0x0061，十进制是 97，而 “a” 的 ASCII 编码是 0x61，十进制也是 97，对于汉字的编码,事实上 Unicode 对汉字支持不怎么好，这也是没办法的，简体和繁体总共有六七万个汉字，而 UCS-2 最多能表示 65536 个，才六万多个，所以 Unicode 只能排除一些几乎不用的汉字,好在常用的简体汉字也不过七千多个，为了能表示所有汉字，Unicode 也有 UCS-4 规范，就是用4个字节来编码字符，不过现在普遍采用的还是 UCS-2，只用两个字节来编码，看一下 Unicode 对汉字的编码:</p>
<h2 id="码表">码表</h2>
<pre>
2 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
4e00 一 丁 丂 七 丄 丅 丆 万 丈 三 上 下 丌 不 与 丏 
4e10 丐 丑 丒 专 且 丕 世 丗 丘 丙 业 丛 东 丝 丞 丟 
4e20 丠 両 丢 丣 两 严 並 丧 丨 丩 个 丫 丬 中 丮 丯 
4e30 丰 丱 串 丳 临 丵 丶 丷 丸 丹 为 主 丼 丽 举 丿 
4e40 乀 乁 乂 乃 乄 久 乆 乇 么 义 乊 之 乌 乍 乎 乏 
4e50 乐 乑 乒 乓 乔 乕 乖 乗 乘 乙 乚 乛 乜 九 乞 也 
4e60 习 乡 乢 乣 乤 乥 书 乧 乨 乩 乪 乫 乬 乭 乮 乯 
4e70 买 乱 乲 乳 乴 乵 乶 乷 乸 乹 乺 乻 乼 乽 乾 乿 
4e80 亀 亁 亂 亃 亄 亅 了 亇 予 争 亊 事 二 亍 于 亏 
4e90 亐 云 互 亓 五 井 亖 亗 亘 亙 亚 些 亜 亝 亞 亟 
4ea0 亠 亡 亢 亣 交 亥 亦 产 亨 亩 亪 享 京 亭 亮 亯 
4eb0 亰 亱 亲 亳 亴 亵 亶 亷 亸 亹 人 亻 亼 亽 亾 亿 
4ec0 什 仁 仂 仃 仄 仅 仆 仇 仈 仉 今 介 仌 仍 从 仏 
4ed0 仐 仑 仒 仓 仔 仕 他 仗 付 仙 仚 仛 仜 仝 仞 仟 
4ee0 仠 仡 仢 代 令 以 仦 仧 仨 仩 仪 仫 们 仭 仮 仯 
4ef0 仰 仱 仲 仳 仴 仵 件 价 仸 仹 仺 任 仼 份 仾 仿 
4f00 伀 企 伂 伃 伄 伅 伆 伇 伈 伉 伊 伋 伌 伍 伎 伏 
4f10 伐 休 伒 伓 伔 伕 伖 众 优 伙 会 伛 伜 伝 伞 伟 
4f20 传 伡 伢 伣 伤 伥 伦 伧 伨 伩 伪 伫 伬 伭 伮 伯 

-------------------------------------------------------

3 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
4f30 估 伱 伲 伳 伴 伵 伶 伷 伸 伹 伺 伻 似 伽 伾 伿 
4f40 佀 佁 佂 佃 佄 佅 但 佇 佈 佉 佊 佋 佌 位 低 住 
4f50 佐 佑 佒 体 佔 何 佖 佗 佘 余 佚 佛 作 佝 佞 佟 
4f60 你 佡 佢 佣 佤 佥 佦 佧 佨 佩 佪 佫 佬 佭 佮 佯 
4f70 佰 佱 佲 佳 佴 併 佶 佷 佸 佹 佺 佻 佼 佽 佾 使 
4f80 侀 侁 侂 侃 侄 侅 來 侇 侈 侉 侊 例 侌 侍 侎 侏 
4f90 侐 侑 侒 侓 侔 侕 侖 侗 侘 侙 侚 供 侜 依 侞 侟 
4fa0 侠 価 侢 侣 侤 侥 侦 侧 侨 侩 侪 侫 侬 侭 侮 侯 
4fb0 侰 侱 侲 侳 侴 侵 侶 侷 侸 侹 侺 侻 侼 侽 侾 便 
4fc0 俀 俁 係 促 俄 俅 俆 俇 俈 俉 俊 俋 俌 俍 俎 俏 
4fd0 俐 俑 俒 俓 俔 俕 俖 俗 俘 俙 俚 俛 俜 保 俞 俟 
4fe0 俠 信 俢 俣 俤 俥 俦 俧 俨 俩 俪 俫 俬 俭 修 俯 
4ff0 俰 俱 俲 俳 俴 俵 俶 俷 俸 俹 俺 俻 俼 俽 俾 俿 
5000 倀 倁 倂 倃 倄 倅 倆 倇 倈 倉 倊 個 倌 倍 倎 倏 
5010 倐 們 倒 倓 倔 倕 倖 倗 倘 候 倚 倛 倜 倝 倞 借 
5020 倠 倡 倢 倣 値 倥 倦 倧 倨 倩 倪 倫 倬 倭 倮 倯 
5030 倰 倱 倲 倳 倴 倵 倶 倷 倸 倹 债 倻 值 倽 倾 倿 
5040 偀 偁 偂 偃 偄 偅 偆 假 偈 偉 偊 偋 偌 偍 偎 偏 
5050 偐 偑 偒 偓 偔 偕 偖 偗 偘 偙 做 偛 停 偝 偞 偟 
5060 偠 偡 偢 偣 偤 健 偦 偧 偨 偩 偪 偫 偬 偭 偮 偯 
5070 偰 偱 偲 偳 側 偵 偶 偷 偸 偹 偺 偻 偼 偽 偾 偿 


-------------------------------------------------------

4 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5080 傀 傁 傂 傃 傄 傅 傆 傇 傈 傉 傊 傋 傌 傍 傎 傏 
5090 傐 傑 傒 傓 傔 傕 傖 傗 傘 備 傚 傛 傜 傝 傞 傟 
50a0 傠 傡 傢 傣 傤 傥 傦 傧 储 傩 傪 傫 催 傭 傮 傯 
50b0 傰 傱 傲 傳 傴 債 傶 傷 傸 傹 傺 傻 傼 傽 傾 傿 
50c0 僀 僁 僂 僃 僄 僅 僆 僇 僈 僉 僊 僋 僌 働 僎 像 
50d0 僐 僑 僒 僓 僔 僕 僖 僗 僘 僙 僚 僛 僜 僝 僞 僟 
50e0 僠 僡 僢 僣 僤 僥 僦 僧 僨 僩 僪 僫 僬 僭 僮 僯 
50f0 僰 僱 僲 僳 僴 僵 僶 僷 僸 價 僺 僻 僼 僽 僾 僿 
5100 儀 儁 儂 儃 億 儅 儆 儇 儈 儉 儊 儋 儌 儍 儎 儏 
5110 儐 儑 儒 儓 儔 儕 儖 儗 儘 儙 儚 儛 儜 儝 儞 償 
5120 儠 儡 儢 儣 儤 儥 儦 儧 儨 儩 優 儫 儬 儭 儮 儯 
5130 儰 儱 儲 儳 儴 儵 儶 儷 儸 儹 儺 儻 儼 儽 儾 儿 
5140 兀 允 兂 元 兄 充 兆 兇 先 光 兊 克 兌 免 兎 兏 
5150 児 兑 兒 兓 兔 兕 兖 兗 兘 兙 党 兛 兜 兝 兞 兟 
5160 兠 兡 兢 兣 兤 入 兦 內 全 兩 兪 八 公 六 兮 兯 
5170 兰 共 兲 关 兴 兵 其 具 典 兹 兺 养 兼 兽 兾 兿 
5180 冀 冁 冂 冃 冄 内 円 冇 冈 冉 冊 冋 册 再 冎 冏 
5190 冐 冑 冒 冓 冔 冕 冖 冗 冘 写 冚 军 农 冝 冞 冟 
51a0 冠 冡 冢 冣 冤 冥 冦 冧 冨 冩 冪 冫 冬 冭 冮 冯 
51b0 冰 冱 冲 决 冴 况 冶 冷 冸 冹 冺 冻 冼 冽 冾 冿 
51c0 净 凁 凂 凃 凄 凅 准 凇 凈 凉 凊 凋 凌 凍 凎 减 


-------------------------------------------------------

5 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------  
51D0 凐 凑 凒 凓 凔 凕 凖 凗 凘 凙 凚 凛 凜 凝 凞 凟  
51E0 几 凡 凢 凣 凤 凥 処 凧 凨 凩 凪 凫 凬 凭 凮 凯  
51F0 凰 凱 凲 凳 凴 凵 凶 凷 凸 凹 出 击 凼 函 凾 凿 
5200 刀 刁 刂 刃 刄 刅 分 切 刈 刉 刊 刋 刌 刍 刎 刏 
5210 刐 刑 划 刓 刔 刕 刖 列 刘 则 刚 创 刜 初 刞 刟 
5220 删 刡 刢 刣 判 別 刦 刧 刨 利 刪 别 刬 刭 刮 刯 
5230 到 刱 刲 刳 刴 刵 制 刷 券 刹 刺 刻 刼 刽 刾 刿 
5240 剀 剁 剂 剃 剄 剅 剆 則 剈 剉 削 剋 剌 前 剎 剏 
5250 剐 剑 剒 剓 剔 剕 剖 剗 剘 剙 剚 剛 剜 剝 剞 剟 
5260 剠 剡 剢 剣 剤 剥 剦 剧 剨 剩 剪 剫 剬 剭 剮 副 
5270 剰 剱 割 剳 剴 創 剶 剷 剸 剹 剺 剻 剼 剽 剾 剿 
5280 劀 劁 劂 劃 劄 劅 劆 劇 劈 劉 劊 劋 劌 劍 劎 劏  
5290 劐 劑 劒 劓 劔 劕 劖 劗 劘 劙 劚 力 劜 劝 办 功 
52A0 加 务 劢 劣 劤 劥 劦 劧 动 助 努 劫 劬 劭 劮 劯  
52B0 劰 励 劲 劳 労 劵 劶 劷 劸 効 劺 劻 劼 劽 劾 势 
52C0 勀 勁 勂 勃 勄 勅 勆 勇 勈 勉 勊 勋 勌 勍 勎 勏  
52D0 勐 勑 勒 勓 勔 動 勖 勗 勘 務 勚 勛 勜 勝 勞 募 
52E0 勠 勡 勢 勣 勤 勥 勦 勧 勨 勩 勪 勫 勬 勭 勮 勯  
52F0 勰 勱 勲 勳 勴 勵 勶 勷 勸 勹 勺 勻 勼 勽 勾 勿 
5300 匀 匁 匂 匃 匄 包 匆 匇 匈 匉 匊 匋 匌 匍 匎 匏  
5310 匐 匑 匒 匓 匔 匕 化 北 匘 匙 匚 匛 匜 匝 匞 匟  


-------------------------------------------------------

6 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5320 匠 匡 匢 匣 匤 匥 匦 匧 匨 匩 匪 匫 匬 匭 匮 匯 
5330 匰 匱 匲 匳 匴 匵 匶 匷 匸 匹 区 医 匼 匽 匾 匿 
5340 區 十 卂 千 卄 卅 卆 升 午 卉 半 卋 卌 卍 华 协 
5350 卐 卑 卒 卓 協 单 卖 南 単 卙 博 卛 卜 卝 卞 卟 
5360 占 卡 卢 卣 卤 卥 卦 卧 卨 卩 卪 卫 卬 卭 卮 卯 
5370 印 危 卲 即 却 卵 卶 卷 卸 卹 卺 卻 卼 卽 卾 卿 
5380 厀 厁 厂 厃 厄 厅 历 厇 厈 厉 厊 压 厌 厍 厎 厏 
5390 厐 厑 厒 厓 厔 厕 厖 厗 厘 厙 厚 厛 厜 厝 厞 原 
53a0 厠 厡 厢 厣 厤 厥 厦 厧 厨 厩 厪 厫 厬 厭 厮 厯 
53b0 厰 厱 厲 厳 厴 厵 厶 厷 厸 厹 厺 去 厼 厽 厾 县 
53c0 叀 叁 参 參 叄 叅 叆 叇 又 叉 及 友 双 反 収 叏 
53d0 叐 发 叒 叓 叔 叕 取 受 变 叙 叚 叛 叜 叝 叞 叟 
53e0 叠 叡 叢 口 古 句 另 叧 叨 叩 只 叫 召 叭 叮 可 
53f0 台 叱 史 右 叴 叵 叶 号 司 叹 叺 叻 叼 叽 叾 叿 
5400 吀 吁 吂 吃 各 吅 吆 吇 合 吉 吊 吋 同 名 后 吏 
5410 吐 向 吒 吓 吔 吕 吖 吗 吘 吙 吚 君 吜 吝 吞 吟 
5420 吠 吡 吢 吣 吤 吥 否 吧 吨 吩 吪 含 听 吭 吮 启 
5430 吰 吱 吲 吳 吴 吵 吶 吷 吸 吹 吺 吻 吼 吽 吾 吿 
5440 呀 呁 呂 呃 呄 呅 呆 呇 呈 呉 告 呋 呌 呍 呎 呏 
5450 呐 呑 呒 呓 呔 呕 呖 呗 员 呙 呚 呛 呜 呝 呞 呟 
5460 呠 呡 呢 呣 呤 呥 呦 呧 周 呩 呪 呫 呬 呭 呮 呯 


-------------------------------------------------------

7 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5470 呰 呱 呲 味 呴 呵 呶 呷 呸 呹 呺 呻 呼 命 呾 呿 
5480 咀 咁 咂 咃 咄 咅 咆 咇 咈 咉 咊 咋 和 咍 咎 咏 
5490 咐 咑 咒 咓 咔 咕 咖 咗 咘 咙 咚 咛 咜 咝 咞 咟 
54a0 咠 咡 咢 咣 咤 咥 咦 咧 咨 咩 咪 咫 咬 咭 咮 咯 
54b0 咰 咱 咲 咳 咴 咵 咶 咷 咸 咹 咺 咻 咼 咽 咾 咿 
54c0 哀 品 哂 哃 哄 哅 哆 哇 哈 哉 哊 哋 哌 响 哎 哏 
54d0 哐 哑 哒 哓 哔 哕 哖 哗 哘 哙 哚 哛 哜 哝 哞 哟 
54e0 哠 員 哢 哣 哤 哥 哦 哧 哨 哩 哪 哫 哬 哭 哮 哯 
54f0 哰 哱 哲 哳 哴 哵 哶 哷 哸 哹 哺 哻 哼 哽 哾 哿 
5500 唀 唁 唂 唃 唄 唅 唆 唇 唈 唉 唊 唋 唌 唍 唎 唏 
5510 唐 唑 唒 唓 唔 唕 唖 唗 唘 唙 唚 唛 唜 唝 唞 唟 
5520 唠 唡 唢 唣 唤 唥 唦 唧 唨 唩 唪 唫 唬 唭 售 唯 
5530 唰 唱 唲 唳 唴 唵 唶 唷 唸 唹 唺 唻 唼 唽 唾 唿 
5540 啀 啁 啂 啃 啄 啅 商 啇 啈 啉 啊 啋 啌 啍 啎 問 
5550 啐 啑 啒 啓 啔 啕 啖 啗 啘 啙 啚 啛 啜 啝 啞 啟 
5560 啠 啡 啢 啣 啤 啥 啦 啧 啨 啩 啪 啫 啬 啭 啮 啯 
5570 啰 啱 啲 啳 啴 啵 啶 啷 啸 啹 啺 啻 啼 啽 啾 啿 
5580 喀 喁 喂 喃 善 喅 喆 喇 喈 喉 喊 喋 喌 喍 喎 喏 
5590 喐 喑 喒 喓 喔 喕 喖 喗 喘 喙 喚 喛 喜 喝 喞 喟 
55a0 喠 喡 喢 喣 喤 喥 喦 喧 喨 喩 喪 喫 喬 喭 單 喯 
55b0 喰 喱 喲 喳 喴 喵 営 喷 喸 喹 喺 喻 喼 喽 喾 喿 


--------------------------------------------------------

8 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
55c0 嗀 嗁 嗂 嗃 嗄 嗅 嗆 嗇 嗈 嗉 嗊 嗋 嗌 嗍 嗎 嗏 
55d0 嗐 嗑 嗒 嗓 嗔 嗕 嗖 嗗 嗘 嗙 嗚 嗛 嗜 嗝 嗞 嗟 
55e0 嗠 嗡 嗢 嗣 嗤 嗥 嗦 嗧 嗨 嗩 嗪 嗫 嗬 嗭 嗮 嗯 
55f0 嗰 嗱 嗲 嗳 嗴 嗵 嗶 嗷 嗸 嗹 嗺 嗻 嗼 嗽 嗾 嗿 
5600 嘀 嘁 嘂 嘃 嘄 嘅 嘆 嘇 嘈 嘉 嘊 嘋 嘌 嘍 嘎 嘏 
5610 嘐 嘑 嘒 嘓 嘔 嘕 嘖 嘗 嘘 嘙 嘚 嘛 嘜 嘝 嘞 嘟 
5620 嘠 嘡 嘢 嘣 嘤 嘥 嘦 嘧 嘨 嘩 嘪 嘫 嘬 嘭 嘮 嘯 
5630 嘰 嘱 嘲 嘳 嘴 嘵 嘶 嘷 嘸 嘹 嘺 嘻 嘼 嘽 嘾 嘿 
5640 噀 噁 噂 噃 噄 噅 噆 噇 噈 噉 噊 噋 噌 噍 噎 噏 
5650 噐 噑 噒 噓 噔 噕 噖 噗 噘 噙 噚 噛 噜 噝 噞 噟 
5660 噠 噡 噢 噣 噤 噥 噦 噧 器 噩 噪 噫 噬 噭 噮 噯 
5670 噰 噱 噲 噳 噴 噵 噶 噷 噸 噹 噺 噻 噼 噽 噾 噿 
5680 嚀 嚁 嚂 嚃 嚄 嚅 嚆 嚇 嚈 嚉 嚊 嚋 嚌 嚍 嚎 嚏 
5690 嚐 嚑 嚒 嚓 嚔 嚕 嚖 嚗 嚘 嚙 嚚 嚛 嚜 嚝 嚞 嚟 
56a0 嚠 嚡 嚢 嚣 嚤 嚥 嚦 嚧 嚨 嚩 嚪 嚫 嚬 嚭 嚮 嚯 
56b0 嚰 嚱 嚲 嚳 嚴 嚵 嚶 嚷 嚸 嚹 嚺 嚻 嚼 嚽 嚾 嚿 
56c0 囀 囁 囂 囃 囄 囅 囆 囇 囈 囉 囊 囋 囌 囍 囎 囏 
56d0 囐 囑 囒 囓 囔 囕 囖 囗 囘 囙 囚 四 囜 囝 回 囟 
56e0 因 囡 团 団 囤 囥 囦 囧 囨 囩 囪 囫 囬 园 囮 囯 
56f0 困 囱 囲 図 围 囵 囶 囷 囸 囹 固 囻 囼 国 图 囿 
5700 圀 圁 圂 圃 圄 圅 圆 圇 圈 圉 圊 國 圌 圍 圎 圏 


--------------------------------------------------------

9 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5710 圐 圑 園 圓 圔 圕 圖 圗 團 圙 圚 圛 圜 圝 圞 土 
5720 圠 圡 圢 圣 圤 圥 圦 圧 在 圩 圪 圫 圬 圭 圮 圯 
5730 地 圱 圲 圳 圴 圵 圶 圷 圸 圹 场 圻 圼 圽 圾 圿 
5740 址 坁 坂 坃 坄 坅 坆 均 坈 坉 坊 坋 坌 坍 坎 坏 
5750 坐 坑 坒 坓 坔 坕 坖 块 坘 坙 坚 坛 坜 坝 坞 坟 
5760 坠 坡 坢 坣 坤 坥 坦 坧 坨 坩 坪 坫 坬 坭 坮 坯 
5770 坰 坱 坲 坳 坴 坵 坶 坷 坸 坹 坺 坻 坼 坽 坾 坿 
5780 垀 垁 垂 垃 垄 垅 垆 垇 垈 垉 垊 型 垌 垍 垎 垏 
5790 垐 垑 垒 垓 垔 垕 垖 垗 垘 垙 垚 垛 垜 垝 垞 垟 
57a0 垠 垡 垢 垣 垤 垥 垦 垧 垨 垩 垪 垫 垬 垭 垮 垯 
57b0 垰 垱 垲 垳 垴 垵 垶 垷 垸 垹 垺 垻 垼 垽 垾 垿 
57c0 埀 埁 埂 埃 埄 埅 埆 埇 埈 埉 埊 埋 埌 埍 城 埏 
57d0 埐 埑 埒 埓 埔 埕 埖 埗 埘 埙 埚 埛 埜 埝 埞 域 
57e0 埠 埡 埢 埣 埤 埥 埦 埧 埨 埩 埪 埫 埬 埭 埮 埯 
57f0 埰 埱 埲 埳 埴 埵 埶 執 埸 培 基 埻 埼 埽 埾 埿 
5800 堀 堁 堂 堃 堄 堅 堆 堇 堈 堉 堊 堋 堌 堍 堎 堏 
5810 堐 堑 堒 堓 堔 堕 堖 堗 堘 堙 堚 堛 堜 堝 堞 堟 
5820 堠 堡 堢 堣 堤 堥 堦 堧 堨 堩 堪 堫 堬 堭 堮 堯 
5830 堰 報 堲 堳 場 堵 堶 堷 堸 堹 堺 堻 堼 堽 堾 堿 
5840 塀 塁 塂 塃 塄 塅 塆 塇 塈 塉 塊 塋 塌 塍 塎 塏 
5850 塐 塑 塒 塓 塔 塕 塖 塗 塘 塙 塚 塛 塜 塝 塞 塟 


--------------------------------------------------------

10 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5860 塠 塡 塢 塣 塤 塥 塦 塧 塨 塩 塪 填 塬 塭 塮 塯 
5870 塰 塱 塲 塳 塴 塵 塶 塷 塸 塹 塺 塻 塼 塽 塾 塿 
5880 墀 墁 墂 境 墄 墅 墆 墇 墈 墉 墊 墋 墌 墍 墎 墏 
5890 墐 墑 墒 墓 墔 墕 墖 増 墘 墙 墚 墛 墜 墝 增 墟 
58a0 墠 墡 墢 墣 墤 墥 墦 墧 墨 墩 墪 墫 墬 墭 墮 墯 
58b0 墰 墱 墲 墳 墴 墵 墶 墷 墸 墹 墺 墻 墼 墽 墾 墿 
58c0 壀 壁 壂 壃 壄 壅 壆 壇 壈 壉 壊 壋 壌 壍 壎 壏 
58d0 壐 壑 壒 壓 壔 壕 壖 壗 壘 壙 壚 壛 壜 壝 壞 壟 
58e0 壠 壡 壢 壣 壤 壥 壦 壧 壨 壩 壪 士 壬 壭 壮 壯 
58f0 声 壱 売 壳 壴 壵 壶 壷 壸 壹 壺 壻 壼 壽 壾 壿 
5900 夀 夁 夂 夃 处 夅 夆 备 夈 変 夊 夋 夌 复 夎 夏 
5910 夐 夑 夒 夓 夔 夕 外 夗 夘 夙 多 夛 夜 夝 夞 够 
5920 夠 夡 夢 夣 夤 夥 夦 大 夨 天 太 夫 夬 夭 央 夯 
5930 夰 失 夲 夳 头 夵 夶 夷 夸 夹 夺 夻 夼 夽 夾 夿 
5940 奀 奁 奂 奃 奄 奅 奆 奇 奈 奉 奊 奋 奌 奍 奎 奏 
5950 奐 契 奒 奓 奔 奕 奖 套 奘 奙 奚 奛 奜 奝 奞 奟 
5960 奠 奡 奢 奣 奤 奥 奦 奧 奨 奩 奪 奫 奬 奭 奮 奯 
5970 奰 奱 奲 女 奴 奵 奶 奷 奸 她 奺 奻 奼 好 奾 奿 
5980 妀 妁 如 妃 妄 妅 妆 妇 妈 妉 妊 妋 妌 妍 妎 妏 
5990 妐 妑 妒 妓 妔 妕 妖 妗 妘 妙 妚 妛 妜 妝 妞 妟 
59a0 妠 妡 妢 妣 妤 妥 妦 妧 妨 妩 妪 妫 妬 妭 妮 妯 


--------------------------------------------------------


11 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
59b0 妰 妱 妲 妳 妴 妵 妶 妷 妸 妹 妺 妻 妼 妽 妾 妿 
59c0 姀 姁 姂 姃 姄 姅 姆 姇 姈 姉 姊 始 姌 姍 姎 姏 
59d0 姐 姑 姒 姓 委 姕 姖 姗 姘 姙 姚 姛 姜 姝 姞 姟 
59e0 姠 姡 姢 姣 姤 姥 姦 姧 姨 姩 姪 姫 姬 姭 姮 姯 
59f0 姰 姱 姲 姳 姴 姵 姶 姷 姸 姹 姺 姻 姼 姽 姾 姿 
5a00 娀 威 娂 娃 娄 娅 娆 娇 娈 娉 娊 娋 娌 娍 娎 娏 
5a10 娐 娑 娒 娓 娔 娕 娖 娗 娘 娙 娚 娛 娜 娝 娞 娟 
5a20 娠 娡 娢 娣 娤 娥 娦 娧 娨 娩 娪 娫 娬 娭 娮 娯 
5a30 娰 娱 娲 娳 娴 娵 娶 娷 娸 娹 娺 娻 娼 娽 娾 娿 
5a40 婀 婁 婂 婃 婄 婅 婆 婇 婈 婉 婊 婋 婌 婍 婎 婏 
5a50 婐 婑 婒 婓 婔 婕 婖 婗 婘 婙 婚 婛 婜 婝 婞 婟 
5a60 婠 婡 婢 婣 婤 婥 婦 婧 婨 婩 婪 婫 婬 婭 婮 婯 
5a70 婰 婱 婲 婳 婴 婵 婶 婷 婸 婹 婺 婻 婼 婽 婾 婿 
5a80 媀 媁 媂 媃 媄 媅 媆 媇 媈 媉 媊 媋 媌 媍 媎 媏 
5a90 媐 媑 媒 媓 媔 媕 媖 媗 媘 媙 媚 媛 媜 媝 媞 媟 
5aa0 媠 媡 媢 媣 媤 媥 媦 媧 媨 媩 媪 媫 媬 媭 媮 媯 
5ab0 媰 媱 媲 媳 媴 媵 媶 媷 媸 媹 媺 媻 媼 媽 媾 媿 
5ac0 嫀 嫁 嫂 嫃 嫄 嫅 嫆 嫇 嫈 嫉 嫊 嫋 嫌 嫍 嫎 嫏 
5ad0 嫐 嫑 嫒 嫓 嫔 嫕 嫖 嫗 嫘 嫙 嫚 嫛 嫜 嫝 嫞 嫟 
5ae0 嫠 嫡 嫢 嫣 嫤 嫥 嫦 嫧 嫨 嫩 嫪 嫫 嫬 嫭 嫮 嫯 
5af0 嫰 嫱 嫲 嫳 嫴 嫵 嫶 嫷 嫸 嫹 嫺 嫻 嫼 嫽 嫾 嫿 


-----------------------------------------------------

12 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5b00 嬀 嬁 嬂 嬃 嬄 嬅 嬆 嬇 嬈 嬉 嬊 嬋 嬌 嬍 嬎 嬏 
5b10 嬐 嬑 嬒 嬓 嬔 嬕 嬖 嬗 嬘 嬙 嬚 嬛 嬜 嬝 嬞 嬟 
5b20 嬠 嬡 嬢 嬣 嬤 嬥 嬦 嬧 嬨 嬩 嬪 嬫 嬬 嬭 嬮 嬯 
5b30 嬰 嬱 嬲 嬳 嬴 嬵 嬶 嬷 嬸 嬹 嬺 嬻 嬼 嬽 嬾 嬿 
5b40 孀 孁 孂 孃 孄 孅 孆 孇 孈 孉 孊 孋 孌 孍 孎 孏 
5b50 子 孑 孒 孓 孔 孕 孖 字 存 孙 孚 孛 孜 孝 孞 孟 
5b60 孠 孡 孢 季 孤 孥 学 孧 孨 孩 孪 孫 孬 孭 孮 孯 
5b70 孰 孱 孲 孳 孴 孵 孶 孷 學 孹 孺 孻 孼 孽 孾 孿 
5b80 宀 宁 宂 它 宄 宅 宆 宇 守 安 宊 宋 完 宍 宎 宏 
5b90 宐 宑 宒 宓 宔 宕 宖 宗 官 宙 定 宛 宜 宝 实 実 
5ba0 宠 审 客 宣 室 宥 宦 宧 宨 宩 宪 宫 宬 宭 宮 宯 
5bb0 宰 宱 宲 害 宴 宵 家 宷 宸 容 宺 宻 宼 宽 宾 宿 
5bc0 寀 寁 寂 寃 寄 寅 密 寇 寈 寉 寊 寋 富 寍 寎 寏 
5bd0 寐 寑 寒 寓 寔 寕 寖 寗 寘 寙 寚 寛 寜 寝 寞 察 
5be0 寠 寡 寢 寣 寤 寥 實 寧 寨 審 寪 寫 寬 寭 寮 寯 
5bf0 寰 寱 寲 寳 寴 寵 寶 寷 寸 对 寺 寻 导 寽 対 寿 
5c00 尀 封 専 尃 射 尅 将 將 專 尉 尊 尋 尌 對 導 小 
5c10 尐 少 尒 尓 尔 尕 尖 尗 尘 尙 尚 尛 尜 尝 尞 尟 
5c20 尠 尡 尢 尣 尤 尥 尦 尧 尨 尩 尪 尫 尬 尭 尮 尯 
5c30 尰 就 尲 尳 尴 尵 尶 尷 尸 尹 尺 尻 尼 尽 尾 尿 
5c40 局 屁 层 屃 屄 居 屆 屇 屈 屉 届 屋 屌 屍 屎 屏 


------------------------------------------------------

13 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5c50 屐 屑 屒 屓 屔 展 屖 屗 屘 屙 屚 屛 屜 屝 属 屟 
5c60 屠 屡 屢 屣 層 履 屦 屧 屨 屩 屪 屫 屬 屭 屮 屯 
5c70 屰 山 屲 屳 屴 屵 屶 屷 屸 屹 屺 屻 屼 屽 屾 屿 
5c80 岀 岁 岂 岃 岄 岅 岆 岇 岈 岉 岊 岋 岌 岍 岎 岏 
5c90 岐 岑 岒 岓 岔 岕 岖 岗 岘 岙 岚 岛 岜 岝 岞 岟 
5ca0 岠 岡 岢 岣 岤 岥 岦 岧 岨 岩 岪 岫 岬 岭 岮 岯 
5cb0 岰 岱 岲 岳 岴 岵 岶 岷 岸 岹 岺 岻 岼 岽 岾 岿 
5cc0 峀 峁 峂 峃 峄 峅 峆 峇 峈 峉 峊 峋 峌 峍 峎 峏 
5cd0 峐 峑 峒 峓 峔 峕 峖 峗 峘 峙 峚 峛 峜 峝 峞 峟 
5ce0 峠 峡 峢 峣 峤 峥 峦 峧 峨 峩 峪 峫 峬 峭 峮 峯 
5cf0 峰 峱 峲 峳 峴 峵 島 峷 峸 峹 峺 峻 峼 峽 峾 峿 
5d00 崀 崁 崂 崃 崄 崅 崆 崇 崈 崉 崊 崋 崌 崍 崎 崏 
5d10 崐 崑 崒 崓 崔 崕 崖 崗 崘 崙 崚 崛 崜 崝 崞 崟 
5d20 崠 崡 崢 崣 崤 崥 崦 崧 崨 崩 崪 崫 崬 崭 崮 崯 
5d30 崰 崱 崲 崳 崴 崵 崶 崷 崸 崹 崺 崻 崼 崽 崾 崿 
5d40 嵀 嵁 嵂 嵃 嵄 嵅 嵆 嵇 嵈 嵉 嵊 嵋 嵌 嵍 嵎 嵏 
5d50 嵐 嵑 嵒 嵓 嵔 嵕 嵖 嵗 嵘 嵙 嵚 嵛 嵜 嵝 嵞 嵟 
5d60 嵠 嵡 嵢 嵣 嵤 嵥 嵦 嵧 嵨 嵩 嵪 嵫 嵬 嵭 嵮 嵯 
5d70 嵰 嵱 嵲 嵳 嵴 嵵 嵶 嵷 嵸 嵹 嵺 嵻 嵼 嵽 嵾 嵿 
5d80 嶀 嶁 嶂 嶃 嶄 嶅 嶆 嶇 嶈 嶉 嶊 嶋 嶌 嶍 嶎 嶏 
5d90 嶐 嶑 嶒 嶓 嶔 嶕 嶖 嶗 嶘 嶙 嶚 嶛 嶜 嶝 嶞 嶟 


------------------------------------------------------

14 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5da0 嶠 嶡 嶢 嶣 嶤 嶥 嶦 嶧 嶨 嶩 嶪 嶫 嶬 嶭 嶮 嶯 
5db0 嶰 嶱 嶲 嶳 嶴 嶵 嶶 嶷 嶸 嶹 嶺 嶻 嶼 嶽 嶾 嶿 
5dc0 巀 巁 巂 巃 巄 巅 巆 巇 巈 巉 巊 巋 巌 巍 巎 巏 
5dd0 巐 巑 巒 巓 巔 巕 巖 巗 巘 巙 巚 巛 巜 川 州 巟 
5de0 巠 巡 巢 巣 巤 工 左 巧 巨 巩 巪 巫 巬 巭 差 巯 
5df0 巰 己 已 巳 巴 巵 巶 巷 巸 巹 巺 巻 巼 巽 巾 巿 
5e00 帀 币 市 布 帄 帅 帆 帇 师 帉 帊 帋 希 帍 帎 帏 
5e10 帐 帑 帒 帓 帔 帕 帖 帗 帘 帙 帚 帛 帜 帝 帞 帟 
5e20 帠 帡 帢 帣 帤 帥 带 帧 帨 帩 帪 師 帬 席 帮 帯 
5e30 帰 帱 帲 帳 帴 帵 帶 帷 常 帹 帺 帻 帼 帽 帾 帿 
5e40 幀 幁 幂 幃 幄 幅 幆 幇 幈 幉 幊 幋 幌 幍 幎 幏 
5e50 幐 幑 幒 幓 幔 幕 幖 幗 幘 幙 幚 幛 幜 幝 幞 幟 
5e60 幠 幡 幢 幣 幤 幥 幦 幧 幨 幩 幪 幫 幬 幭 幮 幯 
5e70 幰 幱 干 平 年 幵 并 幷 幸 幹 幺 幻 幼 幽 幾 广 
5e80 庀 庁 庂 広 庄 庅 庆 庇 庈 庉 床 庋 庌 庍 庎 序 
5e90 庐 庑 庒 库 应 底 庖 店 庘 庙 庚 庛 府 庝 庞 废 
5ea0 庠 庡 庢 庣 庤 庥 度 座 庨 庩 庪 庫 庬 庭 庮 庯 
5eb0 庰 庱 庲 庳 庴 庵 庶 康 庸 庹 庺 庻 庼 庽 庾 庿 
5ec0 廀 廁 廂 廃 廄 廅 廆 廇 廈 廉 廊 廋 廌 廍 廎 廏 
5ed0 廐 廑 廒 廓 廔 廕 廖 廗 廘 廙 廚 廛 廜 廝 廞 廟 
5ee0 廠 廡 廢 廣 廤 廥 廦 廧 廨 廩 廪 廫 廬 廭 廮 廯 


------------------------------------------------------

15 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
5ef0 廰 廱 廲 廳 廴 廵 延 廷 廸 廹 建 廻 廼 廽 廾 廿 
5f00 开 弁 异 弃 弄 弅 弆 弇 弈 弉 弊 弋 弌 弍 弎 式 
5f10 弐 弑 弒 弓 弔 引 弖 弗 弘 弙 弚 弛 弜 弝 弞 弟 
5f20 张 弡 弢 弣 弤 弥 弦 弧 弨 弩 弪 弫 弬 弭 弮 弯 
5f30 弰 弱 弲 弳 弴 張 弶 強 弸 弹 强 弻 弼 弽 弾 弿 
5f40 彀 彁 彂 彃 彄 彅 彆 彇 彈 彉 彊 彋 彌 彍 彎 彏 
5f50 彐 彑 归 当 彔 录 彖 彗 彘 彙 彚 彛 彜 彝 彞 彟 
5f60 彠 彡 形 彣 彤 彥 彦 彧 彨 彩 彪 彫 彬 彭 彮 彯 
5f70 彰 影 彲 彳 彴 彵 彶 彷 彸 役 彺 彻 彼 彽 彾 彿 
5f80 往 征 徂 徃 径 待 徆 徇 很 徉 徊 律 後 徍 徎 徏 
5f90 徐 徑 徒 従 徔 徕 徖 得 徘 徙 徚 徛 徜 徝 從 徟 
5fa0 徠 御 徢 徣 徤 徥 徦 徧 徨 復 循 徫 徬 徭 微 徯 
5fb0 徰 徱 徲 徳 徴 徵 徶 德 徸 徹 徺 徻 徼 徽 徾 徿 
5fc0 忀 忁 忂 心 忄 必 忆 忇 忈 忉 忊 忋 忌 忍 忎 忏 
5fd0 忐 忑 忒 忓 忔 忕 忖 志 忘 忙 忚 忛 応 忝 忞 忟 
5fe0 忠 忡 忢 忣 忤 忥 忦 忧 忨 忩 忪 快 忬 忭 忮 忯 
5ff0 忰 忱 忲 忳 忴 念 忶 忷 忸 忹 忺 忻 忼 忽 忾 忿 
6000 怀 态 怂 怃 怄 怅 怆 怇 怈 怉 怊 怋 怌 怍 怎 怏 
6010 怐 怑 怒 怓 怔 怕 怖 怗 怘 怙 怚 怛 怜 思 怞 怟 
6020 怠 怡 怢 怣 怤 急 怦 性 怨 怩 怪 怫 怬 怭 怮 怯 
6030 怰 怱 怲 怳 怴 怵 怶 怷 怸 怹 怺 总 怼 怽 怾 怿 
6040 恀 恁 恂 恃 恄 恅 恆 恇 恈 恉 恊 恋 恌 恍 恎 恏 
6050 恐 恑 恒 恓 恔 恕 恖 恗 恘 恙 恚 恛 恜 恝 恞 恟 
6060 恠 恡 恢 恣 恤 恥 恦 恧 恨 恩 恪 恫 恬 恭 恮 息 
6070 恰 恱 恲 恳 恴 恵 恶 恷 恸 恹 恺 恻 恼 恽 恾 恿  


-------------------------------------------------------

16 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6080 悀 悁 悂 悃 悄 悅 悆 悇 悈 悉 悊 悋 悌 悍 悎 悏 
6090 悐 悑 悒 悓 悔 悕 悖 悗 悘 悙 悚 悛 悜 悝 悞 悟 
60a0 悠 悡 悢 患 悤 悥 悦 悧 您 悩 悪 悫 悬 悭 悮 悯 
60b0 悰 悱 悲 悳 悴 悵 悶 悷 悸 悹 悺 悻 悼 悽 悾 悿 
60c0 惀 惁 惂 惃 惄 情 惆 惇 惈 惉 惊 惋 惌 惍 惎 惏 
60d0 惐 惑 惒 惓 惔 惕 惖 惗 惘 惙 惚 惛 惜 惝 惞 惟 
60e0 惠 惡 惢 惣 惤 惥 惦 惧 惨 惩 惪 惫 惬 惭 惮 惯 
60f0 惰 惱 惲 想 惴 惵 惶 惷 惸 惹 惺 惻 惼 惽 惾 惿 
6100 愀 愁 愂 愃 愄 愅 愆 愇 愈 愉 愊 愋 愌 愍 愎 意 
6110 愐 愑 愒 愓 愔 愕 愖 愗 愘 愙 愚 愛 愜 愝 愞 感 
6120 愠 愡 愢 愣 愤 愥 愦 愧 愨 愩 愪 愫 愬 愭 愮 愯 
6130 愰 愱 愲 愳 愴 愵 愶 愷 愸 愹 愺 愻 愼 愽 愾 愿 
6140 慀 慁 慂 慃 慄 慅 慆 慇 慈 慉 慊 態 慌 慍 慎 慏 
6150 慐 慑 慒 慓 慔 慕 慖 慗 慘 慙 慚 慛 慜 慝 慞 慟 
6160 慠 慡 慢 慣 慤 慥 慦 慧 慨 慩 慪 慫 慬 慭 慮 慯 
6170 慰 慱 慲 慳 慴 慵 慶 慷 慸 慹 慺 慻 慼 慽 慾 慿 
6180 憀 憁 憂 憃 憄 憅 憆 憇 憈 憉 憊 憋 憌 憍 憎 憏 
6190 憐 憑 憒 憓 憔 憕 憖 憗 憘 憙 憚 憛 憜 憝 憞 憟 
61a0 憠 憡 憢 憣 憤 憥 憦 憧 憨 憩 憪 憫 憬 憭 憮 憯 
61b0 憰 憱 憲 憳 憴 憵 憶 憷 憸 憹 憺 憻 憼 憽 憾 憿 
61c0 懀 懁 懂 懃 懄 懅 懆 懇 懈 應 懊 懋 懌 懍 懎 懏 


--------------------------------------------------------------------------------

17 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
61d0 懐 懑 懒 懓 懔 懕 懖 懗 懘 懙 懚 懛 懜 懝 懞 懟 
61e0 懠 懡 懢 懣 懤 懥 懦 懧 懨 懩 懪 懫 懬 懭 懮 懯 
61f0 懰 懱 懲 懳 懴 懵 懶 懷 懸 懹 懺 懻 懼 懽 懾 懿 
6200 戀 戁 戂 戃 戄 戅 戆 戇 戈 戉 戊 戋 戌 戍 戎 戏 
6210 成 我 戒 戓 戔 戕 或 戗 战 戙 戚 戛 戜 戝 戞 戟 
6220 戠 戡 戢 戣 戤 戥 戦 戧 戨 戩 截 戫 戬 戭 戮 戯 
6230 戰 戱 戲 戳 戴 戵 戶 户 戸 戹 戺 戻 戼 戽 戾 房 
6240 所 扁 扂 扃 扄 扅 扆 扇 扈 扉 扊 手 扌 才 扎 扏 
6250 扐 扑 扒 打 扔 払 扖 扗 托 扙 扚 扛 扜 扝 扞 扟 
6260 扠 扡 扢 扣 扤 扥 扦 执 扨 扩 扪 扫 扬 扭 扮 扯 
6270 扰 扱 扲 扳 扴 扵 扶 扷 扸 批 扺 扻 扼 扽 找 承 
6280 技 抁 抂 抃 抄 抅 抆 抇 抈 抉 把 抋 抌 抍 抎 抏 
6290 抐 抑 抒 抓 抔 投 抖 抗 折 抙 抚 抛 抜 抝 択 抟 
62a0 抠 抡 抢 抣 护 报 抦 抧 抨 抩 抪 披 抬 抭 抮 抯 
62b0 抰 抱 抲 抳 抴 抵 抶 抷 抸 抹 抺 抻 押 抽 抾 抿 
62c0 拀 拁 拂 拃 拄 担 拆 拇 拈 拉 拊 拋 拌 拍 拎 拏 
62d0 拐 拑 拒 拓 拔 拕 拖 拗 拘 拙 拚 招 拜 拝 拞 拟 
62e0 拠 拡 拢 拣 拤 拥 拦 拧 拨 择 拪 拫 括 拭 拮 拯 
62f0 拰 拱 拲 拳 拴 拵 拶 拷 拸 拹 拺 拻 拼 拽 拾 拿 
6300 挀 持 挂 挃 挄 挅 挆 指 挈 按 挊 挋 挌 挍 挎 挏 
6310 挐 挑 挒 挓 挔 挕 挖 挗 挘 挙 挚 挛 挜 挝 挞 挟 


------------------------------------------------------

18 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6320 挠 挡 挢 挣 挤 挥 挦 挧 挨 挩 挪 挫 挬 挭 挮 振 
6330 挰 挱 挲 挳 挴 挵 挶 挷 挸 挹 挺 挻 挼 挽 挾 挿 
6340 捀 捁 捂 捃 捄 捅 捆 捇 捈 捉 捊 捋 捌 捍 捎 捏 
6350 捐 捑 捒 捓 捔 捕 捖 捗 捘 捙 捚 捛 捜 捝 捞 损 
6360 捠 捡 换 捣 捤 捥 捦 捧 捨 捩 捪 捫 捬 捭 据 捯 
6370 捰 捱 捲 捳 捴 捵 捶 捷 捸 捹 捺 捻 捼 捽 捾 捿 
6380 掀 掁 掂 掃 掄 掅 掆 掇 授 掉 掊 掋 掌 掍 掎 掏 
6390 掐 掑 排 掓 掔 掕 掖 掗 掘 掙 掚 掛 掜 掝 掞 掟 
63a0 掠 採 探 掣 掤 接 掦 控 推 掩 措 掫 掬 掭 掮 掯 
63b0 掰 掱 掲 掳 掴 掵 掶 掷 掸 掹 掺 掻 掼 掽 掾 掿 
63c0 揀 揁 揂 揃 揄 揅 揆 揇 揈 揉 揊 揋 揌 揍 揎 描 
63d0 提 揑 插 揓 揔 揕 揖 揗 揘 揙 揚 換 揜 揝 揞 揟 
63e0 揠 握 揢 揣 揤 揥 揦 揧 揨 揩 揪 揫 揬 揭 揮 揯 
63f0 揰 揱 揲 揳 援 揵 揶 揷 揸 揹 揺 揻 揼 揽 揾 揿 
6400 搀 搁 搂 搃 搄 搅 搆 搇 搈 搉 搊 搋 搌 損 搎 搏 
6410 搐 搑 搒 搓 搔 搕 搖 搗 搘 搙 搚 搛 搜 搝 搞 搟 
6420 搠 搡 搢 搣 搤 搥 搦 搧 搨 搩 搪 搫 搬 搭 搮 搯 
6430 搰 搱 搲 搳 搴 搵 搶 搷 搸 搹 携 搻 搼 搽 搾 搿 
6440 摀 摁 摂 摃 摄 摅 摆 摇 摈 摉 摊 摋 摌 摍 摎 摏 
6450 摐 摑 摒 摓 摔 摕 摖 摗 摘 摙 摚 摛 摜 摝 摞 摟 
6460 摠 摡 摢 摣 摤 摥 摦 摧 摨 摩 摪 摫 摬 摭 摮 摯 


-------------------------------------------------------

19 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6470 摰 摱 摲 摳 摴 摵 摶 摷 摸 摹 摺 摻 摼 摽 摾 摿 
6480 撀 撁 撂 撃 撄 撅 撆 撇 撈 撉 撊 撋 撌 撍 撎 撏 
6490 撐 撑 撒 撓 撔 撕 撖 撗 撘 撙 撚 撛 撜 撝 撞 撟 
64a0 撠 撡 撢 撣 撤 撥 撦 撧 撨 撩 撪 撫 撬 播 撮 撯 
64b0 撰 撱 撲 撳 撴 撵 撶 撷 撸 撹 撺 撻 撼 撽 撾 撿 
64c0 擀 擁 擂 擃 擄 擅 擆 擇 擈 擉 擊 擋 擌 操 擎 擏 
64d0 擐 擑 擒 擓 擔 擕 擖 擗 擘 擙 據 擛 擜 擝 擞 擟 
64e0 擠 擡 擢 擣 擤 擥 擦 擧 擨 擩 擪 擫 擬 擭 擮 擯 
64f0 擰 擱 擲 擳 擴 擵 擶 擷 擸 擹 擺 擻 擼 擽 擾 擿 
6500 攀 攁 攂 攃 攄 攅 攆 攇 攈 攉 攊 攋 攌 攍 攎 攏 
6510 攐 攑 攒 攓 攔 攕 攖 攗 攘 攙 攚 攛 攜 攝 攞 攟 
6520 攠 攡 攢 攣 攤 攥 攦 攧 攨 攩 攪 攫 攬 攭 攮 支 
6530 攰 攱 攲 攳 攴 攵 收 攷 攸 改 攺 攻 攼 攽 放 政 
6540 敀 敁 敂 敃 敄 故 敆 敇 效 敉 敊 敋 敌 敍 敎 敏 
6550 敐 救 敒 敓 敔 敕 敖 敗 敘 教 敚 敛 敜 敝 敞 敟 
6560 敠 敡 敢 散 敤 敥 敦 敧 敨 敩 敪 敫 敬 敭 敮 敯 
6570 数 敱 敲 敳 整 敵 敶 敷 數 敹 敺 敻 敼 敽 敾 敿 
6580 斀 斁 斂 斃 斄 斅 斆 文 斈 斉 斊 斋 斌 斍 斎 斏 
6590 斐 斑 斒 斓 斔 斕 斖 斗 斘 料 斚 斛 斜 斝 斞 斟 
65a0 斠 斡 斢 斣 斤 斥 斦 斧 斨 斩 斪 斫 斬 断 斮 斯 
65b0 新 斱 斲 斳 斴 斵 斶 斷 斸 方 斺 斻 於 施 斾 斿 


-------------------------------------------------------

20 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------  
65c0 旀 旁 旂 旃 旄 旅 旆 旇 旈 旉 旊 旋 旌 旍 旎 族 
65d0 旐 旑 旒 旓 旔 旕 旖 旗 旘 旙 旚 旛 旜 旝 旞 旟 
65e0 无 旡 既 旣 旤 日 旦 旧 旨 早 旪 旫 旬 旭 旮 旯 
65f0 旰 旱 旲 旳 旴 旵 时 旷 旸 旹 旺 旻 旼 旽 旾 旿 
6600 昀 昁 昂 昃 昄 昅 昆 昇 昈 昉 昊 昋 昌 昍 明 昏 
6610 昐 昑 昒 易 昔 昕 昖 昗 昘 昙 昚 昛 昜 昝 昞 星 
6620 映 昡 昢 昣 昤 春 昦 昧 昨 昩 昪 昫 昬 昭 昮 是 
6630 昰 昱 昲 昳 昴 昵 昶 昷 昸 昹 昺 昻 昼 昽 显 昿 
6640 晀 晁 時 晃 晄 晅 晆 晇 晈 晉 晊 晋 晌 晍 晎 晏 
6650 晐 晑 晒 晓 晔 晕 晖 晗 晘 晙 晚 晛 晜 晝 晞 晟 
6660 晠 晡 晢 晣 晤 晥 晦 晧 晨 晩 晪 晫 晬 晭 普 景 
6670 晰 晱 晲 晳 晴 晵 晶 晷 晸 晹 智 晻 晼 晽 晾 晿 
6680 暀 暁 暂 暃 暄 暅 暆 暇 暈 暉 暊 暋 暌 暍 暎 暏 
6690 暐 暑 暒 暓 暔 暕 暖 暗 暘 暙 暚 暛 暜 暝 暞 暟 
66a0 暠 暡 暢 暣 暤 暥 暦 暧 暨 暩 暪 暫 暬 暭 暮 暯 
66b0 暰 暱 暲 暳 暴 暵 暶 暷 暸 暹 暺 暻 暼 暽 暾 暿 
66c0 曀 曁 曂 曃 曄 曅 曆 曇 曈 曉 曊 曋 曌 曍 曎 曏 
66d0 曐 曑 曒 曓 曔 曕 曖 曗 曘 曙 曚 曛 曜 曝 曞 曟 
66e0 曠 曡 曢 曣 曤 曥 曦 曧 曨 曩 曪 曫 曬 曭 曮 曯 
66f0 曰 曱 曲 曳 更 曵 曶 曷 書 曹 曺 曻 曼 曽 曾 替 
6700 最 朁 朂 會 朄 朅 朆 朇 月 有 朊 朋 朌 服 朎 朏 


-------------------------------------------------------


21 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6710 朐 朑 朒 朓 朔 朕 朖 朗 朘 朙 朚 望 朜 朝 朞 期 
6720 朠 朡 朢 朣 朤 朥 朦 朧 木 朩 未 末 本 札 朮 术 
6730 朰 朱 朲 朳 朴 朵 朶 朷 朸 朹 机 朻 朼 朽 朾 朿 
6740 杀 杁 杂 权 杄 杅 杆 杇 杈 杉 杊 杋 杌 杍 李 杏 
6750 材 村 杒 杓 杔 杕 杖 杗 杘 杙 杚 杛 杜 杝 杞 束 
6760 杠 条 杢 杣 杤 来 杦 杧 杨 杩 杪 杫 杬 杭 杮 杯 
6770 杰 東 杲 杳 杴 杵 杶 杷 杸 杹 杺 杻 杼 杽 松 板 
6780 枀 极 枂 枃 构 枅 枆 枇 枈 枉 枊 枋 枌 枍 枎 枏 
6790 析 枑 枒 枓 枔 枕 枖 林 枘 枙 枚 枛 果 枝 枞 枟 
67a0 枠 枡 枢 枣 枤 枥 枦 枧 枨 枩 枪 枫 枬 枭 枮 枯 
67b0 枰 枱 枲 枳 枴 枵 架 枷 枸 枹 枺 枻 枼 枽 枾 枿 
67c0 柀 柁 柂 柃 柄 柅 柆 柇 柈 柉 柊 柋 柌 柍 柎 柏 
67d0 某 柑 柒 染 柔 柕 柖 柗 柘 柙 柚 柛 柜 柝 柞 柟 
67e0 柠 柡 柢 柣 柤 查 柦 柧 柨 柩 柪 柫 柬 柭 柮 柯 
67f0 柰 柱 柲 柳 柴 柵 柶 柷 柸 柹 柺 査 柼 柽 柾 柿 
6800 栀 栁 栂 栃 栄 栅 栆 标 栈 栉 栊 栋 栌 栍 栎 栏 
6810 栐 树 栒 栓 栔 栕 栖 栗 栘 栙 栚 栛 栜 栝 栞 栟 
6820 栠 校 栢 栣 栤 栥 栦 栧 栨 栩 株 栫 栬 栭 栮 栯 
6830 栰 栱 栲 栳 栴 栵 栶 样 核 根 栺 栻 格 栽 栾 栿 
6840 桀 桁 桂 桃 桄 桅 框 桇 案 桉 桊 桋 桌 桍 桎 桏 
6850 桐 桑 桒 桓 桔 桕 桖 桗 桘 桙 桚 桛 桜 桝 桞 桟 


-------------------------------------------------------

22 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6860 桠 桡 桢 档 桤 桥 桦 桧 桨 桩 桪 桫 桬 桭 桮 桯 
6870 桰 桱 桲 桳 桴 桵 桶 桷 桸 桹 桺 桻 桼 桽 桾 桿 
6880 梀 梁 梂 梃 梄 梅 梆 梇 梈 梉 梊 梋 梌 梍 梎 梏 
6890 梐 梑 梒 梓 梔 梕 梖 梗 梘 梙 梚 梛 梜 條 梞 梟 
68a0 梠 梡 梢 梣 梤 梥 梦 梧 梨 梩 梪 梫 梬 梭 梮 梯 
68b0 械 梱 梲 梳 梴 梵 梶 梷 梸 梹 梺 梻 梼 梽 梾 梿 
68c0 检 棁 棂 棃 棄 棅 棆 棇 棈 棉 棊 棋 棌 棍 棎 棏 
68d0 棐 棑 棒 棓 棔 棕 棖 棗 棘 棙 棚 棛 棜 棝 棞 棟 
68e0 棠 棡 棢 棣 棤 棥 棦 棧 棨 棩 棪 棫 棬 棭 森 棯 
68f0 棰 棱 棲 棳 棴 棵 棶 棷 棸 棹 棺 棻 棼 棽 棾 棿 
6900 椀 椁 椂 椃 椄 椅 椆 椇 椈 椉 椊 椋 椌 植 椎 椏 
6910 椐 椑 椒 椓 椔 椕 椖 椗 椘 椙 椚 椛 検 椝 椞 椟 
6920 椠 椡 椢 椣 椤 椥 椦 椧 椨 椩 椪 椫 椬 椭 椮 椯 
6930 椰 椱 椲 椳 椴 椵 椶 椷 椸 椹 椺 椻 椼 椽 椾 椿 
6940 楀 楁 楂 楃 楄 楅 楆 楇 楈 楉 楊 楋 楌 楍 楎 楏 
6950 楐 楑 楒 楓 楔 楕 楖 楗 楘 楙 楚 楛 楜 楝 楞 楟 
6960 楠 楡 楢 楣 楤 楥 楦 楧 楨 楩 楪 楫 楬 業 楮 楯 
6970 楰 楱 楲 楳 楴 極 楶 楷 楸 楹 楺 楻 楼 楽 楾 楿 
6980 榀 榁 概 榃 榄 榅 榆 榇 榈 榉 榊 榋 榌 榍 榎 榏 
6990 榐 榑 榒 榓 榔 榕 榖 榗 榘 榙 榚 榛 榜 榝 榞 榟 
69a0 榠 榡 榢 榣 榤 榥 榦 榧 榨 榩 榪 榫 榬 榭 榮 榯 


-------------------------------------------------------

23 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
69b0 榰 榱 榲 榳 榴 榵 榶 榷 榸 榹 榺 榻 榼 榽 榾 榿 
69c0 槀 槁 槂 槃 槄 槅 槆 槇 槈 槉 槊 構 槌 槍 槎 槏 
69d0 槐 槑 槒 槓 槔 槕 槖 槗 様 槙 槚 槛 槜 槝 槞 槟 
69e0 槠 槡 槢 槣 槤 槥 槦 槧 槨 槩 槪 槫 槬 槭 槮 槯 
69f0 槰 槱 槲 槳 槴 槵 槶 槷 槸 槹 槺 槻 槼 槽 槾 槿 
6a00 樀 樁 樂 樃 樄 樅 樆 樇 樈 樉 樊 樋 樌 樍 樎 樏 
6a10 樐 樑 樒 樓 樔 樕 樖 樗 樘 標 樚 樛 樜 樝 樞 樟 
6a20 樠 模 樢 樣 樤 樥 樦 樧 樨 権 横 樫 樬 樭 樮 樯 
6a30 樰 樱 樲 樳 樴 樵 樶 樷 樸 樹 樺 樻 樼 樽 樾 樿 
6a40 橀 橁 橂 橃 橄 橅 橆 橇 橈 橉 橊 橋 橌 橍 橎 橏 
6a50 橐 橑 橒 橓 橔 橕 橖 橗 橘 橙 橚 橛 橜 橝 橞 機 
6a60 橠 橡 橢 橣 橤 橥 橦 橧 橨 橩 橪 橫 橬 橭 橮 橯 
6a70 橰 橱 橲 橳 橴 橵 橶 橷 橸 橹 橺 橻 橼 橽 橾 橿 
6a80 檀 檁 檂 檃 檄 檅 檆 檇 檈 檉 檊 檋 檌 檍 檎 檏 
6a90 檐 檑 檒 檓 檔 檕 檖 檗 檘 檙 檚 檛 檜 檝 檞 檟 
6aa0 檠 檡 檢 檣 檤 檥 檦 檧 檨 檩 檪 檫 檬 檭 檮 檯 
6ab0 檰 檱 檲 檳 檴 檵 檶 檷 檸 檹 檺 檻 檼 檽 檾 檿 
6ac0 櫀 櫁 櫂 櫃 櫄 櫅 櫆 櫇 櫈 櫉 櫊 櫋 櫌 櫍 櫎 櫏 
6ad0 櫐 櫑 櫒 櫓 櫔 櫕 櫖 櫗 櫘 櫙 櫚 櫛 櫜 櫝 櫞 櫟 
6ae0 櫠 櫡 櫢 櫣 櫤 櫥 櫦 櫧 櫨 櫩 櫪 櫫 櫬 櫭 櫮 櫯 
6af0 櫰 櫱 櫲 櫳 櫴 櫵 櫶 櫷 櫸 櫹 櫺 櫻 櫼 櫽 櫾 櫿 


-------------------------------------------------------

24 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6b00 欀 欁 欂 欃 欄 欅 欆 欇 欈 欉 權 欋 欌 欍 欎 欏 
6b10 欐 欑 欒 欓 欔 欕 欖 欗 欘 欙 欚 欛 欜 欝 欞 欟 
6b20 欠 次 欢 欣 欤 欥 欦 欧 欨 欩 欪 欫 欬 欭 欮 欯 
6b30 欰 欱 欲 欳 欴 欵 欶 欷 欸 欹 欺 欻 欼 欽 款 欿 
6b40 歀 歁 歂 歃 歄 歅 歆 歇 歈 歉 歊 歋 歌 歍 歎 歏 
6b50 歐 歑 歒 歓 歔 歕 歖 歗 歘 歙 歚 歛 歜 歝 歞 歟 
6b60 歠 歡 止 正 此 步 武 歧 歨 歩 歪 歫 歬 歭 歮 歯 
6b70 歰 歱 歲 歳 歴 歵 歶 歷 歸 歹 歺 死 歼 歽 歾 歿 
6b80 殀 殁 殂 殃 殄 殅 殆 殇 殈 殉 殊 残 殌 殍 殎 殏 
6b90 殐 殑 殒 殓 殔 殕 殖 殗 殘 殙 殚 殛 殜 殝 殞 殟 
6ba0 殠 殡 殢 殣 殤 殥 殦 殧 殨 殩 殪 殫 殬 殭 殮 殯 
6bb0 殰 殱 殲 殳 殴 段 殶 殷 殸 殹 殺 殻 殼 殽 殾 殿 
6bc0 毀 毁 毂 毃 毄 毅 毆 毇 毈 毉 毊 毋 毌 母 毎 每 
6bd0 毐 毑 毒 毓 比 毕 毖 毗 毘 毙 毚 毛 毜 毝 毞 毟 
6be0 毠 毡 毢 毣 毤 毥 毦 毧 毨 毩 毪 毫 毬 毭 毮 毯 
6bf0 毰 毱 毲 毳 毴 毵 毶 毷 毸 毹 毺 毻 毼 毽 毾 毿 
6c00 氀 氁 氂 氃 氄 氅 氆 氇 氈 氉 氊 氋 氌 氍 氎 氏 
6c10 氐 民 氒 氓 气 氕 氖 気 氘 氙 氚 氛 氜 氝 氞 氟 
6c20 氠 氡 氢 氣 氤 氥 氦 氧 氨 氩 氪 氫 氬 氭 氮 氯 
6c30 氰 氱 氲 氳 水 氵 氶 氷 永 氹 氺 氻 氼 氽 氾 氿 
6c40 汀 汁 求 汃 汄 汅 汆 汇 汈 汉 汊 汋 汌 汍 汎 汏 


------------------------------------------------------

25 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6c50 汐 汑 汒 汓 汔 汕 汖 汗 汘 汙 汚 汛 汜 汝 汞 江 
6c60 池 污 汢 汣 汤 汥 汦 汧 汨 汩 汪 汫 汬 汭 汮 汯 
6c70 汰 汱 汲 汳 汴 汵 汶 汷 汸 汹 決 汻 汼 汽 汾 汿 
6c80 沀 沁 沂 沃 沄 沅 沆 沇 沈 沉 沊 沋 沌 沍 沎 沏 
6c90 沐 沑 沒 沓 沔 沕 沖 沗 沘 沙 沚 沛 沜 沝 沞 沟 
6ca0 沠 没 沢 沣 沤 沥 沦 沧 沨 沩 沪 沫 沬 沭 沮 沯 
6cb0 沰 沱 沲 河 沴 沵 沶 沷 沸 油 沺 治 沼 沽 沾 沿 
6cc0 泀 況 泂 泃 泄 泅 泆 泇 泈 泉 泊 泋 泌 泍 泎 泏 
6cd0 泐 泑 泒 泓 泔 法 泖 泗 泘 泙 泚 泛 泜 泝 泞 泟 
6ce0 泠 泡 波 泣 泤 泥 泦 泧 注 泩 泪 泫 泬 泭 泮 泯 
6cf0 泰 泱 泲 泳 泴 泵 泶 泷 泸 泹 泺 泻 泼 泽 泾 泿 
6d00 洀 洁 洂 洃 洄 洅 洆 洇 洈 洉 洊 洋 洌 洍 洎 洏 
6d10 洐 洑 洒 洓 洔 洕 洖 洗 洘 洙 洚 洛 洜 洝 洞 洟 
6d20 洠 洡 洢 洣 洤 津 洦 洧 洨 洩 洪 洫 洬 洭 洮 洯 
6d30 洰 洱 洲 洳 洴 洵 洶 洷 洸 洹 洺 活 洼 洽 派 洿 
6d40 浀 流 浂 浃 浄 浅 浆 浇 浈 浉 浊 测 浌 浍 济 浏 
6d50 浐 浑 浒 浓 浔 浕 浖 浗 浘 浙 浚 浛 浜 浝 浞 浟 
6d60 浠 浡 浢 浣 浤 浥 浦 浧 浨 浩 浪 浫 浬 浭 浮 浯 
6d70 浰 浱 浲 浳 浴 浵 浶 海 浸 浹 浺 浻 浼 浽 浾 浿 
6d80 涀 涁 涂 涃 涄 涅 涆 涇 消 涉 涊 涋 涌 涍 涎 涏 
6d90 涐 涑 涒 涓 涔 涕 涖 涗 涘 涙 涚 涛 涜 涝 涞 涟 


-------------------------------------------------------

26 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6da0 涠 涡 涢 涣 涤 涥 润 涧 涨 涩 涪 涫 涬 涭 涮 涯 
6db0 涰 涱 液 涳 涴 涵 涶 涷 涸 涹 涺 涻 涼 涽 涾 涿 
6dc0 淀 淁 淂 淃 淄 淅 淆 淇 淈 淉 淊 淋 淌 淍 淎 淏 
6dd0 淐 淑 淒 淓 淔 淕 淖 淗 淘 淙 淚 淛 淜 淝 淞 淟 
6de0 淠 淡 淢 淣 淤 淥 淦 淧 淨 淩 淪 淫 淬 淭 淮 淯 
6df0 淰 深 淲 淳 淴 淵 淶 混 淸 淹 淺 添 淼 淽 淾 淿 
6e00 渀 渁 渂 渃 渄 清 渆 渇 済 渉 渊 渋 渌 渍 渎 渏 
6e10 渐 渑 渒 渓 渔 渕 渖 渗 渘 渙 渚 減 渜 渝 渞 渟 
6e20 渠 渡 渢 渣 渤 渥 渦 渧 渨 温 渪 渫 測 渭 渮 港 
6e30 渰 渱 渲 渳 渴 渵 渶 渷 游 渹 渺 渻 渼 渽 渾 渿 
6e40 湀 湁 湂 湃 湄 湅 湆 湇 湈 湉 湊 湋 湌 湍 湎 湏 
6e50 湐 湑 湒 湓 湔 湕 湖 湗 湘 湙 湚 湛 湜 湝 湞 湟 
6e60 湠 湡 湢 湣 湤 湥 湦 湧 湨 湩 湪 湫 湬 湭 湮 湯 
6e70 湰 湱 湲 湳 湴 湵 湶 湷 湸 湹 湺 湻 湼 湽 湾 湿 
6e80 満 溁 溂 溃 溄 溅 溆 溇 溈 溉 溊 溋 溌 溍 溎 溏 
6e90 源 溑 溒 溓 溔 溕 準 溗 溘 溙 溚 溛 溜 溝 溞 溟 
6ea0 溠 溡 溢 溣 溤 溥 溦 溧 溨 溩 溪 溫 溬 溭 溮 溯 
6eb0 溰 溱 溲 溳 溴 溵 溶 溷 溸 溹 溺 溻 溼 溽 溾 溿 
6ec0 滀 滁 滂 滃 滄 滅 滆 滇 滈 滉 滊 滋 滌 滍 滎 滏 
6ed0 滐 滑 滒 滓 滔 滕 滖 滗 滘 滙 滚 滛 滜 滝 滞 滟 
6ee0 滠 满 滢 滣 滤 滥 滦 滧 滨 滩 滪 滫 滬 滭 滮 滯 


-------------------------------------------------------

27 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
6ef0 滰 滱 滲 滳 滴 滵 滶 滷 滸 滹 滺 滻 滼 滽 滾 滿 
6f00 漀 漁 漂 漃 漄 漅 漆 漇 漈 漉 漊 漋 漌 漍 漎 漏 
6f10 漐 漑 漒 漓 演 漕 漖 漗 漘 漙 漚 漛 漜 漝 漞 漟 
6f20 漠 漡 漢 漣 漤 漥 漦 漧 漨 漩 漪 漫 漬 漭 漮 漯 
6f30 漰 漱 漲 漳 漴 漵 漶 漷 漸 漹 漺 漻 漼 漽 漾 漿 
6f40 潀 潁 潂 潃 潄 潅 潆 潇 潈 潉 潊 潋 潌 潍 潎 潏 
6f50 潐 潑 潒 潓 潔 潕 潖 潗 潘 潙 潚 潛 潜 潝 潞 潟 
6f60 潠 潡 潢 潣 潤 潥 潦 潧 潨 潩 潪 潫 潬 潭 潮 潯 
6f70 潰 潱 潲 潳 潴 潵 潶 潷 潸 潹 潺 潻 潼 潽 潾 潿 
6f80 澀 澁 澂 澃 澄 澅 澆 澇 澈 澉 澊 澋 澌 澍 澎 澏 
6f90 澐 澑 澒 澓 澔 澕 澖 澗 澘 澙 澚 澛 澜 澝 澞 澟 
6fa0 澠 澡 澢 澣 澤 澥 澦 澧 澨 澩 澪 澫 澬 澭 澮 澯 
6fb0 澰 澱 澲 澳 澴 澵 澶 澷 澸 澹 澺 澻 澼 澽 澾 澿 
6fc0 激 濁 濂 濃 濄 濅 濆 濇 濈 濉 濊 濋 濌 濍 濎 濏 
6fd0 濐 濑 濒 濓 濔 濕 濖 濗 濘 濙 濚 濛 濜 濝 濞 濟 
6fe0 濠 濡 濢 濣 濤 濥 濦 濧 濨 濩 濪 濫 濬 濭 濮 濯 
6ff0 濰 濱 濲 濳 濴 濵 濶 濷 濸 濹 濺 濻 濼 濽 濾 濿 
7000 瀀 瀁 瀂 瀃 瀄 瀅 瀆 瀇 瀈 瀉 瀊 瀋 瀌 瀍 瀎 瀏 
7010 瀐 瀑 瀒 瀓 瀔 瀕 瀖 瀗 瀘 瀙 瀚 瀛 瀜 瀝 瀞 瀟 
7020 瀠 瀡 瀢 瀣 瀤 瀥 瀦 瀧 瀨 瀩 瀪 瀫 瀬 瀭 瀮 瀯 
7030 瀰 瀱 瀲 瀳 瀴 瀵 瀶 瀷 瀸 瀹 瀺 瀻 瀼 瀽 瀾 瀿 


-------------------------------------------------------

28 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------  
7040 灀 灁 灂 灃 灄 灅 灆 灇 灈 灉 灊 灋 灌 灍 灎 灏 
7050 灐 灑 灒 灓 灔 灕 灖 灗 灘 灙 灚 灛 灜 灝 灞 灟 
7060 灠 灡 灢 灣 灤 灥 灦 灧 灨 灩 灪 火 灬 灭 灮 灯 
7070 灰 灱 灲 灳 灴 灵 灶 灷 灸 灹 灺 灻 灼 災 灾 灿 
7080 炀 炁 炂 炃 炄 炅 炆 炇 炈 炉 炊 炋 炌 炍 炎 炏 
7090 炐 炑 炒 炓 炔 炕 炖 炗 炘 炙 炚 炛 炜 炝 炞 炟 
70a0 炠 炡 炢 炣 炤 炥 炦 炧 炨 炩 炪 炫 炬 炭 炮 炯 
70b0 炰 炱 炲 炳 炴 炵 炶 炷 炸 点 為 炻 炼 炽 炾 炿 
70c0 烀 烁 烂 烃 烄 烅 烆 烇 烈 烉 烊 烋 烌 烍 烎 烏 
70d0 烐 烑 烒 烓 烔 烕 烖 烗 烘 烙 烚 烛 烜 烝 烞 烟 
70e0 烠 烡 烢 烣 烤 烥 烦 烧 烨 烩 烪 烫 烬 热 烮 烯 
70f0 烰 烱 烲 烳 烴 烵 烶 烷 烸 烹 烺 烻 烼 烽 烾 烿 
7100 焀 焁 焂 焃 焄 焅 焆 焇 焈 焉 焊 焋 焌 焍 焎 焏 
7110 焐 焑 焒 焓 焔 焕 焖 焗 焘 焙 焚 焛 焜 焝 焞 焟 
7120 焠 無 焢 焣 焤 焥 焦 焧 焨 焩 焪 焫 焬 焭 焮 焯 
7130 焰 焱 焲 焳 焴 焵 然 焷 焸 焹 焺 焻 焼 焽 焾 焿 
7140 煀 煁 煂 煃 煄 煅 煆 煇 煈 煉 煊 煋 煌 煍 煎 煏 
7150 煐 煑 煒 煓 煔 煕 煖 煗 煘 煙 煚 煛 煜 煝 煞 煟 
7160 煠 煡 煢 煣 煤 煥 煦 照 煨 煩 煪 煫 煬 煭 煮 煯 
7170 煰 煱 煲 煳 煴 煵 煶 煷 煸 煹 煺 煻 煼 煽 煾 煿 
7180 熀 熁 熂 熃 熄 熅 熆 熇 熈 熉 熊 熋 熌 熍 熎 熏 


-------------------------------------------------------

29 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7190 熐 熑 熒 熓 熔 熕 熖 熗 熘 熙 熚 熛 熜 熝 熞 熟 
71a0 熠 熡 熢 熣 熤 熥 熦 熧 熨 熩 熪 熫 熬 熭 熮 熯 
71b0 熰 熱 熲 熳 熴 熵 熶 熷 熸 熹 熺 熻 熼 熽 熾 熿 
71c0 燀 燁 燂 燃 燄 燅 燆 燇 燈 燉 燊 燋 燌 燍 燎 燏 
71d0 燐 燑 燒 燓 燔 燕 燖 燗 燘 燙 燚 燛 燜 燝 燞 營 
71e0 燠 燡 燢 燣 燤 燥 燦 燧 燨 燩 燪 燫 燬 燭 燮 燯 
71f0 燰 燱 燲 燳 燴 燵 燶 燷 燸 燹 燺 燻 燼 燽 燾 燿 
7200 爀 爁 爂 爃 爄 爅 爆 爇 爈 爉 爊 爋 爌 爍 爎 爏 
7210 爐 爑 爒 爓 爔 爕 爖 爗 爘 爙 爚 爛 爜 爝 爞 爟 
7220 爠 爡 爢 爣 爤 爥 爦 爧 爨 爩 爪 爫 爬 爭 爮 爯 
7230 爰 爱 爲 爳 爴 爵 父 爷 爸 爹 爺 爻 爼 爽 爾 爿 
7240 牀 牁 牂 牃 牄 牅 牆 片 版 牉 牊 牋 牌 牍 牎 牏 
7250 牐 牑 牒 牓 牔 牕 牖 牗 牘 牙 牚 牛 牜 牝 牞 牟 
7260 牠 牡 牢 牣 牤 牥 牦 牧 牨 物 牪 牫 牬 牭 牮 牯 
7270 牰 牱 牲 牳 牴 牵 牶 牷 牸 特 牺 牻 牼 牽 牾 牿 
7280 犀 犁 犂 犃 犄 犅 犆 犇 犈 犉 犊 犋 犌 犍 犎 犏 
7290 犐 犑 犒 犓 犔 犕 犖 犗 犘 犙 犚 犛 犜 犝 犞 犟 
72a0 犠 犡 犢 犣 犤 犥 犦 犧 犨 犩 犪 犫 犬 犭 犮 犯 
72b0 犰 犱 犲 犳 犴 犵 状 犷 犸 犹 犺 犻 犼 犽 犾 犿 
72c0 狀 狁 狂 狃 狄 狅 狆 狇 狈 狉 狊 狋 狌 狍 狎 狏 
72d0 狐 狑 狒 狓 狔 狕 狖 狗 狘 狙 狚 狛 狜 狝 狞 狟 


-------------------------------------------------------

30 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
72e0 狠 狡 狢 狣 狤 狥 狦 狧 狨 狩 狪 狫 独 狭 狮 狯 
72f0 狰 狱 狲 狳 狴 狵 狶 狷 狸 狹 狺 狻 狼 狽 狾 狿 
7300 猀 猁 猂 猃 猄 猅 猆 猇 猈 猉 猊 猋 猌 猍 猎 猏 
7310 猐 猑 猒 猓 猔 猕 猖 猗 猘 猙 猚 猛 猜 猝 猞 猟 
7320 猠 猡 猢 猣 猤 猥 猦 猧 猨 猩 猪 猫 猬 猭 献 猯 
7330 猰 猱 猲 猳 猴 猵 猶 猷 猸 猹 猺 猻 猼 猽 猾 猿 
7340 獀 獁 獂 獃 獄 獅 獆 獇 獈 獉 獊 獋 獌 獍 獎 獏 
7350 獐 獑 獒 獓 獔 獕 獖 獗 獘 獙 獚 獛 獜 獝 獞 獟 
7360 獠 獡 獢 獣 獤 獥 獦 獧 獨 獩 獪 獫 獬 獭 獮 獯 
7370 獰 獱 獲 獳 獴 獵 獶 獷 獸 獹 獺 獻 獼 獽 獾 獿 
7380 玀 玁 玂 玃 玄 玅 玆 率 玈 玉 玊 王 玌 玍 玎 玏 
7390 玐 玑 玒 玓 玔 玕 玖 玗 玘 玙 玚 玛 玜 玝 玞 玟 
73a0 玠 玡 玢 玣 玤 玥 玦 玧 玨 玩 玪 玫 玬 玭 玮 环 
73b0 现 玱 玲 玳 玴 玵 玶 玷 玸 玹 玺 玻 玼 玽 玾 玿 
73c0 珀 珁 珂 珃 珄 珅 珆 珇 珈 珉 珊 珋 珌 珍 珎 珏 
73d0 珐 珑 珒 珓 珔 珕 珖 珗 珘 珙 珚 珛 珜 珝 珞 珟 
73e0 珠 珡 珢 珣 珤 珥 珦 珧 珨 珩 珪 珫 珬 班 珮 珯 
73f0 珰 珱 珲 珳 珴 珵 珶 珷 珸 珹 珺 珻 珼 珽 現 珿 
7400 琀 琁 琂 球 琄 琅 理 琇 琈 琉 琊 琋 琌 琍 琎 琏 
7410 琐 琑 琒 琓 琔 琕 琖 琗 琘 琙 琚 琛 琜 琝 琞 琟 
7420 琠 琡 琢 琣 琤 琥 琦 琧 琨 琩 琪 琫 琬 琭 琮 琯 


-------------------------------------------------------


31 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7430 琰 琱 琲 琳 琴 琵 琶 琷 琸 琹 琺 琻 琼 琽 琾 琿 
7440 瑀 瑁 瑂 瑃 瑄 瑅 瑆 瑇 瑈 瑉 瑊 瑋 瑌 瑍 瑎 瑏 
7450 瑐 瑑 瑒 瑓 瑔 瑕 瑖 瑗 瑘 瑙 瑚 瑛 瑜 瑝 瑞 瑟 
7460 瑠 瑡 瑢 瑣 瑤 瑥 瑦 瑧 瑨 瑩 瑪 瑫 瑬 瑭 瑮 瑯 
7470 瑰 瑱 瑲 瑳 瑴 瑵 瑶 瑷 瑸 瑹 瑺 瑻 瑼 瑽 瑾 瑿 
7480 璀 璁 璂 璃 璄 璅 璆 璇 璈 璉 璊 璋 璌 璍 璎 璏 
7490 璐 璑 璒 璓 璔 璕 璖 璗 璘 璙 璚 璛 璜 璝 璞 璟 
74a0 璠 璡 璢 璣 璤 璥 璦 璧 璨 璩 璪 璫 璬 璭 璮 璯 
74b0 環 璱 璲 璳 璴 璵 璶 璷 璸 璹 璺 璻 璼 璽 璾 璿 
74c0 瓀 瓁 瓂 瓃 瓄 瓅 瓆 瓇 瓈 瓉 瓊 瓋 瓌 瓍 瓎 瓏 
74d0 瓐 瓑 瓒 瓓 瓔 瓕 瓖 瓗 瓘 瓙 瓚 瓛 瓜 瓝 瓞 瓟 
74e0 瓠 瓡 瓢 瓣 瓤 瓥 瓦 瓧 瓨 瓩 瓪 瓫 瓬 瓭 瓮 瓯 
74f0 瓰 瓱 瓲 瓳 瓴 瓵 瓶 瓷 瓸 瓹 瓺 瓻 瓼 瓽 瓾 瓿 
7500 甀 甁 甂 甃 甄 甅 甆 甇 甈 甉 甊 甋 甌 甍 甎 甏 
7510 甐 甑 甒 甓 甔 甕 甖 甗 甘 甙 甚 甛 甜 甝 甞 生 
7520 甠 甡 產 産 甤 甥 甦 甧 用 甩 甪 甫 甬 甭 甮 甯 
7530 田 由 甲 申 甴 电 甶 男 甸 甹 町 画 甼 甽 甾 甿 
7540 畀 畁 畂 畃 畄 畅 畆 畇 畈 畉 畊 畋 界 畍 畎 畏 
7550 畐 畑 畒 畓 畔 畕 畖 畗 畘 留 畚 畛 畜 畝 畞 畟 
7560 畠 畡 畢 畣 畤 略 畦 畧 畨 畩 番 畫 畬 畭 畮 畯 
7570 異 畱 畲 畳 畴 畵 當 畷 畸 畹 畺 畻 畼 畽 畾 畿 
7580 疀 疁 疂 疃 疄 疅 疆 疇 疈 疉 疊 疋 疌 疍 疎 疏 
7590 疐 疑 疒 疓 疔 疕 疖 疗 疘 疙 疚 疛 疜 疝 疞 疟 
75a0 疠 疡 疢 疣 疤 疥 疦 疧 疨 疩 疪 疫 疬 疭 疮 疯  


-------------------------------------------------------

32 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------  
75b0 疰 疱 疲 疳 疴 疵 疶 疷 疸 疹 疺 疻 疼 疽 疾 疿 
75c0 痀 痁 痂 痃 痄 病 痆 症 痈 痉 痊 痋 痌 痍 痎 痏 
75d0 痐 痑 痒 痓 痔 痕 痖 痗 痘 痙 痚 痛 痜 痝 痞 痟 
75e0 痠 痡 痢 痣 痤 痥 痦 痧 痨 痩 痪 痫 痬 痭 痮 痯 
75f0 痰 痱 痲 痳 痴 痵 痶 痷 痸 痹 痺 痻 痼 痽 痾 痿 
7600 瘀 瘁 瘂 瘃 瘄 瘅 瘆 瘇 瘈 瘉 瘊 瘋 瘌 瘍 瘎 瘏 
7610 瘐 瘑 瘒 瘓 瘔 瘕 瘖 瘗 瘘 瘙 瘚 瘛 瘜 瘝 瘞 瘟 
7620 瘠 瘡 瘢 瘣 瘤 瘥 瘦 瘧 瘨 瘩 瘪 瘫 瘬 瘭 瘮 瘯 
7630 瘰 瘱 瘲 瘳 瘴 瘵 瘶 瘷 瘸 瘹 瘺 瘻 瘼 瘽 瘾 瘿 
7640 癀 癁 療 癃 癄 癅 癆 癇 癈 癉 癊 癋 癌 癍 癎 癏  


--------------------------------------------------------

33 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7650 癐 癑 癒 癓 癔 癕 癖 癗 癘 癙 癚 癛 癜 癝 癞 癟 
7660 癠 癡 癢 癣 癤 癥 癦 癧 癨 癩 癪 癫 癬 癭 癮 癯 
7670 癰 癱 癲 癳 癴 癵 癶 癷 癸 癹 発 登 發 白 百 癿 
7680 皀 皁 皂 皃 的 皅 皆 皇 皈 皉 皊 皋 皌 皍 皎 皏 
7690 皐 皑 皒 皓 皔 皕 皖 皗 皘 皙 皚 皛 皜 皝 皞 皟 
76a0 皠 皡 皢 皣 皤 皥 皦 皧 皨 皩 皪 皫 皬 皭 皮 皯 
76b0 皰 皱 皲 皳 皴 皵 皶 皷 皸 皹 皺 皻 皼 皽 皾 皿 
76c0 盀 盁 盂 盃 盄 盅 盆 盇 盈 盉 益 盋 盌 盍 盎 盏 
76d0 盐 监 盒 盓 盔 盕 盖 盗 盘 盙 盚 盛 盜 盝 盞 盟 
76e0 盠 盡 盢 監 盤 盥 盦 盧 盨 盩 盪 盫 盬 盭 目 盯 
76f0 盰 盱 盲 盳 直 盵 盶 盷 相 盹 盺 盻 盼 盽 盾 盿 
7700 眀 省 眂 眃 眄 眅 眆 眇 眈 眉 眊 看 県 眍 眎 眏 
7710 眐 眑 眒 眓 眔 眕 眖 眗 眘 眙 眚 眛 眜 眝 眞 真 
7720 眠 眡 眢 眣 眤 眥 眦 眧 眨 眩 眪 眫 眬 眭 眮 眯 
7730 眰 眱 眲 眳 眴 眵 眶 眷 眸 眹 眺 眻 眼 眽 眾 眿 
7740 着 睁 睂 睃 睄 睅 睆 睇 睈 睉 睊 睋 睌 睍 睎 睏 
7750 睐 睑 睒 睓 睔 睕 睖 睗 睘 睙 睚 睛 睜 睝 睞 睟 
7760 睠 睡 睢 督 睤 睥 睦 睧 睨 睩 睪 睫 睬 睭 睮 睯 
7770 睰 睱 睲 睳 睴 睵 睶 睷 睸 睹 睺 睻 睼 睽 睾 睿 
7780 瞀 瞁 瞂 瞃 瞄 瞅 瞆 瞇 瞈 瞉 瞊 瞋 瞌 瞍 瞎 瞏 
7790 瞐 瞑 瞒 瞓 瞔 瞕 瞖 瞗 瞘 瞙 瞚 瞛 瞜 瞝 瞞 瞟 


-------------------------------------------------------

34 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
77a0 瞠 瞡 瞢 瞣 瞤 瞥 瞦 瞧 瞨 瞩 瞪 瞫 瞬 瞭 瞮 瞯 
77b0 瞰 瞱 瞲 瞳 瞴 瞵 瞶 瞷 瞸 瞹 瞺 瞻 瞼 瞽 瞾 瞿 
77c0 矀 矁 矂 矃 矄 矅 矆 矇 矈 矉 矊 矋 矌 矍 矎 矏 
77d0 矐 矑 矒 矓 矔 矕 矖 矗 矘 矙 矚 矛 矜 矝 矞 矟 
77e0 矠 矡 矢 矣 矤 知 矦 矧 矨 矩 矪 矫 矬 短 矮 矯 
77f0 矰 矱 矲 石 矴 矵 矶 矷 矸 矹 矺 矻 矼 矽 矾 矿 
7800 砀 码 砂 砃 砄 砅 砆 砇 砈 砉 砊 砋 砌 砍 砎 砏 
7810 砐 砑 砒 砓 研 砕 砖 砗 砘 砙 砚 砛 砜 砝 砞 砟 
7820 砠 砡 砢 砣 砤 砥 砦 砧 砨 砩 砪 砫 砬 砭 砮 砯 
7830 砰 砱 砲 砳 破 砵 砶 砷 砸 砹 砺 砻 砼 砽 砾 砿 
7840 础 硁 硂 硃 硄 硅 硆 硇 硈 硉 硊 硋 硌 硍 硎 硏 
7850 硐 硑 硒 硓 硔 硕 硖 硗 硘 硙 硚 硛 硜 硝 硞 硟 
7860 硠 硡 硢 硣 硤 硥 硦 硧 硨 硩 硪 硫 硬 硭 确 硯 
7870 硰 硱 硲 硳 硴 硵 硶 硷 硸 硹 硺 硻 硼 硽 硾 硿 
7880 碀 碁 碂 碃 碄 碅 碆 碇 碈 碉 碊 碋 碌 碍 碎 碏 
7890 碐 碑 碒 碓 碔 碕 碖 碗 碘 碙 碚 碛 碜 碝 碞 碟 
78a0 碠 碡 碢 碣 碤 碥 碦 碧 碨 碩 碪 碫 碬 碭 碮 碯 
78b0 碰 碱 碲 碳 碴 碵 碶 碷 碸 碹 確 碻 碼 碽 碾 碿 
78c0 磀 磁 磂 磃 磄 磅 磆 磇 磈 磉 磊 磋 磌 磍 磎 磏 
78d0 磐 磑 磒 磓 磔 磕 磖 磗 磘 磙 磚 磛 磜 磝 磞 磟 
78e0 磠 磡 磢 磣 磤 磥 磦 磧 磨 磩 磪 磫 磬 磭 磮 磯 


-------------------------------------------------------

35 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
78f0 磰 磱 磲 磳 磴 磵 磶 磷 磸 磹 磺 磻 磼 磽 磾 磿 
7900 礀 礁 礂 礃 礄 礅 礆 礇 礈 礉 礊 礋 礌 礍 礎 礏 
7910 礐 礑 礒 礓 礔 礕 礖 礗 礘 礙 礚 礛 礜 礝 礞 礟 
7920 礠 礡 礢 礣 礤 礥 礦 礧 礨 礩 礪 礫 礬 礭 礮 礯 
7930 礰 礱 礲 礳 礴 礵 礶 礷 礸 礹 示 礻 礼 礽 社 礿 
7940 祀 祁 祂 祃 祄 祅 祆 祇 祈 祉 祊 祋 祌 祍 祎 祏 
7950 祐 祑 祒 祓 祔 祕 祖 祗 祘 祙 祚 祛 祜 祝 神 祟 
7960 祠 祡 祢 祣 祤 祥 祦 祧 票 祩 祪 祫 祬 祭 祮 祯 
7970 祰 祱 祲 祳 祴 祵 祶 祷 祸 祹 祺 祻 祼 祽 祾 祿 
7980 禀 禁 禂 禃 禄 禅 禆 禇 禈 禉 禊 禋 禌 禍 禎 福 
7990 禐 禑 禒 禓 禔 禕 禖 禗 禘 禙 禚 禛 禜 禝 禞 禟 
79a0 禠 禡 禢 禣 禤 禥 禦 禧 禨 禩 禪 禫 禬 禭 禮 禯 
79b0 禰 禱 禲 禳 禴 禵 禶 禷 禸 禹 禺 离 禼 禽 禾 禿 
79c0 秀 私 秂 秃 秄 秅 秆 秇 秈 秉 秊 秋 秌 种 秎 秏 
79d0 秐 科 秒 秓 秔 秕 秖 秗 秘 秙 秚 秛 秜 秝 秞 租 
79e0 秠 秡 秢 秣 秤 秥 秦 秧 秨 秩 秪 秫 秬 秭 秮 积 
79f0 称 秱 秲 秳 秴 秵 秶 秷 秸 秹 秺 移 秼 秽 秾 秿 
7a00 稀 稁 稂 稃 稄 稅 稆 稇 稈 稉 稊 程 稌 稍 税 稏 
7a10 稐 稑 稒 稓 稔 稕 稖 稗 稘 稙 稚 稛 稜 稝 稞 稟 
7a20 稠 稡 稢 稣 稤 稥 稦 稧 稨 稩 稪 稫 稬 稭 種 稯 
7a30 稰 稱 稲 稳 稴 稵 稶 稷 稸 稹 稺 稻 稼 稽 稾 稿 


------------------------------------------------------

36 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7a40 穀 穁 穂 穃 穄 穅 穆 穇 穈 穉 穊 穋 穌 積 穎 穏 
7a50 穐 穑 穒 穓 穔 穕 穖 穗 穘 穙 穚 穛 穜 穝 穞 穟 
7a60 穠 穡 穢 穣 穤 穥 穦 穧 穨 穩 穪 穫 穬 穭 穮 穯 
7a70 穰 穱 穲 穳 穴 穵 究 穷 穸 穹 空 穻 穼 穽 穾 穿 
7a80 窀 突 窂 窃 窄 窅 窆 窇 窈 窉 窊 窋 窌 窍 窎 窏 
7a90 窐 窑 窒 窓 窔 窕 窖 窗 窘 窙 窚 窛 窜 窝 窞 窟 
7aa0 窠 窡 窢 窣 窤 窥 窦 窧 窨 窩 窪 窫 窬 窭 窮 窯 
7ab0 窰 窱 窲 窳 窴 窵 窶 窷 窸 窹 窺 窻 窼 窽 窾 窿 
7ac0 竀 竁 竂 竃 竄 竅 竆 竇 竈 竉 竊 立 竌 竍 竎 竏 
7ad0 竐 竑 竒 竓 竔 竕 竖 竗 竘 站 竚 竛 竜 竝 竞 竟 
7ae0 章 竡 竢 竣 竤 童 竦 竧 竨 竩 竪 竫 竬 竭 竮 端 
7af0 竰 竱 竲 竳 竴 竵 競 竷 竸 竹 竺 竻 竼 竽 竾 竿 
7b00 笀 笁 笂 笃 笄 笅 笆 笇 笈 笉 笊 笋 笌 笍 笎 笏 
7b10 笐 笑 笒 笓 笔 笕 笖 笗 笘 笙 笚 笛 笜 笝 笞 笟 
7b20 笠 笡 笢 笣 笤 笥 符 笧 笨 笩 笪 笫 第 笭 笮 笯 
7b30 笰 笱 笲 笳 笴 笵 笶 笷 笸 笹 笺 笻 笼 笽 笾 笿 
7b40 筀 筁 筂 筃 筄 筅 筆 筇 筈 等 筊 筋 筌 筍 筎 筏 
7b50 筐 筑 筒 筓 答 筕 策 筗 筘 筙 筚 筛 筜 筝 筞 筟 
7b60 筠 筡 筢 筣 筤 筥 筦 筧 筨 筩 筪 筫 筬 筭 筮 筯 
7b70 筰 筱 筲 筳 筴 筵 筶 筷 筸 筹 筺 筻 筼 筽 签 筿 
7b80 简 箁 箂 箃 箄 箅 箆 箇 箈 箉 箊 箋 箌 箍 箎 箏 


-------------------------------------------------------

37 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7b90 箐 箑 箒 箓 箔 箕 箖 算 箘 箙 箚 箛 箜 箝 箞 箟 
7ba0 箠 管 箢 箣 箤 箥 箦 箧 箨 箩 箪 箫 箬 箭 箮 箯 
7bb0 箰 箱 箲 箳 箴 箵 箶 箷 箸 箹 箺 箻 箼 箽 箾 箿 
7bc0 節 篁 篂 篃 範 篅 篆 篇 篈 築 篊 篋 篌 篍 篎 篏 
7bd0 篐 篑 篒 篓 篔 篕 篖 篗 篘 篙 篚 篛 篜 篝 篞 篟 
7be0 篠 篡 篢 篣 篤 篥 篦 篧 篨 篩 篪 篫 篬 篭 篮 篯 
7bf0 篰 篱 篲 篳 篴 篵 篶 篷 篸 篹 篺 篻 篼 篽 篾 篿 
7c00 簀 簁 簂 簃 簄 簅 簆 簇 簈 簉 簊 簋 簌 簍 簎 簏 
7c10 簐 簑 簒 簓 簔 簕 簖 簗 簘 簙 簚 簛 簜 簝 簞 簟 
7c20 簠 簡 簢 簣 簤 簥 簦 簧 簨 簩 簪 簫 簬 簭 簮 簯 
7c30 簰 簱 簲 簳 簴 簵 簶 簷 簸 簹 簺 簻 簼 簽 簾 簿 
7c40 籀 籁 籂 籃 籄 籅 籆 籇 籈 籉 籊 籋 籌 籍 籎 籏 
7c50 籐 籑 籒 籓 籔 籕 籖 籗 籘 籙 籚 籛 籜 籝 籞 籟 
7c60 籠 籡 籢 籣 籤 籥 籦 籧 籨 籩 籪 籫 籬 籭 籮 籯 
7c70 籰 籱 籲 米 籴 籵 籶 籷 籸 籹 籺 类 籼 籽 籾 籿 
7c80 粀 粁 粂 粃 粄 粅 粆 粇 粈 粉 粊 粋 粌 粍 粎 粏 
7c90 粐 粑 粒 粓 粔 粕 粖 粗 粘 粙 粚 粛 粜 粝 粞 粟 
7ca0 粠 粡 粢 粣 粤 粥 粦 粧 粨 粩 粪 粫 粬 粭 粮 粯 
7cb0 粰 粱 粲 粳 粴 粵 粶 粷 粸 粹 粺 粻 粼 粽 精 粿 
7cc0 糀 糁 糂 糃 糄 糅 糆 糇 糈 糉 糊 糋 糌 糍 糎 糏 
7cd0 糐 糑 糒 糓 糔 糕 糖 糗 糘 糙 糚 糛 糜 糝 糞 糟 


-------------------------------------------------------

38 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7ce0 糠 糡 糢 糣 糤 糥 糦 糧 糨 糩 糪 糫 糬 糭 糮 糯 
7cf0 糰 糱 糲 糳 糴 糵 糶 糷 糸 糹 糺 系 糼 糽 糾 糿 
7d00 紀 紁 紂 紃 約 紅 紆 紇 紈 紉 紊 紋 紌 納 紎 紏 
7d10 紐 紑 紒 紓 純 紕 紖 紗 紘 紙 級 紛 紜 紝 紞 紟 
7d20 素 紡 索 紣 紤 紥 紦 紧 紨 紩 紪 紫 紬 紭 紮 累 
7d30 細 紱 紲 紳 紴 紵 紶 紷 紸 紹 紺 紻 紼 紽 紾 紿 
7d40 絀 絁 終 絃 組 絅 絆 絇 絈 絉 絊 絋 経 絍 絎 絏 
7d50 結 絑 絒 絓 絔 絕 絖 絗 絘 絙 絚 絛 絜 絝 絞 絟 
7d60 絠 絡 絢 絣 絤 絥 給 絧 絨 絩 絪 絫 絬 絭 絮 絯 
7d70 絰 統 絲 絳 絴 絵 絶 絷 絸 絹 絺 絻 絼 絽 絾 絿 
7d80 綀 綁 綂 綃 綄 綅 綆 綇 綈 綉 綊 綋 綌 綍 綎 綏 
7d90 綐 綑 綒 經 綔 綕 綖 綗 綘 継 続 綛 綜 綝 綞 綟 
7da0 綠 綡 綢 綣 綤 綥 綦 綧 綨 綩 綪 綫 綬 維 綮 綯 
7db0 綰 綱 網 綳 綴 綵 綶 綷 綸 綹 綺 綻 綼 綽 綾 綿 
7dc0 緀 緁 緂 緃 緄 緅 緆 緇 緈 緉 緊 緋 緌 緍 緎 総 
7dd0 緐 緑 緒 緓 緔 緕 緖 緗 緘 緙 線 緛 緜 緝 緞 緟 
7de0 締 緡 緢 緣 緤 緥 緦 緧 編 緩 緪 緫 緬 緭 緮 緯 
7df0 緰 緱 緲 緳 練 緵 緶 緷 緸 緹 緺 緻 緼 緽 緾 緿 
7e00 縀 縁 縂 縃 縄 縅 縆 縇 縈 縉 縊 縋 縌 縍 縎 縏 
7e10 縐 縑 縒 縓 縔 縕 縖 縗 縘 縙 縚 縛 縜 縝 縞 縟 
7e20 縠 縡 縢 縣 縤 縥 縦 縧 縨 縩 縪 縫 縬 縭 縮 縯 


------------------------------------------------------

39 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7e30 縰 縱 縲 縳 縴 縵 縶 縷 縸 縹 縺 縻 縼 總 績 縿 
7e40 繀 繁 繂 繃 繄 繅 繆 繇 繈 繉 繊 繋 繌 繍 繎 繏 
7e50 繐 繑 繒 繓 織 繕 繖 繗 繘 繙 繚 繛 繜 繝 繞 繟 
7e60 繠 繡 繢 繣 繤 繥 繦 繧 繨 繩 繪 繫 繬 繭 繮 繯 
7e70 繰 繱 繲 繳 繴 繵 繶 繷 繸 繹 繺 繻 繼 繽 繾 繿 
7e80 纀 纁 纂 纃 纄 纅 纆 纇 纈 纉 纊 纋 續 纍 纎 纏 
7e90 纐 纑 纒 纓 纔 纕 纖 纗 纘 纙 纚 纛 纜 纝 纞 纟 
7ea0 纠 纡 红 纣 纤 纥 约 级 纨 纩 纪 纫 纬 纭 纮 纯 
7eb0 纰 纱 纲 纳 纴 纵 纶 纷 纸 纹 纺 纻 纼 纽 纾 线 
7ec0 绀 绁 绂 练 组 绅 细 织 终 绉 绊 绋 绌 绍 绎 经 
7ed0 绐 绑 绒 结 绔 绕 绖 绗 绘 给 绚 绛 络 绝 绞 统 
7ee0 绠 绡 绢 绣 绤 绥 绦 继 绨 绩 绪 绫 绬 续 绮 绯 
7ef0 绰 绱 绲 绳 维 绵 绶 绷 绸 绹 绺 绻 综 绽 绾 绿 
7f00 缀 缁 缂 缃 缄 缅 缆 缇 缈 缉 缊 缋 缌 缍 缎 缏 
7f10 缐 缑 缒 缓 缔 缕 编 缗 缘 缙 缚 缛 缜 缝 缞 缟 
7f20 缠 缡 缢 缣 缤 缥 缦 缧 缨 缩 缪 缫 缬 缭 缮 缯 
7f30 缰 缱 缲 缳 缴 缵 缶 缷 缸 缹 缺 缻 缼 缽 缾 缿 
7f40 罀 罁 罂 罃 罄 罅 罆 罇 罈 罉 罊 罋 罌 罍 罎 罏 
7f50 罐 网 罒 罓 罔 罕 罖 罗 罘 罙 罚 罛 罜 罝 罞 罟 
7f60 罠 罡 罢 罣 罤 罥 罦 罧 罨 罩 罪 罫 罬 罭 置 罯 
7f70 罰 罱 署 罳 罴 罵 罶 罷 罸 罹 罺 罻 罼 罽 罾 罿 


-------------------------------------------------------

40 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
7f80 羀 羁 羂 羃 羄 羅 羆 羇 羈 羉 羊 羋 羌 羍 美 羏 
7f90 羐 羑 羒 羓 羔 羕 羖 羗 羘 羙 羚 羛 羜 羝 羞 羟 
7fa0 羠 羡 羢 羣 群 羥 羦 羧 羨 義 羪 羫 羬 羭 羮 羯 
7fb0 羰 羱 羲 羳 羴 羵 羶 羷 羸 羹 羺 羻 羼 羽 羾 羿 
7fc0 翀 翁 翂 翃 翄 翅 翆 翇 翈 翉 翊 翋 翌 翍 翎 翏 
7fd0 翐 翑 習 翓 翔 翕 翖 翗 翘 翙 翚 翛 翜 翝 翞 翟 
7fe0 翠 翡 翢 翣 翤 翥 翦 翧 翨 翩 翪 翫 翬 翭 翮 翯 
7ff0 翰 翱 翲 翳 翴 翵 翶 翷 翸 翹 翺 翻 翼 翽 翾 翿 
8000 耀 老 耂 考 耄 者 耆 耇 耈 耉 耊 耋 而 耍 耎 耏 
8010 耐 耑 耒 耓 耔 耕 耖 耗 耘 耙 耚 耛 耜 耝 耞 耟 
8020 耠 耡 耢 耣 耤 耥 耦 耧 耨 耩 耪 耫 耬 耭 耮 耯 
8030 耰 耱 耲 耳 耴 耵 耶 耷 耸 耹 耺 耻 耼 耽 耾 耿 
8040 聀 聁 聂 聃 聄 聅 聆 聇 聈 聉 聊 聋 职 聍 聎 聏 
8050 聐 聑 聒 聓 联 聕 聖 聗 聘 聙 聚 聛 聜 聝 聞 聟 
8060 聠 聡 聢 聣 聤 聥 聦 聧 聨 聩 聪 聫 聬 聭 聮 聯 
8070 聰 聱 聲 聳 聴 聵 聶 職 聸 聹 聺 聻 聼 聽 聾 聿 
8080 肀 肁 肂 肃 肄 肅 肆 肇 肈 肉 肊 肋 肌 肍 肎 肏 
8090 肐 肑 肒 肓 肔 肕 肖 肗 肘 肙 肚 肛 肜 肝 肞 肟 
80a0 肠 股 肢 肣 肤 肥 肦 肧 肨 肩 肪 肫 肬 肭 肮 肯 
80b0 肰 肱 育 肳 肴 肵 肶 肷 肸 肹 肺 肻 肼 肽 肾 肿 
80c0 胀 胁 胂 胃 胄 胅 胆 胇 胈 胉 胊 胋 背 胍 胎 胏 


------------------------------------------------------


41 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
80d0 胐 胑 胒 胓 胔 胕 胖 胗 胘 胙 胚 胛 胜 胝 胞 胟 
80e0 胠 胡 胢 胣 胤 胥 胦 胧 胨 胩 胪 胫 胬 胭 胮 胯 
80f0 胰 胱 胲 胳 胴 胵 胶 胷 胸 胹 胺 胻 胼 能 胾 胿 
8100 脀 脁 脂 脃 脄 脅 脆 脇 脈 脉 脊 脋 脌 脍 脎 脏 
8110 脐 脑 脒 脓 脔 脕 脖 脗 脘 脙 脚 脛 脜 脝 脞 脟 
8120 脠 脡 脢 脣 脤 脥 脦 脧 脨 脩 脪 脫 脬 脭 脮 脯 
8130 脰 脱 脲 脳 脴 脵 脶 脷 脸 脹 脺 脻 脼 脽 脾 脿 
8140 腀 腁 腂 腃 腄 腅 腆 腇 腈 腉 腊 腋 腌 腍 腎 腏 
8150 腐 腑 腒 腓 腔 腕 腖 腗 腘 腙 腚 腛 腜 腝 腞 腟 
8160 腠 腡 腢 腣 腤 腥 腦 腧 腨 腩 腪 腫 腬 腭 腮 腯 
8170 腰 腱 腲 腳 腴 腵 腶 腷 腸 腹 腺 腻 腼 腽 腾 腿 
8180 膀 膁 膂 膃 膄 膅 膆 膇 膈 膉 膊 膋 膌 膍 膎 膏 
8190 膐 膑 膒 膓 膔 膕 膖 膗 膘 膙 膚 膛 膜 膝 膞 膟 
81a0 膠 膡 膢 膣 膤 膥 膦 膧 膨 膩 膪 膫 膬 膭 膮 膯 
81b0 膰 膱 膲 膳 膴 膵 膶 膷 膸 膹 膺 膻 膼 膽 膾 膿 
81c0 臀 臁 臂 臃 臄 臅 臆 臇 臈 臉 臊 臋 臌 臍 臎 臏 
81d0 臐 臑 臒 臓 臔 臕 臖 臗 臘 臙 臚 臛 臜 臝 臞 臟 
81e0 臠 臡 臢 臣 臤 臥 臦 臧 臨 臩 自 臫 臬 臭 臮 臯 
81f0 臰 臱 臲 至 致 臵 臶 臷 臸 臹 臺 臻 臼 臽 臾 臿 
8200 舀 舁 舂 舃 舄 舅 舆 與 興 舉 舊 舋 舌 舍 舎 舏 
8210 舐 舑 舒 舓 舔 舕 舖 舗 舘 舙 舚 舛 舜 舝 舞 舟 


-------------------------------------------------------

42 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
8220 舠 舡 舢 舣 舤 舥 舦 舧 舨 舩 航 舫 般 舭 舮 舯 
8230 舰 舱 舲 舳 舴 舵 舶 舷 舸 船 舺 舻 舼 舽 舾 舿 
8240 艀 艁 艂 艃 艄 艅 艆 艇 艈 艉 艊 艋 艌 艍 艎 艏 
8250 艐 艑 艒 艓 艔 艕 艖 艗 艘 艙 艚 艛 艜 艝 艞 艟 
8260 艠 艡 艢 艣 艤 艥 艦 艧 艨 艩 艪 艫 艬 艭 艮 良 
8270 艰 艱 色 艳 艴 艵 艶 艷 艸 艹 艺 艻 艼 艽 艾 艿 
8280 芀 芁 节 芃 芄 芅 芆 芇 芈 芉 芊 芋 芌 芍 芎 芏 
8290 芐 芑 芒 芓 芔 芕 芖 芗 芘 芙 芚 芛 芜 芝 芞 芟 
82a0 芠 芡 芢 芣 芤 芥 芦 芧 芨 芩 芪 芫 芬 芭 芮 芯 
82b0 芰 花 芲 芳 芴 芵 芶 芷 芸 芹 芺 芻 芼 芽 芾 芿 
82c0 苀 苁 苂 苃 苄 苅 苆 苇 苈 苉 苊 苋 苌 苍 苎 苏 
82d0 苐 苑 苒 苓 苔 苕 苖 苗 苘 苙 苚 苛 苜 苝 苞 苟 
82e0 苠 苡 苢 苣 苤 若 苦 苧 苨 苩 苪 苫 苬 苭 苮 苯 
82f0 苰 英 苲 苳 苴 苵 苶 苷 苸 苹 苺 苻 苼 苽 苾 苿 
8300 茀 茁 茂 范 茄 茅 茆 茇 茈 茉 茊 茋 茌 茍 茎 茏 
8310 茐 茑 茒 茓 茔 茕 茖 茗 茘 茙 茚 茛 茜 茝 茞 茟 
8320 茠 茡 茢 茣 茤 茥 茦 茧 茨 茩 茪 茫 茬 茭 茮 茯 
8330 茰 茱 茲 茳 茴 茵 茶 茷 茸 茹 茺 茻 茼 茽 茾 茿 
8340 荀 荁 荂 荃 荄 荅 荆 荇 荈 草 荊 荋 荌 荍 荎 荏 
8350 荐 荑 荒 荓 荔 荕 荖 荗 荘 荙 荚 荛 荜 荝 荞 荟 
8360 荠 荡 荢 荣 荤 荥 荦 荧 荨 荩 荪 荫 荬 荭 荮 药 


-------------------------------------------------------

43 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
8370 荰 荱 荲 荳 荴 荵 荶 荷 荸 荹 荺 荻 荼 荽 荾 荿 
8380 莀 莁 莂 莃 莄 莅 莆 莇 莈 莉 莊 莋 莌 莍 莎 莏 
8390 莐 莑 莒 莓 莔 莕 莖 莗 莘 莙 莚 莛 莜 莝 莞 莟 
83a0 莠 莡 莢 莣 莤 莥 莦 莧 莨 莩 莪 莫 莬 莭 莮 莯 
83b0 莰 莱 莲 莳 莴 莵 莶 获 莸 莹 莺 莻 莼 莽 莾 莿 
83c0 菀 菁 菂 菃 菄 菅 菆 菇 菈 菉 菊 菋 菌 菍 菎 菏 
83d0 菐 菑 菒 菓 菔 菕 菖 菗 菘 菙 菚 菛 菜 菝 菞 菟 
83e0 菠 菡 菢 菣 菤 菥 菦 菧 菨 菩 菪 菫 菬 菭 菮 華 
83f0 菰 菱 菲 菳 菴 菵 菶 菷 菸 菹 菺 菻 菼 菽 菾 菿 
8400 萀 萁 萂 萃 萄 萅 萆 萇 萈 萉 萊 萋 萌 萍 萎 萏 
8410 萐 萑 萒 萓 萔 萕 萖 萗 萘 萙 萚 萛 萜 萝 萞 萟 
8420 萠 萡 萢 萣 萤 营 萦 萧 萨 萩 萪 萫 萬 萭 萮 萯 
8430 萰 萱 萲 萳 萴 萵 萶 萷 萸 萹 萺 萻 萼 落 萾 萿 
8440 葀 葁 葂 葃 葄 葅 葆 葇 葈 葉 葊 葋 葌 葍 葎 葏 
8450 葐 葑 葒 葓 葔 葕 葖 著 葘 葙 葚 葛 葜 葝 葞 葟 
8460 葠 葡 葢 董 葤 葥 葦 葧 葨 葩 葪 葫 葬 葭 葮 葯 
8470 葰 葱 葲 葳 葴 葵 葶 葷 葸 葹 葺 葻 葼 葽 葾 葿 
8480 蒀 蒁 蒂 蒃 蒄 蒅 蒆 蒇 蒈 蒉 蒊 蒋 蒌 蒍 蒎 蒏 
8490 蒐 蒑 蒒 蒓 蒔 蒕 蒖 蒗 蒘 蒙 蒚 蒛 蒜 蒝 蒞 蒟 
84a0 蒠 蒡 蒢 蒣 蒤 蒥 蒦 蒧 蒨 蒩 蒪 蒫 蒬 蒭 蒮 蒯 
84b0 蒰 蒱 蒲 蒳 蒴 蒵 蒶 蒷 蒸 蒹 蒺 蒻 蒼 蒽 蒾 蒿 


-------------------------------------------------------

44 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
84c0 蓀 蓁 蓂 蓃 蓄 蓅 蓆 蓇 蓈 蓉 蓊 蓋 蓌 蓍 蓎 蓏 
84d0 蓐 蓑 蓒 蓓 蓔 蓕 蓖 蓗 蓘 蓙 蓚 蓛 蓜 蓝 蓞 蓟 
84e0 蓠 蓡 蓢 蓣 蓤 蓥 蓦 蓧 蓨 蓩 蓪 蓫 蓬 蓭 蓮 蓯 
84f0 蓰 蓱 蓲 蓳 蓴 蓵 蓶 蓷 蓸 蓹 蓺 蓻 蓼 蓽 蓾 蓿 
8500 蔀 蔁 蔂 蔃 蔄 蔅 蔆 蔇 蔈 蔉 蔊 蔋 蔌 蔍 蔎 蔏 
8510 蔐 蔑 蔒 蔓 蔔 蔕 蔖 蔗 蔘 蔙 蔚 蔛 蔜 蔝 蔞 蔟 
8520 蔠 蔡 蔢 蔣 蔤 蔥 蔦 蔧 蔨 蔩 蔪 蔫 蔬 蔭 蔮 蔯 
8530 蔰 蔱 蔲 蔳 蔴 蔵 蔶 蔷 蔸 蔹 蔺 蔻 蔼 蔽 蔾 蔿 
8540 蕀 蕁 蕂 蕃 蕄 蕅 蕆 蕇 蕈 蕉 蕊 蕋 蕌 蕍 蕎 蕏 
8550 蕐 蕑 蕒 蕓 蕔 蕕 蕖 蕗 蕘 蕙 蕚 蕛 蕜 蕝 蕞 蕟 
8560 蕠 蕡 蕢 蕣 蕤 蕥 蕦 蕧 蕨 蕩 蕪 蕫 蕬 蕭 蕮 蕯 
8570 蕰 蕱 蕲 蕳 蕴 蕵 蕶 蕷 蕸 蕹 蕺 蕻 蕼 蕽 蕾 蕿 
8580 薀 薁 薂 薃 薄 薅 薆 薇 薈 薉 薊 薋 薌 薍 薎 薏 
8590 薐 薑 薒 薓 薔 薕 薖 薗 薘 薙 薚 薛 薜 薝 薞 薟 
85a0 薠 薡 薢 薣 薤 薥 薦 薧 薨 薩 薪 薫 薬 薭 薮 薯 
85b0 薰 薱 薲 薳 薴 薵 薶 薷 薸 薹 薺 薻 薼 薽 薾 薿 
85c0 藀 藁 藂 藃 藄 藅 藆 藇 藈 藉 藊 藋 藌 藍 藎 藏 
85d0 藐 藑 藒 藓 藔 藕 藖 藗 藘 藙 藚 藛 藜 藝 藞 藟 
85e0 藠 藡 藢 藣 藤 藥 藦 藧 藨 藩 藪 藫 藬 藭 藮 藯 
85f0 藰 藱 藲 藳 藴 藵 藶 藷 藸 藹 藺 藻 藼 藽 藾 藿 
8600 蘀 蘁 蘂 蘃 蘄 蘅 蘆 蘇 蘈 蘉 蘊 蘋 蘌 蘍 蘎 蘏 


-------------------------------------------------------

45 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
8610 蘐 蘑 蘒 蘓 蘔 蘕 蘖 蘗 蘘 蘙 蘚 蘛 蘜 蘝 蘞 蘟 
8620 蘠 蘡 蘢 蘣 蘤 蘥 蘦 蘧 蘨 蘩 蘪 蘫 蘬 蘭 蘮 蘯 
8630 蘰 蘱 蘲 蘳 蘴 蘵 蘶 蘷 蘸 蘹 蘺 蘻 蘼 蘽 蘾 蘿 
8640 虀 虁 虂 虃 虄 虅 虆 虇 虈 虉 虊 虋 虌 虍 虎 虏 
8650 虐 虑 虒 虓 虔 處 虖 虗 虘 虙 虚 虛 虜 虝 虞 號 
8660 虠 虡 虢 虣 虤 虥 虦 虧 虨 虩 虪 虫 虬 虭 虮 虯 
8670 虰 虱 虲 虳 虴 虵 虶 虷 虸 虹 虺 虻 虼 虽 虾 虿 
8680 蚀 蚁 蚂 蚃 蚄 蚅 蚆 蚇 蚈 蚉 蚊 蚋 蚌 蚍 蚎 蚏 
8690 蚐 蚑 蚒 蚓 蚔 蚕 蚖 蚗 蚘 蚙 蚚 蚛 蚜 蚝 蚞 蚟 
86a0 蚠 蚡 蚢 蚣 蚤 蚥 蚦 蚧 蚨 蚩 蚪 蚫 蚬 蚭 蚮 蚯 
86b0 蚰 蚱 蚲 蚳 蚴 蚵 蚶 蚷 蚸 蚹 蚺 蚻 蚼 蚽 蚾 蚿 
86c0 蛀 蛁 蛂 蛃 蛄 蛅 蛆 蛇 蛈 蛉 蛊 蛋 蛌 蛍 蛎 蛏 
86d0 蛐 蛑 蛒 蛓 蛔 蛕 蛖 蛗 蛘 蛙 蛚 蛛 蛜 蛝 蛞 蛟 
86e0 蛠 蛡 蛢 蛣 蛤 蛥 蛦 蛧 蛨 蛩 蛪 蛫 蛬 蛭 蛮 蛯 
86f0 蛰 蛱 蛲 蛳 蛴 蛵 蛶 蛷 蛸 蛹 蛺 蛻 蛼 蛽 蛾 蛿 
8700 蜀 蜁 蜂 蜃 蜄 蜅 蜆 蜇 蜈 蜉 蜊 蜋 蜌 蜍 蜎 蜏 
8710 蜐 蜑 蜒 蜓 蜔 蜕 蜖 蜗 蜘 蜙 蜚 蜛 蜜 蜝 蜞 蜟 
8720 蜠 蜡 蜢 蜣 蜤 蜥 蜦 蜧 蜨 蜩 蜪 蜫 蜬 蜭 蜮 蜯 
8730 蜰 蜱 蜲 蜳 蜴 蜵 蜶 蜷 蜸 蜹 蜺 蜻 蜼 蜽 蜾 蜿 
8740 蝀 蝁 蝂 蝃 蝄 蝅 蝆 蝇 蝈 蝉 蝊 蝋 蝌 蝍 蝎 蝏 
8750 蝐 蝑 蝒 蝓 蝔 蝕 蝖 蝗 蝘 蝙 蝚 蝛 蝜 蝝 蝞 蝟 


-------------------------------------------------------

46 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------  
8760 蝠 蝡 蝢 蝣 蝤 蝥 蝦 蝧 蝨 蝩 蝪 蝫 蝬 蝭 蝮 蝯 
8770 蝰 蝱 蝲 蝳 蝴 蝵 蝶 蝷 蝸 蝹 蝺 蝻 蝼 蝽 蝾 蝿 
8780 螀 螁 螂 螃 螄 螅 螆 螇 螈 螉 螊 螋 螌 融 螎 螏 
8790 螐 螑 螒 螓 螔 螕 螖 螗 螘 螙 螚 螛 螜 螝 螞 螟 
87a0 螠 螡 螢 螣 螤 螥 螦 螧 螨 螩 螪 螫 螬 螭 螮 螯 
87b0 螰 螱 螲 螳 螴 螵 螶 螷 螸 螹 螺 螻 螼 螽 螾 螿 
87c0 蟀 蟁 蟂 蟃 蟄 蟅 蟆 蟇 蟈 蟉 蟊 蟋 蟌 蟍 蟎 蟏 
87d0 蟐 蟑 蟒 蟓 蟔 蟕 蟖 蟗 蟘 蟙 蟚 蟛 蟜 蟝 蟞 蟟 
87e0 蟠 蟡 蟢 蟣 蟤 蟥 蟦 蟧 蟨 蟩 蟪 蟫 蟬 蟭 蟮 蟯 
87f0 蟰 蟱 蟲 蟳 蟴 蟵 蟶 蟷 蟸 蟹 蟺 蟻 蟼 蟽 蟾 蟿 
8800 蠀 蠁 蠂 蠃 蠄 蠅 蠆 蠇 蠈 蠉 蠊 蠋 蠌 蠍 蠎 蠏 
8810 蠐 蠑 蠒 蠓 蠔 蠕 蠖 蠗 蠘 蠙 蠚 蠛 蠜 蠝 蠞 蠟 
8820 蠠 蠡 蠢 蠣 蠤 蠥 蠦 蠧 蠨 蠩 蠪 蠫 蠬 蠭 蠮 蠯 
8830 蠰 蠱 蠲 蠳 蠴 蠵 蠶 蠷 蠸 蠹 蠺 蠻 蠼 蠽 蠾 蠿 
8840 血 衁 衂 衃 衄 衅 衆 衇 衈 衉 衊 衋 行 衍 衎 衏 
8850 衐 衑 衒 術 衔 衕 衖 街 衘 衙 衚 衛 衜 衝 衞 衟 
8860 衠 衡 衢 衣 衤 补 衦 衧 表 衩 衪 衫 衬 衭 衮 衯 
8870 衰 衱 衲 衳 衴 衵 衶 衷 衸 衹 衺 衻 衼 衽 衾 衿 
8880 袀 袁 袂 袃 袄 袅 袆 袇 袈 袉 袊 袋 袌 袍 袎 袏 
8890 袐 袑 袒 袓 袔 袕 袖 袗 袘 袙 袚 袛 袜 袝 袞 袟 
88a0 袠 袡 袢 袣 袤 袥 袦 袧 袨 袩 袪 被 袬 袭 袮 袯 
88b0 袰 袱 袲 袳 袴 袵 袶 袷 袸 袹 袺 袻 袼 袽 袾 袿 
88c0 裀 裁 裂 裃 裄 装 裆 裇 裈 裉 裊 裋 裌 裍 裎 裏 
88d0 裐 裑 裒 裓 裔 裕 裖 裗 裘 裙 裚 裛 補 裝 裞 裟  


-------------------------------------------------------

47 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
88e0 裠 裡 裢 裣 裤 裥 裦 裧 裨 裩 裪 裫 裬 裭 裮 裯 
88f0 裰 裱 裲 裳 裴 裵 裶 裷 裸 裹 裺 裻 裼 製 裾 裿 
8900 褀 褁 褂 褃 褄 褅 褆 複 褈 褉 褊 褋 褌 褍 褎 褏 
8910 褐 褑 褒 褓 褔 褕 褖 褗 褘 褙 褚 褛 褜 褝 褞 褟 
8920 褠 褡 褢 褣 褤 褥 褦 褧 褨 褩 褪 褫 褬 褭 褮 褯 
8930 褰 褱 褲 褳 褴 褵 褶 褷 褸 褹 褺 褻 褼 褽 褾 褿 
8940 襀 襁 襂 襃 襄 襅 襆 襇 襈 襉 襊 襋 襌 襍 襎 襏 
8950 襐 襑 襒 襓 襔 襕 襖 襗 襘 襙 襚 襛 襜 襝 襞 襟 
8960 襠 襡 襢 襣 襤 襥 襦 襧 襨 襩 襪 襫 襬 襭 襮 襯 
8970 襰 襱 襲 襳 襴 襵 襶 襷 襸 襹 襺 襻 襼 襽 襾 西 
8980 覀 要 覂 覃 覄 覅 覆 覇 覈 覉 覊 見 覌 覍 覎 規 
8990 覐 覑 覒 覓 覔 覕 視 覗 覘 覙 覚 覛 覜 覝 覞 覟 
89a0 覠 覡 覢 覣 覤 覥 覦 覧 覨 覩 親 覫 覬 覭 覮 覯 
89b0 覰 覱 覲 観 覴 覵 覶 覷 覸 覹 覺 覻 覼 覽 覾 覿 
89c0 觀 见 观 觃 规 觅 视 觇 览 觉 觊 觋 觌 觍 觎 觏 
89d0 觐 觑 角 觓 觔 觕 觖 觗 觘 觙 觚 觛 觜 觝 觞 觟 
89e0 觠 觡 觢 解 觤 觥 触 觧 觨 觩 觪 觫 觬 觭 觮 觯 
89f0 觰 觱 觲 觳 觴 觵 觶 觷 觸 觹 觺 觻 觼 觽 觾 觿 
8a00 言 訁 訂 訃 訄 訅 訆 訇 計 訉 訊 訋 訌 訍 討 訏 
8a10 訐 訑 訒 訓 訔 訕 訖 託 記 訙 訚 訛 訜 訝 訞 訟 
8a20 訠 訡 訢 訣 訤 訥 訦 訧 訨 訩 訪 訫 訬 設 訮 訯 


-------------------------------------------------------

48 汉字编码表 

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
8a30 訰 許 訲 訳 訴 訵 訶 訷 訸 訹 診 註 証 訽 訾 訿 
8a40 詀 詁 詂 詃 詄 詅 詆 詇 詈 詉 詊 詋 詌 詍 詎 詏 
8a50 詐 詑 詒 詓 詔 評 詖 詗 詘 詙 詚 詛 詜 詝 詞 詟 
8a60 詠 詡 詢 詣 詤 詥 試 詧 詨 詩 詪 詫 詬 詭 詮 詯 
8a70 詰 話 該 詳 詴 詵 詶 詷 詸 詹 詺 詻 詼 詽 詾 詿 
8a80 誀 誁 誂 誃 誄 誅 誆 誇 誈 誉 誊 誋 誌 認 誎 誏 
8a90 誐 誑 誒 誓 誔 誕 誖 誗 誘 誙 誚 誛 誜 誝 語 誟 
8aa0 誠 誡 誢 誣 誤 誥 誦 誧 誨 誩 說 誫 説 読 誮 誯 
8ab0 誰 誱 課 誳 誴 誵 誶 誷 誸 誹 誺 誻 誼 誽 誾 調 
8ac0 諀 諁 諂 諃 諄 諅 諆 談 諈 諉 諊 請 諌 諍 諎 諏 
8ad0 諐 諑 諒 諓 諔 諕 論 諗 諘 諙 諚 諛 諜 諝 諞 諟 
8ae0 諠 諡 諢 諣 諤 諥 諦 諧 諨 諩 諪 諫 諬 諭 諮 諯 
8af0 諰 諱 諲 諳 諴 諵 諶 諷 諸 諹 諺 諻 諼 諽 諾 諿 
8b00 謀 謁 謂 謃 謄 謅 謆 謇 謈 謉 謊 謋 謌 謍 謎 謏 
8b10 謐 謑 謒 謓 謔 謕 謖 謗 謘 謙 謚 講 謜 謝 謞 謟 
8b20 謠 謡 謢 謣 謤 謥 謦 謧 謨 謩 謪 謫 謬 謭 謮 謯 
8b30 謰 謱 謲 謳 謴 謵 謶 謷 謸 謹 謺 謻 謼 謽 謾 謿 
8b40 譀 譁 譂 譃 譄 譅 譆 譇 譈 證 譊 譋 譌 譍 譎 譏 
8b50 譐 譑 譒 譓 譔 譕 譖 譗 識 譙 譚 譛 譜 譝 譞 譟 
8b60 譠 譡 譢 譣 譤 譥 警 譧 譨 譩 譪 譫 譬 譭 譮 譯 
8b70 議 譱 譲 譳 譴 譵 譶 護 譸 譹 譺 譻 譼 譽 譾 譿 


-------------------------------------------------------

49 汉字编码表 

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
8B70 議 譱 譲 譳 譴 譵 譶 護 譸 譹 譺 譻 譼 譽 譾 譿  
8B80 讀 讁 讂 讃 讄 讅 讆 讇 讈 讉 變 讋 讌 讍 讎 讏 
8B90 讐 讑 讒 讓 讔 讕 讖 讗 讘 讙 讚 讛 讜 讝 讞 讟 
8BA0 讠 计 订 讣 认 讥 讦 讧 讨 让 讪 讫 讬 训 议 讯 
8BB0 记 讱 讲 讳 讴 讵 讶 讷 许 讹 论 讻 讼 讽 设 访  
8BC0 诀 证 诂 诃 评 诅 识 诇 诈 诉 诊 诋 诌 词 诎 诏  
8BD0 诐 译 诒 诓 诔 试 诖 诗 诘 诙 诚 诛 诜 话 诞 诟 
8BE0 诠 诡 询 诣 诤 该 详 诧 诨 诩 诪 诫 诬 语 诮 误 
8BF0 诰 诱 诲 诳 说 诵 诶 请 诸 诹 诺 读 诼 诽 课 诿  
8C00 谀 谁 谂 调 谄 谅 谆 谇 谈 谉 谊 谋 谌 谍 谎 谏  
8C10 谐 谑 谒 谓 谔 谕 谖 谗 谘 谙 谚 谛 谜 谝 谞 谟 
8C20 谠 谡 谢 谣 谤 谥 谦 谧 谨 谩 谪 谫 谬 谭 谮 谯 
8C30 谰 谱 谲 谳 谴 谵 谶 谷 谸 谹 谺 谻 谼 谽 谾 谿  
8C40 豀 豁 豂 豃 豄 豅 豆 豇 豈 豉 豊 豋 豌 豍 豎 豏 
8C50 豐 豑 豒 豓 豔 豕 豖 豗 豘 豙 豚 豛 豜 豝 豞 豟 
8C60 豠 象 豢 豣 豤 豥 豦 豧 豨 豩 豪 豫 豬 豭 豮 豯
8C70 豰 豱 豲 豳 豴 豵 豶 豷 豸 豹 豺 豻 豼 豽 豾 豿  
8C80 貀 貁 貂 貃 貄 貅 貆 貇 貈 貉 貊 貋 貌 貍 貎 貏 
8C90 貐 貑 貒 貓 貔 貕 貖 貗 貘 貙 貚 貛 貜 貝 貞 貟


-------------------------------------------------------

50 汉字编码表 

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
8CA0 負 財 貢 貣 貤 貥 貦 貧 貨 販 貪 貫 責 貭 貮 貯 
8CB0 貰 貱 貲 貳 貴 貵 貶 買 貸 貹 貺 費 貼 貽 貾 貿  
8CC0 賀 賁 賂 賃 賄 賅 賆 資 賈 賉 賊 賋 賌 賍 賎 賏  
8CD0 賐 賑 賒 賓 賔 賕 賖 賗 賘 賙 賚 賛 賜 賝 賞 賟  
8CE0 賠 賡 賢 賣 賤 賥 賦 賧 賨 賩 質 賫 賬 賭 賮 賯 
8CF0 賰 賱 賲 賳 賴 賵 賶 賷 賸 賹 賺 賻 購 賽 賾 賿  
8D00 贀 贁 贂 贃 贄 贅 贆 贇 贈 贉 贊 贋 贌 贍 贎 贏  
8D10 贐 贑 贒 贓 贔 贕 贖 贗 贘 贙 贚 贛 贜 贝 贞 负  
8D20 贠 贡 财 责 贤 败 账 货 质 贩 贪 贫 贬 购 贮 贯  
8D30 贰 贱 贲 贳 贴 贵 贶 贷 贸 费 贺 贻 贼 贽 贾 贿  
8D40 赀 赁 赂 赃 资 赅 赆 赇 赈 赉 赊 赋 赌 赍 赎 赏 
8D50 赐 赑 赒 赓 赔 赕 赖 赗 赘 赙 赚 赛 赜 赝 赞 赟  
8D60 赠 赡 赢 赣 赤 赥 赦 赧 赨 赩 赪 赫 赬 赭 赮 赯


-------------------------------------------------------


51 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
8D70 走 赱 赲 赳 赴 赵 赶 起 赸 赹 赺 赻 赼 赽 赾 赿 
8D80 趀 趁 趂 趃 趄 超 趆 趇 趈 趉 越 趋 趌 趍 趎 趏  
8D90 趐 趑 趒 趓 趔 趕 趖 趗 趘 趙 趚 趛 趜 趝 趞 趟 
8DA0 趠 趡 趢 趣 趤 趥 趦 趧 趨 趩 趪 趫 趬 趭 趮 趯 
8DB0 趰 趱 趲 足 趴 趵 趶 趷 趸 趹 趺 趻 趼 趽 趾 趿  
8DC0 跀 跁 跂 跃 跄 跅 跆 跇 跈 跉 跊 跋 跌 跍 跎 跏 
8DD0 跐 跑 跒 跓 跔 跕 跖 跗 跘 跙 跚 跛 跜 距 跞 跟 
8DE0 跠 跡 跢 跣 跤 跥 跦 跧 跨 跩 跪 跫 跬 跭 跮 路 
8DF0 跰 跱 跲 跳 跴 践 跶 跷 跸 跹 跺 跻 跼 跽 跾 跿 
8E00 踀 踁 踂 踃 踄 踅 踆 踇 踈 踉 踊 踋 踌 踍 踎 踏 
8E10 踐 踑 踒 踓 踔 踕 踖 踗 踘 踙 踚 踛 踜 踝 踞 踟 
8E20 踠 踡 踢 踣 踤 踥 踦 踧 踨 踩 踪 踫 踬 踭 踮 踯 
8E30 踰 踱 踲 踳 踴 踵 踶 踷 踸 踹 踺 踻 踼 踽 踾 踿 
8E40 蹀 蹁 蹂 蹃 蹄 蹅 蹆 蹇 蹈 蹉 蹊 蹋 蹌 蹍 蹎 蹏 
8E50 蹐 蹑 蹒 蹓 蹔 蹕 蹖 蹗 蹘 蹙 蹚 蹛 蹜 蹝 蹞 蹟 
8E60 蹠 蹡 蹢 蹣 蹤 蹥 蹦 蹧 蹨 蹩 蹪 蹫 蹬 蹭 蹮 蹯 
8E70 蹰 蹱 蹲 蹳 蹴 蹵 蹶 蹷 蹸 蹹 蹺 蹻 蹼 蹽 蹾 蹿 
8E80 躀 躁 躂 躃 躄 躅 躆 躇 躈 躉 躊 躋 躌 躍 躎 躏 
8E90 躐 躑 躒 躓 躔 躕 躖 躗 躘 躙 躚 躛 躜 躝 躞 躟 
8EA0 躠 躡 躢 躣 躤 躥 躦 躧 躨 躩 躪 身 躬 躭 躮 躯 
8EB0 躰 躱 躲 躳 躴 躵 躶 躷 躸 躹 躺 躻 躼 躽 躾 躿 
8EC0 軀 軁 軂 軃 軄 軅 軆 軇 軈 軉 車 軋 軌 軍 軎 軏 
8ED0 軐 軑 軒 軓 軔 軕 軖 軗 軘 軙 軚 軛 軜 軝 軞 軟 
8EE0 軠 軡 転 軣 軤 軥 軦 軧 軨 軩 軪 軫 軬 軭 軮 軯 
8EF0 軰 軱 軲 軳 軴 軵 軶 軷 軸 軹 軺 軻 軼 軽 軾 軿 
8F00 輀 輁 輂 較 輄 輅 輆 輇 輈 載 輊 輋 輌 輍 輎 輏 
8F10 輐 輑 輒 輓 輔 輕 輖 輗 輘 輙 輚 輛 輜 輝 輞 輟 
8F20 輠 輡 輢 輣 輤 輥 輦 輧 輨 輩 輪 輫 輬 輭 輮 輯 
8F30 輰 輱 輲 輳 輴 輵 輶 輷 輸 輹 輺 輻 輼 輽 輾 輿 
8F40 轀 轁 轂 轃 轄 轅 轆 轇 轈 轉 轊 轋 轌 轍 轎 轏 
8F50 轐 轑 轒 轓 轔 轕 轖 轗 轘 轙 轚 轛 轜 轝 轞 轟


---------------------------------------------------------

52 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
8F60 轠 轡 轢 轣 轤 轥 车 轧 轨 轩 轪 轫 转 轭 轮 软 
8F70 轰 轱 轲 轳 轴 轵 轶 轷 轸 轹 轺 轻 轼 载 轾 轿 
8F80 辀 辁 辂 较 辄 辅 辆 辇 辈 辉 辊 辋 辌 辍 辎 辏 
8F90 辐 辑 辒 输 辔 辕 辖 辗 辘 辙 辚 辛 辜 辝 辞 辟 
8FA0 辠 辡 辢 辣 辤 辥 辦 辧 辨 辩 辪 辫 辬 辭 辮 辯 
8FB0 辰 辱 農 辳 辴 辵 辶 辷 辸 边 辺 辻 込 辽 达 辿 
8FC0 迀 迁 迂 迃 迄 迅 迆 过 迈 迉 迊 迋 迌 迍 迎 迏 
8FD0 运 近 迒 迓 返 迕 迖 迗 还 这 迚 进 远 违 连 迟 
8FE0 迠 迡 迢 迣 迤 迥 迦 迧 迨 迩 迪 迫 迬 迭 迮 迯 
8FF0 述 迱 迲 迳 迴 迵 迶 迷 迸 迹 迺 迻 迼 追 迾 迿 
9000 退 送 适 逃 逄 逅 逆 逇 逈 选 逊 逋 逌 逍 逎 透 
9010 逐 逑 递 逓 途 逕 逖 逗 逘 這 通 逛 逜 逝 逞 速 
9020 造 逡 逢 連 逤 逥 逦 逧 逨 逩 逪 逫 逬 逭 逮 逯 
9030 逰 週 進 逳 逴 逵 逶 逷 逸 逹 逺 逻 逼 逽 逾 逿 
9040 遀 遁 遂 遃 遄 遅 遆 遇 遈 遉 遊 運 遌 遍 過 遏 
9050 遐 遑 遒 道 達 違 遖 遗 遘 遙 遚 遛 遜 遝 遞 遟 
9060 遠 遡 遢 遣 遤 遥 遦 遧 遨 適 遪 遫 遬 遭 遮 遯 
9070 遰 遱 遲 遳 遴 遵 遶 遷 選 遹 遺 遻 遼 遽 遾 避 
9080 邀 邁 邂 邃 還 邅 邆 邇 邈 邉 邊 邋 邌 邍 邎 邏


---------------------------------------------------------

53 汉字编码表

 U+  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
9090 邐 邑 邒 邓 邔 邕 邖 邗 邘 邙 邚 邛 邜 邝 邞 邟 
90A0 邠 邡 邢 那 邤 邥 邦 邧 邨 邩 邪 邫 邬 邭 邮 邯 
90B0 邰 邱 邲 邳 邴 邵 邶 邷 邸 邹 邺 邻 邼 邽 邾 邿 
90C0 郀 郁 郂 郃 郄 郅 郆 郇 郈 郉 郊 郋 郌 郍 郎 郏 
90D0 郐 郑 郒 郓 郔 郕 郖 郗 郘 郙 郚 郛 郜 郝 郞 郟 
90E0 郠 郡 郢 郣 郤 郥 郦 郧 部 郩 郪 郫 郬 郭 郮 郯 
90F0 郰 郱 郲 郳 郴 郵 郶 郷 郸 郹 郺 郻 郼 都 郾 郿 
9100 鄀 鄁 鄂 鄃 鄄 鄅 鄆 鄇 鄈 鄉 鄊 鄋 鄌 鄍 鄎 鄏 
9110 鄐 鄑 鄒 鄓 鄔 鄕 鄖 鄗 鄘 鄙 鄚 鄛 鄜 鄝 鄞 鄟 
9120 鄠 鄡 鄢 鄣 鄤 鄥 鄦 鄧 鄨 鄩 鄪 鄫 鄬 鄭 鄮 鄯 
9130 鄰 鄱 鄲 鄳 鄴 鄵 鄶 鄷 鄸 鄹 鄺 鄻 鄼 鄽 鄾 鄿 
9140 酀 酁 酂 酃 酄 酅 酆 酇 酈 酉 酊 酋 酌 配 酎 酏 
9150 酐 酑 酒 酓 酔 酕 酖 酗 酘 酙 酚 酛 酜 酝 酞 酟 
9160 酠 酡 酢 酣 酤 酥 酦 酧 酨 酩 酪 酫 酬 酭 酮 酯 
9170 酰 酱 酲 酳 酴 酵 酶 酷 酸 酹 酺 酻 酼 酽 酾 酿 
9180 醀 醁 醂 醃 醄 醅 醆 醇 醈 醉 醊 醋 醌 醍 醎 醏 
9190 醐 醑 醒 醓 醔 醕 醖 醗 醘 醙 醚 醛 醜 醝 醞 醟 
91A0 醠 醡 醢 醣 醤 醥 醦 醧 醨 醩 醪 醫 醬 醭 醮 醯 
91B0 醰 醱 醲 醳 醴 醵 醶 醷 醸 醹 醺 醻 醼 醽 醾 醿 
91C0 釀 釁 釂 釃 釄 釅 釆 采 釈 釉 释 釋 里 重 野 量 
91D0 釐 金 釒 釓 釔 釕 釖 釗 釘 釙 釚 釛 釜 針 釞 釟 
91E0 釠 釡 釢 釣 釤 釥 釦 釧 釨 釩 釪 釫 釬 釭 釮 釯 
91F0 釰 釱 釲 釳 釴 釵 釶 釷 釸 釹 釺 釻 釼 釽 釾 釿 
9200 鈀 鈁 鈂 鈃 鈄 鈅 鈆 鈇 鈈 鈉 鈊 鈋 鈌 鈍 鈎 鈏 
9210 鈐 鈑 鈒 鈓 鈔 鈕 鈖 鈗 鈘 鈙 鈚 鈛 鈜 鈝 鈞 鈟 


-------------------------------------------------------

54 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
9210 鈐 鈑 鈒 鈓 鈔 鈕 鈖 鈗 鈘 鈙 鈚 鈛 鈜 鈝 鈞 鈟 
9220 鈠 鈡 鈢 鈣 鈤 鈥 鈦 鈧 鈨 鈩 鈪 鈫 鈬 鈭 鈮 鈯 
9230 鈰 鈱 鈲 鈳 鈴 鈵 鈶 鈷 鈸 鈹 鈺 鈻 鈼 鈽 鈾 鈿 
9240 鉀 鉁 鉂 鉃 鉄 鉅 鉆 鉇 鉈 鉉 鉊 鉋 鉌 鉍 鉎 鉏 
9250 鉐 鉑 鉒 鉓 鉔 鉕 鉖 鉗 鉘 鉙 鉚 鉛 鉜 鉝 鉞 鉟 
9260 鉠 鉡 鉢 鉣 鉤 鉥 鉦 鉧 鉨 鉩 鉪 鉫 鉬 鉭 鉮 鉯 
9270 鉰 鉱 鉲 鉳 鉴 鉵 鉶 鉷 鉸 鉹 鉺 鉻 鉼 鉽 鉾 鉿 
9280 銀 銁 銂 銃 銄 銅 銆 銇 銈 銉 銊 銋 銌 銍 銎 銏 
9290 銐 銑 銒 銓 銔 銕 銖 銗 銘 銙 銚 銛 銜 銝 銞 銟 
92a0 銠 銡 銢 銣 銤 銥 銦 銧 銨 銩 銪 銫 銬 銭 銮 銯 
92b0 銰 銱 銲 銳 銴 銵 銶 銷 銸 銹 銺 銻 銼 銽 銾 銿 
92c0 鋀 鋁 鋂 鋃 鋄 鋅 鋆 鋇 鋈 鋉 鋊 鋋 鋌 鋍 鋎 鋏 
92d0 鋐 鋑 鋒 鋓 鋔 鋕 鋖 鋗 鋘 鋙 鋚 鋛 鋜 鋝 鋞 鋟 
92e0 鋠 鋡 鋢 鋣 鋤 鋥 鋦 鋧 鋨 鋩 鋪 鋫 鋬 鋭 鋮 鋯 
92f0 鋰 鋱 鋲 鋳 鋴 鋵 鋶 鋷 鋸 鋹 鋺 鋻 鋼 鋽 鋾 鋿 
9300 錀 錁 錂 錃 錄 錅 錆 錇 錈 錉 錊 錋 錌 錍 錎 錏 
9310 錐 錑 錒 錓 錔 錕 錖 錗 錘 錙 錚 錛 錜 錝 錞 錟 
9320 錠 錡 錢 錣 錤 錥 錦 錧 錨 錩 錪 錫 錬 錭 錮 錯 
9330 錰 錱 録 錳 錴 錵 錶 錷 錸 錹 錺 錻 錼 錽 錾 錿 
9340 鍀 鍁 鍂 鍃 鍄 鍅 鍆 鍇 鍈 鍉 鍊 鍋 鍌 鍍 鍎 鍏 
9350 鍐 鍑 鍒 鍓 鍔 鍕 鍖 鍗 鍘 鍙 鍚 鍛 鍜 鍝 鍞 鍟 


---------------------------------------------------------

55 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------  
9360 鍠 鍡 鍢 鍣 鍤 鍥 鍦 鍧 鍨 鍩 鍪 鍫 鍬 鍭 鍮 鍯 
9370 鍰 鍱 鍲 鍳 鍴 鍵 鍶 鍷 鍸 鍹 鍺 鍻 鍼 鍽 鍾 鍿 
9380 鎀 鎁 鎂 鎃 鎄 鎅 鎆 鎇 鎈 鎉 鎊 鎋 鎌 鎍 鎎 鎏 
9390 鎐 鎑 鎒 鎓 鎔 鎕 鎖 鎗 鎘 鎙 鎚 鎛 鎜 鎝 鎞 鎟 
93a0 鎠 鎡 鎢 鎣 鎤 鎥 鎦 鎧 鎨 鎩 鎪 鎫 鎬 鎭 鎮 鎯 
93b0 鎰 鎱 鎲 鎳 鎴 鎵 鎶 鎷 鎸 鎹 鎺 鎻 鎼 鎽 鎾 鎿 
93c0 鏀 鏁 鏂 鏃 鏄 鏅 鏆 鏇 鏈 鏉 鏊 鏋 鏌 鏍 鏎 鏏 
93d0 鏐 鏑 鏒 鏓 鏔 鏕 鏖 鏗 鏘 鏙 鏚 鏛 鏜 鏝 鏞 鏟 
93e0 鏠 鏡 鏢 鏣 鏤 鏥 鏦 鏧 鏨 鏩 鏪 鏫 鏬 鏭 鏮 鏯 
93f0 鏰 鏱 鏲 鏳 鏴 鏵 鏶 鏷 鏸 鏹 鏺 鏻 鏼 鏽 鏾 鏿 
9400 鐀 鐁 鐂 鐃 鐄 鐅 鐆 鐇 鐈 鐉 鐊 鐋 鐌 鐍 鐎 鐏 
9410 鐐 鐑 鐒 鐓 鐔 鐕 鐖 鐗 鐘 鐙 鐚 鐛 鐜 鐝 鐞 鐟 
9420 鐠 鐡 鐢 鐣 鐤 鐥 鐦 鐧 鐨 鐩 鐪 鐫 鐬 鐭 鐮 鐯 
9430 鐰 鐱 鐲 鐳 鐴 鐵 鐶 鐷 鐸 鐹 鐺 鐻 鐼 鐽 鐾 鐿 
9440 鑀 鑁 鑂 鑃 鑄 鑅 鑆 鑇 鑈 鑉 鑊 鑋 鑌 鑍 鑎 鑏 
9450 鑐 鑑 鑒 鑓 鑔 鑕 鑖 鑗 鑘 鑙 鑚 鑛 鑜 鑝 鑞 鑟 
9460 鑠 鑡 鑢 鑣 鑤 鑥 鑦 鑧 鑨 鑩 鑪 鑫 鑬 鑭 鑮 鑯 
9470 鑰 鑱 鑲 鑳 鑴 鑵 鑶 鑷 鑸 鑹 鑺 鑻 鑼 鑽 鑾 鑿 
9480 钀 钁 钂 钃 钄 钅 钆 钇 针 钉 钊 钋 钌 钍 钎 钏 
9490 钐 钑 钒 钓 钔 钕 钖 钗 钘 钙 钚 钛 钜 钝 钞 钟 
94a0 钠 钡 钢 钣 钤 钥 钦 钧 钨 钩 钪 钫 钬 钭 钮 钯 
94b0 钰 钱 钲 钳 钴 钵 钶 钷 钸 钹 钺 钻 钼 钽 钾 钿 
94c0 铀 铁 铂 铃 铄 铅 铆 铇 铈 铉 铊 铋 铌 铍 铎 铏 
94d0 铐 铑 铒 铓 铔 铕 铖 铗 铘 铙 铚 铛 铜 铝 铞 铟 
94e0 铠 铡 铢 铣 铤 铥 铦 铧 铨 铩 铪 铫 铬 铭 铮 铯 
94f0 铰 铱 铲 铳 铴 铵 银 铷 铸 铹 铺 铻 铼 铽 链 铿 
9500 销 锁 锂 锃 锄 锅 锆 锇 锈 锉 锊 锋 锌 锍 锎 锏 
9510 锐 锑 锒 锓 锔 锕 锖 锗 锘 错 锚 锛 锜 锝 锞 锟 
9520 锠 锡 锢 锣 锤 锥 锦 锧 锨 锩 锪 锫 锬 锭 键 锯  


-------------------------------------------------------------

56 汉字编码表 

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
9530 锰 锱 锲 锳 锴 锵 锶 锷 锸 锹 锺 锻 锼 锽 锾 锿 
9540 镀 镁 镂 镃 镄 镅 镆 镇 镈 镉 镊 镋 镌 镍 镎 镏 
9550 镐 镑 镒 镓 镔 镕 镖 镗 镘 镙 镚 镛 镜 镝 镞 镟 
9560 镠 镡 镢 镣 镤 镥 镦 镧 镨 镩 镪 镫 镬 镭 镮 镯 
9570 镰 镱 镲 镳 镴 镵 镶 長 镸 镹 镺 镻 镼 镽 镾 长 
9580 門 閁 閂 閃 閄 閅 閆 閇 閈 閉 閊 開 閌 閍 閎 閏 
9590 閐 閑 閒 間 閔 閕 閖 閗 閘 閙 閚 閛 閜 閝 閞 閟 
95a0 閠 閡 関 閣 閤 閥 閦 閧 閨 閩 閪 閫 閬 閭 閮 閯 
95b0 閰 閱 閲 閳 閴 閵 閶 閷 閸 閹 閺 閻 閼 閽 閾 閿 
95c0 闀 闁 闂 闃 闄 闅 闆 闇 闈 闉 闊 闋 闌 闍 闎 闏 
95d0 闐 闑 闒 闓 闔 闕 闖 闗 闘 闙 闚 闛 關 闝 闞 闟 
95e0 闠 闡 闢 闣 闤 闥 闦 闧 门 闩 闪 闫 闬 闭 问 闯 
95f0 闰 闱 闲 闳 间 闵 闶 闷 闸 闹 闺 闻 闼 闽 闾 闿 
9600 阀 阁 阂 阃 阄 阅 阆 阇 阈 阉 阊 阋 阌 阍 阎 阏 
9610 阐 阑 阒 阓 阔 阕 阖 阗 阘 阙 阚 阛 阜 阝 阞 队 
9620 阠 阡 阢 阣 阤 阥 阦 阧 阨 阩 阪 阫 阬 阭 阮 阯 
9630 阰 阱 防 阳 阴 阵 阶 阷 阸 阹 阺 阻 阼 阽 阾 阿 
9640 陀 陁 陂 陃 附 际 陆 陇 陈 陉 陊 陋 陌 降 陎 陏 
9650 限 陑 陒 陓 陔 陕 陖 陗 陘 陙 陚 陛 陜 陝 陞 陟 
9660 陠 陡 院 陣 除 陥 陦 陧 陨 险 陪 陫 陬 陭 陮 陯 
9670 陰 陱 陲 陳 陴 陵 陶 陷 陸 陹 険 陻 陼 陽 陾 陿 


----------------------------------------------------------

57 汉字编码表 

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
9680 隀 隁 隂 隃 隄 隅 隆 隇 隈 隉 隊 隋 隌 隍 階 随 
9690 隐 隑 隒 隓 隔 隕 隖 隗 隘 隙 隚 際 障 隝 隞 隟 
96a0 隠 隡 隢 隣 隤 隥 隦 隧 隨 隩 險 隫 隬 隭 隮 隯 
96b0 隰 隱 隲 隳 隴 隵 隶 隷 隸 隹 隺 隻 隼 隽 难 隿 
96c0 雀 雁 雂 雃 雄 雅 集 雇 雈 雉 雊 雋 雌 雍 雎 雏 
96d0 雐 雑 雒 雓 雔 雕 雖 雗 雘 雙 雚 雛 雜 雝 雞 雟 
96e0 雠 雡 離 難 雤 雥 雦 雧 雨 雩 雪 雫 雬 雭 雮 雯 
96f0 雰 雱 雲 雳 雴 雵 零 雷 雸 雹 雺 電 雼 雽 雾 雿 
9700 需 霁 霂 霃 霄 霅 霆 震 霈 霉 霊 霋 霌 霍 霎 霏 
9710 霐 霑 霒 霓 霔 霕 霖 霗 霘 霙 霚 霛 霜 霝 霞 霟 
9720 霠 霡 霢 霣 霤 霥 霦 霧 霨 霩 霪 霫 霬 霭 霮 霯 
9730 霰 霱 露 霳 霴 霵 霶 霷 霸 霹 霺 霻 霼 霽 霾 霿 
9740 靀 靁 靂 靃 靄 靅 靆 靇 靈 靉 靊 靋 靌 靍 靎 靏 
9750 靐 靑 青 靓 靔 靕 靖 靗 靘 静 靚 靛 靜 靝 非 靟 
9760 靠 靡 面 靣 靤 靥 靦 靧 靨 革 靪 靫 靬 靭 靮 靯 
9770 靰 靱 靲 靳 靴 靵 靶 靷 靸 靹 靺 靻 靼 靽 靾 靿 
9780 鞀 鞁 鞂 鞃 鞄 鞅 鞆 鞇 鞈 鞉 鞊 鞋 鞌 鞍 鞎 鞏 
9790 鞐 鞑 鞒 鞓 鞔 鞕 鞖 鞗 鞘 鞙 鞚 鞛 鞜 鞝 鞞 鞟 
97a0 鞠 鞡 鞢 鞣 鞤 鞥 鞦 鞧 鞨 鞩 鞪 鞫 鞬 鞭 鞮 鞯 
97b0 鞰 鞱 鞲 鞳 鞴 鞵 鞶 鞷 鞸 鞹 鞺 鞻 鞼 鞽 鞾 鞿 
97c0 韀 韁 韂 韃 韄 韅 韆 韇 韈 韉 韊 韋 韌 韍 韎 韏 


--------------------------------------------------------

58 汉字编码表 

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
97d0 韐 韑 韒 韓 韔 韕 韖 韗 韘 韙 韚 韛 韜 韝 韞 韟 
97e0 韠 韡 韢 韣 韤 韥 韦 韧 韨 韩 韪 韫 韬 韭 韮 韯 
97f0 韰 韱 韲 音 韴 韵 韶 韷 韸 韹 韺 韻 韼 韽 韾 響 
9800 頀 頁 頂 頃 頄 項 順 頇 須 頉 頊 頋 頌 頍 頎 頏 
9810 預 頑 頒 頓 頔 頕 頖 頗 領 頙 頚 頛 頜 頝 頞 頟 
9820 頠 頡 頢 頣 頤 頥 頦 頧 頨 頩 頪 頫 頬 頭 頮 頯 
9830 頰 頱 頲 頳 頴 頵 頶 頷 頸 頹 頺 頻 頼 頽 頾 頿 
9840 顀 顁 顂 顃 顄 顅 顆 顇 顈 顉 顊 顋 題 額 顎 顏 
9850 顐 顑 顒 顓 顔 顕 顖 顗 願 顙 顚 顛 顜 顝 類 顟 
9860 顠 顡 顢 顣 顤 顥 顦 顧 顨 顩 顪 顫 顬 顭 顮 顯 
9870 顰 顱 顲 顳 顴 页 顶 顷 顸 项 顺 须 顼 顽 顾 顿 
9880 颀 颁 颂 颃 预 颅 领 颇 颈 颉 颊 颋 颌 颍 颎 颏 
9890 颐 频 颒 颓 颔 颕 颖 颗 题 颙 颚 颛 颜 额 颞 颟 
98a0 颠 颡 颢 颣 颤 颥 颦 颧 風 颩 颪 颫 颬 颭 颮 颯 
98b0 颰 颱 颲 颳 颴 颵 颶 颷 颸 颹 颺 颻 颼 颽 颾 颿 
98c0 飀 飁 飂 飃 飄 飅 飆 飇 飈 飉 飊 飋 飌 飍 风 飏 
98d0 飐 飑 飒 飓 飔 飕 飖 飗 飘 飙 飚 飛 飜 飝 飞 食 
98e0 飠 飡 飢 飣 飤 飥 飦 飧 飨 飩 飪 飫 飬 飭 飮 飯 
98f0 飰 飱 飲 飳 飴 飵 飶 飷 飸 飹 飺 飻 飼 飽 飾 飿 
9900 餀 餁 餂 餃 餄 餅 餆 餇 餈 餉 養 餋 餌 餍 餎 餏 
9910 餐 餑 餒 餓 餔 餕 餖 餗 餘 餙 餚 餛 餜 餝 餞 餟 


---------------------------------------------------------

59 汉字编码表 

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
----------------------------------------------------- 
9920 餠 餡 餢 餣 餤 餥 餦 餧 館 餩 餪 餫 餬 餭 餮 餯 
9930 餰 餱 餲 餳 餴 餵 餶 餷 餸 餹 餺 餻 餼 餽 餾 餿 
9940 饀 饁 饂 饃 饄 饅 饆 饇 饈 饉 饊 饋 饌 饍 饎 饏 
9950 饐 饑 饒 饓 饔 饕 饖 饗 饘 饙 饚 饛 饜 饝 饞 饟 
9960 饠 饡 饢 饣 饤 饥 饦 饧 饨 饩 饪 饫 饬 饭 饮 饯 
9970 饰 饱 饲 饳 饴 饵 饶 饷 饸 饹 饺 饻 饼 饽 饾 饿 
9980 馀 馁 馂 馃 馄 馅 馆 馇 馈 馉 馊 馋 馌 馍 馎 馏 
9990 馐 馑 馒 馓 馔 馕 首 馗 馘 香 馚 馛 馜 馝 馞 馟 
99a0 馠 馡 馢 馣 馤 馥 馦 馧 馨 馩 馪 馫 馬 馭 馮 馯 
99b0 馰 馱 馲 馳 馴 馵 馶 馷 馸 馹 馺 馻 馼 馽 馾 馿 
99c0 駀 駁 駂 駃 駄 駅 駆 駇 駈 駉 駊 駋 駌 駍 駎 駏 
99d0 駐 駑 駒 駓 駔 駕 駖 駗 駘 駙 駚 駛 駜 駝 駞 駟 
99e0 駠 駡 駢 駣 駤 駥 駦 駧 駨 駩 駪 駫 駬 駭 駮 駯 
99f0 駰 駱 駲 駳 駴 駵 駶 駷 駸 駹 駺 駻 駼 駽 駾 駿 
9a00 騀 騁 騂 騃 騄 騅 騆 騇 騈 騉 騊 騋 騌 騍 騎 騏 
9a10 騐 騑 騒 験 騔 騕 騖 騗 騘 騙 騚 騛 騜 騝 騞 騟 
9a20 騠 騡 騢 騣 騤 騥 騦 騧 騨 騩 騪 騫 騬 騭 騮 騯 
9a30 騰 騱 騲 騳 騴 騵 騶 騷 騸 騹 騺 騻 騼 騽 騾 騿 
9a40 驀 驁 驂 驃 驄 驅 驆 驇 驈 驉 驊 驋 驌 驍 驎 驏 
9a50 驐 驑 驒 驓 驔 驕 驖 驗 驘 驙 驚 驛 驜 驝 驞 驟 
9a60 驠 驡 驢 驣 驤 驥 驦 驧 驨 驩 驪 驫 马 驭 驮 驯 


---------------------------------------------------------


60 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
9a70 驰 驱 驲 驳 驴 驵 驶 驷 驸 驹 驺 驻 驼 驽 驾 驿 
9a80 骀 骁 骂 骃 骄 骅 骆 骇 骈 骉 骊 骋 验 骍 骎 骏 
9a90 骐 骑 骒 骓 骔 骕 骖 骗 骘 骙 骚 骛 骜 骝 骞 骟 
9aa0 骠 骡 骢 骣 骤 骥 骦 骧 骨 骩 骪 骫 骬 骭 骮 骯 
9ab0 骰 骱 骲 骳 骴 骵 骶 骷 骸 骹 骺 骻 骼 骽 骾 骿 
9ac0 髀 髁 髂 髃 髄 髅 髆 髇 髈 髉 髊 髋 髌 髍 髎 髏 
9ad0 髐 髑 髒 髓 體 髕 髖 髗 高 髙 髚 髛 髜 髝 髞 髟 
9ae0 髠 髡 髢 髣 髤 髥 髦 髧 髨 髩 髪 髫 髬 髭 髮 髯 
9af0 髰 髱 髲 髳 髴 髵 髶 髷 髸 髹 髺 髻 髼 髽 髾 髿 
9b00 鬀 鬁 鬂 鬃 鬄 鬅 鬆 鬇 鬈 鬉 鬊 鬋 鬌 鬍 鬎 鬏 
9b10 鬐 鬑 鬒 鬓 鬔 鬕 鬖 鬗 鬘 鬙 鬚 鬛 鬜 鬝 鬞 鬟 
9b20 鬠 鬡 鬢 鬣 鬤 鬥 鬦 鬧 鬨 鬩 鬪 鬫 鬬 鬭 鬮 鬯 
9b30 鬰 鬱 鬲 鬳 鬴 鬵 鬶 鬷 鬸 鬹 鬺 鬻 鬼 鬽 鬾 鬿 
9b40 魀 魁 魂 魃 魄 魅 魆 魇 魈 魉 魊 魋 魌 魍 魎 魏 
9b50 魐 魑 魒 魓 魔 魕 魖 魗 魘 魙 魚 魛 魜 魝 魞 魟 
9b60 魠 魡 魢 魣 魤 魥 魦 魧 魨 魩 魪 魫 魬 魭 魮 魯 
9b70 魰 魱 魲 魳 魴 魵 魶 魷 魸 魹 魺 魻 魼 魽 魾 魿 
9b80 鮀 鮁 鮂 鮃 鮄 鮅 鮆 鮇 鮈 鮉 鮊 鮋 鮌 鮍 鮎 鮏 
9b90 鮐 鮑 鮒 鮓 鮔 鮕 鮖 鮗 鮘 鮙 鮚 鮛 鮜 鮝 鮞 鮟 
9ba0 鮠 鮡 鮢 鮣 鮤 鮥 鮦 鮧 鮨 鮩 鮪 鮫 鮬 鮭 鮮 鮯 
9bb0 鮰 鮱 鮲 鮳 鮴 鮵 鮶 鮷 鮸 鮹 鮺 鮻 鮼 鮽 鮾 鮿 


--------------------------------------------------------------------------------

61 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
9bc0 鯀 鯁 鯂 鯃 鯄 鯅 鯆 鯇 鯈 鯉 鯊 鯋 鯌 鯍 鯎 鯏 
9bd0 鯐 鯑 鯒 鯓 鯔 鯕 鯖 鯗 鯘 鯙 鯚 鯛 鯜 鯝 鯞 鯟 
9be0 鯠 鯡 鯢 鯣 鯤 鯥 鯦 鯧 鯨 鯩 鯪 鯫 鯬 鯭 鯮 鯯 
9bf0 鯰 鯱 鯲 鯳 鯴 鯵 鯶 鯷 鯸 鯹 鯺 鯻 鯼 鯽 鯾 鯿 
9c00 鰀 鰁 鰂 鰃 鰄 鰅 鰆 鰇 鰈 鰉 鰊 鰋 鰌 鰍 鰎 鰏 
9c10 鰐 鰑 鰒 鰓 鰔 鰕 鰖 鰗 鰘 鰙 鰚 鰛 鰜 鰝 鰞 鰟 
9c20 鰠 鰡 鰢 鰣 鰤 鰥 鰦 鰧 鰨 鰩 鰪 鰫 鰬 鰭 鰮 鰯 
9c30 鰰 鰱 鰲 鰳 鰴 鰵 鰶 鰷 鰸 鰹 鰺 鰻 鰼 鰽 鰾 鰿 
9c40 鱀 鱁 鱂 鱃 鱄 鱅 鱆 鱇 鱈 鱉 鱊 鱋 鱌 鱍 鱎 鱏 
9c50 鱐 鱑 鱒 鱓 鱔 鱕 鱖 鱗 鱘 鱙 鱚 鱛 鱜 鱝 鱞 鱟 
9c60 鱠 鱡 鱢 鱣 鱤 鱥 鱦 鱧 鱨 鱩 鱪 鱫 鱬 鱭 鱮 鱯 
9c70 鱰 鱱 鱲 鱳 鱴 鱵 鱶 鱷 鱸 鱹 鱺 鱻 鱼 鱽 鱾 鱿 
9c80 鲀 鲁 鲂 鲃 鲄 鲅 鲆 鲇 鲈 鲉 鲊 鲋 鲌 鲍 鲎 鲏 
9c90 鲐 鲑 鲒 鲓 鲔 鲕 鲖 鲗 鲘 鲙 鲚 鲛 鲜 鲝 鲞 鲟 
9ca0 鲠 鲡 鲢 鲣 鲤 鲥 鲦 鲧 鲨 鲩 鲪 鲫 鲬 鲭 鲮 鲯 
9cb0 鲰 鲱 鲲 鲳 鲴 鲵 鲶 鲷 鲸 鲹 鲺 鲻 鲼 鲽 鲾 鲿 
9cc0 鳀 鳁 鳂 鳃 鳄 鳅 鳆 鳇 鳈 鳉 鳊 鳋 鳌 鳍 鳎 鳏 
9cd0 鳐 鳑 鳒 鳓 鳔 鳕 鳖 鳗 鳘 鳙 鳚 鳛 鳜 鳝 鳞 鳟 
9ce0 鳠 鳡 鳢 鳣 鳤 鳥 鳦 鳧 鳨 鳩 鳪 鳫 鳬 鳭 鳮 鳯 
9cf0 鳰 鳱 鳲 鳳 鳴 鳵 鳶 鳷 鳸 鳹 鳺 鳻 鳼 鳽 鳾 鳿 
9d00 鴀 鴁 鴂 鴃 鴄 鴅 鴆 鴇 鴈 鴉 鴊 鴋 鴌 鴍 鴎 鴏 


--------------------------------------------------------------------------------

62 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
9d10 鴐 鴑 鴒 鴓 鴔 鴕 鴖 鴗 鴘 鴙 鴚 鴛 鴜 鴝 鴞 鴟 
9d20 鴠 鴡 鴢 鴣 鴤 鴥 鴦 鴧 鴨 鴩 鴪 鴫 鴬 鴭 鴮 鴯 
9d30 鴰 鴱 鴲 鴳 鴴 鴵 鴶 鴷 鴸 鴹 鴺 鴻 鴼 鴽 鴾 鴿 
9d40 鵀 鵁 鵂 鵃 鵄 鵅 鵆 鵇 鵈 鵉 鵊 鵋 鵌 鵍 鵎 鵏 
9d50 鵐 鵑 鵒 鵓 鵔 鵕 鵖 鵗 鵘 鵙 鵚 鵛 鵜 鵝 鵞 鵟 
9d60 鵠 鵡 鵢 鵣 鵤 鵥 鵦 鵧 鵨 鵩 鵪 鵫 鵬 鵭 鵮 鵯 
9d70 鵰 鵱 鵲 鵳 鵴 鵵 鵶 鵷 鵸 鵹 鵺 鵻 鵼 鵽 鵾 鵿 
9d80 鶀 鶁 鶂 鶃 鶄 鶅 鶆 鶇 鶈 鶉 鶊 鶋 鶌 鶍 鶎 鶏 
9d90 鶐 鶑 鶒 鶓 鶔 鶕 鶖 鶗 鶘 鶙 鶚 鶛 鶜 鶝 鶞 鶟 
9da0 鶠 鶡 鶢 鶣 鶤 鶥 鶦 鶧 鶨 鶩 鶪 鶫 鶬 鶭 鶮 鶯 
9db0 鶰 鶱 鶲 鶳 鶴 鶵 鶶 鶷 鶸 鶹 鶺 鶻 鶼 鶽 鶾 鶿 
9dc0 鷀 鷁 鷂 鷃 鷄 鷅 鷆 鷇 鷈 鷉 鷊 鷋 鷌 鷍 鷎 鷏 
9dd0 鷐 鷑 鷒 鷓 鷔 鷕 鷖 鷗 鷘 鷙 鷚 鷛 鷜 鷝 鷞 鷟 
9de0 鷠 鷡 鷢 鷣 鷤 鷥 鷦 鷧 鷨 鷩 鷪 鷫 鷬 鷭 鷮 鷯 
9df0 鷰 鷱 鷲 鷳 鷴 鷵 鷶 鷷 鷸 鷹 鷺 鷻 鷼 鷽 鷾 鷿 
9e00 鸀 鸁 鸂 鸃 鸄 鸅 鸆 鸇 鸈 鸉 鸊 鸋 鸌 鸍 鸎 鸏 
9e10 鸐 鸑 鸒 鸓 鸔 鸕 鸖 鸗 鸘 鸙 鸚 鸛 鸜 鸝 鸞 鸟 
9e20 鸠 鸡 鸢 鸣 鸤 鸥 鸦 鸧 鸨 鸩 鸪 鸫 鸬 鸭 鸮 鸯 
9e30 鸰 鸱 鸲 鸳 鸴 鸵 鸶 鸷 鸸 鸹 鸺 鸻 鸼 鸽 鸾 鸿 
9e40 鹀 鹁 鹂 鹃 鹄 鹅 鹆 鹇 鹈 鹉 鹊 鹋 鹌 鹍 鹎 鹏 
9e50 鹐 鹑 鹒 鹓 鹔 鹕 鹖 鹗 鹘 鹙 鹚 鹛 鹜 鹝 鹞 鹟 


--------------------------------------------------------------------------------

63 汉字编码表

 U+   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   
-----------------------------------------------------   
9e60 鹠 鹡 鹢 鹣 鹤 鹥 鹦 鹧 鹨 鹩 鹪 鹫 鹬 鹭 鹮 鹯 
9e70 鹰 鹱 鹲 鹳 鹴 鹵 鹶 鹷 鹸 鹹 鹺 鹻 鹼 鹽 鹾 鹿 
9e80 麀 麁 麂 麃 麄 麅 麆 麇 麈 麉 麊 麋 麌 麍 麎 麏 
9e90 麐 麑 麒 麓 麔 麕 麖 麗 麘 麙 麚 麛 麜 麝 麞 麟 
9ea0 麠 麡 麢 麣 麤 麥 麦 麧 麨 麩 麪 麫 麬 麭 麮 麯 
9eb0 麰 麱 麲 麳 麴 麵 麶 麷 麸 麹 麺 麻 麼 麽 麾 麿 
9ec0 黀 黁 黂 黃 黄 黅 黆 黇 黈 黉 黊 黋 黌 黍 黎 黏 
9ed0 黐 黑 黒 黓 黔 黕 黖 黗 默 黙 黚 黛 黜 黝 點 黟 
9ee0 黠 黡 黢 黣 黤 黥 黦 黧 黨 黩 黪 黫 黬 黭 黮 黯 
9ef0 黰 黱 黲 黳 黴 黵 黶 黷 黸 黹 黺 黻 黼 黽 黾 黿 
9f00 鼀 鼁 鼂 鼃 鼄 鼅 鼆 鼇 鼈 鼉 鼊 鼋 鼌 鼍 鼎 鼏 
9f10 鼐 鼑 鼒 鼓 鼔 鼕 鼖 鼗 鼘 鼙 鼚 鼛 鼜 鼝 鼞 鼟 
9f20 鼠 鼡 鼢 鼣 鼤 鼥 鼦 鼧 鼨 鼩 鼪 鼫 鼬 鼭 鼮 鼯 
9f30 鼰 鼱 鼲 鼳 鼴 鼵 鼶 鼷 鼸 鼹 鼺 鼻 鼼 鼽 鼾 鼿 
9f40 齀 齁 齂 齃 齄 齅 齆 齇 齈 齉 齊 齋 齌 齍 齎 齏 
9f50 齐 齑 齒 齓 齔 齕 齖 齗 齘 齙 齚 齛 齜 齝 齞 齟 
9f60 齠 齡 齢 齣 齤 齥 齦 齧 齨 齩 齪 齫 齬 齭 齮 齯 
9f70 齰 齱 齲 齳 齴 齵 齶 齷 齸 齹 齺 齻 齼 齽 齾 齿 
9f80 龀 龁 龂 龃 龄 龅 龆 龇 龈 龉 龊 龋 龌 龍 龎 龏 
9f90 龐 龑 龒 龓 龔 龕 龖 龗 龘 龙 龚 龛 龜 龝 龞 龟 
9fa0 龠 龡 龢 龣 龤 龥  

--------------------------------------------------------------------------------
</pre>


<p><a href="http://jlqzs.blog.163.com/blog/static/2125298320070101826277/" title="原始出处" target="_blank" rel="external">原始出处</a> <br></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20%E4%BB%80%E4%B9%88%E6%98%AF%20VSync/</loc>
    <lastmod>2015-01-31T11:36:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 什么是 VSync</title>
        <pubTime>2015-01-31T11:36:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>一个老外写的 VSync（垂直同步）原理的文章的翻译：</p>
<p>VSync是垂直同期(Vertical Synchronization)的简称。基本的思路是将你的FPS和显示器的刷新率同期起来。其目的是避免一种称之为”撕裂”的现象。再下面我将详细介绍这些内容。</p>
<p>每一台CRT显示器都有自己的刷新率。其单位是HZ.其数值是显示器每秒钟更新画面的次数。不同的显示器支持再不同分辨率下的不同刷新率。它的范围可以从低到60高到100。注意它不是你游戏中所提到的那个FPS.如果你设置了一个特定的刷新率，显示器将一直按照这个速率刷新画面。甚至画面没有任何的改变。液晶显示器就不同了。LCD的每个像素在被告知改变的时候将一直是亮着的。他们不需要刷新。但是因为VGA(或是DVI)的工作原理，LCD不得不从显示卡那里按一定的速率得到新的新画面。这就是虽然LCD不必要更新，但是他还是有自己的刷新率。</p>
<p>我想这里的每一人都明白FPS。它显示显示卡在每秒钟可以描画多少画面。这显然是越高越好。但是对于快速变化的游戏而言，你的FPS很难一直保持同样的数值，他会随着你所看到的显示卡所要描画的画面的复杂程度而变化。这样画面的撕裂就发生了。所谓”撕裂”就是一种画面分离的现象，就象你照一张照片，在旋转哪怕一度再照一张照片，然后把两张照片的从中间裁开，用一张照片的上半部与另一张的下半部对接起来。这样得到的画像虽然相似但是上半部和下半部确实明显的不同。这就被称之为视觉现实上的撕裂。它不会一直从中间分开，它可能靠近上面也可能下面，分离点可能在屏幕上下移动，也可能在两点间前后移动。（译者：原文的作者实在是啰嗦，其实就是画面移动较快的时候，画面看上去是两截。这种现象恐怕打游戏的都看到过）。为什么会发生这种现象呢？让我们举一个特定的例子。让我们假定你的显示器的刷新率是75Hz, 你真在玩你最喜欢的游戏，而且你现在有100的FPS.这就意味着你的显示器每秒更新75次画面，而你的显示卡每秒更新100次，比你的显示器快33%。这就意味着在你的显示器更新画面的时间里，显示卡描画了1+1/3的画面。这样在画面显示的时候，那个1/3的画面就会覆盖那个完整画面上部的1/3。在下次的图像刷新的时候，显示卡会描画剩下来得2/3和新的2/3的画面。这样，因为屏幕的更新只能跟上画面更新的2/3，这样图像的上部的1/3或是下部的1/3就会和剩下的画面合不上。如果画面的变化不大可能不太会注意到这一点，但是如果你快速的环顾四周那就会非常的明显。现在，一个很普遍的误解就产生了。一些人认为解决这个问题的方法就是简单设置一个FPS的限制让FPS不超过显示器的刷新率，这样显示卡就不会超过75FPS,这样就可以了。真的吗？错！</p>
<p>在我解释为什么之前，让我来讲一下双倍缓冲。双倍缓冲一种用来减轻撕裂问题，虽然不是很完全。基本上来说你有一个显示缓冲和一个后备缓冲。当显示器要显示画面的时候，就会从显示缓冲里“推出”显示画面。显示卡则在后备缓冲里描画另外一个新画面，当描画完成后则将新画面考入显示缓冲里。但是这个过程需要时间，如果显示器的刷新在拷贝过程中进行的话，显示器上显示的仍然是个”撕裂”的画面。</p>
<p>VSync 通过建立一个不让在显示器刷新前将后备缓冲中的画面拷贝到显示缓冲中的规定来解决这个问题。如果FPS高于刷新率的话，没有问题。后备缓冲的更新完成后，系统处于等待状态。当显示器刷新后，后备缓存考入显示缓存，显示卡则可以在后备缓存里描画新的画面，这样就很有效的将你的FPS限制在显示器的刷新率的范围内。这样看起来不错，但是让我们来看一个另外一个不同的例子。让我们假定你已经玩到了你最喜欢的游戏的最后一关，这个游戏有很好的图像.你显示器的刷新率还是在75。但是你的FPS现在只有50了，比刷新率要低33%.这就意味着每次显示器刷新图像，你的显示卡只能画出下一桢画面的2/3。让我们看看它是如何工作的。显示器刚刚更新，第一桢的画面已经拷贝到显示缓冲，第二桢的画面的2/3被写入后备缓冲，这时显示器重新刷新，它会第一次从显示缓冲里提取第一桢的画面。然后显示卡开始完成的第二桢剩下的部分。但是它必须等待，应为再下一次刷新之前它是不会上传的。显示器再次刷新，显示器不得不第二次从显示缓冲里提取第一桢的画面，然后第二桢的画面被写入显示缓冲。显示卡在后备缓冲中写入第三桢的2/3.等到显示器刷新，第一次从显示缓冲里提取第二桢的画面，显示卡开始完成的第三桢剩下的部分。然后又是第二次从显示缓冲里提取第二桢的画面，然后第三桢的画面被写入显示缓冲。如此类推。这样4次显示器刷新，我们只能的到2桢的画面。如果刷新率是75的话，我们只能得到35的FPS.很明显这个数值要低于显示卡可以带到的50FPS.这主要就是应为显示卡不得不在描画后备缓冲上浪费时间。而在此过程中，后备缓冲上的画面是不能被拷贝到显示缓冲。理论上讲，双缓冲的VSync,FPS将是一组不连续的整数，其等于刷新率/n,n是正整数。也就是说，如果你的刷新率是60hz,你能得到的FPS只能是 60，30，20，15，12，10 等等。你可以注意到60到30是一个相当大的差距。只要的显示卡的FPS在60到30之间，你说得到的真实FPS都将只能等于30！</p>
<p>现在，你明白为什么有人不喜欢它了。让我们回到一开始的那个例子。你在玩你最喜欢的游戏，刷新率是75HZ,100FPS。你打开VSync.游戏就被限制在75FPS,没有问题，没有撕裂图像，看起来不错。你到了一个图像特别复杂的地方，在不用VSync的时候，你的FPS下降到了60左右。但是你打开了VSync，你的FPS实际就只有37.5。这样你的游戏突然从75FPS变成了37.5FPS,不管37.5仍然很流畅但是你一定会注意到刷新率突然减少了一半。当让如果以下变到25FPS的话，实际的现实率可能就只有17.5。本来还可以玩的游戏，就变成了幻灯片。这就是大家不喜欢它的原因。</p>
<p>如果你的游戏的FPS可以一直稳定的大于显示器的刷新率，VSync是个不错的东西。但是如果FPS忽大忽小。VSync就是让人烦的东西。如果你的游戏FPS一直都小于刷新率的话，实际的FPS要远远小于显示卡可以显示的FPS.看上去就象是VSync降低了你的FPS,但是从技术角度讲，不是应为图像太复杂，而是因为VSync就是这样工作的。也不是说所有的希望都没有了。现在的triple-buffering技术可以用来解决这个问题。让我们再来看刷新率75。FPS50的例子。第一桢在显示缓冲，第二桢的2/3在后备缓冲。显示器刷新第一桢第一次被显示，在后备缓冲里描画第二桢的剩下的1/3，在第二后备缓冲里描画第三桢的1/3(因为我们有三级缓冲了)。显示器再次刷新第一桢第二次被显示，第二桢放入在显示缓冲，第三桢的的1/3放入后备缓冲，第二后备缓冲里描画第三桢剩下的2/3。接下来显示器再次刷新的时候，第二桢被显示，第三桢就可以放入显示缓冲，这样我们就可以在3次刷新中得到2桢的画面。也就是刷新率的2/3,也就是50FPS.triple-buffering理论上讲可以避免缓冲写入是带来的延迟现象，这样就不会浪费时间。但是triple-buffering并不是适用于所有的游戏。实际上它并不是普及(这个文章可能写的太早，现在triple-buffering已经很普及了)，而且它也会影响显示卡的性能，应为它需要更多的显示内存，需要更多时间在内存之间降数据拷贝来拷贝去。但是triple-buffering确实是一个很好的方法，既可以消除撕裂画面又可以不像普通VSync一样影响你的FPS.我希望这篇文章是有用的，可以帮出你理解VSync的工作原理。（特别是不再犹豫是否打开VSync）总之，如果没有triple-buffering的情况下，如何权衡Vsync的FPS限制和消除撕裂画面带来的视觉感受，那将完全取决于你个人的喜好。</p>
<p>译者按：如果这篇文章的机理是正确的。triple-buffering也不是万能的，实际上就是把减少1/2变成了减少1/3而已，如果是FPS恰好卡到了一定的数值的时候没有问题，一旦没有，那就绝对要损失FPS.所以对于那种FPS刚刚超过24的游戏，不管有没有triple-buffering，都应该关.</p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20Dia%20%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87/</loc>
    <lastmod>2015-01-31T11:34:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Dia 无法输入中文</title>
        <pubTime>2015-01-31T11:34:16.000Z</pubTime>
        
        <tag>other </tag>
         
         <content><![CDATA[<p>需要画流程图装了dia for windows，结果画图时不能输入中文，只能输入英文，很郁闷…，Google之，发现解决方案：</p>
<p>菜单里选择输入法-&gt;简单，就可以了，不能用默认的系统(Windows IME)。</p>
<p>注意：在ubuntu下要用系统(IBUS)，若选简单的话，甚至连输入法都调不出来。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20%E9%82%A3%E4%BA%9B%20cache%20%E5%92%8C%20buffer%20%E2%80%94%E2%80%94%20%E4%B8%8B/</loc>
    <lastmod>2015-01-31T09:40:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 那些 cache 和 buffer —— 下</title>
        <pubTime>2015-01-31T09:40:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p><a href="http://light3moon.com/2015/01/31/[转] 那些 cache 和 buffer —— 上" title="前面一篇文章" target="_blank" rel="external">前面一篇文章</a> 谈了一些Linux系统层面的cache和buffer。这里主要谈谈应用层面的那些cache。相比系统层面的cache集中在IO上，应用层面的cache就显得五花八门了。就从WEB说起吧。</p>
<h2 id="web服务器缓存">web服务器缓存</h2>
<p>web缓存对于服务器和客户端都是不可或缺的。对于web服务器来说，缓存是非常重要的东西，它可以大大的增加并发，缩短相应时间，减少服务器负荷。原理很简单。因为对于一个URL来说，很短时间内它的内容变化其实是不大的，如果每次请求都要服务器算一遍就显得太浪费了。所以web缓存就是放在web服务器前面的一个代理，它接收用户请求，并向后端请求，在返回响应的时候将这些响应缓存起来，遇到请求时不经过服务器计算直接返回响应，从大大提高响应速度，尤其是在请求量很大的时候。web缓存代表作是squid和varnish。</p>
<h2 id="客户端缓存">客户端缓存</h2>
<p>对于客户端的浏览器来说缓存同样不可或缺。甚至在HTTP协议中都为缓存提供了支持，HTTP返回码304 Not Modified就是告诉浏览器，你要的内容没变，用你缓存中的吧。在HTTP协议之外，浏览器自己也会做许多的缓存，对于图片啊，js什么的，短时间内的请求就自作主张直接不去远程取了，会大大减少请求量，从而节省大量的时间，用户需要速度。况且浏览器和服务器本是同根生嘛，不必相互煎熬。所以有时候你得强制刷新。<br>与web服务器紧密相关的就是数据库了。</p>
<h2 id="数据库缓存">数据库缓存</h2>
<p>在数据库系统中，缓存同样无处不在。因为同样的道理，对同一个sql查询来说，在某些条件下（比如它查的表自上次查询后都没更新过）它的结果就应该和上次查询一样的。于是mysql提供了query cache。也有些框架提供了缓存功能，比如hibernate。这都是读缓存，目的在于读很多，而写比较少的时候提高读的性能，如果写很多，而读比较少的话这类缓存就没什么用了。于是，在一些情况下我们希望可以为数据库引入写缓存。典型的是主键查询和更新。于是出现了kv数据库（比如memcached）。可以提供基于主键查询的读写缓存。这对于提高数据系统的整体性能是极其重要的。</p>
<h2 id="其他缓存">其他缓存</h2>
<p>其他五花八门的cache还有那些呢？</p>
<p>比如dns缓存，dns缓存同样存在于客户端和dns服务器中，与web缓存的原理是一样的。将dns的解析结果缓存起来。<br>比如arp缓存，将arp的结果缓存起来。</p>
<p>甚至，连编译系统也引入了缓存比如ccache，比如visual studio中的pch（预编译头）机制。</p>
<p>最后，我想说的是：cache is king! cache is everywhere!</p>
<p><a href="http://blog.dccmx.com/2011/06/about-cache-and-buffer-2/" title="原始出处" target="_blank" rel="external">原始出处</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20%E9%82%A3%E4%BA%9B%20cache%20%E5%92%8C%20buffer%20%E2%80%94%E2%80%94%20%E4%B8%8A/</loc>
    <lastmod>2015-01-31T09:38:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 那些 cache 和 buffer —— 上</title>
        <pubTime>2015-01-31T09:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>江湖人称：cache is king。</p>
<p>还有个与之类似的是buffer。这里就谈谈buffer和cache。那么他们到底是用来干什么的呢？其实他们就是在两个相对独立的系统之间的一个中间层，用来避免这两个系统之间不必要的交互和不不必要的或者重复的同步。同步，你懂的，不同数量级系统之间的同步，你也懂的。比如内存和磁盘之间，比如应用和数据库之间。buffer针对写，cache针对读。这篇文章先来看看Linux里面系统的那些cache和buffer（至于硬件里面的一些cache如cpu指令缓存这里就不谈了）。</p>
<h2 id="文件IO">文件IO</h2>
<p>对于写操作通常我们会遇到两个两个缓冲 （buffer）：</p>
<ul>
<li><p><strong>一个是内核缓冲:</strong><br>当我们调用write写文件时，write返回之后其实内容并没有立刻写到硬盘上，而是写到了内核的缓存中。什么时候写到磁盘？内核有一套刷缓存的机制。这样做有很明显的好处，比如我们调用1次write写1kb和调用1k次write每次写1b的数据，所花的时间是差不多的。后者所花的用户态/内核态切换时间多些，但是写磁盘的次数却是一样的。这样就大大提高了效率。</p>
</li>
<li><p><strong>另外一个是glibc维护的用户态缓冲:</strong><br>这个缓冲又是用来干什么的呢？内核和硬盘是两个相对独立的系统，内核缓冲在这两个之间避免了很多不必要的同步。那么同样，内核和用户程序也是两个相对独立的系统，每次系统调用也是要花代价的。所以上面1次write写1kb和调用1k次write每次写1b的数据的例子，前后两种方法还是有差距的，差距就在于后者需要做1k此用户态和内核态的切换。所以，glibc在用户态上又做了一个缓冲。当我们调用glibc提供的printf输出的时候，并没有直接映射到一次write系统调用，而是存在了glibc管理的缓冲中，当条件满足时（下面会说上面时候满足）再调用一次write，把用户态的缓冲写到内核态去。所以，调用1此printf到文件1kb字符和1k此print每次1个字符，所花的时间就真差不多了。</p>
</li>
</ul>
<h2 id="读缓存（cache）">读缓存（cache）</h2>
<p>用read读文件，其实就是读的内核的缓存。当内核缓存中没有的时候，会从磁盘读些内容到缓存，然后从缓存返回给用户。 注意，在某些情况下我们还可以做进一步的优化。考虑一下，我们从头到尾读文件，只读1次1kb和读1k次每次1b的时间是不是也差不多呢？这就需要内核在 read的时候事先读1kb的内容到缓存才行（这叫：read ahead）。而内核有不知道我们后续的read调用是从头到尾顺序读还是胡乱读，如果是随机读那么read ahead就会适得其反。还好posix规定了posix_fadvise()系统调用，让我们告诉内核，我们读文件的方式。用这个调用告诉内核我们是顺序读。read的性能就上来了。爽啊。</p>
<p>下面列举一下glibc默认的缓冲的行为（可以通过setvbuf修改）：</p>
<ul>
<li>如果文件是stderr，则默认是没缓冲，每次printf对应一次write。</li>
<li>如同文件是终端，则默认是行缓冲，每当遇到换行的时候write一次</li>
<li>如果文件对应的是磁盘文件，则默认是全缓冲，当缓存区满或者文件关闭时会write。</li>
<li>当然，任何时候，你都可以调用fflush()来强制用户态的缓存写到内核缓冲中。</li>
</ul>
<h2 id="socket_缓冲">socket 缓冲</h2>
<p>对！socket也是有缓冲的。同样的例子我们应用到socket上：1次send 1kb和1k次send每次1b。哪个费时费力呢？显然是后者，因为如果我们知道，IP包头，TCP包头都是要花带宽的。如果一个大大的IP包中只有1字节的数据，显然是大大的浪费了带宽。所以，John Nagle提出了Nagle算法，将这些凌乱的小包缓冲起来，集齐N个组成一个大包，再发出去。这样就大大提高了网络效率。</p>
<p>当然，这样做也是有负面作用的，当我们应用对网络的实时性要求比较高的时候，可能会因为这个机制而增加了网络延迟（毕竟要等集齐了才发嘛）。这时还是用setsockopt+TCP_NODELAY参数把这个优化禁用了吧。还有吗？当然，cache和buffer无处不在。内存管理中到处有cache。就那用户空间来说，glibc中的ptmalloc2，google的TCMalloc都有cache的存在。由于这部分复杂度极高，后面有机会再分析吧。这篇文章就这样吧。</p>
<p>所以说：cache is king!</p>
<p><a href="http://blog.dccmx.com/2011/06/about-cache-and-buffer-1/" title="原始出处" target="_blank" rel="external">原始出处</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20eclipse%20%E4%BB%A3%E7%A0%81%E8%A1%A5%E9%BD%90%E3%80%81%E6%B3%A8%E9%87%8A%E5%B0%8F%E7%AA%97%E5%8F%A3%E5%B4%A9%E6%BA%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</loc>
    <lastmod>2015-01-31T09:23:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) eclipse 代码补齐、注释小窗口崩溃解决方法</title>
        <pubTime>2015-01-31T09:34:16.000Z</pubTime>
        
        <tag>other </tag>
         
         <content><![CDATA[<p>最近换了新的 ubuntu，eclipse 一出现代码补齐或是注释的小窗口就崩溃了。查看 crash log 文件（在你的 home 目录下）说是 java 虚拟机挂了。网上找了一下，在 eclispe.ini （在 eclipse 文件夹下）中加入一条配置就好了：</p>
<pre config="brush:bash;toolbar:false;">
-Dorg.eclipse.swt.browser.DefaultType=mozilla
</pre>

<p>不过这样设置之后好像注释（javadoc）小窗口的一些 doc 格式好像没用了，哎，算了，总比崩溃强点。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/Eclipse%20%E6%8F%92%E4%BB%B6%E5%B0%8F%E7%BB%93/</loc>
    <lastmod>2015-01-31T09:23:16.000Z</lastmod>
    <data>
        <display>
        <title>Eclipse 插件小结</title>
        <pubTime>2015-01-31T09:25:16.000Z</pubTime>
        
        <tag>other </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<h2 id="安装">安装</h2>
<ul>
<li>在线安装：在 Help —&gt; Install new sofeware —&gt; 输入相应的 url 然后按照提示做就行了。</li>
<li>离线安装（其实照样需要从相应的站点下载数据，只不过下载得少点而已）：从网上下载插件的 zip 包。然后在 Help —&gt; Install new software —&gt; 点右边的 Add 然后在 Archive 选择你下载的 zip 包，然后取一个名字，然后就和在线安装类似了。</li>
</ul>
<h2 id="删除">删除</h2>
<p>今天在helios中装aptana1.5，结果不兼容，出了一堆错，想卸载，找了半天才找到，特此记录一下，希望对别人也有用处在这里：</p>
<p>Help -&gt; About Eclipse -&gt; Installation Details </p>
<p>在“Installed Software”标签页里，选中要删除的插件，点下面的“Uninstall”按钮就可以了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/Python%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-31T09:23:16.000Z</lastmod>
    <data>
        <display>
        <title>Python 使用总结</title>
        <pubTime>2015-01-31T09:23:16.000Z</pubTime>
        
        <tag>other </tag>
         
        <tag>shell </tag>
         
         <content><![CDATA[<p>android 有个自动化的测试工具 monkeyrunner ，是使用 python 编写一段指令，然后自动跑，测试程序。所以就要稍微会点 python 语法啦。</p>
<h2 id="不要乱用空格（indent）">不要乱用空格（indent）</h2>
<p>平常的其他代码，空格随便用（在不影响美观情况下），但是在 python 中，每行的缩进不要乱用空格。因为空格在 python 中是一个标示符来的。如果你在一行的前面用了几个空格作为缩进符，那么下面的行，你也必须用相同的空格作为缩进符（不能用 tab 代替），否则就会报： Error “mismatched input” expecting DEDENT 这个错误。</p>
<p>虽然可以保证统一用一样的空格，但是还是不要乱用比较好。</p>
<h2 id="打印">打印</h2>
<p>python 中可以使用 print “xxxx” 进行打印。可以用有些高级的用法，例如 print “a” + “b”（2个必须都是 string）。格式化输出： print “test No.%d” % number</p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/GL%20%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87/</loc>
    <lastmod>2015-01-31T09:07:16.000Z</lastmod>
    <data>
        <display>
        <title>GL 中的纹理坐标</title>
        <pubTime>2015-01-31T09:07:16.000Z</pubTime>
        
        <tag>opengl </tag>
         
         <content><![CDATA[<p>GL 中的纹理坐标是左上（0，0）、右上（1，0）、右下（1，1）、左下（0，1），来几张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/opengl/texture-coords/1.jpeg" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/opengl/texture-coords/2.jpeg" alt=""></p>
<p>还有纹理坐标可以为负的，会有很有趣的现象（反过来贴），范围是 0 ～ 1，超过 1 现象会非常奇怪（负数范围也要在 -1 ～ 0）。这里记一下，免得每次都忘记坐标系统。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/OES_draw_texture%20%E8%AF%A6%E8%A7%A3/</loc>
    <lastmod>2015-01-31T08:58:16.000Z</lastmod>
    <data>
        <display>
        <title>OES_draw_texture 详解</title>
        <pubTime>2015-01-31T08:58:16.000Z</pubTime>
        
        <tag>opengl </tag>
         
         <content><![CDATA[<p>昨天在网上找了头天，找到关于这个函数的一部分信息，好像网上对这个函数的信息不是很多，可以在这里看到对该函数的详细解释：<a href="http://www.khronos.org/registry/gles/extensions/OES/OES_draw_texture.txt" title="OES_draw_texture" target="_blank" rel="external">OES_draw_texture</a></p>
<p>这个函数有什么用呢？它的作用是把纹理的指定片断，当然这个片断是个矩形，直接贴到你指定的视图坐标上的一个矩形上面。加快了2D图形的渲染速度。该函数是在opengl es 1.1引入，opengl 1.4引入 。</p>
<p>为什么需要这个函数呢，也前我们如果想要在屏幕上显示一幅图片，需要绑定一个纹理，然后指顶点坐标，以及对应的纹理坐标，指定好后，就可以把纹理显示出来 ，这样做的一个缺点是需要经过顶点变换，纹理坐标变换，然后执行片断处理，性能上不如该函数来的快，这个函数不需要执行顶点变换和纹理变换，直接进行片断处理。现在说一下如何操作吧，首先你需要绑定对应的纹理，然后调用下面函数指定需要用纹理的哪一部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">glTexParameterfv</span>(<span class="keyword">int</span> target,</div><div class="line">                             <span class="keyword">int</span> pname,</div><div class="line">                             <span class="keyword">float</span>[] params,</div><div class="line">                             <span class="keyword">int</span> offset)</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数大家应该很熟悉，pname 为GL_TEXTURE_CROP_RECT_OES， params是纹理的左边界，下边界，宽，高，宽和高可以为负数，这样渲染出来的效果是图片时行了左右颠倒，或者上下颠倒。然后执行下面这个函数指定屏幕坐标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DrawTex{sifx}OES(T X, T Y, T Z, T W, T H);</div><div class="line"><span class="keyword">void</span> DrawTex{sifx}vOES(T* coords);</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面函数指定了屏幕上的一个矩形，最终效果是纹理被填充到这个矩形中，我们可以看到矩形的大小 和纹理大小没有关系，也就是说纹理可能会被放大或者缩小。Z值用于计算纹理距离屏幕的远近,从下面公式可以看出z处于0.1之间会被计算到最远最近平面中间的一点，否则会在最远或者最近平面上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     { n,                 <span class="keyword">if</span> z &lt;= <span class="number">0</span> }</div><div class="line">Zw = { f,                 <span class="keyword">if</span> z &gt;= <span class="number">1</span> }</div><div class="line">     { n + z * (f - n),   otherwise }</div><div class="line"></div></pre></td></tr></table></figure>

<p>指定矩形上的每一个点所对应的纹理坐标是如何算出来的呢？下面是计算纹理坐标的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s = (Ucr + (X - Xs)*(Wcr/Ws)) / Wt</div><div class="line">t = (Vcr + (Y - Ys)*(Hcr/Hs)) / Ht</div><div class="line">r = <span class="number">0</span></div><div class="line">q = <span class="number">1</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>式中，带有CR下标的是纹理截取时的参数，X,Y是某个点的屏幕坐标， 带有S下标的是屏幕截取时的参数。这个公式简单说就是把屏幕上的一点换算到纹理图片上，看它在纹理上的坐标是什么。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/win8.1%20%E8%93%9D%E7%89%99%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-31T08:48:16.000Z</lastmod>
    <data>
        <display>
        <title>win8.1 蓝牙使用备忘</title>
        <pubTime>2015-01-31T08:40:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<h2 id="关闭蓝牙省电功能">关闭蓝牙省电功能</h2>
<p>整了一个蓝牙鼠标，最好把 window 的蓝牙省电功能关掉，不然蓝牙鼠标会时不时的抽风一下的。</p>
<p>在 “设备管理”——&gt;“蓝牙” 注意这里要选择你机子上的蓝牙芯片，例如下面这个<strong>高通的4.0的蓝牙芯片（如果选其他的不会出电源管理选项的）</strong>，然后选属性，就能看到电源管理选项了，把“允许window关闭此设备以省电”的勾选去掉就行了。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/bluetooth-note/1.jpeg" alt=""></p>
<h2 id="手动连接蓝牙设备">手动连接蓝牙设备</h2>
<p>添加、配对很简单，直接点有下角的蓝牙图标添加 bluetooth 设备就能添加、配对了。当时有些时候蓝牙设备抽风断掉了，点那个蓝牙图标就没连接的地方。</p>
<p>以前我找不到只要删掉设备，再重新配对，很慢。后面发现是在 </p>
<pre>
控制面板 --> 硬件和声音 --> 设备和打印机 
</pre>

<p>那就会显示已经配对好了的蓝牙设备的图标，右键单击有个高级操作就是连接，其实直接双击就是连接。还可以<strong>右键创建桌面快捷方式</strong>：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/bluetooth-note/2.jpeg" alt=""></p>
<p>话说微软 win8.1 的设计师还真是脑子被门板夹了，这么个常见的功能居然躲在这么深的设置面板里面，那个傻x的 metro UI 的蓝牙管理界面也没有连接菜单。还是老外的蓝牙设备都很稳定，都不掉线的。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/win8.1%20%E5%BE%AE%E8%BD%AF%E8%BE%93%E5%85%A5%E6%B3%95%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-31T08:48:16.000Z</lastmod>
    <data>
        <display>
        <title>win8.1 微软输入法备忘</title>
        <pubTime>2015-01-31T08:48:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<h2 id="半角、全角切换">半角、全角切换</h2>
<p>win8.1 的微软输入法 UI 灰常简洁，你在输入框都看不到半角、全角的切换按钮和状态显示。有些时候不小心按倒快捷键切换到全角，都不知道。这个你输入的英文字母会比全角的时候间隔要大，然后在网站上输验证码和密码各种不对。蛋疼得很，这个时候只要切换回半角就行了。快捷方式是： <strong>shitf + 空格</strong>。下面放一张全角、和半角的英文对比，很明显的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/ms-input-note/1.jpeg" alt=""></p>
<h2 id="添加日文输入法">添加日文输入法</h2>
<p>正在学习日文，当然要弄个日文输入法。window 微软输入法自带了日文输入的。在 win8.1 中右键单击屏幕下面输入法那个“M”的图标，然后“添加语言”，把日文加上就能调出日文输入法了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/ms-input-note/2.jpeg" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/ms-input-note/3.jpeg" alt=""></p>
<p>然后按 <strong>win键 + 空格</strong> 切换中文输入法和日文输入法。在日文输入中选罗马音输入（默认就是这个）:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/ms-input-note/4.jpeg" alt=""></p>
<p>然后就是按罗马音来输入日文，罗马音就是日文五十音图里标的那些，例如下面这些：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/ms-input-note/5.jpeg" alt=""></p>
<p>敲 a 就是 あ，敲 i 就是 い。然后点击日文输入法的图标会变成 A ,可以直接输入英文（快捷键是 <strong>alt + ~(esc 旁边那个)</strong>）。</p>
<p>然后说下平假名（Hiragana）和片假名（Katakana）切换的问题。日文图标是 あ 的时候输入的是平假名，按 <strong>ctrl + caps lock</strong> 可以切换成<strong>片假名</strong>输入，这个时候图标是 ア。然后按 <strong>atl + caps lock</strong> 可以切换成<strong>平假名</strong>输入。</p>
<p>当然还有一个快捷的办法，在平假名输入的时候，当打出音标的时候有条下划线，类似于我们拼音输入法候选词的时候那个下划线，这个时候按 <strong>F7</strong> 音标会变成<strong>片假名</strong>；同理在片假名的输入的时候按 <strong>F6</strong> 会变成<strong>平假名</strong>。</p>
<p>有了上面的基础，你就可以愉快的打出日文啦（当然前提是你要把五十音图背熟）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/window%20%E5%BC%80%E5%90%AF%E8%87%AA%E5%B8%A6%20ftp/</loc>
    <lastmod>2015-01-31T08:15:16.000Z</lastmod>
    <data>
        <display>
        <title>window 开启自带 ftp</title>
        <pubTime>2015-01-31T08:15:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<h2 id="win7">win7</h2>
<h3 id="添加_ftp_用户">添加 ftp 用户</h3>
<p>在windows里添加一个用户。这个其实是你ftp的用户。当然你可以使用匿名访问，但是这样不怎么安全，要知道ftp外网其实也是可以连进来的。去把密码设一下，标准用户就可以了，不用管理员权限的。</p>
<h3 id="设置_ftp_目录">设置 ftp 目录</h3>
<p>在你机子上的任何一个硬盘分区创建一个文件夹，当做ftp的根目录。当然你使用你整个计算机硬盘也可以，不过这样不太好。</p>
<h3 id="开启_ftp_服务">开启 ftp 服务</h3>
<p>控制面板 —&gt; 程序与功能 —&gt; 打开或关闭windows功能 —&gt; 在Internet信息服务（IIS）里面找到FTP服务器全部打钩。确定重启电脑，一定要重启不然待会找不到IIS的。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/activate-ftp/1.jpeg" alt=""></p>
<h3 id="创建_ftp_站点">创建 ftp 站点</h3>
<p>重启后：控制面板 —&gt; 管理工具-Internet信息服务（IIS）管理器：在左边右击的你的PC站点，我的pC名字是kebin，所以是KEBIN—PC（我从网上抄的图啊~~）。后添加FTP站点，写上你的FTP站点名称，还有指定的物理路径（就是你之前创建的那个文件夹啦），下一步就是ip地址选择“全部未分配”，端口号21；自动启动FTP站点,SS里面选择“允许”。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/activate-ftp/2.jpeg" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/activate-ftp/3.jpeg" alt=""></p>
<h3 id="配置_ftp">配置 ftp</h3>
<p>下一步，就是身份验证和授权信息的填写，验证选择 “基本”（这里是禁止掉了匿名访问的，你要是不怕的话大可开启匿名访问）。然后授权，选指定用户，填上你之前在本机上创建的用户名。权限如果你想只读的话，就只设置读取。不过要共享的话，就要把写入也勾上，这样别人可以把东西也上传到你的机子上。</p>
<h3 id="启动_ftp">启动 ftp</h3>
<p>这样ftp站点就建成了，试下启动，右击站点，”管理ftp站点”-“启动”。如果启动不了，出现“除非Microsoft FTP 服务（FTPSVC）正在运行，否则无法启动FTP站点。服务目前已停止”，就是你的ftp服务还未开启。控制面板-管理工具-服务-找下microsoft FTP服务协议，右击，启动。回去IIS面板里面的启动你的FTP站点。</p>
<h3 id="设置_ftp_用户权限">设置 ftp 用户权限</h3>
<p>在 IIS 管理器的左边点开你的机子 —&gt; 站点 —&gt; 你的ftp（你设置的ftp的名字），右键选择 “编辑权限”，然后在 “安全” 里添加你之前设置的 ftp 用户，然后选 “编辑” 把相应读写权限加上。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/activate-ftp/4.jpeg" alt=""></p>
<p>最后就可以让别人访问你的ftp啦。在window的资源管理器的地址栏或是ftp软件里登录： ftp://xx.xx.xx.xx （你机子当前的ip地址），然后让别人输入你设置的 ftp 用户名和密码，就可以访问啦。如果是你的自己的电脑能登陆，别人的不能登陆，那就是你的防火墙问题了。控制面板-windows防火墙-找到FTP服务器-点击“更改设置”，在对应的地方打上钩。确定，退出。要不然，就直接把防火墙关了。</p>
<h2 id="win8">win8</h2>
<p>win8 开 ftp 其实和 win7 差不多的，也是首先要去 控制面板—&gt;程序—&gt;程序和功能—&gt;启用或关闭 window 功能 那里去把“FTP服务”、“FTP扩展性”和“IIS管理控制台这几个功能开启。然后去 IIS 管理那里设置 ftp 相关的功能，然后开始 ftp 服务就可以了。如果找不到设置的地方，可以用 win8 系统的搜索功能（鼠标放到屏幕右边就会出来了，例如输入 IIS 就可以搜得到 IIS 管理程序）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/win8.1%20%E8%87%AA%E5%B8%A6%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3/</loc>
    <lastmod>2015-01-31T08:00:16.000Z</lastmod>
    <data>
        <display>
        <title>win8.1 自带程序入口</title>
        <pubTime>2015-01-31T08:00:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<p>微软的 win8.1 系统设计师真是脑门被门板夹了，把那个啥移动设备的 UI 搬到传统桌面上来，搞得很多以前一些系统自带的工具都找不到在哪进去了（以前在开始菜单那的）。不过其实这些东西都还在的，可以从运行那里直接敲命令进去（win键+x+r进入运行），这里记一下，备忘。</p>
<h2 id="cleanmgr">cleanmgr</h2>
<p>自带的磁盘清理工具，比网上的xx清理好很多。</p>
<h2 id="defender">defender</h2>
<p>自带的杀毒软件，感觉比网上那些免费的好不少，至少没一堆广告，而且从 win7 开始 window 的安全性本身就很高了，再加上个自带的杀毒软件，偶尔扫描一下，自己再注意点，就差不多了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/window%20%E4%B8%8B%E7%9A%84%20linux%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</loc>
    <lastmod>2015-01-31T08:00:16.000Z</lastmod>
    <data>
        <display>
        <title>window 下的 linux 开发工具</title>
        <pubTime>2015-01-31T08:00:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<p>有些时候要在 window 环境下工作的，这个时候就需要一些必要的工具来 window 上实现一些 linux 上的功能。</p>
<h2 id="cygwin（linux_环境模拟工具）">cygwin（linux 环境模拟工具）</h2>
<p>window 下的神器，不解释： <a href="http://www.cygwin.com/" title="cygwin 官网" target="_blank" rel="external">cygwin 官网</a></p>
<h2 id="GitBash（git）">GitBash（git）</h2>
<p>说真的把 cygwin 中的东西装齐了，这个没 cygwin 神器。</p>
<h2 id="Tortoisesvn_(svn)">Tortoisesvn (svn)</h2>
<p>同 GitBash 没 cygwin 神器： <a href="http://tortoisesvn.net/" title="window svn 工具官网" target="_blank" rel="external">window svn 工具官网</a></p>
<h2 id="putty（远程登录工具）">putty（远程登录工具）</h2>
<p>同样 cygwin 中 ssh 配好，这个也没用了： <a href="http://www.putty.org/" title="putty 官网" target="_blank" rel="external">putty 官网</a></p>
<h2 id="vncviewer（虚拟桌面工具）">vncviewer（虚拟桌面工具）</h2>
<p><a href="http://www.realvnc.com" title="vncviewer 官网" target="_blank" rel="external">vncviewer 官网</a></p>
<h2 id="mstsc-exe（远程桌面工具）">mstsc.exe（远程桌面工具）</h2>
<p>这个是 window 自带的工具。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E6%8F%90%E5%8F%96%20OEM%20window%20key/</loc>
    <lastmod>2015-01-31T07:55:16.000Z</lastmod>
    <data>
        <display>
        <title>提取 OEM window key</title>
        <pubTime>2015-01-31T07:55:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<p>如果买带 window 的笔记本，自带的 window 都是 OEM 授权的正版来的，有 OEM key 的。但是这个 key OEM 厂商并没有主动显式的提供给用户。这样如果自己重新装系统就没办法正常激活正版 window 了。也许 OEM 就想着用户不要自己装系统。不过这个 key 都在我们的笔记本里了，咋还能拿不到么， JS 果然是没办法和广大网友斗的。</p>
<h2 id="提取_OEM_key">提取 OEM key</h2>
<p>首先说下，这个 key 是写在 BIOS 里面的，每台笔记本唯一对应一个 key，所以这个 key 提取出来就被想着给别共享了，没用的，这个 key 只能自己用。首先用一个工具去把 BIOS 里面的 key 给读出来： <a href="http://pan.baidu.com/s/1sjLNbDr" title="RwPortable-V1.6-x64" target="_blank" rel="external">RwPortable-V1.6-x64</a>。当然网上还有其它的工具，但是我是这个的，感觉还挺好用的。</p>
<p>刚刚那个工具解压后打开 rw.exe 程序，参考下图依次点击 ACPI—&gt;MSDM 选项。图中 Data 后面对应的字符就是电脑内置的 Win8/8.1 激活密钥啦。然后把这串东西自己拿个 txt 保存一下就好了（JS 让你奸）。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/dump-OEM-key/1.jpeg" alt=""></p>
<h2 id="选择正确的_window_版本">选择正确的 window 版本</h2>
<p>提取了 key 之后，自己重新装系统的时候还要选择正确的 window 版本才能用 OEM key 激活的。因为 OEM key 是对应特定的 window 版本的，这个就是你笔记本预转的那个 window 版本。这个可以用 Win+R 打开运行，输入“slmgr.vbs /dlv”，回车即可看到预装系统版本信息（所以在没把信息收集全前，不要那么快把预装的系统干掉）。例如，Windows 8中文版查看结果如下图所示：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/dump-OEM-key/2.jpeg" alt=""></p>
<p>一般 win8 有如下几种版本：</p>
<pre config="brush:bash;toolbar:false;">
Win8单语言版本（CoreSingleLanguage）
Win8特定国家版（CoreCountrySpecific，Win8中文版属于该版本）
Win8普通版（Core）
Win8专业版（Professional）
Win8专业版含媒体中心（ProfessionalWMC）
Win8企业版（Enterprise）
</pre>

<p>预装的一般都是啥特定国家版（例如针对中国的版本），找到版本后，从网上找对应的版本的 iso 下就行了。然后在网上可以找得到这个版本得安装 key（注意是安装 key，这个 key 可以用来安装，但是装好的系统是非激活状态的，还要前面提取的 key 进行激活，前面的提取的 key 是不能用来安装的，有点麻烦的说）。其实没必要上啥旗舰版的（特定国家版好像就是高级家庭版加了点中文），预装版基本够用了（至少现在我没发现缺啥的东西）。关键正版还是挺爽的，不用担心被黑和去网上各种找 key，还是我还是喜欢官方原版的 OS，啥 xx 版的真的没原版舒服。</p>
<p>这里给个 win8.1 的版本下载地址噻： <a href="http://www.iruanmi.com/windows-8-1-rtm-iso-download/" title="Windows 8.1 正式版镜像下载大全" target="_blank" rel="external">Windows 8.1 正式版镜像下载大全</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/EFI%20%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F/</loc>
    <lastmod>2015-01-31T03:55:16.000Z</lastmod>
    <data>
        <display>
        <title>EFI 安装系统</title>
        <pubTime>2015-01-31T03:55:16.000Z</pubTime>
        
        <tag>window </tag>
         
        <tag>linux </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<p>啥叫 EFI 自己度娘、google 去，这里不解释。下面直接进入主题：</p>
<h2 id="EFI_安装_Win8（8-1）">EFI 安装 Win8（8.1）</h2>
<h3 id="制作启动安装U盘">制作启动安装U盘</h3>
<p>在EFI下安装系统，是不能像以前那样分区滴，必须重新分区，需要GPT格式。找个大点的 U盘（至少4G以上），格成 fat32 格式的。用 <a href="http://pan.baidu.com/s/1c0ckax6" title="Universal-USB-Installer" target="_blank" rel="external">Universal-USB-Installer</a> 把 win8 iso 制作成启动安装U盘。然后把 <a href="http://pan.baidu.com/s/1dDILxJz" title="EFI(x64)" target="_blank" rel="external">EFI(x64)</a> 下的文件全部 copy 到U盘根目录下。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/1.jpeg" alt=""></p>
<h3 id="进入_EFI">进入 EFI</h3>
<p>这个比较简单，只要进入bois设置一下即可。启动项里，将UEFI这一项放到第一个：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/2.jpeg" alt=""></p>
<h3 id="创建启动分区">创建启动分区</h3>
<p>进入EFI后，实际上就直接进入安装界面了，和正常安装相同，这里就不赘述了。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/3.jpeg" alt=""></p>
<p>到了选择分区的那一步停止（因为下一步是灰的）按shift+F10，打开命令提示行：</p>
<h4 id="1、把MBR磁盘转换为GPT磁盘">1、把MBR磁盘转换为GPT磁盘</h4>
<p>键入 diskpart ，打开 diskpart 工具，选择目标磁盘：</p>
<ul>
<li>list disk——————————列出系统拥有的磁盘</li>
<li>select disk 0 ———————选择0号磁盘（请根据磁盘大小，自行判断你的目标磁盘</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/4.jpeg" alt=""></p>
<h4 id="2、清空目标磁盘，并转换为GPT格式">2、清空目标磁盘，并转换为GPT格式</h4>
<ul>
<li>clean————————————-清除磁盘,该命令会抹去磁盘上所有数据（注意备份以前的重要数据）<br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/5.jpeg" alt=""></li>
<li>convert gpt—————————将磁盘转换为GPT格式<br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/6.jpeg" alt=""></li>
<li>list partition————————-列出磁盘上的分区，因为我们刚转换成GPT格式，因此，分区为空<br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/7.jpeg" alt=""></li>
</ul>
<h4 id="3、建立EFI分区及系统安装分区">3、建立EFI分区及系统安装分区</h4>
<ul>
<li>create partition efi size=200———————-建立EFI分区，大小为200M<br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/8.jpeg" alt=""></li>
<li>create partition msr size=128———————建立MSR分区，微软默认建立的话，大小是128M</li>
<li>create partition primary size=51200———-建立主分区，大小为50G，根据自己需求调整，该分区用来安装win8</li>
<li>list partition————————————————-列出磁盘上的分区<br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/9.jpeg" alt=""></li>
</ul>
<p>PS：其实，一个diskpart工具，几乎可以代替其他的第三方磁盘工具了，大部分硬盘分区工具是无法更改GPT格式磁盘的分区ID的，但是diskpart可以。</p>
<h3 id="安装win8：">安装win8：</h3>
<p>关闭命令提示符，点刷新:</p>
<p><img src="hhttp://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/10.jpeg" alt=""></p>
<p>选择50G的主分区安装win8:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/other/EFI-install/11.jpeg" alt=""></p>
<p>然后等着安装完成就 OK 了。</p>
<p><a href="http://benyouhui.it168.com/thread-2475714-1-1.html" title="原始出处" target="_blank" rel="external">原始出处</a></p>
<h2 id="EFI_安装_ubuntu">EFI 安装 ubuntu</h2>
<p>EFI Ubuntu 安装参看官网的的文档吧：  <a href="https://help.ubuntu.com/community/UEFI" title="Ubuntu EFI" target="_blank" rel="external">Ubuntu EFI</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Other" url="http://www.light3moon.com/categories/Other/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/cygwin%20screen%20Caption%20line%20issue/</loc>
    <lastmod>2015-01-31T03:50:16.000Z</lastmod>
    <data>
        <display>
        <title>cygwin screen Caption line issue</title>
        <pubTime>2015-01-31T03:50:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<p>win8.1 64bit cygwin screen 4.1.0 在 screenrc 中设置：caption always “%{= dd}%-w%{+bu}%n %t%{-}%+w” （就是 screen session 的标题一直显示） 会造成当显示内容超过一屏会在最后一行（就是显示标题那一行）重复覆盖显示。 google 了好久，在这发现一个老外的解决办法：<a href="http://stackoverflow.com/questions/18881116/gnu-screen-output-that-causes-the-screen-to-scroll-leaves-garbage-at-the-bottom" title="screen output issue" target="_blank" rel="external">screen output issue</a>  。 说是要在 cygwin 中装 xterm，我把 cygwin xterm 的包全装上了，但是还是有这个问题。不过后面我右键 cygwin 窗口，调出 option —&gt; terminal —&gt; Type 那里改成 xterm-vt220 就好了。</p>
<p>PS：一开始好像默认是 xterm 的，我不知道装不装 xterm 包会不会出 xterm-vt220 的选项，terminal type 那还有好几个别的选项，我不太清楚其它的有什么区别，反正是又能正常用了。64bit win8.1 的 cygwin 问题咋就这么多咧，我以前 win7 用得好好的，蛋蛋疼了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/cygwin%20screen%20Directory%20tmp%20uscreens%20S-UserName%20must%20have%20mode%20700/</loc>
    <lastmod>2015-01-31T03:49:16.000Z</lastmod>
    <data>
        <display>
        <title>cygwin screen Directory tmp uscreens S-UserName must have mode 700</title>
        <pubTime>2015-01-31T03:49:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<p>win8.1 cygwin 目录权限问题很多。使用 cygwin 自带安装的 screen 会报上面的错误。S-UserName 就是你 cygwin 的用户名。有2种解决办法：</p>
<h2 id="修改文件夹所有者">修改文件夹所有者</h2>
<p>一开始我根据它的提示直接去改这个 S-UserName 这个文件夹的权限为 700 （chmod -R 700 S-UserName）。但是发现没用，还是报这个错。google 到一个老外说要把这个文件夹的所属用户组改一下：</p>
<ul>
<li>chgrp Users S-UserName （cat /etc/group 可以看得到 cygwin 下面有一个 Users 组的）</li>
<li>chmod -R 700 S-UserName （改完用户组，再改一次权限就 OK 了）</li>
</ul>
<h2 id="修改源码">修改源码</h2>
<p>在这里 <a href="https://gist.github.com/pasela/3401354" title="screen-4.1.0-cygwin-sock-permission.patch" target="_blank" rel="external">screen-4.1.0-cygwin-sock-permission.patch</a> 可以找得到 screen 4.1.0 的一个 patch，就是在 cygwin 的环境下忽略这个文件夹的权限检测：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/screen.c b/src/screen.c</div><div class="line">index <span class="number">6e19732</span>.<span class="number">.3</span>a8ca3e <span class="number">100644</span></div><div class="line">--- a/src/screen.c</div><div class="line">+++ b/src/screen.c</div><div class="line">@@ -<span class="number">1102</span>,<span class="number">8</span> +<span class="number">1102</span>,<span class="number">10</span> @@ <span class="keyword">char</span> **av;</div><div class="line"> 	      n = (eff_uid == <span class="number">0</span> && (real_uid || (st.st_mode & <span class="number">0775</span>) != <span class="number">0775</span>)) ? <span class="number">0755</span> :</div><div class="line"> 	          (eff_gid == (<span class="keyword">int</span>)st.st_gid && eff_gid != real_gid) ? <span class="number">0775</span> :</div><div class="line"> 		  <span class="number">0777</span>;</div><div class="line">+<span class="preprocessor">#<span class="keyword">if</span> !defined(__CYGWIN__)</span></div><div class="line"> 	      <span class="keyword">if</span> (((<span class="keyword">int</span>)st.st_mode & <span class="number">0777</span>) != n)</div><div class="line"> 		Panic(<span class="number">0</span>, <span class="string">"Directory '%s' must have mode %03o."</span>, SockDir, n);</div><div class="line">+<span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"> 	    }</div><div class="line"> 	  <span class="built_in">sprintf</span>(SockPath, <span class="string">"%s/S-%s"</span>, SockDir, LoginName);</div><div class="line"> 	  <span class="keyword">if</span> (access(SockPath, F_OK))</div><div class="line">@@ -<span class="number">1133</span>,<span class="number">8</span> +<span class="number">1135</span>,<span class="number">10</span> @@ <span class="keyword">char</span> **av;</div><div class="line">       <span class="keyword">if</span> ((<span class="keyword">int</span>)st.st_uid != real_uid)</div><div class="line"> 	Panic(<span class="number">0</span>, <span class="string">"You are not the owner of %s."</span>, SockPath);</div><div class="line">     }</div><div class="line">+<span class="preprocessor">#<span class="keyword">if</span> !defined(__CYGWIN__)</span></div><div class="line">   <span class="keyword">if</span> ((st.st_mode & <span class="number">0777</span>) != <span class="number">0700</span>)</div><div class="line">     Panic(<span class="number">0</span>, <span class="string">"Directory %s must have mode 700."</span>, SockPath);</div><div class="line">+<span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">   <span class="keyword">if</span> (SockMatch && index(SockMatch, <span class="string">'/'</span>))</div><div class="line">     Panic(<span class="number">0</span>, <span class="string">"Bad session name '%s'"</span>, SockMatch);</div><div class="line">   SockName = SockPath + <span class="built_in">strlen</span>(SockPath) + <span class="number">1</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以在 cygwin 中下载 screen 4.1.0 的 source 下来（要编译的话还得把 devel 那一票工具下下来，automake、make 子类的，还得把 cygwin 的开发头文件下下来）。源码位置在 /usr/src/ 下面，是一个 tar.bz2 的压缩包，自己解压一下。照着打 patch，然后 autogen、configure、make，重新编译出 screen.exe ，然后把这个 exe 替换到 /usr/bin 下面就可以了。用是可以用了，不过好像我自己打过 patch 编出来的有些小问题，退出的时候老报个什么错误，快捷键也有点小错误。所以还是第一种方法靠谱点，这个纯粹是逗自己玩（正好我用的 cygwin screen 版本是 4.1.0 的）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/window%20%E5%9C%A8%20cygwin%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20repo%20ssh/</loc>
    <lastmod>2015-01-31T03:42:16.000Z</lastmod>
    <data>
        <display>
        <title>window 在 cygwin 中使用 repo ssh</title>
        <pubTime>2015-01-31T03:42:16.000Z</pubTime>
        
        <tag>window </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<p>其实在 cygwin 中弄 ssh 是为使用在 window 中使用 repo 。如果单纯为了在 window 上 ssh 登陆 linux 服务器的话，直接用 putty 就行了，简单方便，无需安装、配置。</p>
<h2 id="安装_cygwin">安装 cygwin</h2>
<p>从<a href="http://cygwin.com/setup.exe" title="cygwin web" target="_blank" rel="external">cygwin web</a> 下载一个很小的 setup.exe ，然后第一选从网上安装（第一次装好后，会把安装文件缓存到你指定的目录，下次就可以选中从本地安装了）。如果选择从网上安装的话，之后会让你选择安装源（我选的163的那个，看上去就像是国内的源）。之后就会解析源信息（无论是在线的、还是本地的），如果出现说：提示你这个 setup.exe 有新版，然后出现解析失败的话，先要去它提示你的网址下载最新的 setup.exe，然后就会解析成功了。</p>
<p>最后一步是让你选择要安装的包，如果你硬盘够大，又不在意安装时间的话，可以全部选择安装（在那些分类上点击出现  install 就行了）。默认是 default，default 的话，它会安装一些最基本的 linux 的包（例如 bash 这些），然后如果是之前安装过的，default 是会保留你之前安装的包。所以如果你要卸载的话 ，就把它点成 uninstall，还有一个 reinstall 是重新安装。</p>
<p>这些我只是要用 repo 和 git （svn也算上吧）而已，所以把 Net 大类和 Python （repo要用 python）大类点上（点成 install 状态，然后点开看到具体的软件的版本号就算行了），然后在搜索栏上敲 ssh，把出来的也点上（一般就是  openssh），然后还可以点些自己需要的东西，例如 vim、unzip、sqlite 等。我为了省空间强制干掉了 X11、Gonme、KDE、Graphic、Audio 的东西，然后也没点啥编译的东西（gcc、make 之类的玩意，这些东西在 Devel 这个类下，想在 window 下要编 NDK 的要勾上这些了）。</p>
<p>选好后，点下一步就等进度条就行了。</p>
<h2 id="配置_cygwin">配置 cygwin</h2>
<p>cygwin 是个在 window 上模拟的 linux 环境，很多和 linux 差不多。我们可以先配一下，以后用着顺手。一开桌面上的快捷方式，它会在你的安装目录下以你当前 window 用户创建一个用户目录，例如我的安装目录是 C:\cygwin ，我当前的 window 用户是 Administrator，那就会创建这么目录。然后在这个目录下会自动创建 .bashrc_histroy 等一些文件。顺带说一下，这个目录就是你的 home 目录了，然后在安装目录下就有 etc、usr、lib、dev、bin 等 linux 的目录。然后我们可以自己用得习惯的 bash 配置文件 .bashrc 放到自己的 home 目录（还可以放一些别的软件配置文件，例如 .srceenrc, .vimrc 等）。不过别以直接丢 .bashrc 到 home 就完事了，你再次打开 bash 发现是无效的。因为 cygwin bash 的配置文件不在这个 home 目录下，而是在 etc 下的 bash.bashrc 。当然你可以在 bash.bashrc  里改，但是我建议还是把你自定义的配置文件放到 home 目录下，然后在 bash.bashrc 的最后加上 source ~/.bashrc 就 OK 了。这样做的好处的能最大的兼容 cygwin ，因为你打开 bash.bashrc 会发现它其实设置了一些东西的，所以最好不要乱动别人的东西。</p>
<h2 id="配置_sshd">配置 sshd</h2>
<p>ssh 的客户端不需要配置什么东西，直接 ssh username@host 就可以用。不过一上来就这么用的话，会发现会报啥 connect to xx port  22: Conection  refused 之类的错误的。这个是因为你的 ssh 服务的守护进程没有启动（也就是 sshd）。我这里的配置大多数是网上的：</p>
<p>如果之前有配置过，但是配错了，想重新配置，就直接敲 ssh-host-config 就行了。但是如果想重新安装，可以用 sc delete sshd 这个命令先把之前安装的 sshd 服务给卸掉。如果创建了一些不想用的window用户，可以去 window 的控制面板去闪除。如果是 cygwin 的用户的话，你直接把 /etc/passwd 和 /etc/group 给删掉就好了，然后再用 mkpasswd -l &gt; /etc/passwd 和 mkgroup -l &gt; /etc/group 重新恢复默认用户和用户组就行了。记得重新分组后，要 chmod +r /ect/passwd 和 chmod +r /ect/group 改下权限，然后 rm -rf /var ，把这些临时文件给删掉。</p>
<p>其实就是直接敲 ssh-host-config ，只不过会一些选项让你选择而已：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">$ ssh-host-config</div><div class="line">*** Info: Generating /etc/ssh_host_key</div><div class="line">*** Info: Generating /etc/ssh_host_rsa_key</div><div class="line">*** Info: Generating /etc/ssh_host_dsa_key</div><div class="line">*** Info: Creating default /etc/ssh_config file（如果这里之前安装过，会问你是否覆盖，选 yes 覆盖）</div><div class="line">*** Info: Creating default /etc/sshd_config file （如果这里之前安装过，会问你是否覆盖，选 yes 覆盖）</div><div class="line"></div><div class="line">*** Info: Privilege separation is <span class="keyword">set</span> to yes by default since OpenSSH <span class="number">3.3</span>.</div><div class="line">*** Info: However, this requires a non-privileged account called <span class="string">'sshd'</span>.</div><div class="line">*** Info: For more info on privilege separation <span class="built_in">read</span> /usr/share/doc/openssh/REAME.privsep.</div><div class="line">*** Query: Should privilege separation be used? (yes/no) yes（这里的意思开启 sshd 需要一个有系统管理员权限的用户，说的是 window 的；问你是不是要单独创建一个这样的window用户，网上有说选no，有说选 yes 的，我是选 yes 的，可以启动 sshd）</div><div class="line"></div><div class="line">*** Info: Updating /etc/sshd_config file</div><div class="line">*** Info: Creating default /etc/inetd.d/sshd-inetd file</div><div class="line">*** Info: Updated /etc/inetd.d/sshd-inetd</div><div class="line">*** Warning: The following functions require administrator privileges!</div><div class="line">*** Query: Do you want to install sshd as a service?</div><div class="line">*** Query: (Say <span class="string">"no"</span> <span class="keyword">if</span> it is already installed as a service) (yes/no) yes（这里是问你是不是要安装 sshd 服务，肯定要选 yes，必须要装的）</div><div class="line">*** Info: Note that the CYGWIN variable must contain at least <span class="string">"ntsec"</span></div><div class="line">*** Info: <span class="keyword">for</span> sshd to be able to change user context without password.</div><div class="line"></div><div class="line">*** Query: Enter the value of CYGWIN <span class="keyword">for</span> the daemon: [] ntsec tty（这里好像问的你是使用的终端连接方式吧，照网上的说法填 ntsec tty）</div><div class="line">*** Info: On Windows Server <span class="number">2003</span>, Windows Vista, and above, the</div><div class="line">*** Info: SYSTEM account cannot setuid to other users -- a capability</div><div class="line">*** Info: sshd requires.  You need to have or to create a privileged</div><div class="line">*** Info: account.  This script will <span class="built_in">help</span> you <span class="keyword">do</span> so.</div><div class="line">*** Info: You appear to be running Windows <span class="number">2003</span> Server or later.  On <span class="number">2003</span></div><div class="line">*** Info: and later systems, it<span class="string">'s not possible to use the LocalSystem</span></div><div class="line"><span class="string">*** Info: account for services that can change the user id without an</span></div><div class="line"><span class="string">*** Info: explicit password (such as passwordless logins [e.g. public key</span></div><div class="line"><span class="string">*** Info: authentication] via sshd).</span></div><div class="line"><span class="string">*** Info: If you want to enable that functionality, it'</span>s required to create</div><div class="line">*** Info: a new account with special privileges (unless a similar account</div><div class="line">*** Info: already exists). This account is <span class="keyword">then</span> used to run these special</div><div class="line">*** Info: servers.</div><div class="line">*** Info: Note that creating a new user requires that the current account（这里第一次还会有个问题的，就是说如果你用的高于 window xp 的版本，就需要你重新创建一个有管理权限的用户，这个用户是 cygwin 的，这里选 yes，创建）</div><div class="line"></div><div class="line">*** Info: have Administrator privileges itself.</div><div class="line">*** Info: No privileged account could be found.</div><div class="line">*** Info: This script plans to use <span class="string">'cyg_server'</span>.</div><div class="line">*** Info: <span class="string">'cyg_server'</span> will only be used by registered services.</div><div class="line">*** Query: Do you want to use a different name? (yes/no) no（这里创建的用户默认名字是 cyg_server 问你是不是要改名字，一般不用改）</div><div class="line">*** Warning: Privileged account <span class="string">'cyg_server'</span> was specified,</div><div class="line">*** Warning: but it does not have the necessary privileges.</div><div class="line">*** Warning: Continuing, but will probably use a different account.</div><div class="line">*** Warning: The specified account <span class="string">'cyg_server'</span> does not have the</div><div class="line">*** Warning: required permissions or group memberships. This may</div><div class="line">*** Warning: cause problems <span class="keyword">if</span> not corrected; continuing...</div><div class="line"></div><div class="line">*** Query: Please enter the password <span class="keyword">for</span> user <span class="string">'cyg_server'</span>: ******（然后让你为刚刚创建的 cyg_server 设密码）</div><div class="line">*** Query: Reenter: ******</div><div class="line">*** Info: The sshd service has been installed under the <span class="string">'cyg_server'</span></div><div class="line">*** Info: account.  To start the service now, call `net start sshd<span class="string">' or</span></div><div class="line"><span class="string">*** Info: `cygrunsrv -S sshd'</span>.  Otherwise, it will start automatically</div><div class="line">*** Info: after the next reboot.</div><div class="line">*** Info: Host configuration finished. Have fun!</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后出现这个提示就表示配置成功了。因为新创建了2个用户（一个 window 的，一个 cygwin 的），再用 mkpasswd -l &gt; /etc/passwd 和 mkgroup -l &gt; /etc/group 重新设置下用户信息。如果配置的过程中，出现创建用户不成功的提示，就用最开始说的，把之前创建的用户给删掉；还有在重新配置前先要停掉正在运行的 sshd 服务（net stop sshd）。</p>
<p>然后按提示的，使用 net start sshd 就可以启动 sshd 服务了。成功的话，会出成功的提示（cygwin bash 中文乱码的话，右键鼠标 —&gt; options —&gt; text 设置下编码可以解决）。然后在 window 的控制面板中的 系统安全 —&gt; 管理工具 —&gt; 服务 中可以看到一个叫 CYGWIN sshd 的服务，点开属性，登陆那里可以看到是使用刚刚创建的用户在启动的。</p>
<p>然后就可以使用 ssh user@host 来登陆了。如果使用密码登陆，记得把服务器的 /etc/ssh/sshd_config 中的 PasswordAuthentication 设置成 yes，如果使用密钥进行登陆就把 RSAAuthentication 和 PubkeyAuthentication 设置成 yes （具体使用密钥的方式，可以参看我的另外一篇叫 Rsa 验证的笔记）。</p>
<p>然后再记下，window 的 hosts 文件的位置在 C:\Windows\System32\drivers\etc 下，默认是隐藏、只读的系统文件。</p>
<p>最后，搞好 ssh 后，终于可以在 window 下用 repo 和 git pull、push 或是 sync 代码了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/cygwin%20%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-31T03:31:16.000Z</lastmod>
    <data>
        <display>
        <title>cygwin 使用备忘</title>
        <pubTime>2015-01-31T03:31:16.000Z</pubTime>
        
        <tag>window </tag>
         
         <content><![CDATA[<h2 id="乱码">乱码</h2>
<p>有些时候中文或是别的字符集会乱码。可以右键单击标题栏 ——&gt; Options ——&gt; Text 修改字符集还有编码，但是注意一下，有些如果改了对应的字符集和编码，记得上面的 Font 要选择相应支持的字体才行。例如说，如果改的是<strong>GBK</strong>的，字体要选择<strong>宋体</strong>之类的才行。有些时候改了，一些命令的输出对了，但是正常使用又不行了，可以临时改了，用完了命令后再改回去。</p>
<h2 id="清屏">清屏</h2>
<p>cygwin 好像没带 clear 命令，可以使用 ctrl + L 代替。</p>
<h2 id="win8-1_提示_ssh_私钥权限错误">win8.1 提示 ssh 私钥权限错误</h2>
<p>有些时候复制 ssh 私钥的时候会出现权限问题，一般 cygwin 会提示：</p>
<pre>
Permissions 0660 for '/home/***/.ssh/id_rsa' are too open. It is required that your private key files are NOT accessible by others. 
</pre>

<p>一般按照提示去把 <code>id_rsa</code> chmod 600 就行了。但是在 win8.1 下有个蛋疼的问题。就是你 chmod 600 会发现还是 660 ，就是 group 和 other 的权限怎么都收不回来。后来发现是因为 win8.1 的 cygwin 有个 None 的用户组，这个组很奇怪。<code>id_rsa</code> 被分到那个组去了。解决办法很简单，cat /etc/group 把 <code>id_rsa</code> 分配到不是 None 的组就行了，例如说我分配到 Users 组去了（<code>chgrp Users id_rsa</code> 就行了）。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/window/cygwin-note/1.jpeg" alt=""></p>
]]></content>
         
         
           
             
              <breadCrumb title="Window" url="http://www.light3moon.com/categories/Window/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%88%A0%E9%99%A4%E9%81%97%E5%BF%98%E7%9A%84%20vpn%20%E5%AD%98%E5%82%A8%E5%87%AD%E6%8D%AE/</loc>
    <lastmod>2015-01-31T03:21:16.000Z</lastmod>
    <data>
        <display>
        <title>删除遗忘的 vpn 存储凭据</title>
        <pubTime>2015-01-31T03:21:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>自从入手了 nexus7，公司就不时有人来玩下新系统的新功能。上次好像谁给我设了什么加密的破密码，后面他好像解除掉了，但是不知道为什么每次我进系统设置的 vpn 界面，就弹个什么鸟界面，让我输入什么存储的凭据，我刚开始以为是我设置锁屏的 PIN 码，但是不对。连续输错了3次后，系统提示说存储凭据已被删除，但是还是让我继续输存储凭据的密码，不让我添加、编辑 vpn 。我操，哪个脑残设计的， vpn 和这玩意有关系么，以为是 vpn 帐号的密码，试了好几次也不是。</p>
<p>搞得我差点想去改源码，废了这个脑残的东西（后面知乎上有人说老外用 vpn 的场景一般是公司内部比较隐身的网络，所以需要设置一些加密措施，不像国内一般是翻墙用的）。后面度娘发现，好像这个鸟 keystore 存在：</p>
<pre>
# 当前用户
/data/misc/keystore/user_0/.masterkey
</pre>

<p>NND，哥自己编的系统，root 权限随便玩，二话不说，shell 上去 rm 掉，然后重启，终于可以玩 vpn。蛋蛋疼。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%5B%E8%BD%AC%5D%20Nexus7%202rd%20unlock%20fastboot/</loc>
    <lastmod>2015-01-31T03:00:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Nexus7 2rd unlock fastboot</title>
        <pubTime>2015-01-31T03:00:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<ul>
<li>电脑上装 android sdk（主要是保证有 platform-tools 下的 adb 和 fastboot）。</li>
<li>装 usb 驱动，window 要，linux 下不需要，地址： <a href="http://developer.android.com/sdk/win-usb.html" title="google usb driver" target="_blank" rel="external">google usb driver</a>。</li>
<li>在 N7 上开启 adb，这个默认的系统把开发者选项隐藏起来了，在 系统设置 —&gt; 关于 —&gt; 系统版本号 那里多点几下就能开启开发者模式，里面可以开启 adb。</li>
<li>adb reboot bootloader —&gt; 当 n7 进入 bootloader 后，输入 fastboot oem unlock 然后用音量+、-选择 yes，按电源确定。</li>
</ul>
<p>PS： unlock fastboot 会格掉机器中的所有数据，整之前记得把数据备份下。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/Google%20android%20source%20code%20build%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-31T02:58:16.000Z</lastmod>
    <data>
        <display>
        <title>Google android source code build 问题总结</title>
        <pubTime>2015-01-31T02:58:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<h2 id="编译_external/chromium_org_出错">编译 external/chromium_org 出错</h2>
<p>编译 external/chromium_org 的时候如果报类似下面的错误：</p>
<pre config="brush:bash;toolbar:false;">
Traceback (most recent call last):
  File "../../base/android/jni_generator/jni_generator.py", line 1065, in <module>
    sys.exit(main(sys.argv))
  File "../../base/android/jni_generator/jni_generator.py", line 1061, in main
    options.optimize_generation)
  File "../../base/android/jni_generator/jni_generator.py", line 996, in GenerateJNIHeader
    jni_from_javap = JNIFromJavaP.CreateFromClass(input_file, namespace)
  File "../../base/android/jni_generator/jni_generator.py", line 507, in CreateFromClass
    stderr=subprocess.PIPE)
  File "/usr/lib/python2.7/subprocess.py",/usr/java/jdk1.6.0_45/bin line 709, in __init__
    errread, errwrite)
  File "/usr/lib/python2.7/subprocess.py", line 1326, in _execute_child
    raise child_exception
OSError: [Errno 2] No such file or directory
make: *** [/home/odexcide/android-4./out/target/product/generic/obj/GYP/shared_intermediates/ui/gl/jni/Surface_jni.h] Error 1
make: *** Waiting for unfinished jobs....
</module></pre>

<p>那是 jdk 到 javap 没装好。其实不一定是没装，装完 jdk6 后，默认 java 的命令路径是 /usr/bin/java 这个其实是一个 /usr/java/jdk1.6.0_45/bin/java 的链接来的。去 /usr/java/jdk1.6.0_45/bin 下其实是有 javap（这个东西是用来反编译 java class 的） 的，这就好办了，自己手动在 /usr/bin/ 下创建一个 javap 的软链接就行了。</p>
<h2 id="5-0_编译_external/chromium_org_出错">5.0 编译 external/chromium_org 出错</h2>
<p>如果 javap 设置好，编这个 chromium_org 还是出错，那么可以在 chromium_org 的 Android.mk 加入这么一句：</p>
<pre>
PRODUCT_PREBUILT_WEBVIEWCHROMIUM :=yes
</pre>

<p>这句好像是说不自己编译 chromium 的 webiew（webkit？？），用预编译好的（源码里自带现成的）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%BA%94%E7%94%A8%E5%86%85%E7%BD%AE%E5%B9%BF%E5%91%8A.%E6%8B%A6%E6%88%AA%E7%AF%87/</loc>
    <lastmod>2015-01-31T02:46:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——拦截应用内置广告.拦截篇</title>
        <pubTime>2015-01-31T02:46:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>上一篇说到怎么检测一个应用是否带有广告。那么现在就来说说怎么拦截广告。在开始之前首先感谢看雪论坛的牛人的<a href="http://bbs.pediy.com/showthread.php?p=1158941" title="分享" target="_blank" rel="external">分享</a>，后面的方法基本是借鉴别人的想法的。</p>
<h2 id="拦截思路">拦截思路</h2>
<h3 id="修改_hosts">修改 hosts</h3>
<p>以前在 PC 通过修改 hosts 来访问 google 的哥们对这个东西应该不陌生吧。同样在 android 也有这个东西。在 /system/etc/hosts 然后整个 /system/etc 链接到了根目录的 /etc 。</p>
<p>有了这个文件，网络请求就优先去读这个文件中的配置，如果 hosts 中有要访问的域名，就不会去请求 DNS 解析，所以如果把那些广告的域名写到这个文件里面，然后设置成 127.0.0.1 的话，那些广告 sdk 就无法从广告服务器获取广告数据了，就无法展现出来了。例如这样（下面这2个是 google ad 的）：</p>
<pre>
127.0.0.1 adwords.google.com
127.0.0.1 adwords.google.sk
</pre>

<p>然后这样设置的话，一般那些广告 sdk 访问网络都会报一个 xx hosts 无法解析的网络异常错误。</p>
<p>前面看雪论坛的哥们分析了乐安全是用这种方式的，我研究了下腾讯的手机管家，也是用这种方式。腾讯管家，是你勾选了那些应用，那就对应把这几个应用使用的广告 sdk 的广告域名写道 /system/etc/hosts 中。每次设置完后，去看 hosts 文件的更新日期就发现被改变了。</p>
<p>这种方法需要 root 权限，因为 system 分区是只读的，写 hosts 之前得先 remount 成读写的，而且 remount 成读写的之后，写也需要 root 权限。</p>
<p>这种方法比较简单。能够阻止广告 sdk 去服务器取数据，不仅省去广告的骚扰，而且能够节省广告的流量开销（当然在 wifi only 的平板上可以忽略这点）。但是同时广告 sdk 方也很容易应对。 hosts 文件只能记录对应一个域名，广告 sdk 只要定期随机更换域名去取广告数据就能够避免被屏蔽了（好像多盟广告就已经这么干了）。</p>
<h3 id="注入系统服务，屏蔽广告_view">注入系统服务，屏蔽广告 view</h3>
<p>这个属于比较高级（麻烦）的做法。具体的去看前面贴出那个看雪论坛的哥们分析的金山手机毒霸的帖子吧。简单来说就是向 system server 注入自己的代码，然后在 view 处理流程中检测出 activity 中的广告 view （一般的广告都有一个 view 作为载体的），然后把这个 view 屏蔽掉（设置为 GONE）。</p>
<p>这个也是需要 root 的（进程注入的 api 正常是用来调试用的，只允许注入子进程，但是 root 没有这个限制）。然后实现起来很麻烦。而且会影响正常的程序的效率。在 view 布局的流程加了一道这种工序。而且可能会影响某些程序的运行。因为是把广告 view 设置为 GONE 了。有些比较二的程序（不排除是故意）布局是以广告 view 为基准点的，你把它设置为 GONE 了，界面就全乱了（你把哥的广告屏蔽了，哥就不让你用了）。而且这种方法，广告还是把流量给跑了，只是没展现出来而已（就是说最终只是便宜了运营商而已）。</p>
<h2 id="实现">实现</h2>
<p>这里我选择了比较简单的修改 hosts 方法来实现。后一种方法实现太麻烦了。这里要改 hosts，我从网上找了一个网友收集的，还是挺多的，可以先暂时用着。然后你的程序可以写成 hosts 定时从服务器上更新，这样有新广告的时候也可以更新 hosts。但是最主要的问题是 root。腾讯手机管家，要使用这个功能，需要用户已经 root 了设备。这里我们就有想办法在手机上 root 了（俗称手机上一键 root）。</p>
<h3 id="root">root</h3>
<p>非 fastboot 刷机模式的 root 都是通过漏洞来提升自己的进程的权限来实现的（刷机的不说了，直接刷机工具把 su, busybox, superuser.apk 弄到 system 分区去了）。这里我直接贴出几个地址吧，我也不是研究这些漏洞的。一堆老外有事没事倒腾这些东西。</p>
<p><a href="http://www.exploit-db.com/" title="Exploit Database" target="_blank" rel="external">Exploit Database</a><br><a href="http://www.cvedetails.com/" title="CVE security vulnerability datasource" target="_blank" rel="external">CVE security vulnerability datasource</a></p>
<p>上面2个都是专门收集一些 linux 的漏洞的（kernel 的比较多，不能访问的时候请自备翻墙）。漏洞都以 CEV-xxxx-xxxx 的格式编号入库例如：CVE-2009-1234（后面那个一般是提交的时间）。然后有漏洞曝光提交后，如果这些漏洞有 linux kernel 的本地（local）漏洞，就可以用来提升进程的权限，来达到临时 root 的目的。然后这些漏洞曝光后，相关厂商会修复这些漏洞，同时会有修复补丁发出来，利用之前可以看看补丁的相关内容，确定下 kernel 还能否利用这个漏洞。</p>
<p>然后有个老外收集了一些 android 上 kernel 的漏洞，整了一个开源的工具出来：</p>
<p><a href="https://github.com/android-rooting-tools/android_run_root_shell" title="android_run_root_shell" target="_blank" rel="external">android_run_root_shell</a></p>
<p>下载的时候注意看上面的 READE.md 的说明，这是一个 recursive 的 git 库，附带其它别的一堆库的。代码写得还不错，能够比较方便的添加新的漏洞。我用 ndk 编译的时候（READE.md 有编译说明），报了几个错误，好像有一些漏洞的 api ndk 不支持，注释掉就好。</p>
<p>然后我在 rk（rockchip） 的 4.2.2 上试了下，这个漏洞有效：</p>
<p><a href="http://blog.csdn.net/hu3167343/article/details/34454381" title="Missing access checks in put_user/get_user kernel API (CVE-2013-6282)" target="_blank" rel="external">Missing access checks in put_user/get_user kernel API (CVE-2013-6282)</a></p>
<p>然后就是这个工具需要获取一些 kernel 中的函数地址。记录在 sqlite 的数据中。如果没有记录的话，就会尝试从 /proc/kallsyms 中去读。这个东西是 kernel 调试用的，在编译中，关闭一个选项这个文件中就没有地址了（一般发放出去的 kernel 这个文件都中的函数地址都是 0 来的）。所以好像指望这个东西来做坏事好像不行（我很好奇它自带的数据库里面那一堆地址从哪来的）。</p>
<p>不过我们 kernel 是自己编译的。在编译完 kernel 后，在 kernel 根目录生成一个 System.map 的文件，这个文件里面就有 kernel 所有函数以及 static 变量的地址（十六进制的）。只要确定 kernel <strong>版本</strong>，用<strong>相同的编译器</strong>编译一次就能得到地址了。</p>
<p>单个工具验证 OK，就要集成到 apk 中使用（要开始干坏事了）。首先上面那个小工具编译出来是一个 bin 文件，然后要改 hosts 文件的话，我决定把原来的 /system/etc/hosts 文件做一个软链接，指向一个普通应用可以读写的地方（例如 sdcard 的某个地方），所以需要一个 shell 脚本（在 root 的进程下调用）。然后做软件链接需要 busybox（编一个出来就好）。</p>
<p>东西准备好，思路就是：这些脚本、bin 文件全部放到 assert 目录下，程序安装好后，通过 AssertManager copy 到程序的 data 目录下，然后再 copy 到 /data/local/tmp 下面执行。注意，android 中 bin 文件要在 shell 下执行只有在这个目录和 system/bin, /system/xbin 下可以，所以要执行 root 工具需要 copy 到 /data/local/tmp 下，system 现在还没 root 权限咧，无法 remount 的。copy 完成后，就可以在目录下执行命令了。java 层执行命令可以用下面的代码（不用 jni 了还麻烦）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execlCommand</span>(String path, String command) {</div><div class="line">	Process proc = <span class="keyword">null</span>;</div><div class="line">	DataOutputStream os = <span class="keyword">null</span>;</div><div class="line">	BufferedReader in = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		Log.d(TAG, <span class="string">"execl path: "</span> + path + <span class="string">", command: "</span> + command);</div><div class="line">		</div><div class="line">		<span class="comment">// new a shell process for run out root kit</span></div><div class="line">		proc = Runtime.getRuntime().exec(<span class="string">"/system/bin/sh"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">// send shell command</span></div><div class="line">		os = <span class="keyword">new</span> DataOutputStream(proc.getOutputStream());</div><div class="line">		os.writeBytes(<span class="string">"echo new a shell, now execl the command ... \n"</span>);</div><div class="line">		os.writeBytes(<span class="string">"cd "</span> + path + <span class="string">" \n"</span>);</div><div class="line">		<span class="comment">// change the file permission, java api copy file can't provider the file have execute permission</span></div><div class="line">		os.writeBytes(<span class="string">"chmod 777 "</span> + RootKit.ROOT_BIN + <span class="string">" \n"</span>);</div><div class="line">		os.writeBytes(<span class="string">"chmod 777 "</span> + RootKit.ROOT_DB + <span class="string">" \n"</span>);</div><div class="line">		os.writeBytes(<span class="string">"chmod 777 "</span> + RootKit.SHELL_TOOL + <span class="string">" \n"</span>);</div><div class="line">		os.writeBytes(<span class="string">"chmod 777 "</span> + RootKit.SHELL_COMMAND + <span class="string">" \n"</span>);</div><div class="line">		<span class="comment">// and then execute the root kit</span></div><div class="line">           os.writeBytes(<span class="string">"./"</span> + RootKit.ROOT_BIN + <span class="string">" -c "</span> + command + <span class="string">" \n"</span>);</div><div class="line">           os.writeBytes(<span class="string">"exit \n"</span>);</div><div class="line">           os.flush();</div><div class="line">           </div><div class="line">           <span class="comment">// wait for shell execute</span></div><div class="line">		proc.waitFor();</div><div class="line">           </div><div class="line">           <span class="comment">// get result of execute command</span></div><div class="line">           Log.d(TAG, <span class="string">"command execl: "</span>);</div><div class="line">           in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(proc.getInputStream())); </div><div class="line">           String line = <span class="keyword">null</span>;    </div><div class="line">           <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) {    </div><div class="line">           	Log.d(TAG, line);</div><div class="line">           }</div><div class="line">           </div><div class="line">		<span class="comment">// release resources</span></div><div class="line">		proc.destroy();</div><div class="line">		os.close();</div><div class="line">		in.close();</div><div class="line">	} <span class="keyword">catch</span> (Exception e) {</div><div class="line">		e.printStackTrace();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>从 AssertManager copy 的代码我就不贴了，网上一大堆（就是 java io 的相关函数）。</p>
<p>其实，如果你收集的漏洞多（多去 google 一下老外，总会有新发现的，请自带翻墙），而且没有上面的那些函数地址的限制（或是你有办法可以在机器上获取到地址），自己就可以做所谓的一键 root 工具。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%BA%94%E7%94%A8%E5%86%85%E7%BD%AE%E5%B9%BF%E5%91%8A.%E6%A3%80%E6%B5%8B%E7%AF%87/</loc>
    <lastmod>2015-01-31T02:44:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——拦截应用内置广告.检测篇</title>
        <pubTime>2015-01-31T02:44:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>最近步步高的平板被熊孩子的家长爆料了，说里面有有黄色内容。后面发现是一些免费的第三放学习应用内置广告，在后台弹窗口广告，结果有些无节操的广告就蹦出来了，例如下面那个：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-antiad-scan/1.jpeg" alt=""></p>
<p>然后这边就让想办法屏蔽这些第三方应用内的广告。发现市场上有不少工具类的软件可以检测，并且拦截第三应用内的广告。例如腾讯手机管家、360安全卫士等。下载下来研究了下，从这些软件检测出来的结果好像可以看出一点线索：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-antiad-scan/2.jpeg" alt=""><br>（上面那个是腾讯手机管家的）</p>
<p>它列出的广告软件，后面都带有一些包名。虽然后面那些 a、b、c 之类应该是混淆过的，但是前面的前缀就很明显了。一般应用的广告都是集成一些广告或是平台的 sdk 。这里 sdk 一般都是 jar 包，虽然可以混淆，但是一般包名的前缀会保留，一般如果全部混淆弄成 a、b、c 之类，作为库来说，极易和其他混淆后的库或是程序本身的名字冲突。</p>
<p>这就给我们检测提供了机会了。我发现腾讯管家在扫描的时候会提示，正在扫描应用，然后之后会提示正在云端检测。好，这下我就能确定了（虽然可以反编译 apk 然后慢慢看，但是腾讯管家代码太多了，拦截广告只是它的一个小功能，我就懒得慢慢看了，这种时候需要大胆猜猜，呵呵）。它应该是可以扫描出 apk 调用了哪些类，然后应该有个广告的类名字数据库，本地匹配玩之后，再到它们的服务进行匹配（前面说了就算混淆了，但是前缀就能够识别了）。</p>
<p>于是去度娘了一下（度娘能解决的，就不请谷姐了，免得天天翻墙），发现 android 的 dex 还真有接口可以枚举出一个 apk 调用哪些 class 文件。下面直接上代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectInstalledPkgs</span>(ArrayList&lt;String&gt; output) {</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == output) {</div><div class="line">		Log.d(TAG, <span class="string">"output data is null, we can't collect installed pkgs"</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	List&lt;PackageInfo&gt; pkgInfos = mPm.getInstalledPackages(<span class="number">0</span>);</div><div class="line">	</div><div class="line">	output.clear();</div><div class="line">	<span class="keyword">for</span> (PackageInfo info : pkgInfos) {</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == info) <span class="keyword">continue</span>;</div><div class="line">		output.add(info.packageName);</div><div class="line">		Log.d(TAG, <span class="string">"collect pkg: "</span> + info.packageName);</div><div class="line">	}</div><div class="line">	</div><div class="line">	pkgInfos.clear();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanPkgDexFile</span>(String pkgName) {</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == pkgName) {</div><div class="line">		Log.d(TAG, <span class="string">"the target pkgName can't null !"</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	ApplicationInfo info = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		info = mPm.getApplicationInfo(pkgName, <span class="number">0</span>);</div><div class="line">	} <span class="keyword">catch</span> (NameNotFoundException e) {</div><div class="line">		e.printStackTrace();</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == info) {</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="comment">// we ignore system app or our bbk app</span></div><div class="line">	<span class="keyword">if</span> ((info.flags & ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span> </div><div class="line">			|| (info.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != <span class="number">0</span> </div><div class="line">			|| pkgName.startsWith(<span class="string">"com.eebbk"</span>) </div><div class="line">			|| pkgName.startsWith(<span class="string">"com.bbk"</span>)) {</div><div class="line">		Log.d(TAG, <span class="string">"pkg: "</span> + pkgName + <span class="string">" is system app or bbk app, we ignore it."</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		DexFile dexFile = <span class="keyword">new</span> DexFile(info.sourceDir);</div><div class="line">		Enumeration&lt;String&gt; entries = dexFile.entries();</div><div class="line">		Log.d(TAG, <span class="string">"scan pkg: "</span> + pkgName + <span class="string">" source path: "</span> + info.sourceDir);</div><div class="line">		<span class="keyword">while</span> (entries.hasMoreElements()) {</div><div class="line">			Log.d(TAG, entries.nextElement());</div><div class="line">		}</div><div class="line">		Log.d(TAG, <span class="string">" "</span>);</div><div class="line">	} <span class="keyword">catch</span> (IOException e) {</div><div class="line">		e.printStackTrace();</div><div class="line">		Log.e(TAG, <span class="string">"scan dex file failed !"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后贴下输出：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-antiad-scan/3.jpeg" alt=""><br>(很明显这个是 google 的 admob)</p>
<p>但是感觉好像和腾讯的有点不太一样。然后我在 framework 的 DexFile.java(ibcore/dalvik/src/main/java/dalvik/system/DexFile.java) 中加了打印，发现腾讯的好像没调这个接口。有点奇怪了，不知道它是通过什么方式检测的，可能通过 DexFile 是比较初级的办法，不过这个确实可以检测得出来。</p>
<p>另外在 AndroidManifest.xml 里面申明广告 sdk 的 activity 的一般都是插屏广告（就是那种弹出式的，整个大屏幕的）。也有接口可以解析 AndroidManifest 中申明的 activity 的，这样可以更加细化检测到的广告。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-31T02:31:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——利用反射需要注意的问题</title>
        <pubTime>2015-01-31T02:31:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>java 中的反射可以实现很多方便的功能。例如在配置文中写一些布局文件，运行的时候载入配置文件，然后利用反射创建配置文件中的对象（android 的 LayoutInflater 就是利用反射的）。</p>
<p>运用得好的话，会很方便，但是需要注意一点。混淆过后，就导致通过名字创建对象的反射机制无法正确的找到 class 。这个问题我在改 framework 的 SystemUI 出现过，我自己弄了一个东西通过 xml 去实现一些自定义的界面，然后里面就用到反射了。刚开始 eng debug 模式下爽歪歪，后面发正式版本，换成 user release 模式就给跪了，各种 class not found 的异常。</p>
<p>后来发现是混淆的问题，eng 模式是不带混淆的，user 模式才开启混淆。要用反射的话，就不要混淆要使用反射的类的构造函数，或是某些你反射中要用到的方法。</p>
<p>在对应的模块的 proguard.flags 的文件中增加配置就行了：</p>
<pre config="brush:bash;toolbar:false;">
-keep class com.android.systemui.statusbar.tablet.TabletStatusBarService {
  public void notificationIconsClicked(android.view.View);
  public void systemInfoClicked(android.view.View);
  public void recentButtonClicked(android.view.View);
  public void toggleLightsOut(android.view.View);
}

-keep class com.android.systemui.statusbar.policy.KeyButtonView {
  public float getDrawingAlpha();
  public float getGlowAlpha();
  public float getGlowScale();
  public void setDrawingAlpha(float);
  public void setGlowAlpha(float);
  public void setGlowScale(float);
}

-keep class com.android.systemui.statusbar.tv.TvStatusBar

-keep class * extends com.android.systemui.statusbar.toggle.NotificationToggleController {
  <init>(...);
}

-keep class com.android.systemui.statusbar.toggle.NotificationToggleScroller {
  public void setScrollPos(int);
  public int getScrollPos();
}
</init></pre>

<p>下面那几个 toggle 相关就是我自己增加的，其它的都是系统原来 SystemUI 的。这个问题以后要注意一下，别调试的时候乐呵呵，发布之后各种崩溃一时半会还不知道原因。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Android%20%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E7%B3%BB%E7%BB%9F%E5%AD%97%E4%BD%93/</loc>
    <lastmod>2015-01-31T02:19:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——Android 动态切换系统字体</title>
        <pubTime>2015-01-31T02:19:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>最近在调研一个东西，就是动态切换 android 的系统字体。我的手机是三棒的 Galaxy SIII，系统设置中自带的了这个功能：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-switch-sysfont/1.jpeg" alt=""></p>
<p>既然别人都弄出来了，应该是可行的。于是开始琢磨（这里事先申明下，以下是基于 4.1.2 的源码的）。</p>
<h2 id="初步了解">初步了解</h2>
<p>经过几番百度， Typeface（frameworks/base/graphics/java/android/graphics/Typeface.java） 这个类。这个类有好几个 public static final 的变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* The default NORMAL typeface object */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Typeface DEFAULT;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The default BOLD typeface object. Note: this may be not actually be</span></div><div class="line"><span class="comment"> * bold, depending on what fonts are installed. Call getStyle() to know</span></div><div class="line"><span class="comment"> * for sure.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Typeface DEFAULT_BOLD;</div><div class="line"><span class="comment">/* The NORMAL style of the default sans serif typeface. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Typeface SANS_SERIF;</div><div class="line"><span class="comment">/* The NORMAL style of the default serif typeface. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Typeface SERIF;</div><div class="line"><span class="comment">/* The NORMAL style of the default monospace typeface. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Typeface MONOSPACE;</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li><p><strong>DEFAULT</strong><br>默认字体。</p>
</li>
<li><p><strong>DEFAULT_BOLD</strong><br>默认的粗体字体，不过这个不一定是粗体，和就用的字体有关，如果你用的字体不是粗体，这个就不是粗体。</p>
</li>
<li><p><strong>SANS_SERIF</strong><br>正常样式的无衬线字体。</p>
</li>
<li><p><strong>SERIF</strong><br>正常样式的衬线字体。</p>
</li>
<li><p><strong>MONOSPACE</strong><br>正常样式的等宽字体。</p>
</li>
</ul>
<p>至于什么是衬线字、无衬线字、等宽字百度吧。然后还有4种样式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Style</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL = <span class="number">0</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOLD = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITALIC = <span class="number">2</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOLD_ITALIC = <span class="number">3</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>分别是正常、粗体、斜体、粗斜体。默认系统里面是有9个字体文件的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-switch-sysfont/2.jpeg" alt=""></p>
<p>那个 Fallback 是备用字体。Droid Sans Fallback 包含了东亚字符。当需要显示的字符在 Droid Sans 字体中不存在（如汉字），即没有对应编码的字符时，系统会到 Droid Sans Fallback 中去寻找相应编码的字符，如果找到，则使用 Droid Sans Fallback 字体来显示它，如果仍然找不到该编码对应的字符，则系统无法在屏幕上显示出这个字符。</p>
<p>所以要动态字体能够比较好的适应系统，虽然不一定要覆盖全这9种字体文件，但是至少要有4种会比较好，例如 <code>sans_serif</code> 的 Regular, Bold, Italic, BoldItalic 。这里只是简单的研究下，所以只去找个几个别的字体的 Regular 的。</p>
<p>然后，这些 static 变量都是 static 初始化的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> {</div><div class="line">    DEFAULT         = create((String) null, <span class="number">0</span>);</div><div class="line">    DEFAULT_BOLD    = create((String) null, Typeface.BOLD);</div><div class="line">    SANS_SERIF      = create(<span class="string">"sans-serif"</span>, <span class="number">0</span>);</div><div class="line">    SERIF           = create(<span class="string">"serif"</span>, <span class="number">0</span>);</div><div class="line">    MONOSPACE       = create(<span class="string">"monospace"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    sDefaults = <span class="keyword">new</span> Typeface[] {</div><div class="line">        DEFAULT,</div><div class="line">        DEFAULT_BOLD,</div><div class="line">        create((String) null, Typeface.ITALIC),</div><div class="line">        create((String) null, Typeface.BOLD_ITALIC),</div><div class="line">    };</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 create 是通过 jni 去调用 skia 的接口创建 SkTypeface 的。而创建相应的 SkTypeface 是根据系统加载的默认字体来决定的。系统的默认字体文件在 /system/fonts 下，配置也是在这个下面，是 <code>system_fonts.xml</code> 和 <code>fallback_fonts.xml</code> 。</p>
<p>而加载默认字体的代码在：<br><code>external/skia/src/ports/SkFontHost_android.cpp</code> 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> loadSystemFontsLocked() {</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> !defined(SK_BUILD_FOR_ANDROID_NDK)</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> prevLanguage[<span class="number">3</span>];</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> prevRegion[<span class="number">3</span>];</div><div class="line">    <span class="keyword">char</span> language[<span class="number">3</span>] = <span class="string">""</span>; </div><div class="line">    <span class="keyword">char</span> region[<span class="number">3</span>] = <span class="string">""</span>; </div><div class="line"></div><div class="line">    getLocale(language, region);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!gDefaultNormal) {</div><div class="line">        <span class="built_in">strncpy</span>(prevLanguage, language, <span class="number">2</span>); </div><div class="line">        <span class="built_in">strncpy</span>(prevRegion, region, <span class="number">2</span>); </div><div class="line">        initSystemFontsLocked();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(language, prevLanguage, <span class="number">2</span>) || <span class="built_in">strncmp</span>(region, prevRegion, <span class="number">2</span>)) {</div><div class="line">        <span class="built_in">strncpy</span>(prevLanguage, language, <span class="number">2</span>); </div><div class="line">        <span class="built_in">strncpy</span>(prevRegion, region, <span class="number">2</span>); </div><div class="line">        reloadFallbackFontsLocked();</div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (!gDefaultNormal) {</div><div class="line">        initSystemFontsLocked();</div><div class="line">        reloadFallbackFontsLocked();</div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里流程我没太仔细研究，因为是初步调研，最关键的是后面没下文了，所以没啥动力了。然后去解析前面那2个 xml 里面的内容，然后加载字体文件。然后上层 java 层的 Typeface 预先创建了几个默认的字形对象（Typeface）。然后应用可以直接引用这几个 static 的变量，也可以通过这几个变量创建出不同的样式（系统默认没创建完所有样式的 Typeface 变量，而且系统也没提供完所有 Typeface 的样式的字体文件，自己数数看，默认、衬线、无衬线、等宽4种类型，每种4种样式，默认字体才9个，还有一个是时钟专用的，就是才8个而已）。</p>
<h2 id="基本思路">基本思路</h2>
<p>有个初步了解后，那么基本思路就出来了。就是在 framework 里面弄一个界面（三棒的是在 Settings 里面的），读取特定路径下的可变化字体。然后替换默认字体，最后让应用更新一下就行了。基本思路虽然简单，其实实践起来有不少问题的。下面慢慢来说。</p>
<h2 id="1-替换默认字体">1.替换默认字体</h2>
<p>这点其实挺麻烦，因为系统使用的字体很多。要想完全换完，你得提供配套的可换的字体。这里你自己就得设计一下一套字体的规范了，例如必须要包含 Regular，其它的可选。然后那几种类型必须要有一个。然后这样肯定 ttf 文件不止一个，那么可以认为规定下 ttf 命名规范： <code>字体-类型.ttf</code> 。例如说： <code>Chococooky-Regular.ttf</code> 然后 UI 选择界面那里就只用出现一个名字： Chococooky 就代表了这一整套字体。然后自己把数据结构设计好，扫描的时候把 Chococooky 开头的都算上，然后根据后面的后缀判断这是什么类型、样式的。</p>
<p>这里可以规定一个目录，可以在 data 分区，专门放自定义可更换的字体。放 data 分区也方便以后在线更新。或者现在很多是把字体打包到 apk 里面了，这也好办，选中某个字体 apk 的时候，把里面的 ttf 复制到 data 分区就好了。不要不复制出 apk ，因为改系统字体，开机要加载的，如果单纯放 apk 里，不太稳定，还是复制到 data 分区的某一个目录比较靠谱。</p>
<p>然后正确的做法，应该是选中了之后，应该根据这套字体 ttf 文件的数量（种类、样式），生成类似 <code>system_fonts</code> 类似的文件，也放到 data 分区这个目录下，然后可以在 SystemProperties 增加一条属性，来记得当前使用的字体情况。这个就可以自由发挥了，例如说：</p>
<pre config="brush:bash;toolbar:false;">
SystemProperties.get("persist.sys.customfont", "default");
</pre>

<p>例如取得是 “default” 就去解析默认的 <code>system_fonts.xml</code> ，如果取得是 “custom” 的去解析 data 分区下那个 <code>system_fonts.xml</code> 。然后加载指定的字体。</p>
<p>当然这个得改 skia 里面那个 SkFontHost_android.cpp 里面那几加载字体相关的函数。我前面说了，我这个是粗略的研究，就懒得改 skia ，于是我暂时是把 java 层 Typeface 那几个 static 变量给改了（改 skia，也要做这一步的）。把他们的 final 属性去掉了，然后增加一些处理，例如根据 SystemProperties 直接去 data 分区加载自定义的 ttf 字体。</p>
<p>我这里做简单测试，就一种字体就只放了 Regular 的，然后扫描，就只认一个 ttf。然后贴下我改的代码，简单粗暴，当然这样换，肯定是换不全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ===========================================</span></div><div class="line"><span class="comment">// add by hmm@dw.gdbbk.com</span></div><div class="line"><span class="comment">// change system default api</span></div><div class="line"><span class="comment">// ===========================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> Typeface DEFAULT_INTERNAL;</div><div class="line"><span class="keyword">static</span> Typeface DEFAULT_BOLD_INTERNAL;</div><div class="line"><span class="keyword">static</span> Typeface SANS_SERIF_INTERNAL;</div><div class="line"><span class="keyword">static</span> Typeface SERIF_INTERNAL;</div><div class="line"><span class="keyword">static</span> Typeface MONOSPACE_INTERNAL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateDefaultFont</span>() {</div><div class="line">    <span class="comment">// change default font.</span></div><div class="line">    setCustomFont();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> setCustomFont() {</div><div class="line">    <span class="keyword">boolean</span> useDefault = <span class="keyword">false</span>;    </div><div class="line">    Typeface font = <span class="keyword">null</span>; </div><div class="line">    String fontPath = SystemProperties.get(<span class="string">"persist.sys.customfont"</span>, <span class="string">"default"</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="string">"default"</span>.equals(fontPath)) { </div><div class="line">        Slog.i(TAG, <span class="string">"use the default system font !!"</span>);</div><div class="line">        font = DEFAULT_INTERNAL;       </div><div class="line">        useDefault = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            font = createFromFile(fontPath);</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            e.printStackTrace() ;</div><div class="line">            Slog.e(TAG, <span class="string">"load custom font: "</span> + fontPath + <span class="string">" failed !!"</span>);</div><div class="line">            font = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != font) {</div><div class="line">        Slog.i(<span class="string">"test"</span>, <span class="string">"system: use the custom font: "</span> + fontPath + <span class="string">" as system font. old-default="</span> + DEFAULT + <span class="string">", new="</span> + font);</div><div class="line">        DEFAULT = font;</div><div class="line">        <span class="keyword">if</span> (useDefault) {</div><div class="line">            DEFAULT_BOLD = DEFAULT_BOLD_INTERNAL;</div><div class="line">            SANS_SERIF = SANS_SERIF_INTERNAL;</div><div class="line">            SERIF = SERIF_INTERNAL;</div><div class="line">            MONOSPACE = MONOSPACE_INTERNAL;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            DEFAULT_BOLD = font;</div><div class="line">            SANS_SERIF = font;</div><div class="line">            SERIF = font;</div><div class="line">            MONOSPACE = font;</div><div class="line">        }</div><div class="line"></div><div class="line">        sDefaults[<span class="number">0</span>] = DEFAULT;</div><div class="line">        sDefaults[<span class="number">1</span>] = DEFAULT_BOLD;</div><div class="line">        sDefaults[<span class="number">2</span>] = DEFAULT;</div><div class="line">        sDefaults[<span class="number">3</span>] = DEFAULT;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> {</div><div class="line">    <span class="comment">//DEFAULT         = create((String) null, 0);</span></div><div class="line">    <span class="comment">//DEFAULT_BOLD    = create((String) null, Typeface.BOLD);</span></div><div class="line">    <span class="comment">//SANS_SERIF      = create("sans-serif", 0);</span></div><div class="line">    <span class="comment">//SERIF           = create("serif", 0);</span></div><div class="line">    <span class="comment">//MONOSPACE       = create("monospace", 0);</span></div><div class="line"></div><div class="line">    DEFAULT = DEFAULT_INTERNAL = create((String) <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">    DEFAULT_BOLD = DEFAULT_BOLD_INTERNAL  = create((String) <span class="keyword">null</span>, Typeface.BOLD);</div><div class="line">    SANS_SERIF = SANS_SERIF_INTERNAL = create(<span class="string">"sans-serif"</span>, <span class="number">0</span>);</div><div class="line">    SERIF = SERIF_INTERNAL = create(<span class="string">"serif"</span>, <span class="number">0</span>);</div><div class="line">    MONOSPACE = MONOSPACE_INTERNAL = create(<span class="string">"monospace"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    sDefaults = <span class="keyword">new</span> Typeface[] {</div><div class="line">        DEFAULT,</div><div class="line">        DEFAULT_BOLD,</div><div class="line">        create((String) <span class="keyword">null</span>, Typeface.ITALIC),</div><div class="line">        create((String) <span class="keyword">null</span>, Typeface.BOLD_ITALIC),</div><div class="line">    };</div><div class="line"></div><div class="line">    setCustomFont();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我在 Settings 里面简单加了一个测试用的换字体的界面，是长着这个样子的：</p>
<p>（图链接错了，然后原图不小心删掉了，懒得贴了，反正就是一个简单的 ListView）</p>
<p>这个代码就不贴了，很简单，一个 listview，底下2个 button，确定、取消。然稍微开个线程（懒的话，线程都不用开）去扫描 data 分区下我指定的那个放自定义字体的文件夹下的 ttf 文件，拿 ttf 文件的文件名来显示。然后选中把 ttf 的文件名在 SystemProperties 保存一下，如果 SystemProperties 没有就是默认的。</p>
<p>如果真的要在自己的产品里做的话，就要像我之前说的改 skia ，要把加载的默认字体换了，然后再把 java 层 Typeface 里面的默认字形给换了。我这里相当于是省略了 skia 那一步，只换 Typeface 里的字形而已。但是就是这个就有不少坑。下面来说说最大的一个坑，而且这个坑还是由于人家 android 的努力优化造成的。</p>
<p>这个坑是怎么回事呢。前面是不说要换 Typeface 的那几个 static 变量么。那首先把这几个变量的 final 属性去掉（其实这里就是坑了，人家原来这个 final 属性不是乱加的，后面就会知道）。然后看起前面我改的代码，Settings 那里自己写的界面，把 SystemProperties 改了，然后调用 Typeface 的 updateDefaultSysFont 会去重新加载设置的 ttf 文件，然后把那几个 static 变量换掉了。照理来说，还没启动的应用字体就应该换过来了（已经启动的，我还没加更新操作，先不管）。不过我发现好像不是这么回事，重新启动的应用还是原来系统的字体，我用 Settings forceStopPackage， shell 里面 kill -9 然后重启应用都没有。感觉很奇怪。但是重启后，就变过去了。刚开始我怀疑是没把 Typface 那几个 static 变量改过去，然后我里面加几个打印，发现是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-switch-sysfont/3.jpeg" alt=""></p>
<p>这还真是没改过去。这是为什么。然后我在 Settings 那个设置字体的界面也加了点打印，发现就这个 Settings 的改变了，因为我是在 Settings 里调用的 Typface 的 updateDefaultSysFont 。后面我突然想到了一点，下面就来慢慢说。</p>
<p>前面说到了 Typeface 这几个 static 变量是在 static 语句的初始化的，就是每个进程这个 Typeface 类第一次实例化的时候就触发。android 用的是 dalvik（从 4.4 开始加入 art，L 开始 art 变成默认的虚拟机了）虚拟机。我们知道启动一个 java 程序是很慢的，没感觉的去 PC 启动个 java 程序看看就知道了。不光要启动进程，还要启动 dalvik 虚拟机，而且 android 上层 java 接口还有 N 个 class，系统还有一堆系统资源。如果重头开始加载的话，冷启动一个 android 程序是非常慢的（这里为什么说冷启动呢，因为 android 一旦启动了一个应用，为其开启了一个进程，退出应用后，这个进程不会马上销毁的，这样进程加载了的运行环境都还在，下次启动直接从应用的业务逻辑开始加载就新了，这个是不是有点像电脑的快速休眠、唤醒，这种我觉得可以叫热启动。那么相应的如果事先不存在这个应用的运行环境，重头开始启动就叫冷启动，相当于电脑开机）。</p>
<p>于是 android 就开始动脑筋开始优化了。首先 android 弄了一个叫 Zygote 的东西，这个是个 natvie 程序，开机由 init.rc 启动。init.rc 启动的二进制程序是 frameworks/cmds/app_process 这个（后面启动的时候好像是 set process name 改成 zygote 的）：</p>
<pre config="brush:bash;toolbar:false;">
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
    onrestart restart netd
</pre>

<p>然后这个会调用 AppRuntime 的 start 方法，去启动 dalvik 虚拟机，然后去加载 java 中 zygote 相关的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line">    <span class="comment">// These are global variables in ProcessState.cpp</span></div><div class="line">    mArgC = argc;</div><div class="line">    mArgV = argv;</div><div class="line"></div><div class="line">    mArgLen = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;argc; i++) {</div><div class="line">        mArgLen += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</div><div class="line">    }</div><div class="line">    mArgLen--;</div><div class="line"></div><div class="line">    AppRuntime runtime;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* argv0 = argv[<span class="number">0</span>];</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (zygote) {</div><div class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>,</div><div class="line">                startSystemServer ? <span class="string">"start-system-server"</span> : <span class="string">""</span>);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (className) {</div><div class="line">        <span class="comment">// Remainder of args get passed to startup class main()</span></div><div class="line">        runtime.mClassName = className;</div><div class="line">        runtime.mArgC = argc - i;</div><div class="line">        runtime.mArgV = argv + i;</div><div class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>,</div><div class="line">                application ? <span class="string">"application"</span> : <span class="string">"tool"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</div><div class="line">        app_usage();</div><div class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 AppRuntime 继承自 AndroidRuntime ，这个在 frameworks/base/core/jni/AndroidRuntime.cpp 这里，然后这个 start 就会调用 startVM 去启动 dalvik 虚拟机加载 java 运行环境，然后调用 com.android.internal.os.ZygoteInit 这个类的 main 函数运行 java 代码了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> <span class="keyword">char</span>* options)</div><div class="line">{</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">/* start the virtual machine */</span></div><div class="line">    JNIEnv* env; </div><div class="line">    <span class="keyword">if</span> (startVm(&mJavaVM, &env) != <span class="number">0</span>) { </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    onVmCreated(env);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Register android functions.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) { </div><div class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></div><div class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></div><div class="line"><span class="comment">     * Create an array to hold them.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    jclass stringClass;</div><div class="line">    jobjectArray strArray;</div><div class="line">    jstring classNameStr;</div><div class="line">    jstring optionsStr;</div><div class="line"></div><div class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</div><div class="line">    assert(stringClass != NULL);</div><div class="line">    strArray = env-&gt;NewObjectArray(<span class="number">2</span>, stringClass, NULL);</div><div class="line">    assert(strArray != NULL);</div><div class="line">    classNameStr = env-&gt;NewStringUTF(className);</div><div class="line">    assert(classNameStr != NULL);</div><div class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</div><div class="line">    optionsStr = env-&gt;NewStringUTF(options);</div><div class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">1</span>, optionsStr);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></div><div class="line"><span class="comment">     * not return until the VM exits.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</div><div class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class="line">    <span class="keyword">if</span> (startClass == NULL) {</div><div class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</div><div class="line">        <span class="comment">/* keep going */</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</div><div class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</div><div class="line">        <span class="keyword">if</span> (startMeth == NULL) {</div><div class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</div><div class="line">            <span class="comment">/* keep going */</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</div><div class="line">                threadExitUncaughtException(env);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="built_in">free</span>(slashClassName);</div><div class="line"></div><div class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</div><div class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</div><div class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</div><div class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</div><div class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里代码不想分析太多，挺复杂的，只是走走流程而已。然后就到 java 里面了，com.android.internal.os.ZygoteInit 的 main 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String argv[]) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// Start profiling the zygote initialization.</span></div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">        registerZygoteSocket();</div><div class="line">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class="line">            SystemClock.uptimeMillis());</div><div class="line">        <span class="comment">// 注意这个 preload</span></div><div class="line">        preload();</div><div class="line">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class="line">            SystemClock.uptimeMillis());</div><div class="line"></div><div class="line">        <span class="comment">// Finish profiling the zygote initialization.</span></div><div class="line">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class="line"></div><div class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></div><div class="line">        gc();</div><div class="line"></div><div class="line">        <span class="comment">// If requested, start system server directly from Zygote</span></div><div class="line">        <span class="keyword">if</span> (argv.length != <span class="number">2</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>].equals(<span class="string">"start-system-server"</span>)) {</div><div class="line">            startSystemServer();</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!argv[<span class="number">1</span>].equals(<span class="string">""</span>)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</div><div class="line">        }   </div><div class="line"></div><div class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ZYGOTE_FORK_MODE) {</div><div class="line">            runForkMode();</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            runSelectLoopMode();</div><div class="line">        }   </div><div class="line"></div><div class="line">        closeServerSocket();</div><div class="line">    } <span class="keyword">catch</span> (MethodAndArgsCaller caller) {</div><div class="line">        caller.run();</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException ex) {</div><div class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</div><div class="line">        closeServerSocket();</div><div class="line">        <span class="keyword">throw</span> ex; </div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>注意那个 preload：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> preload() {</div><div class="line">    preloadClasses();</div><div class="line">    preloadResources();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里差不多该该说原理了。前面说了由于启动虚拟机很慢，而且还要 android 应用经常要使用系统提供的那一堆 java class 的接口和资源，这些东西第一加载也慢，第二其实每个应用这些东西都是一样的，如果每个应用一份，会浪费内存。</p>
<p>所以 android 就想了个办法，这个办法主要源自 linux（unix） 的 fork 机制。fork 是一个 linux 系统调用，能够在当前进程创建出一个子进程，子进程完全共享父进程的共有环境变量。好，有了这个基础就可以做一些优化了：</p>
<ol>
<li>弄一个所有应用的共有父进程，专门用来 fork 子进程的，这个就是 zygote（孵化器这个名字取得真形象）。</li>
<li>由于子进程可以共享（继承）父进程的运行环境，所以可以把一些共用的东西在 zygote 中加载好，这样子进程一 fork 出来就有完整的运行环境，不需要重新加载。</li>
<li>由于子进程可以共享（继承）父进程的运行环境，基于 fork 的 <code>copy-on-write</code> 原则，只要这些变量不改变，那么子进程都不需要复制 zygote 进程的环境变量，共同一份，内存开销大大降低。</li>
</ol>
<p>所以这个 zygote 在初始化的时候会有一个 preload 的预加载处理，其实这些资源，zygote 根本不用，是给它的子进程用的，这些子进程就是 android 的那些上层应用。这里我看看 preloadClasses 就是预先加载 sdk 中的那些 class（preloadResrouces 就不看先了，和这篇文章关系不大）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Performs Zygote process initialization. Loads and initializes</span></div><div class="line"><span class="comment">     * commonly used classes.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Most classes only cause a few hundred bytes to be allocated, but</span></div><div class="line"><span class="comment">     * a few will allocate a dozen Kbytes (in one case, 500+K).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span>() {</div><div class="line">        <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</div><div class="line"></div><div class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(</div><div class="line">                PRELOADED_CLASSES);</div><div class="line">        <span class="keyword">if</span> (is == <span class="keyword">null</span>) {</div><div class="line">            Log.e(TAG, <span class="string">"Couldn't find "</span> + PRELOADED_CLASSES + <span class="string">"."</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Log.i(TAG, <span class="string">"Preloading classes..."</span>);</div><div class="line">            <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</div><div class="line">.... ...</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                BufferedReader br</div><div class="line">                    = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is), <span class="number">256</span>*<span class="number">4</span>);</div><div class="line"></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                String line;</div><div class="line">                <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">// Skip comments and blank lines.</span></div><div class="line">                    line = line.trim();</div><div class="line">                    <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.equals(<span class="string">""</span>)) {</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">                            Log.v(TAG, <span class="string">"Preloading "</span> + line + <span class="string">"..."</span>);</div><div class="line">                        }</div><div class="line">                        <span class="comment">// 预加载就是 new 一个 class 的对象出来</span></div><div class="line">                        Class.forName(line);</div><div class="line">                        <span class="keyword">if</span> (Debug.getGlobalAllocSize() &gt; PRELOAD_GC_THRESHOLD) {</div><div class="line">                            <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">                                Log.v(TAG,</div><div class="line">                                    <span class="string">" GC at "</span> + Debug.getGlobalAllocSize());</div><div class="line">                            }</div><div class="line">                            System.gc();</div><div class="line">                            runtime.runFinalizationSync();</div><div class="line">                            Debug.resetGlobalAllocSize();</div><div class="line">                        }</div><div class="line">                        count++;</div><div class="line">                    } <span class="keyword">catch</span> (ClassNotFoundException e) {</div><div class="line">                        Log.w(TAG, <span class="string">"Class not found for preloading: "</span> + line);</div><div class="line">                    } <span class="keyword">catch</span> (Throwable t) {</div><div class="line">                        Log.e(TAG, <span class="string">"Error preloading "</span> + line + <span class="string">"."</span>, t);</div><div class="line">                        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) {</div><div class="line">                            <span class="keyword">throw</span> (Error) t;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) {</div><div class="line">                            <span class="keyword">throw</span> (RuntimeException) t;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">                System.gc();</div><div class="line">                runtime.runFinalizationSync();</div><div class="line">                Debug.resetGlobalAllocSize();</div><div class="line">           </div><div class="line">                Log.i(TAG, <span class="string">"...preloaded "</span> + count + <span class="string">" classes in "</span></div><div class="line">                        + (SystemClock.uptimeMillis()-startTime) + <span class="string">"ms."</span>);</div><div class="line">            } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                Log.e(TAG, <span class="string">"Error reading "</span> + PRELOADED_CLASSES + <span class="string">"."</span>, e);</div><div class="line">            } <span class="keyword">finally</span> {</div><div class="line">                IoUtils.closeQuietly(is);</div><div class="line">                <span class="comment">// Restore default.</span></div><div class="line">                runtime.setTargetHeapUtilization(defaultUtilization);</div><div class="line">                        </div><div class="line">                Debug.stopAllocCounting();</div><div class="line"></div><div class="line">                <span class="comment">// Bring back root. We'll need it later.</span></div><div class="line">                setEffectiveUser(ROOT_UID);</div><div class="line">                setEffectiveGroup(ROOT_GID);</div><div class="line">            }</div><div class="line">        }               </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>它是会解析 frameworks-res.apk 中一个叫 preloaded-classes 的文件。这个文件在 frameworks/base 下面，会打包到 framework-res.apk 中去。这个文件和 ini 文件差不多，一行一个 class 路径。这个文件由 frameworks/base/tools/preload 这个个工具生成，会去检测 frameworks/base 下面的类，如果判断加载这个类超过 1250 微妙就会把这个类写入 preloaded-classes 中。当然这个文件是可以定制的。</p>
<p>preloadClasses 就是一行一行的解析这个文件，然后每次 Class.forName 就相当于 new 一个这个类的一个对象出来，就相当于加载这个类了。所以出触发这个类的一些 static 方法块。</p>
<p>我们在这个文件中发现有 Typeface。好，现在差不多就可以解释前面那个问题了。为什么我在 Settings 里，改了 Typeface 里的 static 变量会没用，即便是冷启动的应用都没有。那是因为通过 Settings 里面调用设置了 SystemProperties，就算是另外一个应用重新启动，但是由于这些应用都是通过 zygote fork 出来的，zygote 里面预先加载了 Typeface，跑了它的 static 代码块，它的那些 static 变量都已经设置好了。所以它 fork 出来的子进程，就算是新 fork 出来的，也不会再跑 Typeface 的那些 static 语句块，因为它继承了 zygote 预先加载好的 Typeface 的这些变量。所以 Typface 里面那几个 static 变量前面加的 final 不是乱加的，你要是乱改，就被坑了。</p>
<p>但是代码在咋手上，肯定还是有办法的。fork 的子进程会继承 zygote 的环境变量，那么只要把 zygote 里面的预先加载好的 Typeface 的环境变量更新一下就可以了。其实就是在 zygote 的进程里面调用下我在 Typeface 中新增的那个 updateDefaultSysFonts 就可以了。</p>
<p>好，现在要做的事，就是要更新 zygote 中的预先加载的 Typeface 的变量。这样就需要在 zygote 中加个接口。android 中 IPC 使用的 binder，但是也有非主流的，这里的 zygote 就是，zygote 用的是 socket 来通信的（同样的还有 vold）。</p>
<p>那就先看看它的协议，然后增加一条自己的就差不多。稍微来看下。前面 zygote 初始化那里，最后会跑到一个 runSelectLoopMode 的函数里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Runs the zygote process's select loop. Accepts new connections as</span></div><div class="line"><span class="comment"> * they happen, and reads commands from connections one spawn-request's</span></div><div class="line"><span class="comment"> * worth at a time.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @throws MethodAndArgsCaller in a child process when a main() should</span></div><div class="line"><span class="comment"> * be executed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> runSelectLoopMode() throws MethodAndArgsCaller {</div><div class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList();</div><div class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList();</div><div class="line">    FileDescriptor[] fdArray = <span class="keyword">new</span> FileDescriptor[<span class="number">4</span>];</div><div class="line"></div><div class="line">    fds.add(sServerSocket.getFileDescriptor());</div><div class="line">    peers.add(null);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> loopCount = GC_LOOP_COUNT; </div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Call gc() before we block in select().</span></div><div class="line"><span class="comment">         * It's work that has to be done anyway, and it's better</span></div><div class="line"><span class="comment">         * to avoid making every child do it.  It will also</span></div><div class="line"><span class="comment">         * madvise() any free memory as a side-effect.</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * Don't call it every time, because walking the entire</span></div><div class="line"><span class="comment">         * heap is a lot of overhead to free a few hundred bytes.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">if</span> (loopCount &lt;= <span class="number">0</span>) {</div><div class="line">            gc();</div><div class="line">            loopCount = GC_LOOP_COUNT;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            loopCount--;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            fdArray = fds.toArray(fdArray);</div><div class="line">            index = selectReadable(fdArray);</div><div class="line">        } <span class="keyword">catch</span> (IOException ex) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error in select()"</span>, ex);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error in select()"</span>);</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) {</div><div class="line">            ZygoteConnection newPeer = acceptCommandPeer();</div><div class="line">            peers.add(newPeer);</div><div class="line">            fds.add(newPeer.getFileDesciptor());</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            boolean done;</div><div class="line">            done = peers.get(index).runOnce();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (done) {</div><div class="line">                peers.remove(index);</div><div class="line">                fds.remove(index);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个是一个循环，这个才是典型的 service 结构么，这里 java 层的，android 又把 socket 封装了一下，这里不深究了，主要下面，当有一个连接请求过来的话，这个处理被封装成 ZygoteConnection 了，然后里面的 runOnce 函数。瞄了一下发现 zygote 这个 socket 通信的协议基本说可以没有（代码不贴了，这篇文章不是分析这个为主的）。就是 client 把几个命名，按一行一行的写入，然后 zygote 这边一行一行的读取，解析。而且这个命令主要就只有一个，就是启动新的进程，然后主要是一些参数多一点而已。</p>
<p>为此 zygote 弄了一个类 Arguments ，里面有不少变量，主要是它支持的参数多。哦，那就好办了，咋随便选一个，然后发一个特殊的参数过去当成我们的接口就 OK 了。</p>
<p>我这里选了 classpath 和 niceName，classpath 发一个特殊的字符串，我这里发 “#Lights#3Moon” 这个串，代表是我自己加的接口，路径这个都是非法的，所以不会和正常的通信起冲突，然后 niceName 就是我自己要的命令，例如现在加一个 “updatefont” 代表更新字体变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =================================================</span></div><div class="line"><span class="comment">// add by hmm@dw.gdbbk.com</span></div><div class="line"><span class="comment">// our mgiac command.</span></div><div class="line">    </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ZYGOTE_MAGIC_COMMAND = <span class="string">"#Lights#3Moon"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ZYGOTE_COMMAND_UPDATE_FONT = <span class="string">"updateFont"</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后就琢磨了下 parseArgs ，然后发命令的格式就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add by hmm@dw.gdbbk.com</span></div><div class="line"><span class="comment">// for change system default fonts.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateConfigurationForChangeSysFont</span>() {</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="comment">// update Zygote preload class cache.</span></div><div class="line">        <span class="keyword">try</span> { </div><div class="line">            ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">            <span class="comment">// we use --classpath as magic number</span></div><div class="line">            <span class="comment">// --nice-name as command</span></div><div class="line">            argsForZygote.add(<span class="string">"-classpath"</span>);</div><div class="line">            argsForZygote.add(ZYGOTE_MAGIC_COMMAND);</div><div class="line">            argsForZygote.add(<span class="string">"--nice-name="</span> + ZYGOTE_COMMAND_UPDATE_FONT);</div><div class="line">            Process.zygoteSendArgsAndGetResult(argsForZygote);</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="comment">// update current process.</span></div><div class="line">        <span class="comment">// we kill running process, and let restart, this is simple but effective.</span></div><div class="line">        killProcessForUpdateSysFontLocked(); </div><div class="line">    }     </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Process 直接就有接口，直接利用现成的就行了。然后 ZygoteConnection 的 runOnce 稍微改改，增加下我们的 magic command 的相应就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Reads one start command from the command socket. If successful,</span></div><div class="line"><span class="comment">     * a child is forked and a {@link ZygoteInit.MethodAndArgsCaller}</span></div><div class="line"><span class="comment">     * exception is thrown in that child while in the parent process,</span></div><div class="line"><span class="comment">     * the method returns normally. On failure, the child is not</span></div><div class="line"><span class="comment">     * spawned and messages are printed to the log and stderr. Returns</span></div><div class="line"><span class="comment">     * a boolean status value indicating whether an end-of-file on the command</span></div><div class="line"><span class="comment">     * socket has been encountered.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @return false if command socket should continue to be read from, or</span></div><div class="line"><span class="comment">     * true if an end-of-file has been encountered.</span></div><div class="line"><span class="comment">     * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()</span></div><div class="line"><span class="comment">     * method in child process</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">boolean</span> runOnce() <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line"></div><div class="line">        String args[];</div><div class="line">        Arguments parsedArgs = <span class="keyword">null</span>;   </div><div class="line">        FileDescriptor[] descriptors;  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// add by hmm@dw.gdbbk.com</span></div><div class="line">        <span class="keyword">boolean</span> isMagicCommand = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            parsedArgs = <span class="keyword">new</span> Arguments(args);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ZYGOTE_MAGIC_COMMAND.equals(parsedArgs.classpath)) {</div><div class="line">                isMagicCommand = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"> </div><div class="line">            <span class="comment">// 这一堆是权限检测的，我是通过 ActivityManagerService 发过来的，权限木得问题</span></div><div class="line">            applyUidSecurityPolicy(parsedArgs, peer);</div><div class="line">            applyRlimitSecurityPolicy(parsedArgs, peer);</div><div class="line">            applyCapabilitiesSecurityPolicy(parsedArgs, peer);</div><div class="line">            applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class="line"></div><div class="line">            applyDebuggerSystemProperty(parsedArgs);</div><div class="line">            applyInvokeWithSystemProperty(parsedArgs);</div><div class="line"></div><div class="line">            <span class="keyword">int</span>[][] rlimits = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (parsedArgs.rlimits != <span class="keyword">null</span>) {</div><div class="line">                rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (parsedArgs.runtimeInit && parsedArgs.invokeWith != <span class="keyword">null</span>) {</div><div class="line">                FileDescriptor[] pipeFds = Libcore.os.pipe();</div><div class="line">                childPipeFd = pipeFds[<span class="number">1</span>];</div><div class="line">                serverPipeFd = pipeFds[<span class="number">0</span>];</div><div class="line">                ZygoteInit.setCloseOnExec(serverPipeFd, <span class="keyword">true</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// for our magic command</span></div><div class="line">            <span class="comment">//pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid,</span></div><div class="line">            <span class="comment">//        parsedArgs.gids, parsedArgs.debugFlags, rlimits);</span></div><div class="line">            <span class="keyword">if</span> (isMagicCommand) {</div><div class="line">                pid = <span class="number">9999</span>;</div><div class="line">                execMagicCommand(parsedArgs);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid,</div><div class="line">                        parsedArgs.gids, parsedArgs.debugFlags, rlimits);</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (IOException ex) {</div><div class="line">            logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</div><div class="line">        } <span class="keyword">catch</span> (ErrnoException ex) {</div><div class="line">            logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</div><div class="line">        } <span class="keyword">catch</span> (IllegalArgumentException ex) {</div><div class="line">            logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</div><div class="line">        } <span class="keyword">catch</span> (ZygoteSecurityException ex) {</div><div class="line">            logAndPrintError(newStderr,</div><div class="line">                    <span class="string">"Zygote security policy prevents request: "</span>, ex);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) {</div><div class="line">                <span class="comment">// in child</span></div><div class="line">                IoUtils.closeQuietly(serverPipeFd);</div><div class="line">                serverPipeFd = <span class="keyword">null</span>;</div><div class="line">                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class="line"></div><div class="line">                <span class="comment">// should never get here, the child is expected to either</span></div><div class="line">                <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// in parent...pid of &lt; 0 means failure</span></div><div class="line">                IoUtils.closeQuietly(childPipeFd);</div><div class="line">                childPipeFd = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">//return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span></div><div class="line">                <span class="keyword">if</span> (isMagicCommand) {</div><div class="line">                    <span class="keyword">return</span> handleParentProcInMagicCommand(pid, descriptors, parsedArgs);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            IoUtils.closeQuietly(childPipeFd);</div><div class="line">            IoUtils.closeQuietly(serverPipeFd);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后就是我自己加的那几个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行我们自定义的命令</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execMagicCommand</span>(Arguments parsedArgs) {</div><div class="line">    <span class="comment">// niceName 是我们的自己的命令</span></div><div class="line">    String cmds = parsedArgs.niceName;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == cmds) {</div><div class="line">        Log.i(TAG, <span class="string">"the magic command is null, ignore it !!"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ZYGOTE_COMMAND_UPDATE_FONT.equals(cmds)) {</div><div class="line">        <span class="comment">// "updatefont" 的话更新 zygote 进程的 Typeface 变量</span></div><div class="line">        Log.i(TAG, <span class="string">"exec zygote magic command: "</span> + cmds);</div><div class="line">        Typeface.updateDefaultFont();</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Log.i(TAG, <span class="string">"the magic command: "</span> + cmds + <span class="string">" is unknow, ignore it !!"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 最后要扫下尾，主要是通信结束后关闭 socket，然后返回一个假的 pid</span></div><div class="line"><span class="comment">// 这个可以照着原来的改一下</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleParentProcInMagicCommand</span>(<span class="keyword">int</span> pid,</div><div class="line">        FileDescriptor[] descriptors, Arguments parsedArgs) {</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">for</span> (FileDescriptor fd: descriptors) {</div><div class="line">            IoUtils.closeQuietly(fd);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> usingWrapper = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 这个 pid 本来是 fork 的子进程的</span></div><div class="line">        <span class="comment">// 前面写了个假的 9999</span></div><div class="line">        mSocketOutStream.writeInt(pid);</div><div class="line">        mSocketOutStream.writeBoolean(usingWrapper);</div><div class="line">    } <span class="keyword">catch</span> (IOException ex) {</div><div class="line">        Log.e(TAG, <span class="string">"Error reading from command socket"</span>, ex);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * If the peer wants to use the socket to wait on the</span></div><div class="line"><span class="comment">     * newly spawned process, then we're all done.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.peerWait) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 关闭 socket </span></div><div class="line">            mSocket.close();</div><div class="line">        } <span class="keyword">catch</span> (IOException ex) {</div><div class="line">            Log.e(TAG, <span class="string">"Zygote: error closing sockets"</span>, ex);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这样 zygote 就改造完成了，试了下果然有效果。但是现在只是 zygote 更新后，新 fork 的子进程有效，原来 fork 出来的还是没改变。这个就是下面要说，更新之前的应用的字体。</p>
<h2 id="2-_更新应用">2. 更新应用</h2>
<p>这个咧，一开始我觉得我可以参考下 Settings 里面切换语言，因为这个和切换字体感觉挺像的。这个主要是调到了 AM 里面的 updateConfigurationLocked 这个函数。这个函数的参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Do either or both things: (1) change the current configuration, and (2)</span></div><div class="line"><span class="comment"> * make sure the given activity is running with the (now) current</span></div><div class="line"><span class="comment"> * configuration.  Returns true if the activity has been left running, or</span></div><div class="line"><span class="comment"> * false if &lt;var&gt;starting&lt;/var&gt; is being destroyed to match the new</span></div><div class="line"><span class="comment"> * configuration.</span></div><div class="line"><span class="comment"> * @param persistent TODO</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">//boolean updateConfigurationLocked(Configuration values,</span></div><div class="line"><span class="comment">//        ActivityRecord starting, boolean persistent, boolean initLocale);</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>切换语言的时候发送 Settings 调用的参数是： updateConfigurationLocked(newConfig, null, false, false). Configuration 中有几个变量是和语言相关的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Current user preference for the locale, corresponding to</span></div><div class="line"><span class="comment"> * &lt;a href="{@docRoot}guide/topics/resources/providing-resources.html#LocaleQualifier"&gt;locale&lt;/a&gt;</span></div><div class="line"><span class="comment"> * resource qualifier.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> Locale locale;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Locale should persist on setting.  This is hidden because it is really</span></div><div class="line"><span class="comment"> * questionable whether this is the right way to expose the functionality.</span></div><div class="line"><span class="comment"> * @hide</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> userSetLocale;</div><div class="line"></div></pre></td></tr></table></figure>

<p>第一个是表示当前的语言（En、zh-rCN 等），后面那个是表示用户是否设置了语言。这个函数的第一参数是表示当前更改的语言（包含在 Configuration 中）。然后看了下这个函数的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> updateConfigurationLocked(Configuration values,</div><div class="line">        ActivityRecord starting, <span class="keyword">boolean</span> persistent, <span class="keyword">boolean</span> initLocale) {</div><div class="line">    <span class="comment">// do nothing if we are headless</span></div><div class="line">    <span class="keyword">if</span> (mHeadless) <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line"></div><div class="line">    <span class="keyword">int</span> changes = <span class="number">0</span>;</div><div class="line">                          </div><div class="line">    <span class="keyword">boolean</span> kept = <span class="keyword">true</span>; </div><div class="line">          </div><div class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) {</div><div class="line">        Configuration newConfig = <span class="keyword">new</span> Configuration(mConfiguration);</div><div class="line">        changes = newConfig.updateFrom(values);</div><div class="line">        <span class="keyword">if</span> (changes != <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_CONFIGURATION) {</div><div class="line">                Slog.i(TAG, <span class="string">"Updating configuration to: "</span> + values);</div><div class="line">            }     </div><div class="line">                  </div><div class="line">            EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (values.locale != <span class="keyword">null</span> && !initLocale) {</div><div class="line">                saveLocaleLocked(values.locale, </div><div class="line">                                 !values.locale.equals(mConfiguration.locale),</div><div class="line">                                 values.userSetLocale);</div><div class="line">            }     </div><div class="line"></div><div class="line">            mConfigurationSeq++;</div><div class="line">            <span class="keyword">if</span> (mConfigurationSeq &lt;= <span class="number">0</span>) {</div><div class="line">                mConfigurationSeq = <span class="number">1</span>;</div><div class="line">            }     </div><div class="line">            newConfig.seq = mConfigurationSeq;</div><div class="line">            mConfiguration = newConfig;</div><div class="line">            Slog.i(TAG, <span class="string">"Config changed: "</span> + newConfig);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> Configuration configCopy = <span class="keyword">new</span> Configuration(mConfiguration);</div><div class="line">                  </div><div class="line">            <span class="comment">// TODO: If our config changes, should we auto dismiss any currently</span></div><div class="line">            <span class="comment">// showing dialogs?</span></div><div class="line">            mShowDialogs = shouldShowDialogs(newConfig);</div><div class="line"></div><div class="line">            AttributeCache ac = AttributeCache.instance();</div><div class="line">            <span class="keyword">if</span> (ac != <span class="keyword">null</span>) {</div><div class="line">                ac.updateConfiguration(configCopy);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Make sure all resources in our process are updated</span></div><div class="line">            <span class="comment">// right now, so that anyone who is going to retrieve</span></div><div class="line">            <span class="comment">// resource values after we return will be sure to get</span></div><div class="line">            <span class="comment">// the new ones.  This is especially important during</span></div><div class="line">            <span class="comment">// boot, where the first config change needs to guarantee</span></div><div class="line">            <span class="comment">// all resources have that config before following boot</span></div><div class="line">            <span class="comment">// code is executed.</span></div><div class="line">            mSystemThread.applyConfigurationToResources(configCopy);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (persistent && Settings.System.hasInterestingConfigurationChanges(changes)) {</div><div class="line">                Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG);</div><div class="line">                msg.obj = <span class="keyword">new</span> Configuration(configCopy);</div><div class="line">                mHandler.sendMessage(msg);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=mLruProcesses.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) {</div><div class="line">                ProcessRecord app = mLruProcesses.get(i);</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) {</div><div class="line">                        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Sending to proc "</span></div><div class="line">                                + app.processName + <span class="string">" new config "</span> + mConfiguration);</div><div class="line">                        app.thread.scheduleConfigurationChanged(configCopy);</div><div class="line">                    }</div><div class="line">                } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                }</div><div class="line">            }</div><div class="line">            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CONFIGURATION_CHANGED);</div><div class="line">            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</div><div class="line">                    | Intent.FLAG_RECEIVER_REPLACE_PENDING);</div><div class="line">            broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                    <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, <span class="number">0</span> <span class="comment">/* TODO: Verify */</span>);</div><div class="line">            <span class="keyword">if</span> ((changes&ActivityInfo.CONFIG_LOCALE) != <span class="number">0</span>) {</div><div class="line">                broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                        <span class="keyword">new</span> Intent(Intent.ACTION_LOCALE_CHANGED),</div><div class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                        <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, <span class="number">0</span> <span class="comment">/* TODO: Verify */</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (changes != <span class="number">0</span> && starting == <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// If the configuration changed, and the caller is not already</span></div><div class="line">        <span class="comment">// in the process of starting an activity, then find the top</span></div><div class="line">        <span class="comment">// activity to check if its configuration needs to change.</span></div><div class="line">        starting = mMainStack.topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (starting != <span class="keyword">null</span>) {</div><div class="line">        kept = mMainStack.ensureActivityConfigurationLocked(starting, changes);</div><div class="line">        <span class="comment">// And we need to make sure at this point that all other activities</span></div><div class="line">        <span class="comment">// are made visible with the correct configuration.</span></div><div class="line">        mMainStack.ensureActivitiesVisibleLocked(starting, changes);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span> && mWindowManager != <span class="keyword">null</span>) {</div><div class="line">        mWindowManager.setNewConfiguration(mConfiguration);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> kept;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子先是对比下传过来的 config 和现在正在使用的相比看看有没有变化，有的话通过 mLruProcesses 对最近使用过的进程的主线程（UI 线程）发送新的配置，让其重新加载资源。然后后面那个 starting 如果不为 null 的话，估计会根据配置变化情况是否重新启动吧，最后然 WM 也根据新配置做下调整。</p>
<p>如果是这里换字体想利用这个去更新界面的话，我尝试传递在这个函数增加一个参数，标志是我更新字体专用的。这个时候我就取当前的 config 作为更改的配置，然后故意在里面把 changes 改了一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (updateForChangeSysFont) {</div><div class="line">    <span class="comment">// we let as change launage it will update the ui show which we need when change system font.</span></div><div class="line">    newConfig.userSetLocale = <span class="keyword">true</span>;</div><div class="line">    changes |= ActivityInfo.CONFIG_LOCALE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>后面发现，确实走了下面，但是发现界面并没有更新，后面跟了下代码，发现后面很多函数还会判断你传过去的 config 使用的 local 是不是和当前的一样的 -_-|| 。看样子没那么容易忽悠 android 啊。</p>
<p>后面我又想到了一个简单、暴力的办法，把进程直接 kill 掉，但是保留任务记录，然后让它们自己重新启动就好了。AM 里面有个方法可以直接 kill 进程，但是不清除任务记录：</p>
<pre config="brush:bash;toolbar:false;">
public boolean killPids(int[] pids, String pReason, boolean secure)
</pre>

<p>这个和 forceStopPackage 不一样，只会把进程杀掉而已，而且能一次性杀很多个。看了下实现后，发现这个接口应该是系统内存不足的时候要调整内存用的，其中里面可以看得到进程的类型，以及被杀的优先级。这个里面会选传递过去那一组 pids 中进程优先级最低的开始杀，所以不太符合我们的需求，我就访问它的实现自己改了一个出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">killProcessForUpdateSysFontLocked</span>() {</div><div class="line">    <span class="comment">// we kill add process exclude system persistent process.</span></div><div class="line">    <span class="keyword">int</span> worstType = ProcessList.FOREGROUND_APP_ADJ - <span class="number">1</span>;</div><div class="line">    String reason = <span class="string">"update sys font"</span>;</div><div class="line">    Slog.w(TAG, <span class="string">"Killing processes for reason: "</span> + reason + <span class="string">", adj="</span> + worstType);</div><div class="line">    <span class="keyword">for</span> (ProcessRecord app : mLruProcesses) {</div><div class="line">        ProcessRecord proc = mPidsSelfLocked.get(app.pid);</div><div class="line">        <span class="keyword">if</span> (proc == <span class="keyword">null</span>) {            </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">int</span> adj = proc.setAdj;         </div><div class="line">        Slog.w(TAG, <span class="string">"try to Killing "</span> + proc + <span class="string">" (adj "</span> + adj + <span class="string">"): "</span> + reason + <span class="string">", killedBackground="</span> + proc.killedBackground);</div><div class="line">        <span class="keyword">if</span> (adj &gt;= worstType && !proc.killedBackground) {</div><div class="line">            Slog.w(TAG, <span class="string">"Killing "</span> + proc + <span class="string">" (adj "</span> + adj + <span class="string">"): "</span> + reason);</div><div class="line">            EventLog.writeEvent(EventLogTags.AM_KILL, proc.pid,</div><div class="line">                    proc.processName, adj, reason);</div><div class="line">            proc.killedBackground = <span class="keyword">true</span>;  </div><div class="line">            Process.killProcessQuiet(app.pid);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>（我的调用这个函数的地方有 synchronized 锁的，前面的代码可以看得到，所以里面就没加锁了）。这里稍微贴一下 ProcessList 的调整等级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This is a process holding the home application -- we want to try</span></div><div class="line"><span class="comment">// avoiding killing it, even if it would normally be in the background,</span></div><div class="line"><span class="comment">// because the user interacts with it so much.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOME_APP_ADJ = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is a process holding an application service -- killing it will not</span></div><div class="line"><span class="comment">// have much of an impact as far as the user is concerned.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_ADJ = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is a process currently hosting a backup operation.  Killing it</span></div><div class="line"><span class="comment">// is not entirely fatal but is generally a bad idea.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACKUP_APP_ADJ = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is a process with a heavy-weight application.  It is in the</span></div><div class="line"><span class="comment">// background, but we want to try to avoid killing it.  Value set in</span></div><div class="line"><span class="comment">// system/rootdir/init.rc on startup.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAVY_WEIGHT_APP_ADJ = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is a process only hosting components that are perceptible to the</span></div><div class="line"><span class="comment">// user, and we really want to avoid killing them, but they are not</span></div><div class="line"><span class="comment">// immediately visible. An example is background music playback.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERCEPTIBLE_APP_ADJ = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is a process only hosting activities that are visible to the</span></div><div class="line"><span class="comment">// user, so we'd prefer they don't disappear.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VISIBLE_APP_ADJ = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is the process running the current foreground app.  We'd really</span></div><div class="line"><span class="comment">// rather not kill it!</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOREGROUND_APP_ADJ = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// This is a system persistent process, such as telephony.  Definitely</span></div><div class="line"><span class="comment">// don't want to kill it, but doing so is not completely fatal.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERSISTENT_PROC_ADJ = -<span class="number">12</span>;</div><div class="line"></div><div class="line"><span class="comment">// The system process runs at the default adjustment.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYSTEM_ADJ = -<span class="number">16</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里没贴完的，剩余自己去看吧。按照原来的实现，数值越大的进程，就越是容易被杀掉。至于那2个负数的等级，自己看注释吧，-12 那个应该是代表通话的进程，还有 system ui 这些。-16 那个不要想了，那个 zygote 和 <code>system_server</code> 都在里面的，杀掉直接系统重启了。</p>
<p>所以我选了 <code>FOREGROUND_APP_ADJ - 1</code>。这个调用之后，几乎可以杀掉你能“看到”的所有进程，但是 system ui 杀不掉。所以 system ui 的字体没更新。这个的话，当然可以考虑使用 -12 ，但是真的是要项目上用的话，效果很不好，因为其他应用挂了，黑屏一下，还可以曲线救国一下：可以考虑在 <code>system_server</code> 搞个界面做字体选择，挡住原来那些应用，就看不到黑屏了。 但 system ui 一挂，无论如何你都会看到状态栏、虚拟按键突然没了，然后再出来，体验太不好了。</p>
<p>所以可以考虑继续使用我一开始说的那个方法，但是得继续研究下，例如在 Configuration 中加个字段，表示换字体强制更新界面，然后发给 system ui，然后 system ui 那里再处理下这个字段。或者是不是所有的应用都可以用这种方式更新，而不用杀掉它们。反正这个我目前还没研究了，但是要能用的话，至少 system ui 不能杀掉的，想偷点懒的话就结合杀进程一起用吧（system ui 更新，其他的杀）。</p>
<p>这里只是记录下大致思路，以及一些已经验证了的想法。后面真要做这个功能这里的东西还是有一定参考价值的，以后用到再说啦。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Android%20%E5%A4%9A%E7%94%A8%E6%88%B7%E4%B8%8B%E7%9A%84%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-31T02:12:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——Android 多用户下的要注意的问题</title>
        <pubTime>2015-01-31T02:12:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>之前有篇小笔记也遇到了类似的问题。就是如果你的系统要使用多用户功能，自己写的一些东西（或是以前写的）就要注意用户问题， android 增加了很多带 userID 的参数的接口，如果发起调用的用户和当前的用户不配对的话，要么崩溃，要么抛权限异常。</p>
<p>不知道从什么时候开始 core/java/android/app/ 下有个 AppGlobals， 要取啥 pm 之类的用这个比较好，然后注意启动一些应用、发啥广播、通知的，都要加上当前用户，当然如果你的应用有 <code>INTERACT_ACROSS_USERS（INTERACT_ACROSS_USERS_FULL）</code> 权限就当我没说（这个权限好像只有系统应用可以获取 … …）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/31/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Android%20%E5%A4%9A%E7%94%A8%E6%88%B7%E5%88%87%E6%8D%A2%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-31T01:38:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——Android 多用户切换无法启动应用的问题</title>
        <pubTime>2015-01-31T01:38:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Android 好像是从 3.0 开始引入多用户相关的支持，到 4.4 的是已经比较成熟了，相关的功能都有了，例如独立的用户空间（4.4 之后，android 把 flash 模拟成几个分区 0、1 等，对应 用户0、用户1），不同用户安装不同应用隔离等等。</p>
<p>多用户功能可以关闭的，把系统中最大用户数配置成 1，就关闭了（在 framework-res 的  config_multiuserMaximumUsers 这个配置里面），目前不少手机 OEM rom 都是关闭多用户的，因为开启会浪费一些空间，而且国内手机 rom 基本上不使用这个功能。</p>
<p>最近在项目要用多用户的相关功能，遇到点问题。就是切换用户之后，发现一些公共的 activity 启动不起来了。android 多用户会有保护，如果这个 apk 不属于这个用户安装的无法启动的，就算用代码 startActivity 也无法启动，am 会判断启动的用户是否是当前的用户的（代码懒得贴了，我目前对这么还没怎么研究，不过大概是这么个意思）。</p>
<p>但是刚开始感觉这些公用的 apk 切换用户后应该能启动才对。后面跟了下代码，发现 startActivity 启动 activity 如果这个 apk 没还没 killed 掉，那么这个 activity 是属于最开始启动这个 apk 的用户的。例如说 SystemUI 里面的某个系统 activity，切换用户，SystemUI 没有被 killed 掉，所以不会重新启动，所属用户为系统默认的用户（机主），这个时候如果调用 startActivity 去启动 SystemUI 的 activity 的话，是启动不了的，因为使用的是默认用户，不是当前这个。</p>
<p>那要怎么办咧，android 早就想好了，用下面这个 api 就好了（以当前用户启动 activity ^_^）：</p>
<pre config="brush:bash;toolbar:false;">
public void startActivityAsUser(Intent intent, UserHandle user)
</pre>

<p>后面有个 UserHandle 的参数，话说以前接触 4.2 之后，发现很多 api 多了个 UserHandle， userID 的东西，刚开始不知道是干什么用的，现在明白了，android 为了多用户支持，大开刀啊。</p>
<p>然后要以当前用户启动的话，就这么用：</p>
<pre config="brush:bash;toolbar:false;">
startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
</pre>


<p>然后类似的问题还有发通知的时候，点击通知启动 activity，同理以前有 PendingIntent.getActivity 设置的 PendingIntent 如果是类似 SystemUI 这种公用的 activity，切换用户后也是无法启动的，改成带当前用户的发送就可以了：</p>
<pre config="brush:bash;toolbar:false;">
PendingIntent pi = PendingIntent.getActivityAsUser(
    context, 0, intent, 0, null, UserHandle.CURRENT);
</pre>

<p>不过目前多用户相关的接口都是 hide 的，所以普通应用不需要关注这些东西，但是如果改系统里面的东西就需要注意下这方面的问题哦。当然如果压根不用多用户的话，可以无视。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/30/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%AD%97%E5%BA%93%E4%B9%B1%E7%A0%81%E6%8E%92%E6%9F%A5/</loc>
    <lastmod>2015-01-30T09:00:16.000Z</lastmod>
    <data>
        <display>
        <title>工作小笔记——扩展字库乱码排查</title>
        <pubTime>2015-01-30T09:00:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="起源">起源</h2>
<p>前几天市场反馈说，我们的平板上用浏览器在百度搜索的时候某些页面会有乱码现象：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/1.jpeg" alt=""></p>
<p>我们的平板的字库文件是被我们自己扩展过的。因为我们的应用需要显示一些特殊的符号（不在 unicode 编码里面），所以我们系统中的 ttf 字体是被我们扩展了很多东西进去。找到相关人员问了下，当初做字体的时候很多，塞了很多可能不需要的东西进去。晕，把字体文件换成 android 原来的（我们改的是 DroidSansFallback.ttf，替换 /system/fonts 下面的就可以了），果然就不乱码了。</p>
<p>既然是塞进了很多不用的，那初步想法是：在字库文件中找到这个字模，把它干掉就行了。</p>
<h2 id="找出乱码网页编码">找出乱码网页编码</h2>
<p>要先找到乱码字体的字模，首先得知道这个乱码是个什么字体。这个是个百度搜索的网页。在 PC 上用 chrome 的话，可以右键查看网页源码，看到传送过来的字符数据。但是发现 PC 上百度搜索和平板的页面不一样。PC 上这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/2.jpeg" alt=""></p>
<p>后面问我们这搞网络相关的同时，平板上发送的 http 请求的 user agent 不一样，百度服务器识别出这是移动平台的，所以发送过来的页面就不一样。然后要通过抓包得到平板上的浏览器发送的 user agent。</p>
<p>在 android 上可以使用 tcpdump 来抓包，这个是个开源的东西，不过我懒得自己编了（要交叉编译，烦），随笔百度一下就有现成的了（arm 的）： <a href="http://www.strazzere.com/android/tcpdump" title="下载地址" target="_blank" rel="external">下载地址</a> 。</p>
<p>下载好后， push 到 /system/bin 下面。注意要使用这个东西，机器要有 root 权限。然后运行这个程序：</p>
<pre>
./tcpdump -i any -p -s 0 -w /mnt/sdcard/capture.pcap
</pre>

<p>这东西的参数啥的自己去官网查： <a href="http://www.tcpdump.org/" title="tcpdump.org" target="_blank" rel="external">tcpdump.org</a>。 运行之后，就开浏览器，然后开百度搜索，等结果出来了，在 adb shell 里面 ctrl+c 终止，就能停止抓包了。</p>
<p>然后把抓包文件 capture.pcap pull 出来。在 PC 用 wireshark 来查看。 wireshark 在 ubuntu 可以直接用 apt-get install 安装，window 去官网下载就行了。用 wireshark 看到 user agent：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/3.jpeg" alt=""></p>
<p>可以看得到 user agent 是： “Mozilla/5.0 (Linux; U; Android 4.2.2; zh-cn; H10 Build/JDQ39) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30\r\n”</p>
<p>然后可以写一个程序，用 webview 模拟这个请求，去加载乱码的页面，然后通过开启 JavaScript 运行本地调用，把网页的源代码导出成 html 文件。直接上代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URL_1 = <span class="string">"http://www.baidu.com/from=844b/s?word=%E4%B8%AD%E5%A4%AE%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD&ts=3758057&sa=ib&ms=1"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Button mBtnUrl1 = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">private</span> WebView mWebView = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   </div><div class="line">   <span class="comment">// JavaScript 本地方法	</span></div><div class="line">   <span class="keyword">final</span> class InJavaScriptLocalObj {</div><div class="line">   	</div><div class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showSource</span>(String html) {</div><div class="line">           <span class="comment">// 导出网页的 html 源码</span></div><div class="line">           Log.d(<span class="string">"HTML"</span>, html);</div><div class="line">           saveHtmlToFile(html, <span class="string">"/mnt/sdcard/dump/"</span> + System.currentTimeMillis() + <span class="string">".html"</span>);</div><div class="line">       }</div><div class="line">       </div><div class="line">   }</div><div class="line">   </div><div class="line">   <span class="keyword">final</span> class MyWebViewClient extends WebViewClient {</div><div class="line">   	</div><div class="line">   	<span class="annotation">@Override</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span>(WebView view, String url) {   </div><div class="line">           view.loadUrl(url);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;   </div><div class="line">       }</div><div class="line">       </div><div class="line">   	<span class="annotation">@Override</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span>(WebView view, String url, Bitmap favicon) {</div><div class="line">           Log.d(TAG,<span class="string">"onPageStarted"</span>);</div><div class="line">       }</div><div class="line">       </div><div class="line">   	<span class="annotation">@Override</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span>(WebView view, String url) {</div><div class="line">           Log.d(TAG,<span class="string">"onPageFinished "</span>);</div><div class="line"></div><div class="line">       <span class="comment">// 网页加载结束后，调用 JavaScript</span></div><div class="line">       view.loadUrl(<span class="string">"javascript:window.local_obj.showSource('&lt;head&gt;'+"</span> +</div><div class="line">                   <span class="string">"document.getElementsByTagName('html')[0].innerHTML+'&lt;/head&gt;');"</span>);</div><div class="line">       }</div><div class="line">       </div><div class="line">   }</div><div class="line"></div><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle savedInstanceState) {</div><div class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">	</div><div class="line">	requestWindowFeature(Window.FEATURE_NO_TITLE);</div><div class="line">	setContentView(R.layout.activity_dump_html);</div><div class="line">	</div><div class="line">	mBtnUrl1 = (Button) findViewById(R.id.btn_url_1);</div><div class="line">	mWebView = (WebView) findViewById(R.id.wv_src);</div><div class="line">	</div><div class="line">	WebSettings settings = mWebView.getSettings();</div><div class="line">       <span class="comment">// 设置 user agent，这样百度才能识别为移动平台</span></div><div class="line">	settings.setUserAgentString(<span class="string">"Mozilla/5.0 (Linux; U; Android 4.2.2; zh-cn; H10 Build/JDQ39) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30\r\n"</span>);</div><div class="line">       <span class="comment">// 开启 JavaScript 支持</span></div><div class="line">	settings.setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">	mWebView.addJavascriptInterface(<span class="keyword">new</span> InJavaScriptLocalObj(), <span class="string">"local_obj"</span>);</div><div class="line">       <span class="comment">// 设置自己的 WebViewClient</span></div><div class="line">	mWebView.setWebViewClient(<span class="keyword">new</span> MyWebViewClient());</div><div class="line">	</div><div class="line">	mBtnUrl1.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span>(View view) {</div><div class="line">	<span class="keyword">if</span> (view.equals(mBtnUrl1)) {</div><div class="line">		setUrl(URL_1);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUrl</span>(String url) {</div><div class="line">	mWebView.loadUrl(url);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getParentDir</span>(String path) {</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == path) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		<span class="keyword">int</span> last = path.lastIndexOf(<span class="string">"/"</span>);</div><div class="line">		<span class="keyword">if</span> (last &lt;= -<span class="number">1</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">return</span> path.substring(<span class="number">0</span>, last);</div><div class="line"></div><div class="line">	} <span class="keyword">catch</span> (Exception e) {</div><div class="line">		Log.e(TAG, e.toString());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkFileDirExists</span>(String fileName) {</div><div class="line">	String dir = getParentDir(fileName);</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == dir) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	File fDir = <span class="keyword">new</span> File(dir);</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		<span class="keyword">if</span> (!fDir.exists()) {</div><div class="line">			<span class="keyword">if</span> (!fDir.mkdirs()) {</div><div class="line">				Log.e(TAG, <span class="string">"create folder "</span> + dir + <span class="string">" failed"</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	} <span class="keyword">catch</span> (SecurityException e) {</div><div class="line">		Log.e(TAG, <span class="string">"create folder "</span> + dir + <span class="string">" failed: "</span> + e.toString());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveHtmlToFile</span>(String html, String fileName) {</div><div class="line">	<span class="keyword">if</span> (!checkFileDirExists(fileName)) {</div><div class="line">		Log.d(TAG, <span class="string">"save html file error: create dir failed !!"</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		</div><div class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(fileName);</div><div class="line">		fos.write(html.getBytes());</div><div class="line">		fos.flush();</div><div class="line">		fos.close();</div><div class="line">		</div><div class="line">		Log.d(TAG, <span class="string">"save "</span> + fileName + <span class="string">" sucess !"</span>);</div><div class="line">		</div><div class="line">	} <span class="keyword">catch</span> (Exception e) {</div><div class="line">		e.printStackTrace();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面开启 JavaScript 支持的话，在 manifest 的 target SDK 生成 level 16 以下。当然如果也有办法高于 16，具体方法见这里： <a href="http://blog.sina.com.cn/s/blog_4e1e357d0101gju8.html" title="android addJavascriptInterface 不能生效 解决办法" target="_blank" rel="external">android addJavascriptInterface 不能生效 解决办法</a>。</p>
<p>然后就能得到乱码页码的 html 源码了。拿 UE 打开，通过搜索 “完整版”（那个乱码页码数据的关键字），可以看到乱码那一排的标题的数据了（注意打开 UE 的自动换行功能，很好用）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/4.jpeg" alt=""></p>
<p>哎， UE 里面显示好像每一个字符后面有个什么东西，换成16进制看一下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/5.jpeg" alt=""></p>
<p>可以看得到果然有一个奇怪的字符在这个乱码的标题中 01，前面的 “E5 89 A7”、“E6 83 85”、“3A” 分别是 “剧”、“情”、“：” 的 utf-8 编码数据。从 html 的头可以看到这个页面是 utf-8 编码的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/6.jpeg" alt=""></p>
<p>utf-8 的编码知识看看可以参看这2篇笔记：<br><a href="http://mingming-killer.diandian.com/post/2014-08-08/40062434087" title="[转] unicode 编码表" target="_blank" rel="external">[转] unicode 编码表</a><br><a href="http://mingming-killer.diandian.com/post/2014-08-08/40062440589" title="[转] 字符编码笔记" target="_blank" rel="external">[转] 字符编码笔记</a></p>
<p>这样看来 0x01 在 unicode 里面是和 ASCII 码一样的（前 128 个字符和 ACSII 兼容），但是 0x01 是不可打印的字符（可以打印的从 0x20 开始）。我用 FontCreatorPro 打开 android 默认的 DroidSansFallback.ttf 看了下 0x01 是没有字模的，也就是说应该渲染不出来的，不知道在我们的字库里面怎么就映射到一个字模上了。这个要看 webkit 怎么解析的了，不过我对 webkit 又不怎么熟。</p>
<p>想到 android 的 2D 失量库是 skia，在字体渲染那里应该可以能看得到字体的编码信息，这样就能值的 webkit 最终渲染的字体是什么了。</p>
<p>这样的话就要尽量减少 webkit 渲染的数量，数量一多打印就看不过来了。所以从刚刚的乱码的 html 中提取乱码的那一段做成一个测试用的 html，然后 webview 加载这个 html 就行了。构造的 html 如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"format-detection"</span> <span class="attribute">content</span>=<span class="value">"telephone=no"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>剧情:┎<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>`</p>
<p>注意“剧情：”这里的要用 UE 的16进制编辑把 utf-8 编码写进去：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/7.jpeg" alt=""></p>
<p>然后 mWebView.loadUrl(“file:///android_asset/test-utf-8.html”); 就可以了（test-utf-8.html 放到 assets 下面），记得在之前把 webview 设成 utf-8 编码模式： mWebView.getSettings().setDefaultTextEncodingName(“utf-8”); 。跑一下，果然可以了。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/8.jpeg" alt=""></p>
<h2 id="找到乱码的字模">找到乱码的字模</h2>
<p>上层 Canvas.java（frameworks/base/graphics/java/android/graphics/Canvas.java） 的 drawText 是调用 jni 的 Canvas.cpp（frameworks/base/core/jni/android/graphics/Canvas.cpp） 里面的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Draw the text, with origin at (x,y), using the specified paint. The</span></div><div class="line"><span class="comment"> * origin is interpreted based on the Align setting in the paint.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param text  The text to be drawn</span></div><div class="line"><span class="comment"> * @param x     The x-coordinate of the origin of the text being drawn</span></div><div class="line"><span class="comment"> * @param y     The y-coordinate of the origin of the text being drawn</span></div><div class="line"><span class="comment"> * @param paint The paint used for the text (e.g. color, size, style)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span>(String text, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint) {</div><div class="line">    native_drawText(mNativeCanvas, text, <span class="number">0</span>, text.length(), x, y, paint.mBidiFlags,</div><div class="line">            paint.mNativePaint);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Canvas.cpp 则是调用 skia 里面的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> drawText__StringIIFFIPaint(JNIEnv* env, jobject,</div><div class="line">                                      SkCanvas* canvas, jstring text,</div><div class="line">                                      <span class="keyword">int</span> start, <span class="keyword">int</span> end, </div><div class="line">                                      jfloat x, jfloat y, <span class="keyword">int</span> flags, SkPaint* paint) {</div><div class="line">    <span class="keyword">const</span> jchar* textArray = env-&gt;GetStringChars(text, NULL);</div><div class="line">    drawTextWithGlyphs(canvas, textArray, start, end, x, y, flags, paint);</div><div class="line">    env-&gt;ReleaseStringChars(text, textArray);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> drawTextWithGlyphs(SkCanvas* canvas, <span class="keyword">const</span> jchar* textArray,</div><div class="line">        <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> contextCount,</div><div class="line">        jfloat x, jfloat y, <span class="keyword">int</span> flags, SkPaint* paint) {</div><div class="line"></div><div class="line">    sp&lt;TextLayoutValue&gt; value = TextLayoutEngine::getInstance().getValue(paint,</div><div class="line">            textArray, start, count, contextCount, flags);</div><div class="line">    <span class="keyword">if</span> (value == NULL) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }    </div><div class="line">    SkPaint::Align align = paint-&gt;getTextAlign();</div><div class="line">    <span class="keyword">if</span> (align == SkPaint::kCenter_Align) {</div><div class="line">        x -= <span class="number">0.5</span> * value-&gt;getTotalAdvance();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (align == SkPaint::kRight_Align) {</div><div class="line">        x -= value-&gt;getTotalAdvance();</div><div class="line">    }</div><div class="line">    paint-&gt;setTextAlign(SkPaint::kLeft_Align);</div><div class="line">    doDrawGlyphsPos(canvas, value-&gt;getGlyphs(), value-&gt;getPos(), <span class="number">0</span>, value-&gt;getGlyphsCount(), x, y, flags, paint);</div><div class="line">    doDrawTextDecorations(canvas, x, y, value-&gt;getTotalAdvance(), paint);</div><div class="line">    paint-&gt;setTextAlign(align);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> doDrawGlyphsPos(SkCanvas* canvas, <span class="keyword">const</span> jchar* glyphArray, <span class="keyword">const</span> jfloat* posArray,</div><div class="line">        <span class="keyword">int</span> index, <span class="keyword">int</span> count, jfloat x, jfloat y, <span class="keyword">int</span> flags, SkPaint* paint) {</div><div class="line">    SkPoint* posPtr = <span class="keyword">new</span> SkPoint[count];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> indx = <span class="number">0</span>; indx &lt; count; indx++) { </div><div class="line">        posPtr[indx].fX = SkFloatToScalar(x + posArray[indx * <span class="number">2</span>]);</div><div class="line">        posPtr[indx].fY = SkFloatToScalar(y + posArray[indx * <span class="number">2</span> + <span class="number">1</span>]);</div><div class="line">    }</div><div class="line">    canvas-&gt;drawPosText(glyphArray, count &lt;&lt; <span class="number">1</span>, posPtr, *paint); </div><div class="line">    <span class="keyword">delete</span>[] posPtr;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到最后是调用了 Skia 的 SkCanvas 来渲染字体的，其实从这里可以看得到 java 层的 canvas 相关的东西（包括 Bitmap）全是 skia 的马甲 jni 调用。skia 在 external/skia 下面，编译出来是一个 so （libskia.so 在 /system/lib 下面）。</p>
<p>SkCanvas.cpp（skia/src/core/SkCanvas.cpp）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SkCanvas::drawPosText(<span class="keyword">const</span> <span class="keyword">void</span>* text, size_t byteLength,</div><div class="line">                           <span class="keyword">const</span> SkPoint pos[], <span class="keyword">const</span> SkPaint& paint) {</div><div class="line">    LOOPER_BEGIN(paint, SkDrawFilter::kText_Type)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (iter.next()) {</div><div class="line">        SkDeviceFilteredPaint dfp(iter.fDevice, looper.paint());</div><div class="line">        iter.fDevice-&gt;drawPosText(iter, text, byteLength, &pos-&gt;fX, <span class="number">0</span>, <span class="number">2</span>,</div><div class="line">                                  dfp.paint());</div><div class="line">    }</div><div class="line"></div><div class="line">    LOOPER_END</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>通过搜索发现， drawPosText 应该是 SkDraw.cpp（skia/src/core/SkDraw.cpp） 里面的实现的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加 log 打印进入的头文件</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utils/CallStack.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cutils/log.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 定义 log 的 TAG</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> LOG_TAG "Skia"</span></div><div class="line"></div><div class="line"><span class="comment">// 打印字符串用的临时 buffer</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> g_strDebugTmp[<span class="number">32</span>] = {<span class="number">0</span>};</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> g_strDebugBuff[<span class="number">512</span>] = {<span class="number">0</span>};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> SkDraw::drawPosText(<span class="keyword">const</span> <span class="keyword">char</span> text[], size_t byteLength,</div><div class="line">                         <span class="keyword">const</span> SkScalar pos[], SkScalar constY,</div><div class="line">                         <span class="keyword">int</span> scalarsPerPosition, <span class="keyword">const</span> SkPaint& paint) <span class="keyword">const</span> {</div><div class="line">    <span class="comment">// ================================================</span></div><div class="line">    <span class="comment">// 有点可疑，在这里加点 log 看看，需要在头文件声明下 cutils/log.h</span></div><div class="line">    <span class="comment">// skia 的 mk 文件本来就链接了 libcutils 所以可以直接使用 android log</span></div><div class="line">    <span class="comment">//android::CallStack stack;</span></div><div class="line">    <span class="comment">//stack.update();</span></div><div class="line">    <span class="comment">//stack.dump("Skia");</span></div><div class="line">    <span class="built_in">memset</span>(g_strDebugTmp, <span class="number">0x00</span>, <span class="built_in">strlen</span>(g_strDebugTmp));</div><div class="line">    <span class="built_in">memset</span>(g_strDebugBuff, <span class="number">0x00</span>, <span class="built_in">strlen</span>(g_strDebugBuff));</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; byteLength; i++) {</div><div class="line">        <span class="built_in">sprintf</span>(g_strDebugTmp, <span class="string">"%02x, "</span>, text[i]);</div><div class="line">        <span class="built_in">strcat</span>(g_strDebugBuff, g_strDebugTmp);</div><div class="line">    }</div><div class="line">    ALOGD(<span class="string">"SkDraw::drawPosText text: %s, len=%d"</span>, g_strDebugBuff, byteLength);</div><div class="line">    <span class="comment">// ================================================</span></div><div class="line"></div><div class="line">    SkASSERT(byteLength == <span class="number">0</span> || text != NULL);</div><div class="line">    SkASSERT(<span class="number">1</span> == scalarsPerPosition || <span class="number">2</span> == scalarsPerPosition);</div><div class="line"></div><div class="line">    SkDEBUGCODE(<span class="keyword">this</span>-&gt;validate();)</div><div class="line"></div><div class="line">    <span class="comment">// nothing to draw</span></div><div class="line">    <span class="keyword">if</span> (text == NULL || byteLength == <span class="number">0</span> || fRC-&gt;isEmpty()) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="comment">/*paint.isLinearText() ||*/</span></div><div class="line">        (fMatrix-&gt;hasPerspective())) {</div><div class="line">        <span class="comment">// TODO !!!!</span></div><div class="line"><span class="comment">//      this-&gt;drawText_asPaths(text, byteLength, x, y, paint);</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> SkMatrix* matrix = fMatrix;</div><div class="line">    <span class="keyword">if</span> (hasCustomD1GProc(*<span class="keyword">this</span>)) {</div><div class="line">        <span class="comment">// only support the fMVMatrix (for now) for the GPU case, which also</span></div><div class="line">        <span class="comment">// sets the fD1GProc</span></div><div class="line">        <span class="keyword">if</span> (fMVMatrix) {</div><div class="line">            matrix = fMVMatrix;</div><div class="line">        }    </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这里好先就是获取字模的地方</span></div><div class="line">    <span class="comment">// 这里是去取获取字模的函数指针。 Cahce 阿，</span></div><div class="line">    <span class="comment">// skia 用的是 FreeType，呵呵 ttf 不用设置好 cache 的话，渲染速度呵呵。</span></div><div class="line">    SkDrawCacheProc     glyphCacheProc = paint.getDrawCacheProc();</div><div class="line">    SkAutoGlyphCache    autoCache(paint, matrix);</div><div class="line">    SkGlyphCache*       cache = autoCache.getCache();</div><div class="line"></div><div class="line">    SkAAClipBlitterWrapper wrapper;</div><div class="line">    SkAutoBlitterChoose blitterChooser;</div><div class="line">    SkBlitter* blitter = NULL;</div><div class="line">    <span class="keyword">if</span> (needsRasterTextBlit(*<span class="keyword">this</span>)) {</div><div class="line">        blitterChooser.choose(*fBitmap, *matrix, paint);</div><div class="line">        blitter = blitterChooser.get();</div><div class="line">        <span class="keyword">if</span> (fRC-&gt;isAA()) {</div><div class="line">            wrapper.init(*fRC, blitter);</div><div class="line">            blitter = wrapper.getBlitter();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*        stop = text + byteLength;</div><div class="line">    AlignProc          alignProc = pick_align_proc(paint.getTextAlign());</div><div class="line">    SkDraw1Glyph       d1g;</div><div class="line">    SkDraw1Glyph::Proc proc = d1g.init(<span class="keyword">this</span>, blitter, cache);</div><div class="line">    TextMapState       tms(*matrix, constY);</div><div class="line">    TextMapState::Proc tmsProc = tms.pickProc(scalarsPerPosition);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cache-&gt;isSubpixel()) {</div><div class="line">        <span class="comment">// maybe we should skip the rounding if linearText is set</span></div><div class="line">        SkAxisAlignment roundBaseline = SkComputeAxisAlignmentForHText(*matrix);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SkPaint::kLeft_Align == paint.getTextAlign()) {</div><div class="line">            <span class="keyword">while</span> (text &lt; stop) {</div><div class="line"></div><div class="line">                tmsProc(tms, pos);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef SK_DRAW_POS_TEXT_IGNORE_SUBPIXEL_LEFT_ALIGN_FIX</span></div><div class="line">                SkFixed fx = SkScalarToFixed(tms.fLoc.fX);</div><div class="line">                SkFixed fy = SkScalarToFixed(tms.fLoc.fY);</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">                SkFixed fx = SkScalarToFixed(tms.fLoc.fX) + (SK_FixedHalf &gt;&gt; SkGlyph::kSubBits);</div><div class="line">                SkFixed fy = SkScalarToFixed(tms.fLoc.fY) + (SK_FixedHalf &gt;&gt; SkGlyph::kSubBits);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">                SkFixed fxMask = ~<span class="number">0</span>;</div><div class="line">                SkFixed fyMask = ~<span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (kX_SkAxisAlignment == roundBaseline) {</div><div class="line">                    fyMask = <span class="number">0</span>;</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (kY_SkAxisAlignment == roundBaseline) {</div><div class="line">                    fxMask = <span class="number">0</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 这里就是调用刚刚获取的获取字模函数的指针取获取字模</span></div><div class="line">                <span class="keyword">const</span> SkGlyph& glyph = glyphCacheProc(cache, &text,</div><div class="line">                                                      fx & fxMask, fy & fyMask);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (glyph.fWidth) {</div><div class="line">                    proc(d1g, fx, fy, glyph);</div><div class="line">                }</div><div class="line">                pos += scalarsPerPosition;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">while</span> (text &lt; stop) {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* currentText = text;</div><div class="line">                <span class="keyword">const</span> SkGlyph* glyph = &glyphCacheProc(cache, &text, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (glyph-&gt;fWidth) {</div><div class="line">                    SkDEBUGCODE(SkFixed prevAdvX = glyph-&gt;fAdvanceX;)</div><div class="line">                    SkDEBUGCODE(SkFixed prevAdvY = glyph-&gt;fAdvanceY;)</div><div class="line"></div><div class="line">                    SkFixed fx, fy;</div><div class="line">                    SkFixed fxMask = ~<span class="number">0</span>;</div><div class="line">                    SkFixed fyMask = ~<span class="number">0</span>;</div><div class="line">                    tmsProc(tms, pos);</div><div class="line"></div><div class="line">                    {</div><div class="line">                        SkIPoint fixedLoc;</div><div class="line">                        alignProc(tms.fLoc, *glyph, &fixedLoc);</div><div class="line">                        fx = fixedLoc.fX + (SK_FixedHalf &gt;&gt; SkGlyph::kSubBits);</div><div class="line">                        fy = fixedLoc.fY + (SK_FixedHalf &gt;&gt; SkGlyph::kSubBits);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (kX_SkAxisAlignment == roundBaseline) {</div><div class="line">                            fyMask = <span class="number">0</span>;</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (kY_SkAxisAlignment == roundBaseline) {</div><div class="line">                            fxMask = <span class="number">0</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="comment">// have to call again, now that we've been "aligned"</span></div><div class="line">                    glyph = &glyphCacheProc(cache, &currentText,</div><div class="line">                                            fx & fxMask, fy & fyMask);</div><div class="line">                    <span class="comment">// the assumption is that the advance hasn't changed</span></div><div class="line">                    SkASSERT(prevAdvX == glyph-&gt;fAdvanceX);</div><div class="line">                    SkASSERT(prevAdvY == glyph-&gt;fAdvanceY);</div><div class="line"></div><div class="line">                    proc(d1g, fx, fy, *glyph);</div><div class="line">                }</div><div class="line">                pos += scalarsPerPosition;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {    <span class="comment">// not subpixel</span></div><div class="line">        <span class="keyword">while</span> (text &lt; stop) {</div><div class="line">            <span class="comment">// the last 2 parameters are ignored</span></div><div class="line">            <span class="keyword">const</span> SkGlyph& glyph = glyphCacheProc(cache, &text, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (glyph.fWidth) {</div><div class="line">                tmsProc(tms, pos);</div><div class="line"></div><div class="line">                SkIPoint fixedLoc;</div><div class="line">                alignProc(tms.fLoc, glyph, &fixedLoc);</div><div class="line"></div><div class="line">                proc(d1g,</div><div class="line">                     fixedLoc.fX + SK_FixedHalf,</div><div class="line">                     fixedLoc.fY + SK_FixedHalf,</div><div class="line">                     glyph);</div><div class="line">            }</div><div class="line">            pos += scalarsPerPosition;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>再跟进去看下取的是哪个字模函数。 SkPaint.cpp（skia/src/core/SkPaint.cpp）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">SkDrawCacheProc SkPaint::getDrawCacheProc() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SkDrawCacheProc gDrawCacheProcs[] = {</div><div class="line">        <span class="comment">// 看样子前面2个应该是 utf-8、utf-16 编码</span></div><div class="line">        sk_getMetrics_utf8_00,</div><div class="line">        sk_getMetrics_utf16_00,</div><div class="line">        sk_getMetrics_glyph_00,</div><div class="line"></div><div class="line">        sk_getMetrics_utf8_xy,</div><div class="line">        sk_getMetrics_utf16_xy,</div><div class="line">        sk_getMetrics_glyph_xy</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> index = <span class="keyword">this</span>-&gt;getTextEncoding();</div><div class="line">    <span class="keyword">if</span> (fFlags & kSubpixelText_Flag) {</div><div class="line">        index += <span class="number">3</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 可以看得出是根据设置的编码使用不同的字模函数的。</span></div><div class="line">    <span class="comment">// 这里把使用的编码打印出来。</span></div><div class="line">    ALOGD(<span class="string">"SkPaint::getDrawCacheProc textEncode: %d"</span>, index);</div><div class="line"></div><div class="line">    SkASSERT(index &lt; SK_ARRAY_COUNT(gDrawCacheProcs));</div><div class="line">    <span class="keyword">return</span> gDrawCacheProcs[index];</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>通过打印可以看得到：</p>
<pre>
D/Skia    (  446): SkDraw::drawPosText text: 1b, 00, 1d, 00, 17, 00, 16, 00, , len=8
D/Skia    (  446): SkPaint::getDrawCacheProc textEncode: 2

D/Skia    ( 1231): SkDraw::drawPosText text: 4c, 52, aa, 60, 1d, 00, f0, 1f, , len=8
D/Skia    ( 1231): SkPaint::getDrawCacheProc textEncode: 5
</pre>

<p>上面的打印是其它地方 UI 渲染字体的打印，下面是测试乱码 url webkit 渲染字体的打印，其它地方用的获取字模的函数是 <code>sk_getMetrics_glyph_00</code>， webkit 那用的是 <code>sk_getMetrics_glyph_xy</code>。在这2个函数再加点打印。跟踪发现这2个函数调用的是 SkGlyphCache.cpp（skia/src/core/SkGlyphCache.cpp）的 getGlyphIDMetrics ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sk_getMetrics_glyph_00</span></div><div class="line"><span class="keyword">const</span> SkGlyph& SkGlyphCache::getGlyphIDMetrics(uint16_t glyphID) {</div><div class="line">    VALIDATE();</div><div class="line">    uint32_t id = SkGlyph::MakeID(glyphID);</div><div class="line">    <span class="keyword">unsigned</span> index = ID2HashIndex(id);</div><div class="line">    SkGlyph* glyph = fGlyphHash[index];</div><div class="line"></div><div class="line">    <span class="comment">// 加点打印</span></div><div class="line">    ALOGD(<span class="string">"SkGlyphCache::getGlyphIDMetrics glyphID: %04x(%d), id=%d, index=%d"</span>,</div><div class="line">            glyphID, glyphID, id, index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (NULL == glyph || glyph-&gt;fID != id) {</div><div class="line">        RecordHashCollisionIf(glyph != NULL);</div><div class="line">        glyph = <span class="keyword">this</span>-&gt;lookupMetrics(glyphID, kFull_MetricsType);</div><div class="line">        fGlyphHash[index] = glyph;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        RecordHashSuccess();</div><div class="line">        <span class="keyword">if</span> (glyph-&gt;isJustAdvance()) {</div><div class="line">            fScalerContext-&gt;getMetrics(glyph);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    SkASSERT(glyph-&gt;isFullMetrics());</div><div class="line">    <span class="keyword">return</span> *glyph;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// sk_getMetrics_glyph_xy</span></div><div class="line"><span class="keyword">const</span> SkGlyph& SkGlyphCache::getGlyphIDMetrics(uint16_t glyphID,</div><div class="line">                                               SkFixed x, SkFixed y) {</div><div class="line">    VALIDATE();</div><div class="line">    uint32_t id = SkGlyph::MakeID(glyphID, x, y); </div><div class="line">    <span class="keyword">unsigned</span> index = ID2HashIndex(id);</div><div class="line">    SkGlyph* glyph = fGlyphHash[index];</div><div class="line"></div><div class="line">    <span class="comment">// 加点打印</span></div><div class="line">    ALOGD(<span class="string">"SkGlyphCache::getGlyphIDMetricsXY glyphID: %04x(%d) - (%d,%d), id=%d, index=%d"</span>, </div><div class="line">            glyphID, glyphID, x, y, id, index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (NULL == glyph || glyph-&gt;fID != id) {</div><div class="line">        RecordHashCollisionIf(glyph != NULL);</div><div class="line">        glyph = <span class="keyword">this</span>-&gt;lookupMetrics(id, kFull_MetricsType);</div><div class="line">        fGlyphHash[index] = glyph;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        RecordHashSuccess();</div><div class="line">        <span class="keyword">if</span> (glyph-&gt;isJustAdvance()) {</div><div class="line">            fScalerContext-&gt;getMetrics(glyph);</div><div class="line">        }   </div><div class="line">    }</div><div class="line">    SkASSERT(glyph-&gt;isFullMetrics());</div><div class="line">    <span class="keyword">return</span> *glyph;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>再来看下打印：</p>
<pre>
D/Skia    (  446): SkDraw::drawPosText text: 1b, 00, 1d, 00, 18, 00, 13, 00, , len=8
D/Skia    (  446): SkPaint::getDrawCacheProc textEncode: 2
D/Skia    (  446): SkGlyphCache::getGlyphIDMetrics glyphID: 001b(27), id=27, index=27
D/Skia    (  446): SkGlyphCache::getGlyphIDMetrics glyphID: 001d(29), id=29, index=29
D/Skia    (  446): SkGlyphCache::getGlyphIDMetrics glyphID: 0018(24), id=24, index=24
D/Skia    (  446): SkGlyphCache::getGlyphIDMetrics glyphID: 0013(19), id=19, index=19
</pre>

<p>这个 001b、001d、0018、0013 应该就是渲染的字体的字模信息，但是还不确定是 unicode 的编码还是别的什么。先来猜一下，0x001b，如果是 UCS-2 的话，那么应该是 ASCII 的不可打印字符，所以应该不是，那肯能就会字库里字模的索引，用 font creator 看一下，发现我们改过的字库里，0x001b 的索引是个空的，用 android 原来的字库看一下，发现是 “8” 的字模，然后 0x001d、0x0018、0x0013 分别是： “:”、”5”、”0”</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/9.jpeg" alt=""></p>
<p>连在一起就是 “8:50”，哎，这个好像是状态栏上显示的时间的文本：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/10.jpeg" alt=""></p>
<p>然后这个东西，还经常在打印，拿出来一看，果然是和当前显示的时间对上的。所以 textEncode 为 2 的 <code>sk_getMetrics_glyph_00</code> 中的数据是字模的索引号。那么来看下我要找的乱码的那个字符串的字模索引是多少：</p>
<p>既然之前我是用 android 原来的字体推测出来的，那这里继续先用 android 原来的字体。跑我之前写的测试 url 小程序，发现打印如下：</p>
<pre>
D/Skia    ( 1228): SkDraw::drawPosText text: c5, 0b, 23, 1a, 1d, 00, bc, cb, , len=8
D/Skia    ( 1228): SkPaint::getDrawCacheProc textEncode: 5
D/Skia    ( 1228): SkGlyphCache::getGlyphIDMetricsXY glyphID: 0bc5(3013) - (532480,0), id=3013, index=3013
D/Skia    ( 1228): SkGlyphCache::getGlyphIDMetricsXY glyphID: 1a23(6691) - (1581056,0), id=6691, index=2595
D/Skia    ( 1228): SkGlyphCache::getGlyphIDMetricsXY glyphID: 001d(29) - (2629632,0), id=29, index=29
D/Skia    ( 1228): SkGlyphCache::getGlyphIDMetricsXY glyphID: cbbc(52156) - (2912256,0), id=67161020, index=4028
</pre>

<p>这里文本是：“剧”、“情”、“:” 和一个不知道是什么字符的东西。首先第三个 “:” 的索引 0x001d 和上面的的一样。然后 “剧” 的如果按照索引来找，字模好像不对，用 UCS-2 编码去查 “剧” 发现， “剧” 其实在离索引找出来的字模不远的地方，“情” 也是一样的，后来我一算发现 索引号-0x65 就是了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/11.jpeg" alt=""></p>
<p>然后最后那个 cbbc 在 android 原来的字库中根本就每这个索引（超过字库范围了），看样子 webkit 是把那个 0x01 转化为一个根本不可能渲染出来的字体来处理的。</p>
<p>好，先在换我们改过的字库来看一下，打印如下：</p>
<pre>
D/Skia    ( 1231): SkDraw::drawPosText text: 4c, 52, aa, 60, 1d, 00, f0, 1f, , len=8
D/Skia    ( 1231): SkPaint::getDrawCacheProc textEncode: 5
D/Skia    ( 1231): SkGlyphCache::getGlyphIDMetricsXY glyphID: 524c(21068) - (532480,0), id=21068, index=588
D/Skia    ( 1231): SkGlyphCache::getGlyphIDMetricsXY glyphID: 60aa(24746) - (1581056,0), id=24746, index=170
D/Skia    ( 1231): SkGlyphCache::getGlyphIDMetricsXY glyphID: 001d(29) - (2629632,0), id=29, index=29
D/Skia    ( 1231): SkGlyphCache::getGlyphIDMetricsXY glyphID: 1ff0(8176) - (2912256,0), id=67117040, index=3056
</pre>

<p>0x524c - 0x65 = 0x51e7 ，一找，还真是 “剧” 的字模，看样子猜对了。 </p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/12.jpeg" alt=""></p>
<p>textEncode 为 5 的 <code>sk_getMetrics_glyph_xy</code> 的文本数据也是字模的索引，但是有一定的偏移，这里的偏移是 0x65，可能不同的字库偏移不一样吧。然后最终找到那个乱码的字模了： 0x1ff0 - 0x65 = 0x1f8B :</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-font-wrong/13.jpeg" alt=""></p>
<p>看样子我们的字库里面塞了太多东西，webkit 本来想转为一个不存在的字模的，但是在我们这就能渲染出来了。用 font creator 把这个字模的数据删掉（右键—&gt;属性，然后 crtl+a，delete 就行了），就显示不出来了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/30/Android%20%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B0%8F%E5%B7%A5%E5%85%B7%20%E2%80%94%E2%80%94%20service/</loc>
    <lastmod>2015-01-30T08:32:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 一些有意思的命令小工具 —— service</title>
        <pubTime>2015-01-30T08:32:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 自带了很多 cmds 的小工具，都挺用有的，也有些比较有意思。这里介绍的是 service 这个工具。说之前先把相关源码位置说下（4.4 的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># service 命令模块</span></div><div class="line">frameworks/native/cmds/service</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="作用">作用</h2>
<p>这个工具的作用是让你能够在 shell 中调用 android system services 的一部分接口。至于怎么调用，看它的 usage 就清除了：</p>
<pre>
Usage: service [-h|-?]
       service list
       service check SERVICE
       service call SERVICE CODE [i32 INT | s16 STR] ...
Options:
   i32: Write the integer INT into the send parcel.
   s16: Write the UTF-16 string STR into the send parcel.
</pre>

<p>它的用法就是 service 命令 + 参数。service 的命令很少一般有用的就2个：</p>
<h3 id="list">list</h3>
<p>列出当前系统有所有的 system service :</p>
<pre>
ming ~ $ adb shell service list
Found 73 services:
0       media_router: [android.media.IMediaRouterService]
1       print: [android.print.IPrintManager]
2       assetatlas: [android.view.IAssetAtlas]
3       dreams: [android.service.dreams.IDreamManager]
4       commontime_management: []
5       samplingprofiler: []
6       diskstats: []
7       appwidget: [com.android.internal.appwidget.IAppWidgetService]
8       backup: [android.app.backup.IBackupManager]
9       uimode: [android.app.IUiModeManager]
10      serial: [android.hardware.ISerialManager]
11      usb: [android.hardware.usb.IUsbManager]
12      audio: [android.media.IAudioService]
13      wallpaper: [android.app.IWallpaperManager]
14      dropbox: [com.android.internal.os.IDropBoxManagerService]
15      search: [android.app.ISearchManager]
16      country_detector: [android.location.ICountryDetector]
17      location: [android.location.ILocationManager]
18      devicestoragemonitor: []
19      notification: [android.app.INotificationManager]
20      updatelock: [android.os.IUpdateLock]
21      servicediscovery: [android.net.nsd.INsdManager]
22      ethernet: [android.net.ethernet.IEthernetManager]
23      connectivity: [android.net.IConnectivityManager]
24      wifi: [android.net.wifi.IWifiManager]
25      wifip2p: [android.net.wifi.p2p.IWifiP2pManager]
26      netpolicy: [android.net.INetworkPolicyManager]
27      netstats: [android.net.INetworkStatsService]
28      textservices: [com.android.internal.textservice.ITextServicesManager]
29      network_management: [android.os.INetworkManagementService]
30      clipboard: [android.content.IClipboard]
31      statusbar: [com.android.internal.statusbar.IStatusBarService]
32      device_policy: [android.app.admin.IDevicePolicyManager]
33      lock_settings: [com.android.internal.widget.ILockSettings]
34      mount: [IMountService]
35      accessibility: [android.view.accessibility.IAccessibilityManager]
36      input_method: [com.android.internal.view.IInputMethodManager]
37      bluetooth_manager: [android.bluetooth.IBluetoothManager]
38      input: [android.hardware.input.IInputManager]
39      window: [android.view.IWindowManager]
40      alarm: [android.app.IAlarmManager]
41      consumer_ir: [android.hardware.IConsumerIrService]
42      vibrator: [android.os.IVibratorService]
43      battery: []
44      hardware: [android.os.IHardwareService]
45      content: [android.content.IContentService]
46      account: [android.accounts.IAccountManager]
47      user: [android.os.IUserManager]
48      entropy: []
49      permission: [android.os.IPermissionController]
50      cpuinfo: []
51      dbinfo: []
52      gfxinfo: []

... ...
</pre>

<h3 id="call">call</h3>
<p>这个是主要功能，就是调用指定 service 的接口。具体的在下面的源码分析说一边分析一边说。</p>
<h2 id="分析">分析</h2>
<p>这个工具的代码其实很少，只有一个 service.cpp 文件，而且只有 300 行不到。我们慢慢看，首先 mian 函数开头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line">    <span class="comment">// 取 SM </span></div><div class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">    fflush(stdout);</div><div class="line">    <span class="keyword">if</span> (sm == NULL) {</div><div class="line">        aerr &lt;&lt; <span class="string">"service: Unable to get default service manager!"</span> &lt;&lt; endl;</div><div class="line">        <span class="keyword">return</span> <span class="number">20</span>; </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">bool</span> wantsUsage = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 敲 service -h 或是 service -? 是出前面的 usage 提示</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">int</span> ic = getopt(argc, argv, <span class="string">"h?"</span>);</div><div class="line">        <span class="keyword">if</span> (ic &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (ic) {</div><div class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'?'</span>:</div><div class="line">            wantsUsage = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            aerr &lt;&lt; <span class="string">"service: Unknown option -"</span> &lt;&lt; ic &lt;&lt; endl;</div><div class="line">            wantsUsage = <span class="keyword">true</span>;</div><div class="line">            result = <span class="number">10</span>; </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }   </div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="check">check</h3>
<p>接下来就有一个 check 的命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (optind &gt;= argc) {</div><div class="line">        wantsUsage = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!wantsUsage) {</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"check"</span>) == <span class="number">0</span>) {</div><div class="line">            optind++;</div><div class="line">            <span class="keyword">if</span> (optind &lt; argc) {</div><div class="line">                <span class="comment">// 是调 SM 的 checkService 接口</span></div><div class="line">                sp&lt;IBinder&gt; service = sm-&gt;checkService(String16(argv[optind]));</div><div class="line">                aout &lt;&lt; <span class="string">"Service "</span> &lt;&lt; argv[optind] &lt;&lt;</div><div class="line">                    (service == NULL ? <span class="string">": not found"</span> : <span class="string">": found"</span>) &lt;&lt; endl;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                aerr &lt;&lt; <span class="string">"service: No service specified for check"</span> &lt;&lt; endl;</div><div class="line">                wantsUsage = <span class="keyword">true</span>;</div><div class="line">                result = <span class="number">10</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line">            </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            aerr &lt;&lt; <span class="string">"service: Unknown command "</span> &lt;&lt; argv[optind] &lt;&lt; endl;</div><div class="line">            wantsUsage = <span class="keyword">true</span>;</div><div class="line">            result = <span class="number">10</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 check 命名就是调用 SM 的 checkService 接口。至于这个接口是干啥的，<a href="http://light3moon.com/2015/01/28/Android Binder 分析——系统服务 Binder 对象的传递" title="看这里" target="_blank" rel="external">看这里</a>。不过不知道是不是权限原因，这里从 SM 返回好像都是 NULL，然后老是打印 Service xx not found 。我没去深究，因为这个命令好像也没啥用。</p>
<h3 id="list-1">list</h3>
<p>下面继续：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"list"</span>) == <span class="number">0</span>) {</div><div class="line">            Vector&lt;String16&gt; services = sm-&gt;listServices();</div><div class="line">            aout &lt;&lt; <span class="string">"Found "</span> &lt;&lt; services.size() &lt;&lt; <span class="string">" services:"</span> &lt;&lt; endl;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; services.size(); i++) {</div><div class="line">                String16 name = services[i];</div><div class="line">                sp&lt;IBinder&gt; service = sm-&gt;checkService(name);</div><div class="line">                aout &lt;&lt; i</div><div class="line">                     &lt;&lt; <span class="string">"\t"</span> &lt;&lt; good_old_string(name)</div><div class="line">                     &lt;&lt; <span class="string">": ["</span> &lt;&lt; good_old_string(get_interface_name(service)) &lt;&lt; <span class="string">"]"</span></div><div class="line">                     &lt;&lt; endl;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"call"</span>) == <span class="number">0</span>) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 list 好像也是 SM 的命令来的。SM 会返回一个当前注册的 system service 的列表过来，然后这边一个 for 循环打印这些服务的信息。哎，这里的 checkService 又 OK 了。可能是字符串传递的问题吧。我们来看下另外2个小函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个好像是字符串转化相关的，String8 和 String16 都是 android 在 native </span></div><div class="line"><span class="comment">// 对 char 串的封装</span></div><div class="line"><span class="keyword">static</span> String8 good_old_string(<span class="keyword">const</span> String16& src)</div><div class="line">{</div><div class="line">    String8 name8;</div><div class="line">    <span class="keyword">char</span> ch8[<span class="number">2</span>];</div><div class="line">    ch8[<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; src.size(); j++) { </div><div class="line">        <span class="keyword">char16_t</span> ch = src[j];</div><div class="line">        <span class="keyword">if</span> (ch &lt; <span class="number">128</span>) ch8[<span class="number">0</span>] = (<span class="keyword">char</span>)ch;</div><div class="line">        name8.append(ch8);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> name8;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后这个 <code>get_interface_name</code> 就是上面后面 [] 打印的东西，这个是每个 service 的标示，之前 binder 几篇的文章有说到每次 binder 通信，首先会检测这个标示的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// get the name of the generic interface we hold a reference to</span></div><div class="line"><span class="keyword">static</span> String16 get_interface_name(sp&lt;IBinder&gt; service)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (service != NULL) {</div><div class="line">        Parcel data, reply;</div><div class="line">        status_t err = service-&gt;transact(IBinder::INTERFACE_TRANSACTION, data, &reply);              </div><div class="line">        <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">            <span class="keyword">return</span> reply.readString16();                                                                                  </div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> String16();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后在 Binder.cpp 中，就是 binder Bn 的父类中默认处理中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">status_t BBinder::onTransact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (code) {</div><div class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">            reply-&gt;writeString16(getInterfaceDescriptor());</div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> UNKNOWN_TRANSACTION;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这就获取每个 system service 的标示。</p>
<h3 id="call-1">call</h3>
<p>接下来这个才是最有用的命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line">        </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"call"</span>) == <span class="number">0</span>) {</div><div class="line">            optind++;</div><div class="line">            <span class="keyword">if</span> (optind+<span class="number">1</span> &lt; argc) {</div><div class="line">                <span class="keyword">int</span> serviceArg = optind;</div><div class="line">                <span class="comment">// 从 sm 那获取指定的 service 接口（Bp）</span></div><div class="line">                sp&lt;IBinder&gt; service = sm-&gt;checkService(String16(argv[optind++]));</div><div class="line">                <span class="comment">// 获取服务的标示</span></div><div class="line">                String16 ifName = get_interface_name(service);</div><div class="line">                int32_t code = atoi(argv[optind++]);</div><div class="line">                <span class="keyword">if</span> (service != NULL && ifName.size() &gt; <span class="number">0</span>) {</div><div class="line">                    Parcel data, reply;</div><div class="line"></div><div class="line">                    <span class="comment">// 呵呵，先写服务的标示</span></div><div class="line">                    <span class="comment">// the interface name is first</span></div><div class="line">                    data.writeInterfaceToken(ifName);</div><div class="line"></div><div class="line">                    <span class="comment">// 支持的参数有3种类型：i32、s16 和 intent</span></div><div class="line">                    <span class="comment">// then the rest of the call arguments</span></div><div class="line">                    <span class="keyword">while</span> (optind &lt; argc) {</div><div class="line">                        <span class="comment">// i32 就是 int32，非常简单的类型，</span></div><div class="line">                        <span class="comment">// 直接使用 parcel 的 writeInt32 </span></div><div class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"i32"</span>) == <span class="number">0</span>) {</div><div class="line">                            optind++;</div><div class="line">                            <span class="keyword">if</span> (optind &gt;= argc) {</div><div class="line">                                aerr &lt;&lt; <span class="string">"service: no integer supplied for 'i32'"</span> &lt;&lt; endl;</div><div class="line">                                wantsUsage = <span class="keyword">true</span>;</div><div class="line">                                result = <span class="number">10</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            }</div><div class="line">                            data.writeInt32(atoi(argv[optind++]));</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"s16"</span>) == <span class="number">0</span>) {</div><div class="line">                            <span class="comment">// s16 就是 String16，也是比较简单的类型</span></div><div class="line">                            <span class="comment">// parcel 都有现成的接口可用</span></div><div class="line">                            optind++;</div><div class="line">                            <span class="keyword">if</span> (optind &gt;= argc) {</div><div class="line">                                aerr &lt;&lt; <span class="string">"service: no string supplied for 's16'"</span> &lt;&lt; endl;</div><div class="line">                                wantsUsage = <span class="keyword">true</span>;</div><div class="line">                                result = <span class="number">10</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            }</div><div class="line">                            data.writeString16(String16(argv[optind++]));</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"null"</span>) == <span class="number">0</span>) {</div><div class="line">                            optind++;</div><div class="line">                            data.writeStrongBinder(NULL);</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[optind], <span class="string">"intent"</span>) == <span class="number">0</span>) {</div><div class="line">       </div><div class="line"><span class="comment">// 下面这个 intent 类型，就有点麻烦了，我暂时没去管它 ... ...</span></div><div class="line">... ...</div><div class="line"></div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            aerr &lt;&lt; <span class="string">"service: unknown option "</span> &lt;&lt; argv[optind] &lt;&lt; endl;</div><div class="line">                            wantsUsage = <span class="keyword">true</span>;</div><div class="line">                            result = <span class="number">10</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="comment">// parcel 打好包好，调用 service 的 transact 函数</span></div><div class="line">                    service-&gt;transact(code, data, &reply);</div><div class="line">                    <span class="comment">// 打印 parcel 打包的返回值</span></div><div class="line">                    aout &lt;&lt; <span class="string">"Result: "</span> &lt;&lt; reply &lt;&lt; endl;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    aerr &lt;&lt; <span class="string">"service: Service "</span> &lt;&lt; argv[serviceArg]</div><div class="line">                        &lt;&lt; <span class="string">" does not exist"</span> &lt;&lt; endl;</div><div class="line">                    result = <span class="number">10</span>;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div></pre></td></tr></table></figure>

<p>从上面的代码来看，call 的格式是：</p>
<pre>
service call service code i32 xx
</pre>

<p>service 就是当初 SM addService 的那串字符，就是 list 中第一个名字。例如 WindowManagerService 的就是 window。code 的话就是定义 service 接口的时候那从 <code>android.os.IBinder.FIRST_CALL_TRANSACTION</code> 开始累加的数字。然后后面就是参数了，开始要把参数类型写上，然后才是参数。上面说了一共支持3种类型：i32（int32）、s16（String16）和 intent（复合类型）。</p>
<p>来点例子，例如我那篇 <a href="http://light3moon.com/2015/01/26/hierarchyviewer 无法使用问题" title="hierarchyviewer 无法使用问题" target="_blank" rel="external">hierarchyviewer 无法使用问题</a> 调用 wm 开启 view server 就是这么敲：</p>
<pre>
service call window 1 i32 4939
</pre>

<p>这个 <code>TRANSACTION_CODE</code> 怎么确定咧。这个就要去翻源码啦。例如上面 wm 的那个接口，我在 IWindwManager.java（wm 是用 aidl 的，要去 out 下面去翻 aidl 自动生成的 java 文件） 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_startViewServer = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_stopViewServer = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_isViewServerRunning = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 然后去翻下 IBinder 发现是从 1 开始的 </span></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>,</div><div class="line">        LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>,</div><div class="line">... ...</div><div class="line">    };</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以要调用 wm 的 startViewServer 接口，code 就要填 1 啦。然后我们再去看下 startViewServer 的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Starts the view server on the specified port.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param port The port to listener to.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @return True if the server was successfully started, false otherwise.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @see com.android.server.wm.ViewServer</span></div><div class="line"><span class="comment"> * @see com.android.server.wm.ViewServer#VIEW_SERVER_DEFAULT_PORT</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startViewServer</span>(<span class="keyword">int</span> port)</div><div class="line"></div></pre></td></tr></table></figure>

<p>接口参数就一个 int 的 port（socket 的端口吧），所以后面那个参数就要填 i32 4939 （话说网上怎么知道端口要用 4939 的）。</p>
<p>然后我们来看下 IWindowManager.aidl 中一段有意思的注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * ===== NOTICE =====</span></div><div class="line"><span class="comment"> * The first three methods must remain the first three methods. Scripts</span></div><div class="line"><span class="comment"> * and tools rely on their transaction number to work properly.</span></div><div class="line"><span class="comment"> */</span> </div><div class="line"><span class="comment">// This is used for debugging</span></div><div class="line">boolean startViewServer(<span class="keyword">int</span> port);   <span class="comment">// Transaction #1</span></div><div class="line">boolean stopViewServer();            <span class="comment">// Transaction #2</span></div><div class="line">boolean isViewServerRunning();       <span class="comment">// Transaction #3</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>大致意思是说：请把这2个接口放在最前面声明，因为 aidl 是按顺序生成 code 号的，这样就能保证这3个接口的 code 固定是 1、2、3。这个明显是 android 故意留给这个 shell 命令的小工具的。所以你要自己要加一些 service 的接口，尽量从 <code>LAST_CALL_TRANSACTION</code> 从后往前面加，避免影响一些系统工具的使用。</p>
<p>然后如果是没有参数的话，后面那个参数可以不填，例如查询 wm view server 是否开启的接口：</p>
<pre>
service call window 3
</pre>

<p>然后就是返回值了。binder 的返回值都是通过 parcel 打包的，前面 binder 分析过了，每个服务的 Bp 都会自己解析返回值的 parcel 包，然后里面的返回值拆出来，转化成接口具体的返回值返回给调用者。但是这里就直接打印 parcel 了。前面 binder 也分析过，parcel 就是简单的把数据塞到内存里面而已（当然有一些类型有一点点格式）。这里也只是把 parcel 内存中的东西打印出来而已。</p>
<p>我们来看上面那个查询 wm view server 是否开启的结果：</p>
<pre>
root@H9:/ # service call window 3
Result: Parcel(00000000 00000001   '........')
</pre>

<p>返回值，第一个 int32 是错误值，0 表示没有错误。然后从第二开始才是真正的返回值。这个 startViewServer 的返回值看代码就是一个 int（那个接口是 boolean，在 Bp 那是根据 0、1 来判断的）。所以那个 00000001 就代表 view server 已经启动咯。如果是 00000000 就是没启动。</p>
<p>好，我们再来个稍微复杂点的例子。wm 中有一个这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getAnimationScale</span>(<span class="keyword">int</span> which) { </div><div class="line">    <span class="keyword">switch</span> (which) {</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> mWindowAnimationScale;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> mTransitionAnimationScale;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> mAnimatorDurationScale; </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>而且这个正好在 Settings 中的开发这选项有可以设置（可以拿来测试用）。开发者选项—&gt;绘图：</p>
<pre>
窗口动画缩放    --> mWindowAnimationScale
过渡动画缩放    --> mTransitionAnimationScale
动画程序时长缩放 --> mAnimatorDurationScale
</pre>

<p>我们拿第一个玩一下，因为第一个窗口动画缩放，只要设置成 10x 窗口的缩放动画就会变得很慢。去翻下 IWindowManager.java 4.4 的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getAnimationScale = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">48</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以要获取 mWindowAnimationScale 的值的话就应该这么敲：</p>
<pre>
service call window 49 i32 0
</pre>

<p>得到的结果如下：</p>
<pre>
root@H9:/ # service call window 49 i32 0
Result: Parcel(00000000 3f800000   '.......?')
</pre>

<p>嘿嘿，返回的是 float，顺带学习下 float 在内存中的表示：<a href="http://light3moon.com/2015/01/19/[转] float 类型在内存中的表示" title="看这里啦" target="_blank" rel="external">看这里啦</a>。</p>
<p>0x3f800000 就是 1.0 的 float。然后去 Settings 的调试选项，把这个调成 动画缩放 10x，再敲一下，结果是：</p>
<pre>
root@H9:/ # service call window 49 i32 0
Result: Parcel(00000000 41200000   '...... A')
</pre>

<p>0x41200000 是 10.0 的 float。</p>
<h2 id="限制">限制</h2>
<p>从上面来看，这个小工具其实挺有用的。可以很方便的自己留个小后门或是加一些调试小接口。这个东西，需要知道接口的 <code>TRANSACTION_CODE</code> 和参数才能正常调用，很符合留后门给自己用的风范 ^_^。</p>
<p>还有从上面的分析来看，这个工具只能调用一些参数是 void、int、String 或是 intent 相关的接口。还有返回值如果是比较复杂的 class（结构体）要分析也比较困难，简单的 int、float、String 还好看懂。不过虽然有局限性，还是一个不错的小工具了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/30/Android%20%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B0%8F%E5%B7%A5%E5%85%B7%20%E2%80%94%E2%80%94%20dumpsys/</loc>
    <lastmod>2015-01-30T08:30:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 一些有意思的命令小工具 —— dumpsys</title>
        <pubTime>2015-01-30T08:30:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 自带了很多 cmds 的小工具，都挺用有的，也有些比较有意思。这里介绍的是 dumpsys 这个工具。说之前先把相关源码位置说下（4.4 的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># service 命令模块</span></div><div class="line">frameworks/native/cmds/dumpsys</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="作用">作用</h2>
<p>这个工具的作用是让你能够在 shell 中 dump（导出）系统服务（SS）的当前状态，然后输出到 console 中。不过都能输出到 console 中，重定向一下，就能输出到文件中啦，这个工具是<strong>非常有用的</strong>。用法很简单直接敲 dumpsysy 就行了。不过这样是导出所有实现了 dump 接口的 SS 的状态（基本上 SS 都实现了这个接口），然后输出非常的长，类似下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">Currently running services:</div><div class="line">  SurfaceFlinger</div><div class="line">  accessibility</div><div class="line">  account</div><div class="line">  activity</div><div class="line">  alarm</div><div class="line">  appwidget</div><div class="line">  audio</div><div class="line">  backup</div><div class="line">  battery</div><div class="line">  batteryinfo</div><div class="line">  bluetooth_manager</div><div class="line">  clipboard</div><div class="line">  commontime_management</div><div class="line">  connectivity</div><div class="line">  content</div><div class="line">  country_detector</div><div class="line">  cpuinfo</div><div class="line">  dbinfo</div><div class="line">  device_policy</div><div class="line">  devicestoragemonitor</div><div class="line">  diskstats</div><div class="line">  display</div><div class="line">  dreams</div><div class="line">  drm.drmManager</div><div class="line">  dropbox</div><div class="line">  entropy</div><div class="line">  ethernet</div><div class="line">  gfxinfo</div><div class="line">  hardware</div><div class="line">  input </div><div class="line">  input_method</div><div class="line">  iphonesubinfo</div><div class="line">  isms</div><div class="line">  location</div><div class="line">  lock_settings</div><div class="line">  media.audio_flinger</div><div class="line">  media.audio_policy</div><div class="line">  media.camera</div><div class="line">  media.player</div><div class="line">  meminfo</div><div class="line">  mount </div><div class="line">  netpolicy</div><div class="line">  netstats</div><div class="line">  network_management</div><div class="line">  notification</div><div class="line">  package</div><div class="line">  parentalmode</div><div class="line">  permission</div><div class="line">  phone </div><div class="line">  power </div><div class="line">  samplingprofiler</div><div class="line">  scheduling_policy</div><div class="line">  search</div><div class="line">  sensorservice</div><div class="line">  serial</div><div class="line">  servicediscovery</div><div class="line">  simphonebook</div><div class="line">  statusbar</div><div class="line">  telephony.registry</div><div class="line">  textservices</div><div class="line">  throttle</div><div class="line">  uimode</div><div class="line">  updatelock</div><div class="line">  usagestats</div><div class="line">  usb</div><div class="line">  user</div><div class="line">  vibrator</div><div class="line">  wallpaper</div><div class="line">  wifi</div><div class="line">  wifip2p</div><div class="line">  window</div><div class="line">-------------------------------------------------------------------------------</div><div class="line">DUMP OF SERVICE SurfaceFlinger:</div><div class="line">Build configuration: [sf] [libui] [libgui]</div><div class="line">Visible layers (count = <span class="number">5</span>)</div><div class="line">+ LayerDim <span class="number">0</span>x40941008 (DimAnimator)</div><div class="line">  Region transparentRegion (this=<span class="number">0</span>x40941144, count=<span class="number">1</span>)</div><div class="line">    [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]</div><div class="line">  Region visibleRegion (this=<span class="number">0</span>x40941014, count=<span class="number">1</span>)</div><div class="line">    [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]</div><div class="line">      layerStack=   <span class="number">0</span>, z=        <span class="number">0</span>, pos=(<span class="number">0</span>,<span class="number">0</span>), size=(  <span class="number">16</span>,  <span class="number">16</span>), crop=(   <span class="number">0</span>,   <span class="number">0</span>,  -<span class="number">1</span>,  -<span class="number">1</span>), isOpaque=<span class="number">0</span>, needsDithering=<span class="number">0</span>, invalidate=<span class="number">0</span>, alpha=<span class="number">0</span>x00, flags=<span class="number">0</span>x00000000, mShouldTransform=<span class="number">0</span>, tr=[<span class="number">1.00</span>, <span class="number">0.00</span>][<span class="number">0</span>.</div><div class="line">      client=<span class="number">0</span>x4290cb20, identity=<span class="number">2</span></div><div class="line">+ LayerDim <span class="number">0</span>x40941270 (DimSurface)</div><div class="line">  Region transparentRegion (this=<span class="number">0</span>x409413ac, count=<span class="number">1</span>)</div><div class="line">    [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]</div><div class="line">  Region visibleRegion (this=<span class="number">0</span>x4094127c, count=<span class="number">1</span>)</div><div class="line">    [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]</div><div class="line">      layerStack=   <span class="number">0</span>, z=        <span class="number">0</span>, pos=(<span class="number">0</span>,<span class="number">0</span>), size=(  <span class="number">16</span>,  <span class="number">16</span>), crop=(   <span class="number">0</span>,   <span class="number">0</span>,  -<span class="number">1</span>,  -<span class="number">1</span>), isOpaque=<span class="number">0</span>, needsDithering=<span class="number">0</span>, invalidate=<span class="number">0</span>, alpha=<span class="number">0</span>x00, flags=<span class="number">0</span>x00000000, mShouldTransform=<span class="number">0</span>, tr=[<span class="number">1.00</span>, <span class="number">0.00</span>][<span class="number">0</span>.</div><div class="line">      client=<span class="number">0</span>x4290cb20, identity=<span class="number">3</span></div><div class="line">+ Layer <span class="number">0</span>x40437d28 (com.android.systemui.ImageWallpaper)</div><div class="line">  Region transparentRegion (this=<span class="number">0</span>x40437e64, count=<span class="number">1</span>)</div><div class="line">    [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]</div><div class="line">  Region visibleRegion (this=<span class="number">0</span>x40437d34, count=<span class="number">1</span>)</div><div class="line">    [  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">768</span>, <span class="number">1024</span>]</div><div class="line">      layerStack=   <span class="number">0</span>, z=    <span class="number">21000</span>, pos=(-<span class="number">695</span>,<span class="number">0</span>), size=(<span class="number">1466</span>,<span class="number">1024</span>), crop=( <span class="number">695</span>,   <span class="number">0</span>,<span class="number">1463</span>,<span class="number">1024</span>), isOpaque=<span class="number">1</span>, needsDithering=<span class="number">0</span>, invalidate=<span class="number">0</span>, alpha=<span class="number">0</span>xff, flags=<span class="number">0</span>x00000000, mShouldTransform=<span class="number">0</span>, tr=[<span class="number">1.00</span>, <span class="number">0.00</span>]</div><div class="line">      client=<span class="number">0</span>x40436a68, identity=<span class="number">6</span></div><div class="line">      format= <span class="number">2</span>, activeBuffer=[<span class="number">1466</span>x1024:<span class="number">1472</span>,  <span class="number">1</span>], queued-frames=<span class="number">0</span>, mRefreshPending=<span class="number">0</span></div><div class="line">            mTexName=<span class="number">5</span> mCurrentTexture=-<span class="number">1</span></div><div class="line">            mCurrentCrop=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] mCurrentTransform=<span class="number">0</span></div><div class="line">            mAbandoned=<span class="number">0</span></div><div class="line">            -BufferQueue maxBufferCount=<span class="number">4</span>, mSynchronousMode=<span class="number">1</span>, default-size=[<span class="number">1466</span>x1024], default-format=<span class="number">1</span>, transform-hint=<span class="number">00</span>, FIFO(<span class="number">0</span>)={}</div><div class="line">             [<span class="number">00</span>] state=FREE    , crop=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], xform=<span class="number">0</span>x00, time=<span class="number">0</span>x9e84ca7f2, scale=FREEZE</div><div class="line">             [<span class="number">01</span>] state=FREE    , crop=[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>], xform=<span class="number">0</span>x00, time=<span class="number">0</span>, scale=FREEZE</div><div class="line">             [<span class="number">02</span>] state=FREE    , crop=[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>], xform=<span class="number">0</span>x00, time=<span class="number">0</span>, scale=FREEZE</div><div class="line">             [<span class="number">03</span>] state=FREE    , crop=[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>], xform=<span class="number">0</span>x00, time=<span class="number">0</span>, scale=FREEZE</div><div class="line">+ Layer <span class="number">0</span>x40941648 (com.bbk.studyos.launcher/com.bbk.studyos.launcher.activity.Launcher)</div><div class="line"></div><div class="line">... ...</div><div class="line"></div></pre></td></tr></table></figure>

<p>虽然说可以用搜索，但是太长了还是比较麻烦，可以在接某个（或是几个） SS 的名字，就可以导出指定 SS 的当前状态。例如说像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dumpsys window</div><div class="line"></div></pre></td></tr></table></figure>

<p>这样就能导出你想看的 SS 的当前状态。稍微注意一下，这里 SS 的名字是注册到 SM 中的那个名字，Binder 篇的时候介绍过了一般不是带包名类名的那个，而是短的那个。具体的可以去翻源代码，或者可以先：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dumpsys <span class="operator">-l</span></div><div class="line"></div></pre></td></tr></table></figure>



<p>这样会罗列出所有的 SS 的名字（这个 -l 参数是 4.4 才加的，之前的直接 dumpsys 在一开始也会列出所有的 SS 的名字），然后复制、粘贴一下就行了。</p>
<h2 id="分析">分析</h2>
<p>这个小工具的作用和基本用法知道了，然后我们看看实现（代码不长我直接全贴了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> sort_func(<span class="keyword">const</span> String16* lhs, <span class="keyword">const</span> String16* rhs)</div><div class="line">{</div><div class="line">    <span class="comment">// 排下序，按首字母排序，我没去具体看 native String16 的排序代码，</span></div><div class="line">    <span class="comment">// 看上面的输出应该是按 ASCI 码值排序的 </span></div><div class="line">    <span class="keyword">return</span> lhs-&gt;compare(*rhs);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line">    signal(SIGPIPE, SIG_IGN);</div><div class="line">    <span class="comment">// 获取 native 层的 SM</span></div><div class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">    fflush(stdout);</div><div class="line">    <span class="keyword">if</span> (sm == NULL) {</div><div class="line">        ALOGE(<span class="string">"Unable to get default service manager!"</span>);</div><div class="line">        aerr &lt;&lt; <span class="string">"dumpsys: Unable to get default service manager!"</span> &lt;&lt; endl;</div><div class="line">        <span class="keyword">return</span> <span class="number">20</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    Vector&lt;String16&gt; services;</div><div class="line">    Vector&lt;String16&gt; args;</div><div class="line">    <span class="keyword">bool</span> showListOnly = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 如果只是 dumpsys -l 的话，那就只要列出当前所有的 SS 的名字就可以</span></div><div class="line">    <span class="keyword">if</span> ((argc == <span class="number">2</span>) && (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-l"</span>) == <span class="number">0</span>)) {</div><div class="line">        showListOnly = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 如果只是要列出所有的 SS</span></div><div class="line">    <span class="comment">// 或者是没指定 SS，那么就取所有的 SS</span></div><div class="line">    <span class="keyword">if</span> ((argc == <span class="number">1</span>) || showListOnly) {</div><div class="line">        <span class="comment">// 调用 SM 的 listServices 获取所有的 SS 的 IBinder 接口（Bp）</span></div><div class="line">        services = sm-&gt;listServices();</div><div class="line">        <span class="comment">// 使用自定义排序函数排序</span></div><div class="line">        services.sort(sort_func);</div><div class="line">        <span class="comment">// 如果没给参数，就默认给 -a</span></div><div class="line">        args.add(String16(<span class="string">"-a"</span>));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 指定了要获取的 SS ，就添加指定的 SS</span></div><div class="line">        services.add(String16(argv[<span class="number">1</span>]));</div><div class="line">        <span class="comment">// 获取指定要 dump 的参数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;argc; i++) {</div><div class="line">            args.add(String16(argv[i]));</div><div class="line">        }   </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> size_t N = services.size();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (N &gt; <span class="number">1</span>) {</div><div class="line">        <span class="comment">// first print a list of the current services</span></div><div class="line">        aout &lt;&lt; <span class="string">"Currently running services:"</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">        <span class="comment">// 如果 dump 的 SS 数量大于 1，先打印一下 SS 的名字</span></div><div class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">            sp&lt;IBinder&gt; service = sm-&gt;checkService(services[i]);</div><div class="line">            <span class="keyword">if</span> (service != NULL) {</div><div class="line">                aout &lt;&lt; <span class="string">"  "</span> &lt;&lt; services[i] &lt;&lt; endl;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (showListOnly) {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">        sp&lt;IBinder&gt; service = sm-&gt;checkService(services[i]);</div><div class="line">        <span class="keyword">if</span> (service != NULL) {</div><div class="line">            <span class="keyword">if</span> (N &gt; <span class="number">1</span>) {</div><div class="line">                aout &lt;&lt; <span class="string">"------------------------------------------------------------"</span></div><div class="line">                        <span class="string">"-------------------"</span> &lt;&lt; endl;</div><div class="line">                aout &lt;&lt; <span class="string">"DUMP OF SERVICE "</span> &lt;&lt; services[i] &lt;&lt; <span class="string">":"</span> &lt;&lt; endl;</div><div class="line">            }</div><div class="line">            <span class="comment">// 调用 SS IBinder 的 接口</span></div><div class="line">            <span class="keyword">int</span> err = service-&gt;dump(STDOUT_FILENO, args);</div><div class="line">            <span class="keyword">if</span> (err != <span class="number">0</span>) {</div><div class="line">                aerr &lt;&lt; <span class="string">"Error dumping service info: ("</span> &lt;&lt; strerror(err)</div><div class="line">                        &lt;&lt; <span class="string">") "</span> &lt;&lt; services[i] &lt;&lt; endl;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            aerr &lt;&lt; <span class="string">"Can't find service: "</span> &lt;&lt; services[i] &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>从上面的代码可以看到这个工具是通过 SM 获取 SS 的 IBinder 接口的。SM 主要是 native 的层，所以 native 应用要调用也挺方便。然后导出的内容主要是调用 IBinder 的 dump 接口。IBinder 直接留有 dump 这个抽象接口，所以从 Binder 设计开始，android 就想要要留个东西方便调试（查看当前 SS 的状态）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> IBinder : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> status_t        dump(<span class="keyword">int</span> fd, <span class="keyword">const</span> Vector&lt;String16&gt;& args) = <span class="number">0</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 native 的 Bn 有默认实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =============== Binder.cpp ==================</span></div><div class="line"></div><div class="line">status_t BBinder::dump(<span class="keyword">int</span> fd, <span class="keyword">const</span> Vector&lt;String16&gt;& args)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>接下去是 java 层的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =============== IBinder.java ==================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBinder</span> </span>{</div><div class="line"></div><div class="line">... ....</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Print the object's state into the given stream.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param fd The raw file descriptor that the dump is being sent to.</span></div><div class="line"><span class="comment">     * @param args additional arguments to the dump request.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span>(FileDescriptor fd, String[] args) <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// =============== Binder.java ==================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Implemented to call the more convenient version</span></div><div class="line"><span class="javadoc">     * {@link #dump(FileDescriptor, PrintWriter, String[])}.</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span>(FileDescriptor fd, String[] args) {</div><div class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(fd);</div><div class="line">        PrintWriter pw = <span class="keyword">new</span> FastPrintWriter(fout);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">final</span> String disabled;</div><div class="line">            <span class="keyword">synchronized</span> (Binder.class) {</div><div class="line">                disabled = sDumpDisabled;</div><div class="line">            }  </div><div class="line">            <span class="keyword">if</span> (disabled == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    dump(fd, pw, args);</div><div class="line">                } <span class="keyword">catch</span> (SecurityException e) {</div><div class="line">                    pw.println(<span class="string">"Security exception: "</span> + e.getMessage());</div><div class="line">                    <span class="keyword">throw</span> e;</div><div class="line">                } <span class="keyword">catch</span> (Throwable e) {</div><div class="line">                    <span class="comment">// Unlike usual calls, in this case if an exception gets thrown</span></div><div class="line">                    <span class="comment">// back to us we want to print it back in to the dump data, since</span></div><div class="line">                    <span class="comment">// that is where the caller expects all interesting information to</span></div><div class="line">                    <span class="comment">// go.</span></div><div class="line">                    pw.println();</div><div class="line">                    pw.println(<span class="string">"Exception occurred while dumping:"</span>);</div><div class="line">                    e.printStackTrace(pw);</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                pw.println(sDumpDisabled);</div><div class="line">            }</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            pw.flush();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Print the object's state into the given stream.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param fd The raw file descriptor that the dump is being sent to.</span></div><div class="line"><span class="comment">     * @param fout The file to which you should dump your state.  This will be</span></div><div class="line"><span class="comment">     * closed for you after you return.</span></div><div class="line"><span class="comment">     * @param args additional arguments to the dump request.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span>(FileDescriptor fd, PrintWriter fout, String[] args) {</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>从 dumpsys 通过 native 的 IBinder 一直调用到 java 层的 Binder dump，到 java 的 Binder 有一个同名但是参数不一样的抽象函数。多了的一个参数是 java io 的 PrintWriter，我对这个不是很熟悉（好像是可以控制可以输出到哪去的），所以在这里不讨论这个。然后其实导出什么东西，具体是由不同的 SS 来实现的。我们拿 AMS 来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =============== ActivityManagerService.java ================== </span></div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span>(FileDescriptor fd, PrintWriter pw, String[] args) {</div><div class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.DUMP)</div><div class="line">                != PackageManager.PERMISSION_GRANTED) {</div><div class="line">            pw.println(<span class="string">"Permission Denial: can't dump ActivityManager from from pid="</span></div><div class="line">                    + Binder.getCallingPid()</div><div class="line">                    + <span class="string">", uid="</span> + Binder.getCallingUid()</div><div class="line">                    + <span class="string">" without permission "</span></div><div class="line">                    + android.Manifest.permission.DUMP);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> dumpAll = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">boolean</span> dumpClient = <span class="keyword">false</span>;</div><div class="line">        String dumpPackage = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> opti = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (opti &lt; args.length) {</div><div class="line">            String opt = args[opti];</div><div class="line">            <span class="keyword">if</span> (opt == <span class="keyword">null</span> || opt.length() &lt;= <span class="number">0</span> || opt.charAt(<span class="number">0</span>) != <span class="string">'-'</span>) {</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            opti++;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"-a"</span>.equals(opt)) {</div><div class="line">                dumpAll = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-c"</span>.equals(opt)) {</div><div class="line">                dumpClient = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-h"</span>.equals(opt)) {</div><div class="line">                pw.println(<span class="string">"Activity manager dump options:"</span>);</div><div class="line">                pw.println(<span class="string">"  [-a] [-c] [-h] [cmd] ..."</span>);</div><div class="line">                pw.println(<span class="string">"  cmd may be one of:"</span>);</div><div class="line">                pw.println(<span class="string">"    a[ctivities]: activity stack state"</span>);</div><div class="line">                pw.println(<span class="string">"    b[roadcasts] [PACKAGE_NAME] [history [-s]]: broadcast state"</span>);</div><div class="line">                pw.println(<span class="string">"    i[ntents] [PACKAGE_NAME]: pending intent state"</span>);</div><div class="line">                pw.println(<span class="string">"    p[rocesses] [PACKAGE_NAME]: process state"</span>);</div><div class="line">                pw.println(<span class="string">"    o[om]: out of memory management"</span>);</div><div class="line">                pw.println(<span class="string">"    prov[iders] [COMP_SPEC ...]: content provider state"</span>);</div><div class="line">                pw.println(<span class="string">"    provider [COMP_SPEC]: provider client-side state"</span>);</div><div class="line">                pw.println(<span class="string">"    s[ervices] [COMP_SPEC ...]: service state"</span>);</div><div class="line">                pw.println(<span class="string">"    service [COMP_SPEC]: service client-side state"</span>);</div><div class="line">                pw.println(<span class="string">"    package [PACKAGE_NAME]: all state related to given package"</span>);</div><div class="line">                pw.println(<span class="string">"    all: dump all activities"</span>);</div><div class="line">                pw.println(<span class="string">"    top: dump the top activity"</span>);</div><div class="line">                pw.println(<span class="string">"  cmd may also be a COMP_SPEC to dump activities."</span>);</div><div class="line">                pw.println(<span class="string">"  COMP_SPEC may be a component name (com.foo/.myApp),"</span>);</div><div class="line">                pw.println(<span class="string">"    a partial substring in a component name, a"</span>);</div><div class="line">                pw.println(<span class="string">"    hex object identifier."</span>);</div><div class="line">                pw.println(<span class="string">"  -a: include all available server state."</span>);</div><div class="line">                pw.println(<span class="string">"  -c: include client state."</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                pw.println(<span class="string">"Unknown argument: "</span> + opt + <span class="string">"; use -h for help"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里我们不具体看 AMS 导出了什么东西（AMS 的数据结构一大票，所以能导出很多东西的），但是从代码中发现，其实 dumpsys 还可以传不同的参数给不同的 SS。例如上面的 AMS 有 -c、-h 的参数。从上面 dumpsys 代码中发现，只有指定 SS 的命令格式才能接特定的参数，例如说这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dumpsys activity -c</div><div class="line"></div></pre></td></tr></table></figure>

<p>全部导出的不支持的（默认给你加了 -a），这个是因为不同的 SS 说支持的参数不一样（完全由各个 SS 实现决定），所以只有指定 SS 才能接参数。至于哪些 SS 支持哪些参数，具体的去看 SS 的 dump 实现代码去吧。然后说一点如果自己改某些 SS ，例如说加了某些字段，可以在 dump 中把这些字段也导出来了，这样调试自己加的功能的时候会方便不少。</p>
<h2 id="总结">总结</h2>
<p>dumpsys 这个工具最大的作用在于，可以直接打印（导出到文件）所有（指定）SS 的一些预先写好的状态，对于调某些问题的时候，可以通过这个工具查看到当前 SS 中一些数值的信息，这样可以不用额外加打印就能追踪到一些现象中的 SS 的某些状态。所以对于某些重启现象就消失的情况，这个工具是非常管用的。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/64%E4%BD%8D%20ubuntu%20adb%20No%20such%20file%20or%20directory%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</loc>
    <lastmod>2015-01-29T14:42:16.000Z</lastmod>
    <data>
        <display>
        <title>64位 ubuntu adb No such file or directory 解决办法</title>
        <pubTime>2015-01-25T14:42:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="13-04">13.04</h2>
<p>很简单，安装一个 ia32-libs 就好了（sudo apt-get install ia32-libs）。一看就知道64位系统又悲剧了一次。 </p>
<h2 id="13-10">13.10</h2>
<p>13.10 把 ia32-libs 这个包禁止掉了，它会提用下面几个包来代替：</p>
<ul>
<li>lib32z1</li>
<li>lib32ncurses5</li>
<li>lib32bz2-1.0</li>
</ul>
<p>依次安装好之后，又提示 libstdc++.so.6 找不到， 这个是 32bit 的 gun c++ 的库。安装 lib32stdc++6 就可以了。</p>
<p>最后发现还是要把 ia32-libs 这个包装上比较好，不好很多软件用不了，例如 skype、Beyond Compare。 13.10 只是把这个源去掉了而已，可以自己加上：</p>
<p>在设置的 software update 的软件源那里加上： deb <a href="http://archive.ubuntu.com/ubuntu/" target="_blank" rel="external">http://archive.ubuntu.com/ubuntu/</a> raring main restricted universe multiverse， 然后 apt-get update 一下就可以安装了。</p>
<p>从官方论坛那看到的信息，说是 ia32-libs 其实在 64bit 下是个不好的东西，所以从 12.04 之后就把这个源给去掉了（话说以前我 13.04 怎么装上去的），如果要使用 32bit 的软件包，应该使用 sudo apt-get install package-name:i386 来安装 32bit 的版本。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-28T12:12:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 智能指针备忘</title>
        <pubTime>2015-01-28T12:12:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>在 framework 的 native 层一大票 sp<xx>, wp<xx> 之类的玩意。这个是 android 自己搞的一套智能指针技术，就是为了偷懒用的，利用引用计数和构造、析构函数实现内存自动释放的功能（其实我挺讨厌这套东西，刚看着头晕，自己手动 new、delete 对象有那么难么？）。网上罗升阳的一个分析挺不错的： <a href="http://blog.csdn.net/luoshengyang/article/details/6786239" title="智能指针分析" target="_blank" rel="external">智能指针分析</a>。不过这个太长的，这里稍微记点总结，方便之后查看。</xx></xx></p>
<ul>
<li><p><strong>RefBase</strong><br>所有要支持智能指针的类的基类，如果你写的类想要支持智能使用，就要继承这个东西。支持强指针（sp）和弱指针（wp）。</p>
</li>
<li><p><strong>LightRefBase</strong><br>轻量级指针基类，这个和上面的区别就是只支持强指针（sp）。</p>
</li>
<li><p><strong>生命周期</strong><br>android 的智能指针有个 flag 可以设置指针智能的策略： </p>
</li>
</ul>
<pre config="brush:bash;toolbar:false;">
//! Flags for extendObjectLifetime()
enum {
    OBJECT_LIFETIME_STRONG  = 0x0000,
    OBJECT_LIFETIME_WEAK    = 0x0001,
    OBJECT_LIFETIME_MASK    = 0x0001
};
</pre>

<p><code>OBJECT_LIFETIME_STRONG</code>: 默认策略，对象销毁只受强引用计数影响，如果强引用计数为0，就会 delete 这个对象。</p>
<p><code>OBJECT_LIFETIME_WEAK</code>： 使用 extendObjectLifetime（<code>OBJECT_LIFETIME_WEAK</code>） 设置。设置后对象销毁同时受强引用计数和弱引用计数的影响。只有当强引用计数和弱引用同时为 0 的时候才会 delete 这个对象。</p>
<ul>
<li><p><strong>sp</strong><br>强指针，用这个指针指向对象会导致强引用计数 +1，当这个指针销毁（析构的）的时候强引用计数会 -1。这个指针能够直接操作指向的对象（有 -&gt; 和 * 操作）。</p>
</li>
<li><p><strong>wp</strong><br>弱指针，用这个指针指向对象会导致弱引用计数 +1，当这个指针销毁（析构的）的时候弱引用计数会 -1。弱指针和强指针的最大的区别在于，弱指针不能直接操作指向的对象（没有 -&gt; 和 * 操作）。如果要操作指向的对象需要调用其的 promote() 方法将弱指针转化为强指针访问指向的对象。这个 promote() 如果成功的，会返回对应的强指针，同时导致强引用和弱引用都 +1。但是可能会失败，可能是对象已经被 delete 或是类不允许弱引用转化为强引用。</p>
</li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Provision%20%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E4%BD%9C%E7%94%A8/</loc>
    <lastmod>2015-01-28T12:11:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Provision 的影响和作用</title>
        <pubTime>2015-01-28T12:11:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Provision 是 android 中的一个系统应用（源码位置在： packages/apps/Provision 下面）。它的主要作用是作为开机引导用户进行一些基本设置。但是在原生的 android 系统中，这个 provision 非常的简单，只有一个空白的 activity，这个主要就是留给 OEM 厂商自己定制的（像 google 的 nexus 进行让里你登陆 google 帐号）。</p>
<p>网上说这个东西启动比桌面还早，看下 AndroidManifest.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">application</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"DefaultActivity"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:excludeFromRecents</span>=<span class="value">"true"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">android:priority</span>=<span class="value">"1"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.HOME"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>其实这个就是一个桌面而已，为什么比普通桌面启动快，只不过它把优先级设置得比普通桌面高了一点而已： android:priority=”1” ，普通桌面不设置的话，默认是 0。package manager 在解析 Intent 的时候会优先返回优先级高的。</p>
<p>然后这个 apk 的就只有一个 activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle icicle) {</div><div class="line">        <span class="keyword">super</span>.onCreate(icicle);</div><div class="line"></div><div class="line">        <span class="comment">// Add a persistent setting to allow other apps to know the device has been provisioned.</span></div><div class="line">        Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, <span class="number">1</span>); </div><div class="line">        Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, <span class="number">1</span>); </div><div class="line"></div><div class="line">        <span class="comment">// remove this activity from the package manager.</span></div><div class="line">        PackageManager pm = getPackageManager();</div><div class="line">        ComponentName name = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, DefaultActivity.class);</div><div class="line">        pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</div><div class="line">                PackageManager.DONT_KILL_APP);</div><div class="line"></div><div class="line">        <span class="comment">// terminate the activity.</span></div><div class="line">        finish();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>太简单了。但是要注意2个地方，一个是在 Settings provdier 的 global 表中写入了一条记录： “device_provisioned = 1”（这点非常重要），第二个是调用 package manager 的接口，把自己给 disable 掉了。</p>
<p>先说第一点： 这个条记录非常重要，代表设备已经准备就绪，可以正常使用，换句话说，如果没有这条记录的话，那设备是无法正常使用的。事实上还真是这样，因为系统中那一票 services 都回检测这个值，如果没有的话，都回相应的罢工，例如说无法锁屏、按 Home 键无反应、无法发通知等等。我之前在调一个东西的时候，需要清除 settings provider 中的某个数值，当时为了图简单，我就直接把 settings.db 删掉了。重启后系统各种问题，当时查了好久，坑死爹了。</p>
<p>然后后面第二点就解释为什么手动把 settings.db 删掉了，就各种不能用了，因为 provision 调用 pm 的 disable 把自己 disable 掉了。这就导致下次在启动 HOME 应用的时候，pm 回忽略 disabled 状态的应用。所以如果你手动把 settings.db 删掉了，下次重启就悲剧了。</p>
<p>知道原因了就很好办了，如果调试真的要删除 settings.db ，那自己手动插入 “device_provisioned = 1” 就可以了。</p>
<p>这里可以看出 google 挺黑的，你不好好运行 provision 登陆我的 google 帐号，哥就不让你好好用 android 设备。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20Surface%20flinger%20%E9%A2%9C%E8%89%B2%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-28T11:51:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Surface flinger 颜色格式分析</title>
        <pubTime>2015-01-28T11:51:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>其实是前段时间移植 2.3 的 blur 效果到 4.2 上，然后记录下一些需要注意点的地方。改的地方是 surfacefliner（代码在 framework/native/services/surfaceflinger 下面，2.3 的是在 framework/base/services/surfaceflinger 下）。这里主要说下颜色格式的问题（2.3 的 blur 效果是拿软件做的）。</p>
<h2 id="大小端问题">大小端问题</h2>
<p>这个过了一段时间之后老是忘记，这里要记录一下：大、小端可以理解为，高地址存储的是高位数据还是低位数据。大端存储是高地址存储是高位数据，小端存储是高地址存储的是低位数据（还有一个更取巧的记法：大端存储不要转化，和内存顺序是一致的，小端存储正好反过来）。图文讲解可以看 wiki ，很详细： <a href="http://en.wikipedia.org/wiki/Big-endian" title="Endianness" target="_blank" rel="external">Endianness</a> </p>
<h2 id="颜色格式">颜色格式</h2>
<p>2.3 的 blur 效果，是通过从 GL 的 buffer 中读出 pixel 数据（glReadPixels，相当于截图），然后对这些数据进行软件的模糊算法（类高斯模糊，速度比较快），然后再把模糊后的 pixel 数据生成 texure，再贴回到 GL 上去。</p>
<p>所以这里就涉及到 surface flinger 的 pixel format 以及 GL 中的 pixel format。这里先说下 GL 中的 pixel format。glReadPixels 表示格式的有2个参数：一个是 format，一个是 type。这2个参数的类型可以去查红宝书的第8章， android 的代码里用的 format 和 type 就2种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// surfaceflinger/LayerBlur.cpp --- onDraw()</span></div><div class="line"><span class="keyword">if</span> (mTextureName == -<span class="number">1U</span>) {</div><div class="line">    <span class="comment">// create the texture name the first time</span></div><div class="line">    <span class="comment">// can't do that in the ctor, because it runs in another thread.</span></div><div class="line">    glGenTextures(<span class="number">1</span>, &mTextureName);</div><div class="line">    glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES, &mReadFormat);</div><div class="line">    glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE_OES, &mReadType);</div><div class="line">    <span class="keyword">if</span> (mReadFormat != GL_RGB || mReadType != GL_UNSIGNED_SHORT_5_6_5) {</div><div class="line">        mReadFormat = GL_RGBA;</div><div class="line">        mReadType = GL_UNSIGNED_BYTE;</div><div class="line">        mBlurFormat = GGL_PIXEL_FORMAT_RGBX_8888;</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>代码里面去取 OES 所使用的 format 和 type，如果 format 不是 GL_RGB 或者 type 不是 <code>GL_UNSIGNED_SHORT_5_6_5</code> 就强制设置为 <code>GL_RGBA</code> 和 <code>GL_UNSIGNED_BYTE</code> ，顺带可以看到把 surface 的颜色格式设置为 <code>GGL_PIXEL_FORMAT_RGBX_8888</code> 了（默认是 <code>GGL_PIXEL_FORMAT_RGB_565</code>）。</p>
<p>GL format <code>GL_RGB</code> 就是 RGB 3通道颜色格式， <code>GL_RGBA</code> 就是 RGBA 4通道颜色格式。而 type 就是存储格式， <code>GL_UNSIGNED_SHORT_5_6_5</code> 是打包的存储方式（GL 中这种 <code>5_6_5</code>, <code>4_4_4_4</code> 之类的都是打包的存储方式）。所谓打包的存储方式，就是把前面的 RGB 3通道数据打包到 16 位的无符号整数中。特别注意一点，GL 的打包数据的存储格式总是将颜色分量的高位打包到高位，和 host 的存储方式无关。就是说 <code>GL_UNSIGNED_SHORT_5_6_5</code> with <code>GL_RGB</code> 就是 R（16，11）—G（11，5）—B（5，0） 的存储顺序。但是不打包的存储格式（例如 <code>GL_UNSIGNED_BYTE</code>），就是和存储格式相关的。看看代码的转化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// surfaceflinger/BlurFliter.cpp 2.3 的 blur</span></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></div><div class="line"><span class="keyword">inline</span> uint32_t BLUR_RGBA_TO_HOST(uint32_t v) {</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">}</div><div class="line"><span class="keyword">inline</span> uint32_t BLUR_HOST_TO_RGBA(uint32_t v) {</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">}</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line"><span class="keyword">inline</span> uint32_t BLUR_RGBA_TO_HOST(uint32_t v) {</div><div class="line">    <span class="keyword">return</span> (v&lt;&lt;<span class="number">24</span>) | (v&gt;&gt;<span class="number">24</span>) | ((v&lt;&lt;<span class="number">8</span>)&<span class="number">0xff0000</span>) | ((v&gt;&gt;<span class="number">8</span>)&<span class="number">0xff00</span>);</div><div class="line">}</div><div class="line"><span class="keyword">inline</span> uint32_t BLUR_HOST_TO_RGBA(uint32_t v) {</div><div class="line">    <span class="keyword">return</span> (v&lt;&lt;<span class="number">24</span>) | (v&gt;&gt;<span class="number">24</span>) | ((v&lt;&lt;<span class="number">8</span>)&<span class="number">0xff0000</span>) | ((v&gt;&gt;<span class="number">8</span>)&<span class="number">0xff00</span>);</div><div class="line">}</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> BlurColor888X</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> uint32_t type;</div><div class="line">    <span class="keyword">int</span> r, g, b;</div><div class="line">    <span class="keyword">inline</span> BlurColor888X() { }</div><div class="line">    <span class="keyword">inline</span> BlurColor888X(uint32_t v) {</div><div class="line">        v = BLUR_RGBA_TO_HOST(v);</div><div class="line">        r = v & <span class="number">0xFF</span>;</div><div class="line">        g = (v &gt;&gt;  <span class="number">8</span>) & <span class="number">0xFF</span>;</div><div class="line">        b = (v &gt;&gt; <span class="number">16</span>) & <span class="number">0xFF</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> clear() { r=g=b=<span class="number">0</span>; }</div><div class="line">    <span class="keyword">inline</span> uint32_t to(<span class="keyword">int</span> shift, <span class="keyword">int</span> last, <span class="keyword">int</span> dither) <span class="keyword">const</span> {</div><div class="line">        <span class="keyword">int</span> R = r;</div><div class="line">        <span class="keyword">int</span> G = g;</div><div class="line">        <span class="keyword">int</span> B = b;</div><div class="line">        <span class="keyword">if</span>  (UNLIKELY(last)) {</div><div class="line">            <span class="keyword">if</span> (FACTOR&gt;<span class="number">0</span>) {</div><div class="line">                <span class="keyword">int</span> L = (R+G+G+B)&gt;&gt;<span class="number">2</span>;</div><div class="line">                R += ((L - R) * FACTOR) &gt;&gt; <span class="number">8</span>;</div><div class="line">                G += ((L - G) * FACTOR) &gt;&gt; <span class="number">8</span>;</div><div class="line">                B += ((L - B) * FACTOR) &gt;&gt; <span class="number">8</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        R &gt;&gt;= shift;</div><div class="line">        G &gt;&gt;= shift;</div><div class="line">        B &gt;&gt;= shift;</div><div class="line">        <span class="keyword">return</span> BLUR_HOST_TO_RGBA((<span class="number">0xFF</span>&lt;&lt;<span class="number">24</span>) | (B&lt;&lt;<span class="number">16</span>) | (G&lt;&lt;<span class="number">8</span>) | R);</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> BlurColor888X& <span class="keyword">operator</span> += (<span class="keyword">const</span> BlurColor888X& rhs) {</div><div class="line">        r += rhs.r;</div><div class="line">        g += rhs.g;</div><div class="line">        b += rhs.b;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> BlurColor888X& <span class="keyword">operator</span> -= (<span class="keyword">const</span> BlurColor888X& rhs) {</div><div class="line">        r -= rhs.r;</div><div class="line">        g -= rhs.g;</div><div class="line">        b -= rhs.b;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> BlurColor565</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> uint16_t type;</div><div class="line">    <span class="keyword">int</span> r, g, b;</div><div class="line">    <span class="keyword">inline</span> BlurColor565() { }</div><div class="line">    <span class="keyword">inline</span> BlurColor565(uint16_t v) {</div><div class="line">        r = v &gt;&gt; <span class="number">11</span>;</div><div class="line">        g = (v &gt;&gt; <span class="number">5</span>) & <span class="number">0x3E</span>;</div><div class="line">        b = v & <span class="number">0x1F</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> clear() { r=g=b=<span class="number">0</span>; }</div><div class="line">    <span class="keyword">inline</span> uint16_t to(<span class="keyword">int</span> shift, <span class="keyword">int</span> last, <span class="keyword">int</span> dither) <span class="keyword">const</span> {</div><div class="line">        <span class="keyword">int</span> R = r;</div><div class="line">        <span class="keyword">int</span> G = g;</div><div class="line">        <span class="keyword">int</span> B = b;</div><div class="line">        <span class="keyword">if</span>  (UNLIKELY(last)) {</div><div class="line">            <span class="keyword">if</span> (FACTOR&gt;<span class="number">0</span>) {</div><div class="line">                <span class="keyword">int</span> L = (R+G+B)&gt;&gt;<span class="number">1</span>;</div><div class="line">                R += (((L&gt;&gt;<span class="number">1</span>) - R) * FACTOR) &gt;&gt; <span class="number">8</span>;</div><div class="line">                G += (((L   ) - G) * FACTOR) &gt;&gt; <span class="number">8</span>;</div><div class="line">                B += (((L&gt;&gt;<span class="number">1</span>) - B) * FACTOR) &gt;&gt; <span class="number">8</span>;</div><div class="line">            }</div><div class="line">            R += (dither &lt;&lt; shift) &gt;&gt; BLUR_DITHER_BITS;</div><div class="line">            G += (dither &lt;&lt; shift) &gt;&gt; BLUR_DITHER_BITS;</div><div class="line">            B += (dither &lt;&lt; shift) &gt;&gt; BLUR_DITHER_BITS;</div><div class="line">        }</div><div class="line">        R &gt;&gt;= shift;</div><div class="line">        G &gt;&gt;= shift;</div><div class="line">        B &gt;&gt;= shift;</div><div class="line">        <span class="keyword">return</span> (R&lt;&lt;<span class="number">11</span>) | (G&lt;&lt;<span class="number">5</span>) | B;</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> BlurColor565& <span class="keyword">operator</span> += (<span class="keyword">const</span> BlurColor565& rhs) {</div><div class="line">        r += rhs.r;</div><div class="line">        g += rhs.g;</div><div class="line">        b += rhs.b;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> BlurColor565& <span class="keyword">operator</span> -= (<span class="keyword">const</span> BlurColor565& rhs) {</div><div class="line">        r -= rhs.r;</div><div class="line">        g -= rhs.g;</div><div class="line">        b -= rhs.b;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看的 android 只会转化 <code>GGL_PIXEL_FORMAT_RGBX_8888</code> 格式的， <code>GGL_PIXEL_FORMAT_RGB_565</code> 的不需要转化（因为前面说了 GL 打包的格式是固定是小端存储的）。</p>
<p>然后再看下 android surface 的颜色格式定义。surface 用的颜色格式定义在 pixelflinger 中。这个 pixelflinger 是 android 自带的 GL 软件实现，现在一般机器上的都不用这个了，但是颜色格式定义还是用这个的（代码在 system/core/libpixelflinger/）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// system/core/include/pixelflinger/format.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        ALPHA   = GGL_INDEX_ALPHA,</div><div class="line">        RED     = GGL_INDEX_RED,</div><div class="line">        GREEN   = GGL_INDEX_GREEN,</div><div class="line">        BLUE    = GGL_INDEX_BLUE,</div><div class="line">        STENCIL = GGL_INDEX_STENCIL,</div><div class="line">        DEPTH   = GGL_INDEX_DEPTH,</div><div class="line">        LUMA    = GGL_INDEX_Y,</div><div class="line">        CHROMAB = GGL_INDEX_CB,</div><div class="line">        CHROMAR = GGL_INDEX_CR,</div><div class="line">    };</div><div class="line">    <span class="keyword">inline</span> uint32_t mask(<span class="keyword">int</span> i) <span class="keyword">const</span> {</div><div class="line">            <span class="keyword">return</span> ((<span class="number">1</span>&lt;&lt;(c[i].h-c[i].l))-<span class="number">1</span>)&lt;&lt;c[i].l;</div><div class="line">    }</div><div class="line">    <span class="keyword">inline</span> uint32_t bits(<span class="keyword">int</span> i) <span class="keyword">const</span> {</div><div class="line">            <span class="keyword">return</span> c[i].h - c[i].l;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    uint8_t     size;   <span class="comment">// bytes per pixel</span></div><div class="line">    uint8_t     bitsPerPixel;</div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        <span class="keyword">struct</span> {</div><div class="line">            uint8_t     ah;     <span class="comment">// alpha high bit position + 1</span></div><div class="line">            uint8_t     al;     <span class="comment">// alpha low bit position</span></div><div class="line">            uint8_t     rh;     <span class="comment">// red high bit position + 1</span></div><div class="line">            uint8_t     rl;     <span class="comment">// red low bit position</span></div><div class="line">            uint8_t     gh;     <span class="comment">// green high bit position + 1</span></div><div class="line">            uint8_t     gl;     <span class="comment">// green low bit position</span></div><div class="line">            uint8_t     bh;     <span class="comment">// blue high bit position + 1</span></div><div class="line">            uint8_t     bl;     <span class="comment">// blue low bit position</span></div><div class="line">        };  </div><div class="line">        <span class="keyword">struct</span> {</div><div class="line">            uint8_t h;</div><div class="line">            uint8_t l;</div><div class="line">        } __attribute__((__packed__)) c[<span class="number">4</span>];    </div><div class="line">    } __attribute__((__packed__));</div><div class="line">    uint16_t    components; <span class="comment">// GGLFormatComponents</span></div><div class="line">} GGLFormat;</div><div class="line"></div><div class="line"><span class="comment">// system/core/libpixelflinger/format.cpp</span></div><div class="line"><span class="keyword">static</span> GGLFormat <span class="keyword">const</span> gPixelFormatInfos[] =</div><div class="line">{   <span class="comment">//          Alpha    Red     Green   Blue</span></div><div class="line">    <span class="comment">// 下面 markdwon 的渲染有点问题，里面的代码 )) 应该是 }} 的</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">4</span>, <span class="number">32</span>, {{<span class="number">32</span>,<span class="number">24</span>,   <span class="number">8</span>, <span class="number">0</span>,  <span class="number">16</span>, <span class="number">8</span>,  <span class="number">24</span>,<span class="number">16</span> )), GGL_RGBA },   <span class="comment">// PIXEL_FORMAT_RGBA_8888</span></div><div class="line">    {  <span class="number">4</span>, <span class="number">24</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span>,  <span class="number">16</span>, <span class="number">8</span>,  <span class="number">24</span>,<span class="number">16</span> )), GGL_RGB  },   <span class="comment">// PIXEL_FORMAT_RGBX_8888</span></div><div class="line">    {  <span class="number">3</span>, <span class="number">24</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span>,  <span class="number">16</span>, <span class="number">8</span>,  <span class="number">24</span>,<span class="number">16</span> )), GGL_RGB  },   <span class="comment">// PIXEL_FORMAT_RGB_888</span></div><div class="line">    {  <span class="number">2</span>, <span class="number">16</span>, {{ <span class="number">0</span>, <span class="number">0</span>,  <span class="number">16</span>,<span class="number">11</span>,  <span class="number">11</span>, <span class="number">5</span>,   <span class="number">5</span>, <span class="number">0</span> )), GGL_RGB  },   <span class="comment">// PIXEL_FORMAT_RGB_565</span></div><div class="line">    {  <span class="number">4</span>, <span class="number">32</span>, {{<span class="number">32</span>,<span class="number">24</span>,  <span class="number">24</span>,<span class="number">16</span>,  <span class="number">16</span>, <span class="number">8</span>,   <span class="number">8</span>, <span class="number">0</span> )), GGL_RGBA },   <span class="comment">// PIXEL_FORMAT_BGRA_8888</span></div><div class="line">    {  <span class="number">2</span>, <span class="number">16</span>, {{ <span class="number">1</span>, <span class="number">0</span>,  <span class="number">16</span>,<span class="number">11</span>,  <span class="number">11</span>, <span class="number">6</span>,   <span class="number">6</span>, <span class="number">1</span> )), GGL_RGBA },   <span class="comment">// PIXEL_FORMAT_RGBA_5551</span></div><div class="line">    {  <span class="number">2</span>, <span class="number">16</span>, {{ <span class="number">4</span>, <span class="number">0</span>,  <span class="number">16</span>,<span class="number">12</span>,  <span class="number">12</span>, <span class="number">8</span>,   <span class="number">8</span>, <span class="number">4</span> )), GGL_RGBA },   <span class="comment">// PIXEL_FORMAT_RGBA_4444</span></div><div class="line">    {  <span class="number">1</span>,  <span class="number">8</span>, {{ <span class="number">8</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )), GGL_ALPHA},   <span class="comment">// PIXEL_FORMAT_A8</span></div><div class="line">    {  <span class="number">1</span>,  <span class="number">8</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span> )), GGL_LUMINANCE},<span class="comment">//PIXEL_FORMAT_L8</span></div><div class="line">    {  <span class="number">2</span>, <span class="number">16</span>, {{<span class="number">16</span>, <span class="number">8</span>,   <span class="number">8</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">0</span> )), GGL_LUMINANCE_ALPHA},<span class="comment">// PIXEL_FORMAT_LA_88</span></div><div class="line">    {  <span class="number">1</span>,  <span class="number">8</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">8</span>, <span class="number">5</span>,   <span class="number">5</span>, <span class="number">2</span>,   <span class="number">2</span>, <span class="number">0</span> )), GGL_RGB  },   <span class="comment">// PIXEL_FORMAT_RGB_332</span></div><div class="line">        </div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line"></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">            </div><div class="line">    {  <span class="number">2</span>, <span class="number">16</span>, {{  <span class="number">0</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )), GGL_DEPTH_COMPONENT},</div><div class="line">    {  <span class="number">1</span>,  <span class="number">8</span>, {{  <span class="number">8</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )), GGL_STENCIL_INDEX  },</div><div class="line">    {  <span class="number">4</span>, <span class="number">24</span>, {{  <span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )), GGL_DEPTH_COMPONENT},</div><div class="line">    {  <span class="number">4</span>,  <span class="number">8</span>, {{ <span class="number">32</span>,<span class="number">24</span>,  <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )), GGL_STENCIL_INDEX  },</div><div class="line"></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line"></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">    {  <span class="number">0</span>,  <span class="number">0</span>, {{ <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span> )),        <span class="number">0</span> },   <span class="comment">// PIXEL_FORMAT_NONE</span></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>从上面的定义可以看得到 <code>GGL_PIXEL_FORMAT_RGBX_8888</code> 是 ABGR 的小端存储格式，所以上面如果 host 是小端格式，就不用转化，是大端的话就需要转化一下。这里的 RGBA 定义感觉挺奇怪的，和 java 层的 Bitmap ARGB 的定义顺序不一样，不知道为什么要这么定义。</p>
<p><code>GGL_PIXEL_FORMAT_RGB_565</code> 正好和 <code>GL_UNSIGNED_SHORT_5_6_5</code> with <code>GL_RGB</code> 存储顺序是一样的，所以 <code>5_6_5</code> 的颜色格式也不需要转化。</p>
<p>颜色格式搞清楚了，软件算法用现成的就好啦。android 2.3 的 blur 效果不算很好，但是速度很快，网上有很多软件的 blur 算法，效果比 2.3 的好，但是速度慢不少。高斯模糊好像就是对这些像素点搞个啥加权求均值，具体的以后再研究了，这次只是把颜色格式搞清楚。</p>
<p>哎，这样吐槽下，以前移植、改的 blur 软件算法的 32位格式 <code>RGBX_8888</code> 格式是错的，只不过一般机器上的 OES 都是 565 的，所以没暴露出来而已，呵呵，以后有空在改吧。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/Android%20%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-28T11:46:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 开机启动画面分析</title>
        <pubTime>2015-01-28T11:46:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 开机启动画面一共有3种：</p>
<h2 id="framebuffer_logo">framebuffer logo</h2>
<p>在 linux kernel framebuffer 驱动中的 logo（代码在 kernel/drivers/video/fbmem.c）。是一个 ppm 文件。可以通过工具制作（下面这些工具在 ubuntu 上自己安装相应的工具就可以）：</p>
<ol>
<li>pngtopnm logo.png &gt; logo_linux.pnm</li>
<li>pnmquant 224 logo_linux.pnm &gt; logo_linux_clut224.pnm</li>
<li>pnmtoplainpnm logo_linux_clut224.pnm &gt; logo_linux_clut224.ppm</li>
<li>替换 kernel/drivers/video/logo 下的文件即可。</li>
</ol>
<p>这是最早的静态启动画面。一般产品发布的时候会把这个 logo 去掉的，一般是一个小企鹅，比较丑的说。这里不做过多分析。</p>
<h2 id="init_启动画面">init 启动画面</h2>
<p>开机的 init (代码在 system/core/init 下面)进程的启动 logo，是一张静态图片（init 的分析可以参考《深入理解 Android 卷I》的第3章）。在其中一个 action 中会调用 load 去加载 565 rle 格式的一张图片，然后写入 framebuffer 中显示出来：</p>
<p>init.c:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> console_init_action(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (console[<span class="number">0</span>]) {</div><div class="line">        <span class="built_in">snprintf</span>(console_name, <span class="keyword">sizeof</span>(console_name), <span class="string">"/dev/%s"</span>, console);</div><div class="line">    }</div><div class="line"></div><div class="line">    fd = open(console_name, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</div><div class="line">        have_console = <span class="number">1</span>;     </div><div class="line">    close(fd);</div><div class="line">    </div><div class="line">    <span class="comment">// 加载 565 rle 图片并且显示</span></div><div class="line">    <span class="comment">// INIT_IMAGE_FILE 定义是 /initlogo.rle，最终打包在 ramdisk.img 里面的</span></div><div class="line">    <span class="comment">// 一般 OEM 定制可以把自己制作好的 rle 放到 devices 下面</span></div><div class="line">    <span class="keyword">if</span>( load_565rle_image(INIT_IMAGE_FILE) ) {</div><div class="line">        <span class="comment">// 如果没有图片或是加载失败，者直接往 fb 中写入 ANDROID 这几个字符</span></div><div class="line">        fd = open(<span class="string">"/dev/tty0"</span>, O_WRONLY); </div><div class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *msg;  </div><div class="line">                msg = <span class="string">"\n"</span>    </div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span>              </div><div class="line">            <span class="string">"\n"</span>  <span class="comment">// console is 40 cols x 30 lines</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"\n"</span></div><div class="line">            <span class="string">"             A N D R O I D "</span>; </div><div class="line">            write(fd, msg, <span class="built_in">strlen</span>(msg));   </div><div class="line">            close(fd);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>logo.c:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> load_565rle_image(<span class="keyword">char</span> *fn)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> FB fb;</div><div class="line">    <span class="keyword">struct</span> stat s;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *data, *bits, *ptr;</div><div class="line">    <span class="keyword">unsigned</span> count, max;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vt_set_mode(<span class="number">1</span>)) </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line"></div><div class="line">    <span class="comment">// 打开 rle 文件</span></div><div class="line">    fd = open(fn, O_RDONLY);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</div><div class="line">        ERROR(<span class="string">"cannot open '%s'\n"</span>, fn);</div><div class="line">        <span class="keyword">goto</span> fail_restore_text;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fstat(fd, &s) &lt; <span class="number">0</span>) {</div><div class="line">        <span class="keyword">goto</span> fail_close_file;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 将 rle 文件读入内存</span></div><div class="line">    data = mmap(<span class="number">0</span>, s.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>); </div><div class="line">    <span class="keyword">if</span> (data == MAP_FAILED)</div><div class="line">        <span class="keyword">goto</span> fail_close_file;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 fb，并 mmap 映射到程序内存（这个函数的实现在 logo.c 里面）</span></div><div class="line">    <span class="keyword">if</span> (fb_open(&fb))</div><div class="line">        <span class="keyword">goto</span> fail_unmap_data;</div><div class="line"></div><div class="line">    max = fb_width(&fb) * fb_height(&fb);</div><div class="line">    ptr = data;</div><div class="line">    count = s.st_size;</div><div class="line">    bits = fb.bits;</div><div class="line">    <span class="comment">// 把 rle 数据写入 fb，这个写法要参看 rle 的格式</span></div><div class="line">    <span class="keyword">while</span> (count &gt; <span class="number">3</span>) {</div><div class="line">        <span class="keyword">unsigned</span> n = ptr[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span> (n &gt; max)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        android_memset16(bits, ptr[<span class="number">1</span>], n &lt;&lt; <span class="number">1</span>); </div><div class="line">        bits += n;</div><div class="line">        max -= n;</div><div class="line">        ptr += <span class="number">2</span>;</div><div class="line">        count -= <span class="number">4</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    munmap(data, s.st_size);</div><div class="line">    fb_update(&fb);</div><div class="line">    fb_close(&fb);</div><div class="line">    close(fd);</div><div class="line">    unlink(fn);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">fail_unmap_data:</div><div class="line">    munmap(data, s.st_size);</div><div class="line">fail_close_file:</div><div class="line">    close(fd);</div><div class="line">fail_restore_text:</div><div class="line">    vt_set_mode(<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>load_565rle_image</code> 函数的输入参数是一个 rle 文件，该函数会把这个文件内容转换为rgb565，写入 framebuffer。以下百度百科来的 rle 简介 <a href="http://baike.baidu.com/view/18819.htm?fromTaglist" title="rle简介" target="_blank" rel="external">rle简介</a> ：</p>
<p>RLE全称（run-length encoding），翻译为游程编码，又译行程长度编码，又称变动长度编码法（run coding），在控制论中对于二值图像而言是一种编码方法，对连续的黑、白像素数(游程)以不同的码字进行编码。游程编码是一种简单的非破坏性资料压缩法，其好处是加压缩和解压缩都非常快。其方法是计算连续出现的资料长度压缩之。</p>
<p>RLE 文件格式为 [count(2 bytes), color(2 bytes)], count最大为 65535； color 为 RGB565, 当然也可以是 YUV422 ，我觉得只要是 2bytes 以下的都可以，但是由于最终我们写入到 framebuffer 中的都是 RGB565，从效率的角度，rle 文件的 color 值为RGB565最好。</p>
<p><code>load_565rel_image</code> 源码第141行：写入n个像素点，像素点的 color 值是 rle 中的原始数据，这对于 rgb565 的 framebuffer 没有问题，但是如果 framebuffer 是RGB32（ARGB），就无法工作了。解决办法是做个转换，把 2bytes 的 RGB565 转换为 4bytes 的 ARGB 即可:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> rgb32_r(rle) (((rle & 0xf800) &gt;&gt; 11) &lt;&lt; 3)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> rgb32_g(rle) (((rle & 0x07e0) &gt;&gt; 5 &lt;&lt; 2))</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> rgb32_b(rle) (((rle & 0x001f) &lt;&lt; 3))</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> rgb32(rle) (rgb32_r(rle) &lt;&lt; 16 | rgb32_g(rle) &lt;&lt; 8 | rgb32_b(rle) &lt;&lt; 0) </span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *bits;</div><div class="line">        bits = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)fb.bits;</div><div class="line">        <span class="keyword">while</span> (count &gt; <span class="number">3</span>) {</div><div class="line">            <span class="keyword">unsigned</span> n = ptr[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (n &gt; max)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            out = rgb32(ptr[<span class="number">1</span>]);</div><div class="line">            android_memset32(bits, out, n &lt;&lt; <span class="number">2</span>);</div><div class="line">            bits += n;</div><div class="line">            max -= n;</div><div class="line">            ptr += <span class="number">2</span>;</div><div class="line">            count -= <span class="number">4</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>现在再回去，看看怎么得到 rle 格式的文件，一般来说分两步走，先把原始图片转为RGB565，然后再把 RGB565 转为 rle（当然不是必需的，如果有个能把 png 直接转为 rle 的工具）。</p>
<ol>
<li>先用 GMIP 生成一个 800X480 的 png 文件，为什么是 800x480，图片大小必须和屏大小一致，至于是不是 png 无所谓，只要有工具能转为 RGB565 即可</li>
<li>convert 命令 png 为 RGB565: <code>convert -depth 8 android_logo.png rgb:android_logo.raw</code></li>
<li>转换 RGB565 为 rle 文件（这个工具是源码编译出来的，在 out/host/linux-x86/bin 下面）：<code>rgb2565 -rle &lt; android_logo.raw &gt; initlogo.rle</code> </li>
<li>替换 ramdisk 中的 initlogo.rle，重新启动即可看到新的启动画面（这个是标准的，不同的平台这个东西在的地方可能不一样）。</li>
</ol>
<p>注意 <code>load_565rle_image</code> 152行 unlink(fn) 会删除 initlogo.rle 文件，进入系统后，会发现 /initlogo.rle 文件已经被删除了，这样可以节约一点 ramdisk 文件系统的内存空间，对于 ramdisk 做 rootfs，这没有问题，因为 ramdisk 镜像本身并没有被修改。但是如果根文件系统是其他文件系统，就需要把 unlink(fn) 注释掉，以防止 initlog.rle 被永久删除。</p>
<p>其实 rle 在一段是我抄别人的： <a href="http://blog.csdn.net/kickxxx/article/details/7548670" title="参考" target="_blank" rel="external">参考</a></p>
<h2 id="bootanimtion">bootanimtion</h2>
<p>bootanimtion 是 system/bin 下的一个本地程序（代码在 framework/base/cmds/bootanimation 下面），在 inin.rc 中会有以下的定义：</p>
<pre config="brush:bash;toolbar:false;">
service bootanim /system/bin/bootanimation
    user graphics
    group graphics
    disabled
    oneshot
</pre>

<p>会在 surfaceflinger 刚启动的时候启动（surfaceflinger 中的 startBootAnim 通过 property_set(“ctl.start”, “bootanim”) 通过 property 服务启动 bootanimation， 在 init.rc 中定义的 service）。 这个程序会一直循环的贴图（这里的动画就是通过不停的贴图来实现的），然后每个循环检测一个 property 值，如果这个值被设置了，就会退出循环。这个值由 surfaceflinger 写入， surfaceflinger 初始化好之后， framework 显示可以正工作了，就让 bootanimation 退出了（bootFinished 中 写入这个值）。当然上层在这里有超时设置的，如果在一段时间这个 property 值没有被设置的话， bootanimation 也会被强制终止掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BootAnimation::checkExit() {</div><div class="line">    <span class="comment">// Allow surface flinger to gracefully request shutdown</span></div><div class="line">    <span class="keyword">if</span>(mShutdown)<span class="comment">//shutdown animation</span></div><div class="line">        {   </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</div><div class="line">    property_get(EXIT_PROP_NAME, value, <span class="string">"0"</span>);</div><div class="line">    <span class="keyword">int</span> exitnow = atoi(value);</div><div class="line">    <span class="keyword">if</span> (exitnow) {</div><div class="line">        requestExit();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面配置可以看得到 bootanimation 被配置到了 graphics 组，这个组可以绘制图像，但是没有写 property 的权限（可以自己去看提供 property 的服务代码），不过有读的权限。所以 bootanimation 是不能靠写入 property 来和上层的 services 进行通信的（我之前曾经想这么做 -_-||）。</p>
<p>bootanimation 是通过 GL 来进行绘制的（简单、粗暴、有效哈），通过 OES 扩展能比较轻松的进行 2D 贴图。 bootaniamtion 会去找 /system/media/bootanimation.zip 这个动画包，如果没有的话，就会显示 android 一排闪亮的字（用 native 的 AssetManager 去加载 framework/base/core/res/assets/image 下面的 android-logo-mask.png 和 android-logo-shine.png 这2张图片的），如果有的会则会解析这个 zip 包。然后读取里面 desc.txt 这个配置文件，设置一些动画属性，然后循环绑定纹理开始贴图。</p>
<p>动画分为2个部分：配置文件（固定为  desc.txt）、资源图片（仅支持 png 格式）。 desc.txt 和 ini 文件类似，一行、一行解析的，分为2种格式：</p>
<p>xx xx xx： 3个参数的，前2个是图像的宽、高，后面一个动画的 fps。例如：768 324 10，表示图像是 768x324，动画以 10fps 播放。这种一般就写一行就行了，写多了后面的会覆盖前面的配置的。如果这个分辨率比屏幕分辨率低的话，就会居中显示。这个分辨率最好和图片一样，否则会缩放的（GL 的纹理贴图，默认代码 GL 纹理选项没开最好的过滤方式，所以最好不要缩放）。</p>
<p>xx xx xx xx： 4个参数的，是用来描述动画组成部分的（part），android 的开机动画 part 分为2种类型，一种是循环有限次数播放的，播放完指定次数这个 part 就结束了，进入到下一个 part；一种是无限循环播放的，直到开机初始化完成，bootanimation 进程结束（一般就2个 part，第一个不循环的，第二个循环的，应该可以写多与3个的 part，但是一般都不这么做）。第一个参数表示 part 是否必需要等到播放完成才能结束（就是说这个 part 能不能被中断，例如说开机初始化很快，动画还没播放就初始化好了，这个时候 bootanimation 进程会接收到上层 framework 请求终止的消息）， 填 ‘c’ 表示必需要等到这个 part 不能被终止（就是要必需被播放完，不能被提前终止）。填其它的表示可以被提前终止（一般填写 ‘p’）。第二参数表示这个 part 的循环次数。如果填 0 就表示是无限循环的，大于 0 就是循环次数。注意一下，不要第一个参数填 ‘c’，这个参数填 0，这样填写开机动画就真*无限循环了。第三个参数表示循环之间的等待时间（单位是以 fps 帧数来算的，例如10就是表示等待10帧），就是播放一次循环后，等多长时间开始下一次循环。第四个参数表示这个 part 使用的图片资源的路径。在 zip 包中不同的 part 要建立不同的文件夹（例如 part1/, part2/），图片以 frame 动画的编号命名放好，例如 f0000、f0001、f0002。例如：</p>
<pre config="brush:bash;toolbar:false;">
p 1 0 part1
p 0 10 part2
</pre>

<p>表示开机动画有 2个 part， 2个part 都可以被提前终止，第一个 part 循环一次（只播放一次），由于只播放一次所以循环等待时间填0，图片路径为 part1；第二个 part 无限循环，每个 part 之间等待时间为 10，图片路径为 part2 。</p>
<p>这个命名上面要注意一下，代码里面使用了一个以名字来排序的 Vector 来存储动画帧图片。所以名字可以是 <code>xx_0001</code>, <code>xx_0002</code>， 也可以是 x0001, x0002，只要是名字的字符能够正确的排序就行了，不要作死的搞一些奇怪的名字就行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Animation {</div><div class="line">    <span class="keyword">struct</span> Frame {</div><div class="line">        String8 name;</div><div class="line">        FileMap* <span class="built_in">map</span>;   </div><div class="line">        <span class="keyword">mutable</span> GLuint tid;</div><div class="line">        <span class="comment">// 以名字来排序</span></div><div class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Frame& rhs) <span class="keyword">const</span> {</div><div class="line">            <span class="keyword">return</span> name &lt; rhs.name;</div><div class="line">        }</div><div class="line">    };</div><div class="line">    <span class="keyword">struct</span> Part {</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="keyword">int</span> pause;</div><div class="line">        String8 path;</div><div class="line">        <span class="comment">// 排序的 vector </span></div><div class="line">        SortedVector&lt;Frame&gt; frames;</div><div class="line">        <span class="keyword">bool</span> playUntilComplete;</div><div class="line">    };</div><div class="line">    <span class="keyword">int</span> fps;</div><div class="line">    <span class="keyword">int</span> width;</div><div class="line">    <span class="keyword">int</span> height;</div><div class="line">    Vector&lt;Part&gt; parts;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>当然，可以自己弄一些其他格式的，例如说只有一个参数的，代表背景颜色。这个主要是我弄的一个芯片 GPU 性能不行， 但是产品偏要用非黑色背景的 bootanimation，要用非黑色背景的只能把图片做成全屏的，但是 GPU 不行，绑纹理速度太慢了，贴全屏的图片卡得和幻灯片一样。所以我就多搞了一个配置，用来指定背景颜色（默认 GL clear color 是黑色的）。这里 GL 调用是很原始的，要自己手动调用 eglSwapBuffers(mDisplay, mSurface); 才会刷新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (;;) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* endl = <span class="built_in">strstr</span>(s, <span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">if</span> (!endl) <span class="keyword">break</span>;</div><div class="line">    String8 line(s, endl - s);     </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* l = line.<span class="built_in">string</span>(); </div><div class="line">    <span class="keyword">int</span> fps, width, height, count, pause;</div><div class="line">    <span class="keyword">char</span> path[<span class="number">256</span>];       </div><div class="line">    <span class="keyword">char</span> pathType;</div><div class="line">    <span class="comment">// 3个参数的</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(l, <span class="string">"%d %d %d"</span>, &width, &height, &fps) == <span class="number">3</span>) { </div><div class="line">        <span class="comment">//ALOGD("&gt; w=%d, h=%d, fps=%d", width, height, fps);</span></div><div class="line">        <span class="keyword">if</span> (mReverseAxis) {            </div><div class="line">            animation.width = height;      </div><div class="line">            animation.height = width;      </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            animation.width = width;       </div><div class="line">            animation.height = height;     </div><div class="line">        }</div><div class="line">        animation.fps = fps;           </div><div class="line">    }</div><div class="line">    <span class="comment">// 4个参数的</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sscanf</span>(l, <span class="string">" %c %d %d %s"</span>, &pathType, &count, &pause, path) == <span class="number">4</span>) {</div><div class="line">        <span class="comment">//ALOGD("&gt; type=%c, count=%d, pause=%d, path=%s", pathType, count, pause, path);</span></div><div class="line">        Animation::Part part;          </div><div class="line">        part.playUntilComplete = pathType == <span class="string">'c'</span>;</div><div class="line">        part.count = count;            </div><div class="line">        part.pause = pause;            </div><div class="line">        part.path = path;</div><div class="line">        animation.parts.add(part);     </div><div class="line">    }</div><div class="line">    <span class="comment">// 我自己加得一个参数的，指定背景颜色的</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sscanf</span>(l, <span class="string">"%d"</span>, &bkColor) == <span class="number">1</span>) {</div><div class="line">        <span class="comment">// add by hmm@dw.gdbb.com      </span></div><div class="line">        <span class="comment">// for support specific bootanimtion background color.</span></div><div class="line">        <span class="comment">// due our GPU is pool, it's can't use full screen(1280x800 or 1920x1080) bitmap as</span></div><div class="line">        <span class="comment">// bootanimtion frame, so we can set background color to reduce the bitmap size.</span></div><div class="line">        <span class="comment">// the background is 10 hex base on RGB(e.g: 0x028cd6 ==&gt; 167162).</span></div><div class="line">        bkR = (<span class="keyword">float</span>)((bkColor & <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>) / <span class="number">255.0f</span>; </div><div class="line">        bkG = (<span class="keyword">float</span>)((bkColor & <span class="number">0x0000ff00</span>) &gt;&gt;  <span class="number">8</span>) / <span class="number">255.0f</span>; </div><div class="line">        bkB = (<span class="keyword">float</span>)(bkColor & <span class="number">0x000000ff</span>)         / <span class="number">255.0f</span>;</div><div class="line">        ALOGD(<span class="string">"read bkColor=0x%x, r=%f, g=%f, b=%f"</span>, bkColor, bkR, bkG, bkB);</div><div class="line">    }</div><div class="line"></div><div class="line">    s = ++endl;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>特别注意一点，关于 bootanimation .zip 这个包打 zip 包的时候，里面的资源文件只能选择 store 模式（即存储模式），因为在代码里面， bootanimation 里面只认 zip 的 store 模式的文件（即不支持压缩）。打包的时候不要选择压缩文件，否则开机动画播不出来的。用 zip -r -0 bootanimation.zip part0/ part1/ desc.txt 就可以指定以存储方式打包，不压缩。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// read all the data structures</span></div><div class="line"><span class="keyword">const</span> size_t pcount = animation.parts.size();</div><div class="line"><span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;numEntries ; i++) {</div><div class="line">    <span class="keyword">char</span> name[<span class="number">256</span>];</div><div class="line">    ZipEntryRO entry = zip.findEntryByIndex(i);</div><div class="line">    <span class="keyword">if</span> (zip.getEntryFileName(entry, name, <span class="number">256</span>) == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">const</span> String8 entryName(name);</div><div class="line">        <span class="keyword">const</span> String8 path(entryName.getPathDir());</div><div class="line">        <span class="keyword">const</span> String8 leaf(entryName.getPathLeaf());</div><div class="line">        <span class="keyword">if</span> (leaf.size() &gt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;pcount ; j++) {</div><div class="line">                <span class="keyword">if</span> (path == animation.parts[j].path) {</div><div class="line">                    <span class="keyword">int</span> method;</div><div class="line">                    <span class="comment">// 只支持存储格式的 png 文件</span></div><div class="line">                    <span class="comment">// supports only stored png files</span></div><div class="line">                    <span class="keyword">if</span> (zip.getEntryInfo(entry, &method, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) {</div><div class="line">                        <span class="keyword">if</span> (method == ZipFileRO::kCompressStored) {</div><div class="line">                            FileMap* <span class="built_in">map</span> = zip.createEntryFileMap(entry);</div><div class="line">                            <span class="keyword">if</span> (<span class="built_in">map</span>) {</div><div class="line">                                Animation::Frame frame;</div><div class="line">                                frame.name = leaf;</div><div class="line">                                frame.<span class="built_in">map</span> = <span class="built_in">map</span>;</div><div class="line">                                Animation::Part& part(animation.parts.editItemAt(j));</div><div class="line">                                part.frames.add(frame);</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>rk 的修改的 bootanimation 支持的开机音效 ogg 文件固定为/system/media/audio/boot.ogg ，打包 system 的时候放自己的 boot.ogg 到这个路径下面就有开机音效了，不放就没有（放的方法参照定制系统音效那里）。</p>
<p>制作好了 bootanimation.zip  在打包 system 的时候 copy 到system/media 下面。修改 device/rockchip/Hx/Hx.mk 添加<br>PRODUCT_COPY_FILES += \<br>    $(LOCAL_PATH)/bootanimation.zip:system/media/bootanimation.zip</p>
<p>当然上面这些框框条条可以自行修改 bootaniamtion 这个模块，增加新的参数，实现新的功能（以前君正的开机音效就是增加了一个参数，把音效 ogg 文件一起打包进 bootanimation.zip 里面去了）。</p>
<p>这里贴一下 rk 播音效的代码，可以参考一下， native 层调用 MediaPlayer 播放音频文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BootAnimation::playMusic()</div><div class="line">{</div><div class="line">    <span class="keyword">char</span> property[PROPERTY_VALUE_MAX];</div><div class="line">    <span class="keyword">bool</span> enable = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> ( property_get( BOOT_MUSIC_PROPERTY, property, <span class="string">"true"</span> ) &gt; <span class="number">0</span> ){</div><div class="line">        enable = !<span class="built_in">strcmp</span>(property, <span class="string">"true"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGD( <span class="string">"BootAnimation::playMusic...enable:%s"</span>, enable ? <span class="string">"true"</span> : <span class="string">"false"</span> );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( enable ){</div><div class="line">        sp&lt;MediaPlayer&gt; mp = <span class="keyword">new</span> MediaPlayer();</div><div class="line">        <span class="comment">// 这里好像是检测能否正常访问音频文件</span></div><div class="line">        <span class="keyword">if</span> ((<span class="number">0</span> == access(BOOTMUSIC_FILE, F_OK)) && mp != NULL) {</div><div class="line">            mp-&gt;setDataSource(BOOTMUSIC_FILE, NULL);</div><div class="line">            mp-&gt;prepare();</div><div class="line">            mp-&gt;start();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/vold%20share%20%E6%93%8D%E4%BD%9C%E6%B8%85%E7%90%86%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%A3%81%E7%9B%98%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-28T11:42:16.000Z</lastmod>
    <data>
        <display>
        <title>vold share 操作清理正在使用磁盘的进程分析</title>
        <pubTime>2015-01-28T11:42:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>vold 是 android system/bin 下的一个本地程序（代码在 system/vold 下）。用于处理 framework 中各种和 mount、unmount 相关的命令。 vold 的框架结构分析，推荐去看一本叫《深入理解 Android 卷I》的第九章，很详细。不过这本书在最后留了个问题，就是当把磁盘挂在到 PC 上（这个就是 vold 的 share 操作）的时候会导致一些进程被杀掉。正好UP主的这段时间的工作也和这个有关，这里在主要是解答下这个小问题。不过首先废话下 android 的2种 usb 模式：</p>
<h2 id="2种_usb_模式">2种 usb 模式</h2>
<p>首先说下 android 上目前支持的2种 usb 连接模式：</p>
<ul>
<li><p><strong>UMS(USB Mass Storage)</strong><br>这种模式下，会将 android 的磁盘从系统中 umount 出去，然后 mount 到 PC 上，就和 PC 上插上U盘类似。使用这种模式，由于需要把 umount 磁盘，所以在使用过程中，android 系统无法使用磁盘。 vold 就是这种模式下用的。</p>
</li>
<li><p><strong>MTP(Media Transfer Protocol)</strong><br>媒体传输协议（具体的百度、google 去吧）。和 UMS 最大的不同，就是不需要 umount 磁盘，插上 PC 后，就和插入数码相机类似，可以查看、copy 多媒体文件到磁盘中。所以这种模式下，android 系统是能够继续使用磁盘的。但是也存在缺点：只能管理多媒体文件，文件IO 速度和稳定性比 UMS 稍差。原生 android 从 4.0 之后默认使用这种模式。</p>
</li>
</ul>
<h2 id="访问磁盘的进程检测">访问磁盘的进程检测</h2>
<p>在 UMS 下，连接 usb ， 打开 SystemUI 的 UsbStorageActivity，点击 mount 按钮，会在 checkStorageUsersAsync() 会调用 MountService 的 getStorageUsers() 去检测有哪些进程还在访问磁盘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStorageUsersAsync</span>() {</div><div class="line">    IMountService ims = getMountService();</div><div class="line">    <span class="keyword">if</span> (ims == <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// Display error dialog</span></div><div class="line">        scheduleShowDialog(DLG_ERROR_SHARING);</div><div class="line">    }   </div><div class="line">    <span class="comment">// 这个路径就是让 vold 去对比的 sdcard 的 mount 路径</span></div><div class="line">    String extStoragePath = Environment.getExternalStorageDirectory().toString();</div><div class="line">    <span class="keyword">boolean</span> showDialog = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">int</span>[] stUsers = ims.getStorageUsers(extStoragePath);</div><div class="line">        <span class="keyword">if</span> (stUsers != <span class="keyword">null</span> && stUsers.length &gt; <span class="number">0</span>) {</div><div class="line">            showDialog = <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// List of applications on sdcard.</span></div><div class="line">            ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">            List&lt;ApplicationInfo&gt; infoList = am.getRunningExternalApplications();</div><div class="line">            <span class="keyword">if</span> (infoList != <span class="keyword">null</span> && infoList.size() &gt; <span class="number">0</span>) {</div><div class="line">                showDialog = <span class="keyword">true</span>;</div><div class="line">            }   </div><div class="line">        }   </div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        <span class="comment">// Display error dialog</span></div><div class="line">        scheduleShowDialog(DLG_ERROR_SHARING);</div><div class="line">    }   </div><div class="line">    <span class="keyword">if</span> (showDialog) {</div><div class="line">        <span class="comment">// Display dialog to user</span></div><div class="line">        scheduleShowDialog(DLG_CONFIRM_KILL_STORAGE_USERS);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.i(TAG, <span class="string">"Enabling UMS"</span>);</div><div class="line">        switchUsbMassStorage(<span class="keyword">true</span>);</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>MountService 里面的 getStorageUsers() 会调用 NativeDaemonConnector 的 executeForList() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">getStorageUsers</span>(String path) {</div><div class="line">    validatePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);</div><div class="line">    waitForReady();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">final</span> String[] r = NativeDaemonEvent.filterMessageList(</div><div class="line">                mConnector.executeForList(<span class="string">"storage"</span>, <span class="string">"users"</span>, path),</div><div class="line">                VoldResponseCode.StorageUsersListResult);</div><div class="line"></div><div class="line">        <span class="comment">// FMT: &lt;pid&gt; &lt;process name&gt;</span></div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[r.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) {</div><div class="line">            String[] tok = r[i].split(<span class="string">" "</span>);</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                data[i] = Integer.parseInt(tok[<span class="number">0</span>]);</div><div class="line">            } <span class="keyword">catch</span> (NumberFormatException nfe) {</div><div class="line">                Slog.e(TAG, String.format(<span class="string">"Error parsing pid %s"</span>, tok[<span class="number">0</span>]));</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">            }    </div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    } <span class="keyword">catch</span> (NativeDaemonConnectorException e) { </div><div class="line">        Slog.e(TAG, <span class="string">"Failed to retrieve storage users list"</span>, e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>NativeDaemonConnector 是 MountService 用来和 Vold 通讯用的。java 层通过 Unix socket 和 native vold 进行通讯（遵守 android 自己定义的通讯协议，暂时不清楚为声明不用 binder）。exectueForList() 最后调用自己内部的 exectue() 把一个 “storage” 命令 + 检测路径（path）打包转化为协议数据包二进制流，然后通过写到 socket 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> NativeDaemonEvent[] <span class="title">execute</span>(<span class="keyword">int</span> timeout, String cmd, Object... args)</div><div class="line">        <span class="keyword">throws</span> NativeDaemonConnectorException {</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ArrayList&lt;NativeDaemonEvent&gt; events = Lists.newArrayList();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> StringBuilder rawBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">final</span> StringBuilder logBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sequenceNumber = mSequenceNumber.incrementAndGet();</div><div class="line">    </div><div class="line">    <span class="comment">// 命令+路径 打包</span></div><div class="line">    makeCommand(rawBuilder, logBuilder, sequenceNumber, cmd, args);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String rawCmd = rawBuilder.toString();</div><div class="line">    <span class="keyword">final</span> String logCmd = logBuilder.toString();</div><div class="line"></div><div class="line">    log(<span class="string">"SND -&gt; {"</span> + logCmd + <span class="string">"}"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mDaemonLock) {</div><div class="line">        <span class="keyword">if</span> (mOutputStream == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NativeDaemonConnectorException(<span class="string">"missing output stream"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 协议数据包二进制流写入 stokect   </span></div><div class="line">            mOutputStream.write(rawCmd.getBytes(StandardCharsets.UTF_8));</div><div class="line">            } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NativeDaemonConnectorException(<span class="string">"problem sending command"</span>, e); </div><div class="line">            }   </div><div class="line">        }   </div><div class="line">    }   </div><div class="line">    NativeDaemonEvent event = <span class="keyword">null</span>;</div><div class="line">    do {</div><div class="line">        event = mResponseQueue.remove(sequenceNumber, timeout, logCmd);</div><div class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) {</div><div class="line">            loge(<span class="string">"timed-out waiting for response to "</span> + logCmd);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NativeDaemonFailureException(logCmd, event);</div><div class="line">        }   </div><div class="line">        log(<span class="string">"RMV &lt;- {"</span> + event + <span class="string">"}"</span>);</div><div class="line">        events.add(event);</div><div class="line">    } <span class="keyword">while</span> (event.isClassContinue());</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> endTime = SystemClock.elapsedRealtime();</div><div class="line">    <span class="keyword">if</span> (endTime - startTime &gt; WARN_EXECUTE_DELAY_MS) {</div><div class="line">        loge(<span class="string">"NDC Command {"</span> + logCmd + <span class="string">"} took too long ("</span> + (endTime - startTime) + <span class="string">"ms)"</span>);</div><div class="line">    }   </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (event.isClassClientError()) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NativeDaemonArgumentException(logCmd, event);</div><div class="line">    }   </div><div class="line">    <span class="keyword">if</span> (event.isClassServerError()) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NativeDaemonFailureException(logCmd, event);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> events.toArray(<span class="keyword">new</span> NativeDaemonEvent[events.size()]);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在 vold 这边， CommandListener 有一个对应 “storage” 命令的处理实现 StorageCmd 。这个实现会用 Process 的 checkFileDescriptorSymLinks() 去检测是否用进程在访问磁盘。检测的方法是：去 /proc/xx/ 下（xx 是进程号 pid，每个打开了 fd 的进程会在系统的 /proc 下有记录的）检测3种东西：</p>
<ul>
<li><p><strong>checkFileDescriptorSymLinks</strong><br>这个是检测进程打开的 fd 的链接路径（Process 通过 linux 系统函数 readlink 去获取一个 fd 的真实文件物理路径，例如 /proc/2100/40 可能的真实 link 是 /mnt/sdcard/text.txt）是否和传入的 mountPoint 一致（一般这就是 sdcard 的挂载点路径，由 java 层传入。不过偶尔也会有坑，例如某些 rom sdcard 挂载点，为了兼容性，弄了一个文件链接给应用用，导致应用打开的 fd 路径和 mount 的时候检测的路径字符串不一样，注意是字符串不一样，导致检测不到进程在访问 sdcard），如果一致就表示该进程正在访问磁盘。</p>
</li>
<li><p><strong>checkFileMaps</strong><br>这个是检测 /proc/xx/maps ，这个我暂时不知道声明情况下会有记录。</p>
</li>
<li><p><strong>checkSymLink</strong><br>这个是检测 /proc/xx/cwd、/proc/xx/root、/proc/xx/exe ，这个目的应该是判断应用时候安装在 sdcard 上，或是有使用的数据在 sdcard 上（例如一些大型游戏的 data 数据）。如果是安装在 sdcard 上的应用，mount 出去的时候肯定要停止才行。</p>
</li>
</ul>
<p>如果上面3种检测任何一种检测到了（返回值为 1），就给 stocket 写该进程的 pid 号，这样 java 层就知道有哪些进程在访问磁盘了。UsbStorageActivity 那里的表现就是弹出一个确定对话框告诉用户现在还有程序在访问磁盘，如果挂载 usb 设备则这些应用可能会出现异常（其实就是要强制杀死它们而已）。如果用户点确定，MountService 在开启 UMS 之前会让 ActivityManager 把那些还在访问磁盘的进程杀掉。先上剩余坚持代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">CommandListener::StorageCmd::StorageCmd() :</div><div class="line">                 VoldCommand(<span class="string">"storage"</span>) {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> CommandListener::StorageCmd::runCommand(SocketClient *cli,</div><div class="line">                                                      <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv) {</div><div class="line">    dumpArgs(argc, argv, -<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</div><div class="line">        cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, <span class="string">"Missing Argument"</span>, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"users"</span>)) {</div><div class="line">        DIR *dir;</div><div class="line">        <span class="keyword">struct</span> dirent *de;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(dir = opendir(<span class="string">"/proc"</span>))) { </div><div class="line">            cli-&gt;sendMsg(ResponseCode::OperationFailed, <span class="string">"Failed to open /proc"</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="keyword">while</span> ((de = readdir(dir))) {</div><div class="line">            <span class="keyword">int</span> pid = Process::getPid(de-&gt;d_name);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }       </div><div class="line"></div><div class="line">            <span class="keyword">char</span> processName[<span class="number">255</span>];</div><div class="line">            Process::getProcessName(pid, processName, <span class="keyword">sizeof</span>(processName));</div><div class="line">            </div><div class="line">            <span class="comment">// Process 里面的代码不上了，具体的看源代码去吧</span></div><div class="line">            <span class="keyword">if</span> (Process::checkFileDescriptorSymLinks(pid, argv[<span class="number">2</span>]) ||</div><div class="line">                Process::checkFileMaps(pid, argv[<span class="number">2</span>]) ||</div><div class="line">                Process::checkSymLink(pid, argv[<span class="number">2</span>], <span class="string">"cwd"</span>) ||</div><div class="line">                Process::checkSymLink(pid, argv[<span class="number">2</span>], <span class="string">"root"</span>) ||</div><div class="line">                Process::checkSymLink(pid, argv[<span class="number">2</span>], <span class="string">"exe"</span>)) {</div><div class="line"></div><div class="line">                <span class="keyword">char</span> msg[<span class="number">1024</span>];</div><div class="line">                <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg), <span class="string">"%d %s"</span>, pid, processName);</div><div class="line">                cli-&gt;sendMsg(ResponseCode::StorageUsersListResult, msg, <span class="keyword">false</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        closedir(dir);</div><div class="line">        cli-&gt;sendMsg(ResponseCode::CommandOkay, <span class="string">"Storage user list complete"</span>, <span class="keyword">false</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, <span class="string">"Unknown storage cmd"</span>, <span class="keyword">false</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>说那么多，上个图先：<br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/vold-share-clean/1.png" alt=""></p>
<h2 id="杀死访问磁盘的进程">杀死访问磁盘的进程</h2>
<p>上面分析在点击挂载到 PC 的时候，如果检测到有进程在访问磁盘，则会弹个询问框出来，告诉用户现在有程序在访问磁盘，如果还是要挂载磁盘则这些程序可能会出现异常。如果点击确定就会先调用 StroageManager 的 enableUsbMassStorage()，这个最后会调用 MountService 的 setUsbMassStorageEnabled(true) 去向 vold 发 shared 命令去把磁盘从 android 中 unmounted，然后再 shared 到 PC 上。</p>
<p>（具体过程以后再分析）</p>
<p>其中 package manager 会收一些广播，然后干一些磁盘 umount 相关的事情，干完后，pm 会调用 MountService 的 finishMediaUpdate() 通知 MountService，然后在 MountService 自己的 Handler 中处理这个消息时候就会调用 ActivityManager 的 killPids 去杀死这些还在访问的磁盘的进程，让挂载能够顺利的进行下去。</p>
<p>Package Manager 中的 Handler 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> UPDATED_MEDIA_STATUS: {</div><div class="line">    <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG, <span class="string">"Got message UPDATED_MEDIA_STATUS"</span>);</div><div class="line">    <span class="keyword">boolean</span> reportStatus = msg.arg1 == <span class="number">1</span>;</div><div class="line">    <span class="keyword">boolean</span> doGc = msg.arg2 == <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG, <span class="string">"reportStatus="</span> + reportStatus + <span class="string">", doGc = "</span> + doGc);</div><div class="line">    <span class="keyword">if</span> (doGc) {</div><div class="line">        <span class="comment">// Force a gc to clear up stale containers.</span></div><div class="line">        Runtime.getRuntime().gc();</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (msg.obj != <span class="keyword">null</span>) {</div><div class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Set&lt;AsecInstallArgs&gt; args = (Set&lt;AsecInstallArgs&gt;) msg.obj;</div><div class="line">        <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG, <span class="string">"Unloading all containers"</span>);</div><div class="line">        <span class="comment">// Unload containers</span></div><div class="line">        unloadAllContainers(args);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (reportStatus) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG, <span class="string">"Invoking MountService call back"</span>);</div><div class="line">            <span class="comment">// 通知 MountService            </span></div><div class="line">            PackageHelper.getMountService().finishMediaUpdate();</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Log.e(TAG, <span class="string">"MountService not running?"</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">} <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>MountService 中的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishMediaUpdate</span>() {</div><div class="line">        mHandler.sendEmptyMessage(H_UNMOUNT_PM_DONE);</div><div class="line">    }</div><div class="line"></div><div class="line">    class MountServiceHandler extends Handler {</div><div class="line">        ArrayList&lt;UnmountCallBack&gt; mForceUnmounts = <span class="keyword">new</span> ArrayList&lt;UnmountCallBack&gt;();</div><div class="line">        <span class="keyword">boolean</span> mUpdatingStatus = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        MountServiceHandler(Looper l) {</div><div class="line">            <span class="keyword">super</span>(l);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">	        ... ...</div><div class="line"></div><div class="line">                <span class="keyword">case</span> H_UNMOUNT_PM_DONE: {</div><div class="line">                    <span class="keyword">if</span> (DEBUG_UNMOUNT) Slog.i(TAG, <span class="string">"H_UNMOUNT_PM_DONE"</span>);</div><div class="line">                    <span class="keyword">if</span> (DEBUG_UNMOUNT) Slog.i(TAG, <span class="string">"Updated status. Processing requests"</span>);</div><div class="line">                    mUpdatingStatus = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">int</span> size = mForceUnmounts.size();</div><div class="line">                    <span class="keyword">int</span> sizeArr[] = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">                    <span class="keyword">int</span> sizeArrN = <span class="number">0</span>;</div><div class="line">                    <span class="comment">// Kill processes holding references first</span></div><div class="line">                    ActivityManagerService ams = (ActivityManagerService)</div><div class="line">                    ServiceManager.getService(<span class="string">"activity"</span>);</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</div><div class="line">                        UnmountCallBack ucb = mForceUnmounts.get(i);</div><div class="line">                        String path = ucb.path;</div><div class="line">                        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (!ucb.force) {</div><div class="line">                            done = <span class="keyword">true</span>;</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            <span class="comment">// 这里重新向 vold 获取了一次正在访问磁盘的进程的 pid</span></div><div class="line">                            <span class="keyword">int</span> pids[] = getStorageUsers(path);</div><div class="line">                            <span class="keyword">if</span> (pids == <span class="keyword">null</span> || pids.length == <span class="number">0</span>) {</div><div class="line">                                done = <span class="keyword">true</span>;</div><div class="line">                            } <span class="keyword">else</span> {</div><div class="line">                                <span class="comment">// 调用 am killPids 去杀正在访问磁盘的进程</span></div><div class="line">                                <span class="comment">// Eliminate system process here?</span></div><div class="line">                                ams.killPids(pids, <span class="string">"unmount media"</span>, <span class="keyword">true</span>);</div><div class="line">                                <span class="comment">// Confirm if file references have been freed.</span></div><div class="line">                                pids = getStorageUsers(path);</div><div class="line">                                <span class="keyword">if</span> (pids == <span class="keyword">null</span> || pids.length == <span class="number">0</span>) {</div><div class="line">                                    done = <span class="keyword">true</span>;</div><div class="line">                                }</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                        <span class="keyword">if</span> (!done && (ucb.retries &lt; MAX_UNMOUNT_RETRIES)) {</div><div class="line">                            <span class="comment">// Retry again</span></div><div class="line">                            Slog.i(TAG, <span class="string">"Retrying to kill storage users again"</span>);</div><div class="line">                            mHandler.sendMessageDelayed(</div><div class="line">                                    mHandler.obtainMessage(H_UNMOUNT_PM_DONE,</div><div class="line">                                            ucb.retries++),</div><div class="line">                                    RETRY_UNMOUNT_DELAY);</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            <span class="keyword">if</span> (ucb.retries &gt;= MAX_UNMOUNT_RETRIES) {</div><div class="line">                                Slog.i(TAG, <span class="string">"Failed to unmount media inspite of "</span> +</div><div class="line">                                        MAX_UNMOUNT_RETRIES + <span class="string">" retries. Forcibly killing processes now"</span>);</div><div class="line">                            }</div><div class="line">                            sizeArr[sizeArrN++] = i;</div><div class="line">                            mHandler.sendMessage(mHandler.obtainMessage(H_UNMOUNT_MS,</div><div class="line">                                    ucb));</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                    <span class="comment">// Remove already processed elements from list.</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = (sizeArrN-<span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) {</div><div class="line">                        mForceUnmounts.remove(sizeArr[i]);</div><div class="line">                    }</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                .... ...</div><div class="line">            }</div><div class="line">      }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/28/forceStopPackage%20%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</loc>
    <lastmod>2015-01-28T11:35:16.000Z</lastmod>
    <data>
        <display>
        <title>forceStopPackage 的副作用</title>
        <pubTime>2015-01-28T11:35:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>ActivityManager 有个一个函数 forceStopPackage: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"><span class="javadoc"> * Have the system perform a force stop of everything associated with</span></div><div class="line"><span class="javadoc"> * the given application package.  All processes that share its uid</span></div><div class="line"><span class="javadoc"> * will be killed, all services it has running stopped, all activities</span></div><div class="line"><span class="javadoc"> * removed, etc.  In addition, a {@link Intent#ACTION_PACKAGE_RESTARTED}</span></div><div class="line"><span class="javadoc"> * broadcast will be sent, so that any of its registered alarms can</span></div><div class="line"><span class="javadoc"> * be stopped, notifications removed, etc.</span></div><div class="line"><span class="javadoc"> * </span></div><div class="line"><span class="javadoc"> * &lt;p&gt;You must hold the permission</span></div><div class="line"><span class="javadoc"> * {@link android.Manifest.permission#FORCE_STOP_PACKAGES} to be able to</span></div><div class="line"><span class="javadoc"> * call this method.</span></div><div class="line"><span class="javadoc"> * </span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @param</span> packageName The name of the package to be stopped.</span></div><div class="line"><span class="javadoc"> * </span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @hide</span> This is not available to third party applications due to</span></div><div class="line"><span class="javadoc"> * it allowing them to break other applications by stopping their</span></div><div class="line"><span class="javadoc"> * services, removing their alarms, etc.</span></div><div class="line"><span class="javadoc"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceStopPackage</span>(String packageName) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        ActivityManagerNative.getDefault().forceStopPackage(packageName,</div><div class="line">                UserHandle.myUserId());</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) { </div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>函数具体的实现流程在 ActivityManagerService 中，具体实现这里不分析（后面可以分析一下）。这个函数用于强制终止指定的 package，包括这个 package 所在的进程，包括的 Service。并且终止 Service 不会被当作 crash 而被系统重新启动起来。就是俗称杀得干净，不像某些 xx 助手的一键清理，那些一键清理调用的是 killBackgroundProcesses(String packageName) 。这个函数虽然能杀死一些后台进程，但是其所属的 Service 会由于异常终止，会被系统重新启动起来。所以那些 xx 助手的清理功能基本上是没用的。</p>
<p>这个函数虽然猛，但是对调用者有严格限制，不仅要求调用者的进程具有系统权限（在 /system/app 下），而且必需具有系统签名（用编译系统 rom 的签名进行编译）。否则调用报权限异常。所以第三方应用想通过反射、root 之类调用的就省省吧，目前官方系统只有系统的 Setting 里面的强制终止应用会调用这个函数。</p>
<p>不过我工作上定制 rom，弄了个帐号切换的功能，然后切换不同帐号要清理下当前的任务，我于是就调用这个函数来清理。清理倒是清理得很干净，但是最近发现一个问题：这个函数强制终止应用，还会把应用设置了的 alarm 给清理掉。这点要特别注意，怪不得在 Setting 里面强制终止应用的时候，会弹一个提示框告诉你可能会出现应用异常。这还真异常了。简单的贴下代码：</p>
<p>在 ActivityManagerService 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceStopPackage</span>(<span class="keyword">final</span> String packageName, <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES)</div><div class="line">            != PackageManager.PERMISSION_GRANTED) {</div><div class="line">        String msg = <span class="string">"Permission Denial: forceStopPackage() from pid="</span></div><div class="line">                + Binder.getCallingPid()</div><div class="line">                + <span class="string">", uid="</span> + Binder.getCallingUid()</div><div class="line">                + <span class="string">" requires "</span> + android.Manifest.permission.FORCE_STOP_PACKAGES;</div><div class="line">        Slog.w(TAG, msg);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</div><div class="line">    }</div><div class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</div><div class="line">            userId, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="string">"forceStopPackage"</span>, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        IPackageManager pm = AppGlobals.getPackageManager();</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">            <span class="keyword">int</span>[] users = userId == UserHandle.USER_ALL</div><div class="line">                    ? getUsersLocked() : <span class="keyword">new</span> <span class="keyword">int</span>[] { userId };</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> user : users) {</div><div class="line">                <span class="keyword">int</span> pkgUid = -<span class="number">1</span>;</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    pkgUid = pm.getPackageUid(packageName, user);</div><div class="line">                } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (pkgUid == -<span class="number">1</span>) {</div><div class="line">                    Slog.w(TAG, <span class="string">"Invalid packageName: "</span> + packageName);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    pm.setPackageStoppedState(packageName, <span class="keyword">true</span>, user);</div><div class="line">                } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                } <span class="keyword">catch</span> (IllegalArgumentException e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></div><div class="line">                            + packageName + <span class="string">": "</span> + e);</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (isUserRunningLocked(user, <span class="keyword">false</span>)) {</div><div class="line">                    forceStopPackageLocked(packageName, pkgUid);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(callingId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forceStopPackageLocked</span>(<span class="keyword">final</span> String packageName, <span class="keyword">int</span> uid) {</div><div class="line">    forceStopPackageLocked(packageName, UserHandle.getAppId(uid), <span class="keyword">false</span>,</div><div class="line">            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, UserHandle.getUserId(uid));</div><div class="line">    <span class="comment">// 发送 ACTION_PACKAGE_RESTARTED 广播</span></div><div class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PACKAGE_RESTARTED,</div><div class="line">            Uri.fromParts(<span class="string">"package"</span>, packageName, <span class="keyword">null</span>));</div><div class="line">    <span class="keyword">if</span> (!mProcessesReady) {</div><div class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</div><div class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</div><div class="line">    }</div><div class="line">    intent.putExtra(Intent.EXTRA_UID, uid);</div><div class="line">    intent.putExtra(Intent.EXTRA_USER_HANDLE, UserHandle.getUserId(uid));</div><div class="line">    broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</div><div class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">            <span class="keyword">false</span>, <span class="keyword">false</span>,</div><div class="line">            MY_PID, Process.SYSTEM_UID, UserHandle.getUserId(uid));</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里会发一个 <code>ACTION_PACKAGE_RESTARTED</code> 的广播，在 AlarmManagerService 里面会接收这个广播，判断这个广播的 package name 如果在设置过了的 alarm list 中，就会把对应的 alarm 给删掉（AlarmManagerSerivce 用了几个 ArrayList 来保存不同 type 的 alarm）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 这个是 AlarmManagerService 里面注册的广播接收器</span></div><div class="line">    <span class="keyword">class</span> UninstallReceiver extends BroadcastReceiver {</div><div class="line">        <span class="keyword">public</span> UninstallReceiver() {</div><div class="line">            IntentFilter filter = <span class="keyword">new</span> IntentFilter();</div><div class="line">            filter.addAction(Intent.ACTION_PACKAGE_REMOVED);</div><div class="line">            <span class="comment">// 接受 forceStopPackage 发送的广播</span></div><div class="line">            filter.addAction(Intent.ACTION_PACKAGE_RESTARTED);</div><div class="line">            filter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</div><div class="line">            filter.addDataScheme(<span class="string">"package"</span>);</div><div class="line">            mContext.registerReceiver(<span class="keyword">this</span>, filter);</div><div class="line">             <span class="comment">// Register for events related to sdcard installation.</span></div><div class="line">            IntentFilter sdFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">            sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);</div><div class="line">            sdFilter.addAction(Intent.ACTION_USER_STOPPED);</div><div class="line">            mContext.registerReceiver(<span class="keyword">this</span>, sdFilter);</div><div class="line">        }    </div><div class="line"></div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onReceive(Context context, Intent intent) {</div><div class="line">            synchronized (mLock) {</div><div class="line">                String action = intent.getAction();</div><div class="line">                Slog.v(TAG, <span class="string">"uninstall recevier action="</span> + action);</div><div class="line">                String pkgList[] = null;</div><div class="line">                <span class="keyword">if</span> (Intent.ACTION_QUERY_PACKAGE_RESTART.equals(action)) {</div><div class="line">                    pkgList = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);</div><div class="line">                    <span class="keyword">for</span> (String packageName : pkgList) {</div><div class="line">                        <span class="keyword">if</span> (lookForPackageLocked(packageName)) {</div><div class="line">                            setResultCode(Activity.RESULT_OK);</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        }    </div><div class="line">                    }    </div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {</div><div class="line">                    pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_USER_STOPPED.equals(action)) {</div><div class="line">                    <span class="keyword">int</span> userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -<span class="number">1</span>); </div><div class="line">                    <span class="keyword">if</span> (userHandle &gt;= <span class="number">0</span>) { </div><div class="line">                        removeUserLocked(userHandle);</div><div class="line">                    }    </div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">if</span> (Intent.ACTION_PACKAGE_REMOVED.equals(action)</div><div class="line">                            && intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>)) {</div><div class="line">                        <span class="comment">// This package is being updated; don't kill its alarms.</span></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    }</div><div class="line">                    Uri data = intent.getData();</div><div class="line">                    <span class="keyword">if</span> (data != null) {  </div><div class="line">                        String pkg = data.getSchemeSpecificPart();</div><div class="line">                        <span class="keyword">if</span> (pkg != null) {</div><div class="line">                            pkgList = <span class="keyword">new</span> String[]{pkg};</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (pkgList != null && (pkgList.length &gt; <span class="number">0</span>)) {</div><div class="line">                    <span class="keyword">for</span> (String pkg : pkgList) {</div><div class="line">                        <span class="comment">// 删除配置的 alarm</span></div><div class="line">                        removeLocked(pkg);</div><div class="line">                        mBroadcastStats.remove(pkg);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其中最后那里那个 removeLocked(String packageName) 就是去删除广播中发的包设置过的 alarm（具体代码这里不贴了，可以去查看 AlarmManagerService）。</p>
<p>这里记录这篇文章就是提醒下，调用这个函数会有这个“副作用”，免得下次应用的 alarm 没反应，啥头绪都没用。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/%5B%E8%BD%AC%5D%20Android%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E4%B8%8E%E8%B0%83%E8%AF%95%E4%B9%8B%E2%80%94%E2%80%94build.prop%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%B5%8F%E6%9E%90/</loc>
    <lastmod>2015-01-27T15:45:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Android系统移植与调试之——build.prop文件详细赏析</title>
        <pubTime>2015-01-27T15:45:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>什么是build.prop？ /system/build.prop 是一个属性文件，在Android系统中.prop文件很重要，记录了系统的设置和改变，类似於/etc中的文件。这个文件是如何生成的呢？</p>
<p>build/tools/buildinfo.sh 脚本就是专门用于生成build.prop文件。build/core/Makefile中使用build/tools/buildinfo.sh 脚本生成build.prop文件，并把系统默认的system.prop以及定制的system.prop中的设定追加到build.prop文件中。后面还有一些设备相关的配置追加到build.prop</p>
<p>以下是build.prop的代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># begin build properties	#开始设置系统性能</span></div><div class="line"><span class="comment"># autogenerated by buildinfo.sh	#以下内容由脚本在编译时自动产生</span></div><div class="line">ro.build.<span class="variable">id=</span>JRO03C	  <span class="comment">#build的标识,一般在编译时产生不必修改</span></div><div class="line">ro.build.display.<span class="variable">id=</span>TBDG1073-eng <span class="number">4.1</span>.<span class="number">1</span> JRO03C <span class="number">20130723</span>.v016 test-keys	<span class="comment">#显示的标识,可以任意修改,显示为手机信息的版本</span></div><div class="line">ro.build.version.<span class="variable">incremental=</span><span class="number">20130723</span>.v016	<span class="comment">#版本的增加说明,一般不显示也没必要修改</span></div><div class="line">ro.build.version.<span class="variable">sdk=</span><span class="number">16</span>	<span class="comment">#系统编译时,使用的SDK的版本,勿修改.</span></div><div class="line">ro.build.version.<span class="variable">codename=</span>REL	  <span class="comment">#版本编码名称,一般不显示也没必要修改</span></div><div class="line">ro.build.version.<span class="variable">release=</span><span class="number">4.1</span>.<span class="number">1</span>	  <span class="comment">#公布的版本,显示为手机信息的系统版本</span></div><div class="line">ro.build.<span class="variable">date=</span>Tue Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">43</span> CST <span class="number">2013</span>	 <span class="comment">#系统编译的时间,没必要修改</span></div><div class="line">ro.build.date.<span class="variable">utc=</span><span class="number">1374570883</span>	 <span class="comment">#系统编译的时间(数字版),没必要修改</span></div><div class="line">ro.build.<span class="variable">type=</span>eng	<span class="comment">#系统编译类型,一般不显示也没必要修改</span></div><div class="line">ro.build.<span class="variable">user=</span>pyou	<span class="comment">#系统用户名,可以修改成自己的名字</span></div><div class="line">ro.build.<span class="variable">host=</span>roco-ubuntu	 <span class="comment">#系统主机名,随便起个名字,英文字母表示</span></div><div class="line">ro.build.<span class="variable">tags=</span>test-keys	 <span class="comment">#系统标记,无意义,不修改</span></div><div class="line">ro.product.<span class="variable">model=</span>TBDG1073_OuyangPeng	<span class="comment">#机器型号,随你创造</span></div><div class="line">ro.product.<span class="variable">brand=</span>TBDG1073	 <span class="comment">#机器品牌,随你创造</span></div><div class="line">ro.product.<span class="variable">name=</span>TBDG1073	 <span class="comment">#机器名,随你创造</span></div><div class="line">ro.product.<span class="variable">device=</span>TBDG1073	 <span class="comment">#设备名,随你创造</span></div><div class="line">ro.product.<span class="variable">board=</span>TBDG1073	 <span class="comment">#主板名,随你创造</span></div><div class="line">ro.product.cpu.<span class="variable">abi=</span>armeabi-v7a	 <span class="comment">#CPU,最好别修改,避免有些软件在识别机器时,出现错乱</span></div><div class="line">ro.product.cpu.<span class="variable">abi2=</span>armeabi	 <span class="comment">#CPU品牌</span></div><div class="line">ro.product.<span class="variable">manufacturer=</span>TBDG1073	 <span class="comment">#制造商,随你创造</span></div><div class="line">ro.product.locale.<span class="variable">language=</span>en	<span class="comment">#系统语言</span></div><div class="line">ro.product.locale.<span class="variable">region=</span>US	<span class="comment">#系统所在地区</span></div><div class="line">ro.wifi.<span class="variable">channels=</span><span class="number">11</span>		<span class="comment">#无线局域网络的通信信道,空白表示自动识别</span></div><div class="line">ro.board.<span class="variable">platform=</span>meson6	<span class="comment">#主板系统</span></div><div class="line"><span class="comment"># ro.build.product is obsolete; use ro.product.device</span></div><div class="line">ro.build.<span class="variable">product=</span>TBDG1073	<span class="comment">#设备名,被废弃了,修改也没用</span></div><div class="line"><span class="comment"># Do not try to parse ro.build.description or .fingerprint	#以下的内容不要试图修改</span></div><div class="line">ro.build.<span class="variable">description=</span>TBDG1073-eng <span class="number">4.1</span>.<span class="number">1</span> JRO03C <span class="number">20130723</span>.v016 test-keys	<span class="comment">#用户的KEY</span></div><div class="line">ro.build.<span class="variable">fingerprint=</span>TBDG1073/TBDG1073/TBDG1073:<span class="number">4.1</span>.<span class="number">1</span>/JRO03C/<span class="number">20130723</span>.v016:eng/test-keys  <span class="comment">#机身码</span></div><div class="line">ro.build.<span class="variable">characteristics=</span>tablet</div><div class="line"><span class="comment"># end build properties	#创建属性结束</span></div><div class="line"><span class="comment"># system.prop for M1 reference board	#系统技术支持由M1提供</span></div><div class="line"><span class="comment"># This overrides settings in the products/generic/system.prop file</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#rild.libpath=/system/lib/libreference-ril.so</span></div><div class="line"><span class="comment">#rild.libargs=-d /dev/ttyS0</span></div><div class="line">ro.sf.<span class="variable">lcd_density=</span><span class="number">120</span> <span class="comment">#显示屏分辨率，数值越大分辨率越底</span></div><div class="line">keyguard.<span class="variable">no_require_sim=</span><span class="number">1</span>	<span class="comment">#无需SIM卡也可操作手机</span></div><div class="line"><span class="comment">#set font</span></div><div class="line">ro.<span class="variable">fontScale=</span><span class="number">1.0</span>	<span class="comment">#字体大小缩放</span></div><div class="line"><span class="comment">#set keyguard.enable=false to disable keyguard</span></div><div class="line">keyguard.<span class="variable">enable=</span><span class="constant">true</span>	<span class="comment">#锁屏</span></div><div class="line">ro.statusbar.<span class="variable">widget=</span><span class="constant">true</span></div><div class="line">ro.statusbar.<span class="variable">button=</span><span class="constant">true</span></div><div class="line">ro.statusbar.<span class="variable">yearmonthdayweek=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#wifi.interface=ra0	#WIFI界面</span></div><div class="line"><span class="comment"># Time between scans in seconds. Keep it high to minimize battery drain.</span></div><div class="line"><span class="comment"># This only affects the case in which there are remembered access points,</span></div><div class="line"><span class="comment"># but none are in range.</span></div><div class="line"><span class="comment">#wifi.supplicant_scan_interval = 60 #WIFI扫描间隔时间，这里设置是45秒。把这个时间设置长点能省电</span></div><div class="line"><span class="comment">#alsa.mixer.playback.master=DAC2 Analog</span></div><div class="line"><span class="comment">#alsa.mixer.capture.master=Analog</span></div><div class="line"><span class="comment">#configure the Dalvik heap for a standard tablet device.</span></div><div class="line"><span class="comment">#frameworks/base/build/tablet-dalvik-heap.mk</span></div><div class="line">dalvik.vm.<span class="variable">heapstartsize=</span><span class="number">5</span>m	<span class="comment">#单个应用程序分配的初始内存</span></div><div class="line">dalvik.vm.<span class="variable">heapgrowthlimit=</span><span class="number">48</span>m	<span class="comment">#单个应用程序最大内存限制，超过将被Kill，这或许是某些大体积程序闪退的原因</span></div><div class="line">dalvik.vm.<span class="variable">heapsize=</span><span class="number">256</span>m  <span class="comment">#dalvik的虚拟内存大小</span></div><div class="line"></div><div class="line"></div><div class="line">hwui.<span class="variable">render_dirty_regions=</span><span class="constant">false</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Disable un-supported Android feature</span></div><div class="line">hw.<span class="variable">nopm=</span><span class="constant">false</span></div><div class="line">hw.<span class="variable">nobattery=</span><span class="constant">false</span></div><div class="line">hw.<span class="variable">nophone=</span><span class="constant">true</span></div><div class="line">hw.<span class="variable">novibrate=</span><span class="constant">true</span></div><div class="line">hw.<span class="variable">cameras=</span><span class="number">1</span></div><div class="line">hw.<span class="variable">hasethernet=</span><span class="constant">false</span></div><div class="line"><span class="comment">#hw.hasdata=true</span></div><div class="line">ro.platform.has.<span class="variable">touch=</span><span class="constant">true</span></div><div class="line">hw.<span class="variable">nodatausage=</span><span class="constant">true</span></div><div class="line"><span class="comment"># Wi-Fi sleep policy</span></div><div class="line">ro.platform.has.<span class="variable">sleeppolicy=</span><span class="constant">false</span></div><div class="line"><span class="comment">#set to 0 temporarily so touch works without other changes</span></div><div class="line">ro.sf.<span class="variable">hwrotation=</span><span class="number">270</span>	<span class="comment">#0的话自动转屏</span></div><div class="line"><span class="comment">#0~7 You are required to get the correct install direction according the sensor placement on target board</span></div><div class="line"><span class="comment">#ro.sf.gsensorposition=6</span></div><div class="line">ro.sf.<span class="variable">ecompassposition=</span><span class="number">4</span></div><div class="line"><span class="variable">allow_all_orientations=</span><span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Set Camera Orientation</span></div><div class="line">ro.camera.orientation.<span class="variable">front=</span><span class="number">270</span></div><div class="line">ro.camera.orientation.<span class="variable">back=</span><span class="number">90</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Use OSD2 mouse patch</span></div><div class="line">ro.ui.<span class="variable">cursor=</span>osd2</div><div class="line"></div><div class="line"></div><div class="line">ro.<span class="variable">hardware=</span>amlogic</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Enable 32-bit OSD</span></div><div class="line">sys.fb.<span class="variable">bits=</span><span class="number">32</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Disable GPS</span></div><div class="line">gps.<span class="variable">enable=</span><span class="constant">false</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Enable player buildin</span></div><div class="line">media.amsuperplayer.<span class="variable">enable=</span><span class="constant">true</span></div><div class="line">media.amplayer.<span class="variable">enable-acodecs=</span>asf,ape,flac,dts</div><div class="line">media.amplayer.<span class="variable">enable=</span><span class="constant">true</span></div><div class="line">media.amsuperplayer.<span class="variable">m4aplayer=</span>STAGEFRIGHT_PLAYER</div><div class="line">media.amsuperplayer.<span class="variable">defplayer=</span>PV_PLAYER</div><div class="line">media.amplayer.<span class="variable">thumbnail=</span><span class="constant">true</span></div><div class="line">media.amplayer.<span class="variable">stopbuflevel=</span><span class="number">0.05</span></div><div class="line">media.amplayer.<span class="variable">widevineenable=</span><span class="constant">true</span></div><div class="line">media.amplayer.<span class="variable">html5_stretch=</span><span class="constant">true</span></div><div class="line">media.libplayer.<span class="variable">fastswitch=</span><span class="number">0</span></div><div class="line">media.libplayer.<span class="variable">ipv4only=</span><span class="number">1</span></div><div class="line">media.amplayer.<span class="variable">dsource4local=</span><span class="number">1</span></div><div class="line"><span class="comment">#media.amplayer.hdmicloseauthen=1</span></div><div class="line">media.amplayer.<span class="variable">delaybuffering=</span><span class="number">2</span></div><div class="line">media.amplayer.<span class="variable">buffertime=</span><span class="number">5</span></div><div class="line">media.amplayer.v4osd.<span class="variable">enable=</span><span class="number">1</span></div><div class="line">media.arm.audio.<span class="variable">decoder=</span>ape</div><div class="line"><span class="comment">#fix doubleTwist apk can not play radio</span></div><div class="line">media.player.<span class="variable">forcemp3softdec=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#fix online video block issue</span></div><div class="line">libplayer.livets.<span class="variable">softdemux=</span><span class="number">1</span></div><div class="line">libplayer.netts.<span class="variable">recalcpts=</span><span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Nand write need force sync when gadget</span></div><div class="line">gadget.nand.<span class="variable">force_sync=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Status bar customization</span></div><div class="line">ro.statusbar.widget.<span class="variable">power=</span><span class="constant">true</span></div><div class="line">ro.statusbar.<span class="variable">yearmonthdayweek=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># HDMI </span></div><div class="line"><span class="comment">#ro.hdmi480p.enable=true</span></div><div class="line"><span class="comment">#rw.fb.need2xscale=ok</span></div><div class="line"><span class="comment">#media.amplayer.osd2xenable=true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#camera DCIM dir. 0:sd only; 1:nand only; 2,sd first</span></div><div class="line">ro.camera.<span class="variable">dcim=</span><span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Disable preload-class</span></div><div class="line">ro.amlogic.no.<span class="variable">preloadclass=</span><span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># App optimization</span></div><div class="line">ro.app.<span class="variable">optimization=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line">persist.sys.<span class="variable">timezone=</span>America/New_York	<span class="comment">#强制时区,此处为美洲纽约时间</span></div><div class="line"><span class="comment">#Dual display</span></div><div class="line">ro.vout.<span class="variable">dualdisplay3=</span><span class="constant">true</span></div><div class="line">ro.vout.player.<span class="variable">exit=</span><span class="constant">false</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># CPU settings</span></div><div class="line">ro.has.cpu.<span class="variable">setting=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># CPU freq customized in setting menu</span></div><div class="line"><span class="comment"># normal, performance, powersaving</span></div><div class="line">ro.cpumode.<span class="variable">maxfreq=</span><span class="number">1200000</span>,<span class="number">1320000</span>,<span class="number">800000</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># when usbstorage, CPU mode and freq</span></div><div class="line">ro.usbstorage.<span class="variable">cpumode=</span>performance</div><div class="line">ro.usbstorage.<span class="variable">maxfreq=</span><span class="number">600000</span></div><div class="line"></div><div class="line"></div><div class="line">ro.bootanimation.<span class="variable">rotation=</span><span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#used to set default surface size, set 1 when hwrotation is 270, set 3 when hwrotation is 90;need set ro.bootanimation.rotation 0;</span></div><div class="line">debug.default.<span class="variable">dimention=</span><span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#support media poll uevent,can use sd cardread on usb port</span></div><div class="line">has.media.<span class="variable">poll=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#used forward seek for libplayer</span></div><div class="line">media.libplayer.seek.<span class="variable">fwdsearch=</span><span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#for tabletui display</span></div><div class="line">ro.ui.<span class="variable">tabletui=</span><span class="constant">true</span></div><div class="line"><span class="comment">#enable address bar cover issue fixing</span></div><div class="line">ro.flashplayer.<span class="variable">surfacehack=</span><span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#add vol button in statusbar.</span></div><div class="line">ro.statusbar.<span class="variable">volume=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line">ro.screen.has.<span class="variable">usbstorage=</span><span class="constant">true</span></div><div class="line">hw.erase.<span class="variable">internalSdcard=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#media partition name</span></div><div class="line">ro.media.partition.<span class="variable">label=</span>OuyangPeng</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#USB PID and VID name</span></div><div class="line"><span class="comment">#ro.usb.vendor.string=AML</span></div><div class="line"><span class="comment">#ro.usb.product.string=MID</span></div><div class="line"><span class="comment">#CTS</span></div><div class="line"><span class="comment">#media.amplayer.widevineenable=true</span></div><div class="line"><span class="comment">#media.amplayer.dsource4local=true</span></div><div class="line">ro.com.google.<span class="variable">gmsversion=</span><span class="number">4.1</span>_r5</div><div class="line">ro.com.google.<span class="variable">clientidbase=</span>android-fih	<span class="comment">#谷歌客户身份</span></div><div class="line">ro.setupwizard.<span class="variable">mode=</span>OPTIONAL	<span class="comment">#安装向导模式 开机出现的帐号设置向导，ENABLED为显示，DISABLED为禁用，OPTIONAL为可选</span></div><div class="line">ro.statusbar.<span class="variable">screenshot=</span><span class="constant">true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># ADDITIONAL_BUILD_PROPERTIES</span></div><div class="line"><span class="comment">#</span></div><div class="line">ro.com.android.<span class="variable">dateformat=</span>MM-dd-yyyy	 <span class="comment">#默认时间格式，改为yyyy-MM-dd，显示效果就是XXXX年XX月XX日</span></div><div class="line">ro.config.<span class="variable">ringtone=</span>Ring_Synth_04.ogg	 <span class="comment">#默认响铃铃声,文件在/system/media/audio/ringtones 把喜欢的铃声放这里</span></div><div class="line">ro.config.<span class="variable">notification_sound=</span>pixiedust.ogg	<span class="comment">#默认提示音，文件在/system/media/audio/notifications 修改方法同上</span></div><div class="line">ro.<span class="variable">carrier=</span>unknown</div><div class="line">ro.opengles.<span class="variable">version=</span><span class="number">131072</span>	<span class="comment">#开放式绘图介面参数</span></div><div class="line">ro.config.<span class="variable">alarm_alert=</span>Alarm_Classic.ogg		<span class="comment">#默认闹铃，文件在/system/media/audio/alarms 修改方法同上</span></div><div class="line">drm.service.<span class="variable">enabled=</span><span class="constant">true</span></div><div class="line">ro.setupwizard.<span class="variable">mode=</span>OPTIONAL <span class="comment">#默认开机时使用设置向导</span></div><div class="line">ro.com.google.<span class="variable">gmsversion=</span><span class="number">4.1</span>_r4</div><div class="line">ro.kernel.android.<span class="variable">checkjni=</span><span class="number">1</span></div><div class="line">net.bt.<span class="variable">name=</span>Android	<span class="comment">#蓝牙网络中显示的名称,可以修改</span></div><div class="line">dalvik.vm.<span class="variable">stack-trace-file=</span>/data/anr/traces.txt</div></pre></td></tr></table></figure>

<p>出处： <a href="http://blog.csdn.net/ouyang_peng/article/details/9426271" title="http://blog.csdn.net/ouyang_peng/article/details/9426271" target="_blank" rel="external">http://blog.csdn.net/ouyang_peng/article/details/9426271</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/%5B%E8%BD%AC%5D%20Android%20locales%20%E6%9C%AC%E5%9C%B0%E5%8C%96/</loc>
    <lastmod>2015-01-27T15:37:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Android locales 本地化</title>
        <pubTime>2015-01-27T15:37:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="1-_ICU">1. ICU</h2>
<p>ICU4C(ICU for C，<a href="http://site.icu-project.org/)是ICU在C/C++平台下的版本" target="_blank" rel="external">http://site.icu-project.org/)是ICU在C/C++平台下的版本</a>, ICU(International Component for Unicode)是基于”IBM公共许可证”的，与开源组织合作研究的, 用于支持软件国际化的开源项目。ICU4C提供了C/C++平台强大的国际化开发能力，软件开发者几乎可以使用ICU4C解决任何国际化的问题，根据各地的风俗和语言习惯，实现对数字、货币、时间、日期、和消息的格式化、解析，对字符串进行大小写转换、整理、搜索和排序等功能，必须一提的是，ICU4C提供了强大的BIDI算法，对阿拉伯语等BIDI语言提供了完善的支持</p>
<p>ICU首先是由Taligent公司开发的，Taligent公司现在被合并为IBM?公司全球化认证中心的Unicode研究组，然后ICU由IBM和开源组织合作继续开发，开源组织给与了ICU极大的帮助开始ICU只有Java平台的版本，后来这个平台下的ICU类被吸纳入SUN公司开发的JDK1.1，并在JDK以后的版本中不断改进。C++和C平台下的ICU是由JAVA平台下的ICU移植过来的，移植过的版本被称为ICU4C，来支持这C/C++两个平台下的国际化应用。</p>
<p>ICU4C和ICU4C区别不大，但由于ICU4C是开源的，并且紧密跟进Unicode标准，ICU4C支持的Unicode标准总是最新的；同时，因为JAVA平台的ICU4J的发布需要和JDK绑定，ICU4C支持Unicode标准改变的速度要比ICU4J快的多。</p>
<p>ICU用户指南： <a href="http://userguide.icu-project.org/locale" title="指南地址" target="_blank" rel="external">指南地址</a></p>
<h2 id="2-_ANDROID_语言包">2. ANDROID 语言包</h2>
<p>Android 使用的语言包就是ICU4C，位置：external/icu4c。<br>Android2.1及2.2支持的26种语言（locales）<br>Android2.3以上版本支持的57种语言（locales）.</p>
<p>定制语言，在PRODUCT_LOCALES字段里添加需要语言，如：</p>
<pre config="brush:bash;toolbar:false;">
PRODUCT_LOCALES := en_US zh_CN
</pre>

<p>则系统里只有英语和汉语两种语言。然后语言的选择处理是在external/icu4c/stubdata/Android.mk里进行的，如下：</p>
<pre config="brush:bash;toolbar:false;">
config := $(word 1, \

            $(if $(findstring ar,$(PRODUCT_LOCALES)),large) \

            $(if $(findstring da,$(PRODUCT_LOCALES)),large) \

            $(if $(findstring el,$(PRODUCT_LOCALES)),large) \
        .....    \
            us)
</pre>

<p>在android2.2中最终生成/system/lib/libicudata.so<br>在android2.3以上版本中最终生成使用的是/system/usr/ict/icudt44l.dat.</p>
<h2 id="3-_默认语言">3. 默认语言</h2>
<p>在PRODUCT_LOCALES字段里，将要选择的语言放在第一位，如：PRODUCT_LOCALES := en_US zh_CN</p>
<h2 id="4-_增加语言支持">4. 增加语言支持</h2>
<p>增加系统版本支持的语言范围内的语言，在setting中增加语言选择。 /build/target/product目录下，language_full.mk|language_small.mk 看你的编译选项使用那个文件了，修改PRODUCT_LOCALES ，如下PRODUCT_LOCALES包括了57中语言的支持：</p>
<pre config="brush:bash;toolbar:false;">
PRODUCT_LOCALES :=ar_EG ar_IL bg_BG ca_ES cs_CZ da_DK de_AT de_CH de_DE de_LI el_GR en_AU en_CA en_GB en_IE en_IN en_NZ en_SG en_US en_ZA es_ES es_US fi_FI fr_BE fr_CA fr_CH fr_FR he_IL hi_IN hr_HR hu_HU id_ID it_CH it_IT ja_JP ko_KR lt_LT lv_LV nb_NO nl_BE nl_NL pl_PL pt_BR pt_PT ro_RO ru_RU sk_SK sl_SI sr_RS sv_SE th_TH tl_PH tr_TR uk_UA vi_VN zh_CN zh_TW
</pre>

<p>增加android系统不支持的语言，如在android2.2中增加对越南语，泰语（这两中语言android2.3中才支持）的支持。例：android2.2系统添加希伯来文</p>
<p>我大概是这样修改的：<br>  1.frameworks\base\data\fonts目录下的字体库，替换为希伯来的<br>  2.将mk文件中的 PRODUCT_LOCALES 添加he_IL希伯来的支持<br>  3.external\icu4c\stubdata\Android.mk 添加希伯来的国籍问题 $(if $(findstring he,$(PRODUCT_LOCALES)),large) \<br>  4.在应用程序中，在res下建立目录 values-iw-rIL，并翻译成希伯来文。。<br>  5.make clean，之后整个make</p>
<p>修改或增加ICU资源或定义，比如对locales地区数字、货币、百分比等书写习惯进行修改。轻易不要修改，除非ICU资源本身有bug.</p>
<pre config="brush:bash;toolbar:false;">
   /external/icu4c/data/locales/

  NumberElements{
        ",",
        " ",
        ";",
        "%",
        "0",
        "#",
        "-",
        "E",
        "‰",
        "∞",
        "NaN",
        "+",
    }
    NumberPatterns{
        "#,##0.###",
        "¤#,##0.00",
        "#,##0%",
        "#E0",
    }
</pre>

<p>编译：<br>   /external/icu4c/runConfigureICU Linux<br>   make -j2</p>
<p>这个目录下的文件定义了各国或地区的语言使用习惯，编译后在android2.3中生成icudtxxl-all.dat,icudtxxl-large.dat数据文件（android2.2稍有不同） 数据文件android编译过程中将复制到out/target/product/xxxxx/system/usr/icu/icudtxxl.dat,在android中经JDK读取解释，如/java/text/NumberFormat.java 这样同一个数字在不同的语言locales设置情况下，将按地区习惯显示</p>
<h2 id="参考">参考</h2>
<p><a href="http://blog.csdn.net/zhq56030207/article/details/6239979" title="如何添加一种语言？" target="_blank" rel="external">如何添加一种语言？</a><br><a href="http://www.eoeandroid.com/thread-46129-1-1.html" title="http://www.eoeandroid.com/thread-46129-1-1.html" target="_blank" rel="external">http://www.eoeandroid.com/thread-46129-1-1.html</a><br><a href="http://www.eoeandroid.com/thread-46129-1-1.html" title="http://www.eoeandroid.com/thread-46129-1-1.html" target="_blank" rel="external">http://www.eoeandroid.com/thread-46129-1-1.html</a><br><a href="http://developer.android.com/reference/java/util/Locale.html" title="http://developer.android.com/reference/java/util/Locale.html" target="_blank" rel="external">http://developer.android.com/reference/java/util/Locale.html</a><br><a href="http://topic.csdn.net/u/20110308/11/7b29dfdf-f106-45ac-baa1-c4bcf19252f5.html?32827" title="http://topic.csdn.net/u/20110308/11/7b29dfdf-f106-45ac-baa1-c4bcf19252f5.html?32827" target="_blank" rel="external">http://topic.csdn.net/u/20110308/11/7b29dfdf-f106-45ac-baa1-c4bcf19252f5.html?32827</a><br><a href="http://hi.baidu.com/xie_jack/blog/item/ac3f390aef09339a0a7b823b.html" title="http://hi.baidu.com/xie_jack/blog/item/ac3f390aef09339a0a7b823b.html" target="_blank" rel="external">http://hi.baidu.com/xie_jack/blog/item/ac3f390aef09339a0a7b823b.html</a><br><a href="http://blog.csdn.net/seker_xinjian/article/details/6289191" title="http://blog.csdn.net/seker_xinjian/article/details/6289191" target="_blank" rel="external">http://blog.csdn.net/seker_xinjian/article/details/6289191</a><br><a href="http://www.douban.com/group/topic/13422793/" title="http://www.douban.com/group/topic/13422793/" target="_blank" rel="external">http://www.douban.com/group/topic/13422793/</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E4%BF%AE%E6%94%B9%20Android%20%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</loc>
    <lastmod>2015-01-27T15:36:16.000Z</lastmod>
    <data>
        <display>
        <title>在源码中修改 Android 系统配置</title>
        <pubTime>2015-01-27T15:36:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Android 的系统（System Settings）的配置文件在 framework/base/core/res/res/values/config.xml 里面。编译模块 framework/base/core/res 能得到 out/target/product/xx/system/framework/framework-res.apk ，这个配置文件中定义的值就打包在这个 apk 中（这个 apk 在板子的 /system/framework 下）。 </p>
<p>例如说，你想把系统设置中自动亮度的开关打开：那就在 config.xml 中找到 config_automatic_brightness_available ，然后改成 true 重新编译 framework-res.apk 就行了。不过一般来说，修改 framework/base/core/res 下的 config.xml 是没用的。 google 提供了一个给 OEM 厂商灵活修改这个配置的方式，在 build/target/board/xx/overlay/frameworks/base/core/res 下面还会有一个 config.xml （xx 就是你 OEM 自己的产品名字，例如 galaxy 之类的）， 如果 build 下面有 overlay 这个目录，那么 framework 里面设置的值是会被这里的覆盖的。所以说改就要改 build 下面那个 overlay 里面的。然后把编出来的 framework-res.apk 替换一下就行了。</p>
<p>最后如果想检验下 framework-res.apk 里面的配置是不是对的，可以用 apk tool 反编译出来看看就可以了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/Android%20%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-27T15:32:16.000Z</lastmod>
    <data>
        <display>
        <title>编译 Android 按键映射分析</title>
        <pubTime>2015-01-27T15:32:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 能够将不同的低层 scancode 转化成上层使用的统一的 keycode （以下分析为 android 2.2 froyo 的）。下面说的几个相关的源代码文件都在 framework/base/libs/ui 下。</p>
<h2 id="EventHub-cpp">EventHub.cpp</h2>
<p>先看看下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 open_device 函数里</span></div><div class="line"><span class="keyword">if</span> ((device-&gt;classes&CLASS_KEYBOARD) != <span class="number">0</span>) { </div><div class="line">   <span class="keyword">char</span> devname[PROPERTY_VALUE_MAX];</div><div class="line">   <span class="keyword">char</span> keylayoutFilename[<span class="number">300</span>];</div><div class="line"></div><div class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* root = getenv(<span class="string">"ANDROID_ROOT"</span>);</div><div class="line">   property_get(<span class="string">"persist.sys.keylayout"</span>, devname, <span class="string">"qwerty"</span>);</div><div class="line">   <span class="built_in">snprintf</span>(keylayoutFilename, <span class="keyword">sizeof</span>(keylayoutFilename), <span class="string">"%s/usr/keylayout/%s.kl"</span>, root, devname);</div><div class="line">   <span class="keyword">bool</span> defaultKeymap = access(keylayoutFilename, R_OK);</div><div class="line">   <span class="keyword">if</span> (defaultKeymap) {</div><div class="line">      <span class="built_in">strcpy</span>(devname, <span class="string">"qwerty"</span>);</div><div class="line">      <span class="built_in">snprintf</span>(keylayoutFilename, <span class="keyword">sizeof</span>(keylayoutFilename),</div><div class="line">                     <span class="string">"%s/usr/keylayout/%s.kl"</span>, root, devname);</div><div class="line">   }</div><div class="line">   LOGI(<span class="string">"keylayout = %s, Filename = %s"</span>, devname, keylayoutFilename);</div><div class="line">   device-&gt;layoutMap-&gt;load(keylayoutFilename);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这段代码是打开键盘设备，并读取按键映射表的。从代码里可以看得到映射文件是从 root/usr/keylayout/qwerty.kl （root 一般是 system）下读取的（这个 qwerty.kl 各个设备厂商应该可以自己改，我看的 x86 的默认使用的是这个）。</p>
<h2 id="kl_文件">kl 文件</h2>
<p>这个文件就是 android 的按键映射文件，结构如下：</p>
<ul>
<li><p><strong>BACK</strong>:</p>
<ul>
<li>BEGIN: key</li>
<li>SCANCODE: 1 </li>
<li>KEYCODE: BACK</li>
<li>FLAG: WACK_DROPPED</li>
</ul>
</li>
<li><p><strong>POWER</strong>:</p>
<ul>
<li>BEGIN: key</li>
<li>SCANCODE: 116 </li>
<li>KEYCODE: POWER</li>
<li>FLAG: WACK</li>
</ul>
</li>
</ul>
<p>这里配合看下下面的代码，在 KeyLayoutMap.cpp 里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">status_t</div><div class="line">KeyLayoutMap::load(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = open(filename, O_RDONLY);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</div><div class="line">        LOGE(<span class="string">"error opening file=%s err=%s\n"</span>, filename, strerror(errno));</div><div class="line">        m_status = errno;</div><div class="line">        <span class="keyword">return</span> errno;</div><div class="line">    }</div><div class="line"></div><div class="line">    off_t len = lseek(fd, <span class="number">0</span>, SEEK_END);</div><div class="line">    off_t errlen = lseek(fd, <span class="number">0</span>, SEEK_SET);</div><div class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span> || errlen &lt; <span class="number">0</span>) {</div><div class="line">        close(fd);</div><div class="line">        LOGE(<span class="string">"error seeking file=%s err=%s\n"</span>, filename, strerror(errno));</div><div class="line">        m_status = errno;</div><div class="line">        <span class="keyword">return</span> errno;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (read(fd, buf, len) != len) {</div><div class="line">        LOGE(<span class="string">"error reading file=%s err=%s\n"</span>, filename, strerror(errno));</div><div class="line">        m_status = errno != <span class="number">0</span> ? errno : ((<span class="keyword">int</span>)NOT_ENOUGH_DATA);</div><div class="line">        <span class="keyword">return</span> errno != <span class="number">0</span> ? errno : ((<span class="keyword">int</span>)NOT_ENOUGH_DATA);</div><div class="line">    }</div><div class="line">    errno = <span class="number">0</span>;</div><div class="line">    buf[len] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    int32_t scancode = -<span class="number">1</span>;</div><div class="line">    int32_t keycode = -<span class="number">1</span>;</div><div class="line">    uint32_t flags = <span class="number">0</span>;</div><div class="line">    uint32_t tmp;</div><div class="line">    <span class="keyword">char</span>* end;</div><div class="line">    status_t err = NO_ERROR;</div><div class="line">    <span class="keyword">int</span> line = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* p = buf;</div><div class="line">    <span class="keyword">enum</span> { BEGIN, SCANCODE, KEYCODE, FLAG } state = BEGIN;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">        String8 token = next_token(&p, &line);</div><div class="line">        <span class="keyword">if</span> (*p == <span class="string">'\0'</span>) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">switch</span> (state)</div><div class="line">        {</div><div class="line">            <span class="keyword">case</span> BEGIN:</div><div class="line">                <span class="keyword">if</span> (token == <span class="string">"key"</span>) {</div><div class="line">                    state = SCANCODE;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    LOGE(<span class="string">"%s:%d: expected key, got '%s'\n"</span>, filename, line,</div><div class="line">                            token.<span class="built_in">string</span>());</div><div class="line">                    err = BAD_VALUE;</div><div class="line">                    <span class="keyword">goto</span> done;</div><div class="line">                }</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> SCANCODE:</div><div class="line">                scancode = strtol(token.<span class="built_in">string</span>(), &end, <span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span> (*end != <span class="string">'\0'</span>) {</div><div class="line">                    LOGE(<span class="string">"%s:%d: expected scancode (a number), got '%s'\n"</span>,</div><div class="line">                            filename, line, token.<span class="built_in">string</span>());</div><div class="line">                    <span class="keyword">goto</span> done;</div><div class="line">                }</div><div class="line">                <span class="comment">//LOGI("%s:%d: got scancode %d\n", filename, line, scancode );</span></div><div class="line">                state = KEYCODE;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> KEYCODE:</div><div class="line">                keycode = token_to_value(token.<span class="built_in">string</span>(), KEYCODES);</div><div class="line">                <span class="comment">//LOGI("%s:%d: got keycode %d for %s\n", filename, line, keycode, token.string() );</span></div><div class="line">                <span class="keyword">if</span> (keycode == <span class="number">0</span>) {</div><div class="line">                    LOGE(<span class="string">"%s:%d: expected keycode, got '%s'\n"</span>,</div><div class="line">                            filename, line, token.<span class="built_in">string</span>());</div><div class="line">                    <span class="keyword">goto</span> done;</div><div class="line">                }</div><div class="line">                state = FLAG;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> FLAG:</div><div class="line">                <span class="keyword">if</span> (token == <span class="string">"key"</span>) {</div><div class="line">                    <span class="keyword">if</span> (scancode != -<span class="number">1</span>) {</div><div class="line">                        <span class="comment">//LOGI("got key decl scancode=%d keycode=%d"</span></div><div class="line">                        <span class="comment">//       " flags=0x%08x\n", scancode, keycode, flags);</span></div><div class="line">                        Key k = { keycode, flags };</div><div class="line">                        m_keys.add(scancode, k);</div><div class="line">                        state = SCANCODE;</div><div class="line">                        scancode = -<span class="number">1</span>;</div><div class="line">                        keycode = -<span class="number">1</span>;</div><div class="line">                        flags = <span class="number">0</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                tmp = token_to_value(token.<span class="built_in">string</span>(), FLAGS);</div><div class="line">                <span class="comment">//LOGI("%s:%d: got flags %x for %s\n", filename, line, tmp, token.string() );</span></div><div class="line">                <span class="keyword">if</span> (tmp == <span class="number">0</span>) {</div><div class="line">                    LOGE(<span class="string">"%s:%d: expected flag, got '%s'\n"</span>,</div><div class="line">                            filename, line, token.<span class="built_in">string</span>());</div><div class="line">                    <span class="keyword">goto</span> done;</div><div class="line">                }</div><div class="line">                flags |= tmp;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (state == FLAG && scancode != -<span class="number">1</span> ) {</div><div class="line">        <span class="comment">//LOGI("got key decl scancode=%d keycode=%d"</span></div><div class="line">        <span class="comment">//       " flags=0x%08x\n", scancode, keycode, flags);</span></div><div class="line">        Key k = { keycode, flags };</div><div class="line">        m_keys.add(scancode, k);</div><div class="line">    }</div><div class="line"></div><div class="line">done:</div><div class="line">    <span class="built_in">free</span>(buf);</div><div class="line">    close(fd);</div><div class="line"></div><div class="line">    m_status = err;</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看得出，android 会解析 kl 文件里的项目，然后把解析后的结果保存到一个 Vector 结构里（android 自己写一个 vector，不是 c++ std 的）。 kl 文件的每一项分为4段：</p>
<ul>
<li><p><strong>BEGIN</strong><br>这一段统一是 “key”，应该是按键映射的标识。</p>
</li>
<li><p><strong>SCANCODE</strong><br>这一段直接将字符串转化为数字，也就是说 kl 文件里的这一段存储的是数字。这里值就是从低层硬件读取出来值。也就是我们在 OM  项目中， vfb 应该发送给 android 的值。这个值不是 android sdk 中描述的值（这个值是上层应用使用的）。不同的硬件会不一样。</p>
</li>
<li><p><strong>KEYCODE</strong><br>这个值就是 android sdk 里描述的啦。不过这一段有很多都是字符串，不是直接保存数值的，这个有个转化关系，具体的后面再说。</p>
</li>
<li><p><strong>FLAG</strong><br>这里目前来说就2个值 WAKE 和 WAKE_DROPPED 。好像 WAKE 代表可以在锁机状态下唤醒屏幕。</p>
</li>
</ul>
<h2 id="KeycodeLabels-h">KeycodeLabels.h</h2>
<p>上面说了 KEYCODE 那里很多是保存字符串的，那么转化的地方就在这个文件里（这个文件在 framework/base/include/ui 下）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> KeycodeLabel {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *literal;</div><div class="line">    <span class="keyword">int</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 这里不贴全了，都在这</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> KeycodeLabel KEYCODES[] = { </div><div class="line">    { <span class="string">"SOFT_LEFT"</span>, <span class="number">1</span> },</div><div class="line">    { <span class="string">"SOFT_RIGHT"</span>, <span class="number">2</span> },</div><div class="line">    { <span class="string">"HOME"</span>, <span class="number">3</span> },</div><div class="line">    { <span class="string">"BACK"</span>, <span class="number">4</span> },</div><div class="line">    { <span class="string">"CALL"</span>, <span class="number">5</span> },</div><div class="line">    { <span class="string">"ENDCALL"</span>, <span class="number">6</span> },</div><div class="line">    { <span class="string">"0"</span>, <span class="number">7</span> },</div><div class="line">    { <span class="string">"1"</span>, <span class="number">8</span> },</div><div class="line">    { <span class="string">"2"</span>, <span class="number">9</span> },</div><div class="line">    { <span class="string">"3"</span>, <span class="number">10</span> },</div><div class="line">    { <span class="string">"4"</span>, <span class="number">11</span> },</div><div class="line">    { <span class="string">"5"</span>, <span class="number">12</span> },</div><div class="line">    { <span class="string">"6"</span>, <span class="number">13</span> },</div><div class="line">    { <span class="string">"7"</span>, <span class="number">14</span> },</div><div class="line">    { <span class="string">"8"</span>, <span class="number">15</span> },</div><div class="line">    { <span class="string">"9"</span>, <span class="number">16</span> },</div><div class="line">    { <span class="string">"STAR"</span>, <span class="number">17</span> },</div><div class="line">    { <span class="string">"POUND"</span>, <span class="number">18</span> },</div><div class="line">    { <span class="string">"DPAD_UP"</span>, <span class="number">19</span> },</div><div class="line">    ... ...</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面说的那个 load 代码里 KEYCODE 那一段的 keycode = token_to_value(token.string(), KEYCODES); 中的 token_to_value 就是通过上面这个数组来得到对应的数值的。这个数值就是 android sdk 里写的给上层应用程序使用的按键值了。所以一般来说，我们修改 kl 文件就可以改变按键映射了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%204.0%20%E8%AE%BF%E9%97%AE%20WebService%20%E5%87%BA%E7%8E%B0%20android.os.NetworkOnMainThreadException%20%E5%BC%82%E5%B8%B8/</loc>
    <lastmod>2015-01-27T15:30:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 4.0 访问 WebService 出现 android.os.NetworkOnMainThreadException 异常</title>
        <pubTime>2015-01-25T15:30:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>在开发涉及 WebService 的 Android 程序是出现了个很烦恼的错误 android.os.NetworkOnMainThreadException，找了很久才找到解决方案，可能在 Android 3.0 以上的版本都有这个问题，貌似他们在3.0以上的版本网络上做了更加严格的限制，更多的查询API上的StrictMode 。这个是由于在主线程中访问 Web API 很有可能会阻塞 UI 线程，所以 Android 就禁止你在主线程里访问 Web API 了。</p>
<h2 id="方法一：">方法一：</h2>
<p>在访问前调用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>(){</div><div class="line">    StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</div><div class="line">        .detectDiskReads()</div><div class="line">        .detectDiskWrites()</div><div class="line">        .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></div><div class="line">        .penaltyLog()</div><div class="line">        .build());</div><div class="line"></div><div class="line">    StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</div><div class="line">        .detectLeakedSqlLiteObjects()</div><div class="line">        .detectLeakedClosableObjects()</div><div class="line">        .penaltyLog()</div><div class="line">        .penaltyDeath()</div><div class="line">        .build());</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="方法二：">方法二：</h2>
<p>不要在主线程里访问 Web API，开个线程来访问（例如 new Thread 或者 AsyncTask 之类的）。这种方法也是 Android 推荐的方法。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/%E7%BC%96%E8%AF%91%20Android%20%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-27T15:28:16.000Z</lastmod>
    <data>
        <display>
        <title>编译 Android 源码问题总结</title>
        <pubTime>2015-01-27T15:28:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="如何在_Android-mk_中添加自定义库">如何在 Android.mk 中添加自定义库</h2>
<p>在编译 android 模块的时候，有时候想自己添加一些自己的东西，或者是说链接一些额外的库（例如说自己写的）。这个时候需要去修改 Android.mk 文件。这里以 android 中简单的 toolbox 模块为例说明。例如说要在 toolbox 中加一个自己的命令，除了编写相应的 .c 文件文件外（例如 myhello.c），Android.mk 中要这么改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// myhello 是你自己加的命令</span></div><div class="line">TOOLS := \</div><div class="line">    myhello \</div><div class="line">    ls \</div><div class="line">    mount \</div><div class="line">    cat \</div><div class="line">    ps \</div><div class="line">    kill \</div><div class="line">    ln \</div><div class="line">    insmod \</div><div class="line">    rmmod \</div><div class="line">    lsmod \</div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="comment">// 默认的是只有 libcutils 和 libc 的，后面的那个 libmyhello 假设就是你要链接的库（你自己写的那个）</span></div><div class="line"><span class="comment">// 动态库是加到 LOCAL_SHARED_LIBRARIES 这个变量，静态库是加到 LOCAL_STATIC_LIBRARIES 这个变量</span></div><div class="line"><span class="comment">// 动态库还需要把你的库复制到 obj/lib 下（弄个连接也可以，运行的时候要把你的库弄到 system/lib 下 ）</span></div><div class="line"><span class="comment">// 动态库和静态库是不一样的，具体的可以通过出错信息来看（mm showcommands）</span></div><div class="line"><span class="comment">// 然后后面那个 LOCAL_LDFLAGS 可以用来设置一些额外链接信息</span></div><div class="line"><span class="comment">// 像这里我链接了 x11 的库，不过一般在 android 里是用不到这个库的</span></div><div class="line">LOCAL_SHARED_LIBRARIES := libcutils libc libmyhello</div><div class="line">OLD_LDFLAGS := $(LOCAL_LDFLAGS)</div><div class="line">LOCAL_LDFLAGS = $(OLD_LDFLAGS) -L/usr/lib -lX11</div><div class="line"></div><div class="line">... ...</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="编译_framework_自动增加自定义资源">编译 framework 自动增加自定义资源</h2>
<p>在定制 framework 的一些模块的时候（例如 framework-res、SystemUI、Launcher 等），有些时候需要增加一些自己的资源（图片、xml 等）。官方预留了一个路径： device/xx(oem)/xx(product)/overlay 。在这个下面可以覆盖一些原有的资源文件（官方的原意应该是主要给 OEM 改一些 config 的）。我们可以把自己的新增的资源文件加如到自己的模块对应的路径下。不过对于新增的资源，需要在 xml 中声明：。</p>
<pre config="brush:bash;toolbar:false;">
# type 是资源类型（integer 等），name 就是资源的名字了
add-resource type="xx" name="xx"
</pre>

<p>不过每一个资源都要加这个声明确实比较烦，可以在模块的 Android.mk 文件中增加了一个标志，让系统在编译的时候帮你自动添加这个 add-resource。增加这个标志：</p>
<pre config="brush:bash;toolbar:false;">
LOCAL_AAPT_FLAGS := --auto-add-overlay
</pre>

<h2 id="增加_overlay_文件夹">增加 overlay 文件夹</h2>
<p>为了方便 OEM 定制， android 中在很多个地方可以增加 overlay 文件夹，覆盖一些 xml 中的定义和替换资源文件（图片等）。其中一个地方就是 /device/vendor/product 下面，例如说 asus 代工的 nexus7 的可以是 /device/asus/flo/overlay。但是新增文件夹还需要告诉编译系统 overlay 的路径是什么。在 /device/vendor/product 下面自定义的 mk（例如说 BoardConfig.mk，在哪个 mk 文件里加可以看自己的具体情况） 文件中加上一句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#override </div><div class="line">DEVICE_PACKAGE_OVERLAYS := device/$(vendor)/$(TARGET_PRODUCT)/overlay</div><div class="line"></div></pre></td></tr></table></figure>

<p>配合上面那个自动增加自定义资源的更好用 ^_^ </p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/Android%20MiniGUI%20Recovery%20%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-27T15:26:16.000Z</lastmod>
    <data>
        <display>
        <title>Android MiniGUI Recovery 笔记</title>
        <pubTime>2015-01-27T15:26:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>minigui </tag>
         
         <content><![CDATA[<p>用 MiniGUI 整的 recovery UI。</p>
<h2 id="关于_recovery_模式下的调试">关于 recovery 模式下的调试</h2>
<p>我们常说的 recovery 模式其实就是没有启动 android 框架的 linux（可能还少了一些服务）。在这个模式下仍然可以启动 adb 服务进行调试。由于 recovery 的分区比较小，所以在调试的时候，可以把应用程序放到别的分区去跑。例如 /data 分区。</p>
<h2 id="ial">ial</h2>
<p>通过 zte blade 的实验和 cm 的代码，发现 /dev/input/event0 是按键设备文件，/dev/input/event3 是触屏设备文件。应该从这个设备读出触屏数据转化成 ial 层的坐标就行了吧。</p>
<h3 id="2011-12-28">2011.12.28</h3>
<p>更正下之前说。 在 recovery 模式下的输入驱动。android 应该是启了一个线程在等待 /dev/input 下的一组设备的输入事件(event0, event1, event2 等等，最大从 cm 的代码里来看有个宏定义是16个，相关代码在 /android/bootable/recovery/minui/events.c)。使用 poll() 函数就能等待一组设备。使用的好像是 linux 的标准输入事件（用的是 <linux input.h=""> 里定义的接口）。可以照搬 events.c 里代码，写个简单的 main 函数的程序打印出打开的设备路径、名字和相应得到的数据出来看看。在正常 android 启动的环境下。可以使用在 adb shell 下用 getevent 来看看正常启动 android 机子所有的输入设备情况。</linux></p>
<p>哎，后面没下文了，腰斩了 … …</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/Android%20Root%20Recovery%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-27T15:21:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Root Recovery 学习笔记</title>
        <pubTime>2015-01-27T15:21:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>喜欢折腾 android 的继续往下看吧。</p>
<h2 id="Root">Root</h2>
<p>首先先说下 android 获取 root 权限的原理。android 是基于 linux 系统的，所以 android 获取 root 权限就是差一个 su 命令，当然为了更好的管理 root 权限还差一个管理权限的应用层软件 superuser.apk。那获取 root 权限就是把 su 放到 /system/bin 下和把 sueruser.apk 放到 /system/app 下就行了。但是 android 的 system 分区是只读的。目前的破解方法都是根据系统的漏洞（adb 守护进程，这个进程自己有 root 权限），来临时获取 root 权限，然后把 system 分区挂载成可读写的，然后把那2个东西放到相应的目录就行了。</p>
<h2 id="android_的系统漏洞">android 的系统漏洞</h2>
<p>这里我就帖几个网站吧，有人已经分析过了。目前来说主要就是 psneuter, zergRush, RageAgainstTheCage? 这几个小程序。其中有几个漏洞在高的 android 版本中已经被修复了，不过我相信迟早还会有新的漏洞被发现的。顺带说一句：如果你是自己做 rom 的话，就不用这么麻烦的了，直接集成进去就行了。</p>
<ul>
<li><a href="http://blog.claudxiao.net/2011/04/android-adb-setuid/" title="Android adb setuid提权漏洞的分析" target="_blank" rel="external">Android adb setuid提权漏洞的分析</a></li>
<li><a href="http://blog.claudxiao.net/2011/10/zergrush/" title="Android提权代码zergRush分析" target="_blank" rel="external">Android提权代码zergRush分析</a></li>
<li><a href="http://blog.csdn.net/AndyTsui/article/details/6535085" title="一键获取android手机 root权限" target="_blank" rel="external">一键获取android手机 root权限</a></li>
</ul>
<h2 id="手动_root_你的手机">手动 root 你的手机</h2>
<h3 id="工具">工具</h3>
<ul>
<li>你手机的 usb 驱动，有些手机不需要，有些需要，自己去官网或者开发网站找吧。</li>
<li>adb 这个不用说了，android sdk 里就有。</li>
<li>临时获取 root 权限的工具（就是上面说的那几个利用 android 系统漏洞的程序）。</li>
<li>busybox, su, superuser.apk 。 这里有下载，可能不是最新的但是基本上能用。</li>
</ul>
<h3 id="步骤">步骤</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">adb <span class="keyword">push</span> busybox /data/<span class="keyword">local</span>/</div><div class="line">adb <span class="keyword">push</span> psneuter /data/<span class="keyword">local</span>/</div><div class="line">adb <span class="keyword">push</span> su /data/<span class="keyword">local</span>/</div><div class="line">adb shell <span class="keyword">chmod</span> <span class="number">777</span> /data/<span class="keyword">local</span>/busybox</div><div class="line">adb shell <span class="keyword">chmod</span> <span class="number">777</span> /data/<span class="keyword">local</span>/psneuter</div><div class="line">adb shell</div><div class="line">/data/<span class="keyword">local</span>/psneuter</div><div class="line">adb shell</div><div class="line">mount -o remount,rw -t ext3 /dev/block/mmcblk0p25 /<span class="keyword">system</span></div><div class="line"><span class="keyword">mkdir</span> /<span class="keyword">system</span>/xbin</div><div class="line">/data/<span class="keyword">local</span>/busybox cp /data/<span class="keyword">local</span>/su /<span class="keyword">system</span>/xbin/su</div><div class="line"><span class="keyword">chown</span> <span class="number">0</span>:<span class="number">0</span> /<span class="keyword">system</span>/xbin/su</div><div class="line"><span class="keyword">chmod</span> <span class="number">6755</span> /<span class="keyword">system</span>/xbin/su</div><div class="line">ln -<span class="keyword">s</span> /<span class="keyword">system</span>/xbin/su /<span class="keyword">system</span>/bin/su</div><div class="line"><span class="keyword">exit</span></div><div class="line">adb <span class="keyword">push</span> Superuser.apk /<span class="keyword">system</span>/app/Superuser.apk</div></pre></td></tr></table></figure>

<p>注意：上面那个 /dev/block/mmcblk0p25 是指手机的 system 分区，不同的手机会不同。这个可以用 cat /proc/partitions 和 cat /proc/mounts 来判断自己手机的 system 分区是哪个一个。都弄好后就可以重启手机了。网上有个 superoneclick 的东西，其实就是把这些东西了自动化了而已，也可以自己写脚本。</p>
<h2 id="Recovery">Recovery</h2>
<p>暂无 … …</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/Android%20x86%20%E5%9C%A8%20X%20window%20system%20%E4%B8%8A%E7%9A%84%E8%B0%83%E7%A0%94/</loc>
    <lastmod>2015-01-27T15:14:16.000Z</lastmod>
    <data>
        <display>
        <title>Android x86 在 X window system 上的调研</title>
        <pubTime>2015-01-27T15:14:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>这个是以前弄到一个项目：把 Android 应用程序跑到 Meego。那个时候 Android 官方还不支持 X86 平台，所以折腾，现在 Android 官方支持了，这个其实就没什么用了，权当纪念一下以前扯蛋的项目吧。</p>
<h2 id="需求">需求</h2>
<p>我们的最终目的是为了让 Android 在 Meego 上（GUI 是 x86 的 X window system）能有接近原生的运行速度。这样的话就不能再采用 demo 里的 vfb 的做法。而应该是让 Android 直接在屏幕上进行绘制（显存中），并且充分的利用平台的硬件加速能力（Intel 945GME），例如使用硬件的 OpenGL 实现等。这样的话就需要利用 X window system 中的原生底层接口来实现 Android 的低层图形驱动模块。所以需要调研 X window system 的一些原理、用法、如何利用硬件加速的。</p>
<h2 id="相关名词">相关名词</h2>
<p>先大概的说一下一些相关的名词吧：（为了方便起见，以下的 Meego 都是说的 netbook 1.1 版本）</p>
<ul>
<li><p><strong>X window system</strong><br>由于其主版本号是 11，因此又叫 X11 。X11 是 linux 上的一个窗口系统，采用 C/S 模型，因此它可以方便的使用于网络中（分布式结构）。但是这也给我们的项目提供了困难，因为上网本上的 Meego 是确定只在本地使用的。X11 会有一个服务端，每一显示设备都是它的一个客户端。客户端通过发送请求到服务端申请显示设备，通过发送请求让服务器绘制图像显示到指定的显示设备上（一般是自己申请的那个）。Meego 上使用的 Xlib 是 1.3.3 的，Xorg-server 是 1.9.0 的，好像在后面的源码路径上都找不到版本一样的，只能找一些接近的了。源码在： <a href="http://www.x.org/releases/" title="X11源代码路径" target="_blank" rel="external">X11源代码路径</a>。</p>
</li>
<li><p><strong>Xlib</strong><br>X11 有很多个模块。Xlib 是它的基本模块，提供了一些基本的图形访问接口。此外 X11 还可以有一些列的扩展接口，只要符合 X11 的扩展规范，就可以。X11 上的 OpenGL 就是通过 X11 的扩展来衔接的。</p>
</li>
<li><p><strong>GLX</strong><br>OpenGL 是一个 3D 图形库，它是独立于窗口系统的。但是如果要在窗口系统中使用，这就必须要和窗口系统建立起联系，例如说如何在窗口中渲染 3D 图形等等。这样就需要一个桥梁来建立起 OpenGL 和本地窗口系统的衔接。在 X11 上这个就是 GLX 要做的事情（类似于嵌入式系统上的 EGL）。Meego 上使用的是 1.4 版本。其其源代码包括在 Mesa 里面。GLX 走的是 X11 的协议，是通过和 X server 打交道来进行渲染的，因此又叫作间接渲染（indirect render）。</p>
</li>
<li><p><strong>DRM &amp; DRI</strong><br>DRI 全称 Direct Rendering Infrastructure。由于 X11 是采用 C/S 架构的，客户端的任何操作都需要和服务器进行通讯，在实时的 3D 渲染上性能无法接受。因此就出现了 DRI 这种框架，在 X11 上能够允许直接访问硬件渲染器（显卡），从而直接将 3D 图形渲染到屏幕上，绕过 X11 ，提升性能，这种叫作直接渲染（direct render）。DRI 为上层 3D 库提供访问底层硬件的接口。DRM 全称 Direct Rendering Manager，从字面上理解为直接渲染管理器，是真正操作硬件的层次。各个硬件厂商负责提供各自硬件的 drm 模块（开源的提供源码、不开源的提供二进制文件）。DRI 通过调用 DRM 的接口来实现上层 3D 图形库的接口。HP mini 上使用的是 Intel 的 945GME 显卡，使用的 DRM 源码在：git://git.kernel.org/pub/scm/linux/kernel/git/ickle/drm-intel（git 路径）。DRI 的源码则在 Mesa 中。</p>
</li>
<li><p><strong>Mesa</strong><br>OpenGL 只是一个规范，它的实现有很多种。Mesa 是 OpenGL 在 linux 上的一个实现。Mesa 自身提供一套纯软件的 OpenGL 实现，能在各个平台运行 OpenGL 程序，不过速度非常慢。其中 Mesa 会根据系统平台的 dri 和 drm 情况调用硬件的 OpenGL 实现，这时就是硬件的 3D 加速，速度会比纯软件的快得多。从上面来看流程应该是： 3D app —&gt; Mesa(OpenGL API) —&gt; dri —&gt; drm —&gt; hardware。Meego 上使用的是 Mesa 7.9 。源码在：<a href="ftp://ftp.freedesktop.org/pub/mesa/" title="Mesa 源代码路径" target="_blank" rel="external">Mesa 源代码路径</a>。</p>
</li>
<li><p><strong>SDL</strong><br>SDL 是一个开源跨平台的图形库，它小巧、简单、快速，提供在 linux 上简单的 GUI 接口。目前的 vfb 就是用 SDL 实现的，在这个方面它比 Qt 简介、方便。在 Meego 上使用的是 1.2.14 版本。源代码在 <a href="http://www.libsdl.org/download-1.2.php" title="SDL源代码路径" target="_blank" rel="external">SDL源代码路径</a>。</p>
</li>
<li><p><strong>Mutter Window Manager</strong><br>X11 只是提供了一些基本的 GUI 元素，但是对于窗口如果显示、窗口移动了怎么办、窗口尺寸改变了又怎么办、多个窗口重叠在一起怎么显示等等，X11 是不会管的。这个些就需要一个叫做窗口管理系统的软件来管理。Meego 上使用的窗口管理系统就是 Mutter Window Manager 。一般 X11 上的窗口管理系统都是基于 Xlib 开发的。源代码在：<a href="http://ftp.acc.umu.se/pub/GNOME/sources/mutter/" title="Mutter源代码路径" target="_blank" rel="external">Mutter源代码路径</a> （在 Meego 源代码里也有）。</p>
</li>
<li><p><strong>Clutter</strong><br>Clutter是一个跨平台的图形库，能够支持 OpenGL。Mutter Window Manager 使用的图形库是就是 Clutter。Clutter 采用 glib 提供的 gobject 实现面向对象设计，采用多种 backend 的架构，实现了跨平台。在 linux 上使用的 backend 是 GLX 和 X11 。Meego 上使用的 Clutter 版本是 1.2.8。源码在：<a href="http://source.clutter-project.org/sources" title="Clutter源代码路径" target="_blank" rel="external">Clutter源代码路径</a></p>
</li>
<li><p><strong>Cogl</strong><br>在 Clutter 中使用的 OpenGL 接口。源代码包含在 Clutter 中。</p>
</li>
</ul>
<h2 id="实现思路">实现思路</h2>
<p>在 Android x86 的代码里，底层有一个叫 gralloc 的模块，是用来管理和分配显存的。我们只要能向 X11 拿到显存地址，就可以分配给上层 Android 程序，从而让 Android 直接绘制到屏幕上（相当于使用本地的一些接口实现 gralloc），这样可以去掉 vfb，这样可以让 Android 原生的跑在 X11 上。并且 Android 在 2D 的块传送上还有一个专门的硬件加速的 copyblt 的模块，我们如果通过 X11 的一些接口，或者是说直接通过显卡驱动的一些接口实现这个模块，也就能相应的完成 Android 2D 加速。至于 OpenGL 的 3D 模块，Android 完整的实现了一套软件的 OpenGL（好像是 ES 的），我们是不是可以用 Mesa 3D 的替换原来的。因此先需要了解 X11 上的绘图相关的东西，看看如果获取显存地址（像素地址）。</p>
<h2 id="Xlib_分析">Xlib 分析</h2>
<p>Xlib 是 X11 上最基本的东西了，这个是肯定是要研究下的。</p>
<h3 id="Xlib_基本数据结构">Xlib 基本数据结构</h3>
<ul>
<li><strong>Display</strong><br>若干个屏幕(Screen)以及一套输入设备（键盘和鼠标）构成一个 Display，Display 概念的关键就是有一套完整的输入输出。屏幕不一定必须是一个，可以有多个，各个屏幕可以用来显示相同的内容，也可以用来构成矩阵显示一个大屏幕的内容。X11 中客户端通过打开 Display 和服务器相连接。要在 X11 上创建一个窗口，第一步就是需要打开一个 Display。它的数据结构是：</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 X11/Xlib.h 中的定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line"><span class="preprocessor">#ifdef XLIB_ILLEGAL_ACCESS</span></div><div class="line">_XDisplay</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">{</div><div class="line">	XExtData *ext_data;	<span class="comment">/* hook for extension to hang data */</span></div><div class="line">	<span class="keyword">struct</span> _XPrivate *private1;</div><div class="line">	<span class="keyword">int</span> fd;			<span class="comment">/* Network socket. */</span></div><div class="line">	<span class="keyword">int</span> private2;</div><div class="line">	<span class="keyword">int</span> proto_major_version;<span class="comment">/* major version of server's X protocol */</span></div><div class="line">	<span class="keyword">int</span> proto_minor_version;<span class="comment">/* minor version of servers X protocol */</span></div><div class="line">	<span class="keyword">char</span> *vendor;		<span class="comment">/* vendor of the server hardware */</span></div><div class="line">        XID private3;</div><div class="line">	XID private4;</div><div class="line">	XID private5;</div><div class="line">	<span class="keyword">int</span> private6;</div><div class="line">	XID (*resource_alloc)(	<span class="comment">/* allocator function */</span></div><div class="line">		<span class="keyword">struct</span> _XDisplay*</div><div class="line">	);</div><div class="line">	<span class="keyword">int</span> byte_order;		<span class="comment">/* screen byte order, LSBFirst, MSBFirst */</span></div><div class="line">	<span class="keyword">int</span> bitmap_unit;	<span class="comment">/* padding and data requirements */</span></div><div class="line">	<span class="keyword">int</span> bitmap_pad;		<span class="comment">/* padding requirements on bitmaps */</span></div><div class="line">	<span class="keyword">int</span> bitmap_bit_order;	<span class="comment">/* LeastSignificant or MostSignificant */</span></div><div class="line">	<span class="keyword">int</span> nformats;		<span class="comment">/* number of pixmap formats in list */</span></div><div class="line">	ScreenFormat *pixmap_format;	<span class="comment">/* pixmap format list */</span></div><div class="line">	<span class="keyword">int</span> private8;</div><div class="line">	<span class="keyword">int</span> release;		<span class="comment">/* release of the server */</span></div><div class="line">	<span class="keyword">struct</span> _XPrivate *private9, *private10;</div><div class="line">	<span class="keyword">int</span> qlen;		<span class="comment">/* Length of input event queue */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_request_read; <span class="comment">/* seq number of last event read */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> request;	<span class="comment">/* sequence number of last request. */</span></div><div class="line">	XPointer private11;</div><div class="line">	XPointer private12;</div><div class="line">	XPointer private13;</div><div class="line">	XPointer private14;</div><div class="line">	<span class="keyword">unsigned</span> max_request_size; <span class="comment">/* maximum number 32 bit words in request*/</span></div><div class="line">	<span class="keyword">struct</span> _XrmHashBucketRec *db;</div><div class="line">	<span class="keyword">int</span> (*private15)(</div><div class="line">		<span class="keyword">struct</span> _XDisplay*</div><div class="line">		);</div><div class="line">	<span class="keyword">char</span> *display_name;	<span class="comment">/* "host:display" string used on this connect*/</span></div><div class="line">	<span class="keyword">int</span> default_screen;	<span class="comment">/* default screen for operations */</span></div><div class="line">	<span class="keyword">int</span> nscreens;		<span class="comment">/* number of screens on this server*/</span></div><div class="line">	Screen *screens;	<span class="comment">/* pointer to list of screens */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> motion_buffer;	<span class="comment">/* size of motion buffer */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> private16;</div><div class="line">	<span class="keyword">int</span> min_keycode;	<span class="comment">/* minimum defined keycode */</span></div><div class="line">	<span class="keyword">int</span> max_keycode;	<span class="comment">/* maximum defined keycode */</span></div><div class="line">	XPointer private17;</div><div class="line">	XPointer private18;</div><div class="line">	<span class="keyword">int</span> private19;</div><div class="line">	<span class="keyword">char</span> *xdefaults;	<span class="comment">/* contents of defaults from server */</span></div><div class="line">	<span class="comment">/* there is more to this structure, but it is private to Xlib */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 在 X11/Xlibint.h 中的定义</span></div><div class="line"><span class="keyword">struct</span> _XDisplay</div><div class="line">{</div><div class="line">	XExtData *ext_data;	<span class="comment">/* hook for extension to hang data */</span></div><div class="line">	<span class="keyword">struct</span> _XFreeFuncs *free_funcs; <span class="comment">/* internal free functions */</span></div><div class="line">	<span class="keyword">int</span> fd;			<span class="comment">/* Network socket. */</span></div><div class="line">	<span class="keyword">int</span> conn_checker;         <span class="comment">/* ugly thing used by _XEventsQueued */</span></div><div class="line">	<span class="keyword">int</span> proto_major_version;<span class="comment">/* maj. version of server's X protocol */</span></div><div class="line">	<span class="keyword">int</span> proto_minor_version;<span class="comment">/* minor version of server's X protocol */</span></div><div class="line">	<span class="keyword">char</span> *vendor;		<span class="comment">/* vendor of the server hardware */</span></div><div class="line">        XID resource_base;	<span class="comment">/* resource ID base */</span></div><div class="line">	XID resource_mask;	<span class="comment">/* resource ID mask bits */</span></div><div class="line">	XID resource_id;	<span class="comment">/* allocator current ID */</span></div><div class="line">	<span class="keyword">int</span> resource_shift;	<span class="comment">/* allocator shift to correct bits */</span></div><div class="line">	XID (*resource_alloc)(	<span class="comment">/* allocator function */</span></div><div class="line">		<span class="keyword">struct</span> _XDisplay*</div><div class="line">		);</div><div class="line">	<span class="keyword">int</span> byte_order;		<span class="comment">/* screen byte order, LSBFirst, MSBFirst */</span></div><div class="line">	<span class="keyword">int</span> bitmap_unit;	<span class="comment">/* padding and data requirements */</span></div><div class="line">	<span class="keyword">int</span> bitmap_pad;		<span class="comment">/* padding requirements on bitmaps */</span></div><div class="line">	<span class="keyword">int</span> bitmap_bit_order;	<span class="comment">/* LeastSignificant or MostSignificant */</span></div><div class="line">	<span class="keyword">int</span> nformats;		<span class="comment">/* number of pixmap formats in list */</span></div><div class="line">	ScreenFormat *pixmap_format;	<span class="comment">/* pixmap format list */</span></div><div class="line">	<span class="keyword">int</span> vnumber;		<span class="comment">/* Xlib's X protocol version number. */</span></div><div class="line">	<span class="keyword">int</span> release;		<span class="comment">/* release of the server */</span></div><div class="line">	<span class="keyword">struct</span> _XSQEvent *head, *tail;	<span class="comment">/* Input event queue. */</span></div><div class="line">	<span class="keyword">int</span> qlen;		<span class="comment">/* Length of input event queue */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_request_read; <span class="comment">/* seq number of last event read */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> request;	<span class="comment">/* sequence number of last request. */</span></div><div class="line">	<span class="keyword">char</span> *last_req;		<span class="comment">/* beginning of last request, or dummy */</span></div><div class="line">	<span class="keyword">char</span> *buffer;		<span class="comment">/* Output buffer starting address. */</span></div><div class="line">	<span class="keyword">char</span> *bufptr;		<span class="comment">/* Output buffer index pointer. */</span></div><div class="line">	<span class="keyword">char</span> *bufmax;		<span class="comment">/* Output buffer maximum+1 address. */</span></div><div class="line">	<span class="keyword">unsigned</span> max_request_size; <span class="comment">/* maximum number 32 bit words in request*/</span></div><div class="line">	<span class="keyword">struct</span> _XrmHashBucketRec *db;</div><div class="line">	<span class="keyword">int</span> (*synchandler)(	<span class="comment">/* Synchronization handler */</span></div><div class="line">		<span class="keyword">struct</span> _XDisplay*</div><div class="line">		);</div><div class="line">	<span class="keyword">char</span> *display_name;	<span class="comment">/* "host:display" string used on this connect*/</span></div><div class="line">	<span class="keyword">int</span> default_screen;	<span class="comment">/* default screen for operations */</span></div><div class="line">	<span class="keyword">int</span> nscreens;		<span class="comment">/* number of screens on this server*/</span></div><div class="line">	Screen *screens;	<span class="comment">/* pointer to list of screens */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> motion_buffer;	<span class="comment">/* size of motion buffer */</span></div><div class="line">	<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;	   <span class="comment">/* internal connection flags */</span></div><div class="line">	<span class="keyword">int</span> min_keycode;	<span class="comment">/* minimum defined keycode */</span></div><div class="line">	<span class="keyword">int</span> max_keycode;	<span class="comment">/* maximum defined keycode */</span></div><div class="line">	KeySym *keysyms;	<span class="comment">/* This server's keysyms */</span></div><div class="line">	XModifierKeymap *modifiermap;	<span class="comment">/* This server's modifier keymap */</span></div><div class="line">	<span class="keyword">int</span> keysyms_per_keycode;<span class="comment">/* number of rows */</span></div><div class="line">	<span class="keyword">char</span> *xdefaults;	<span class="comment">/* contents of defaults from server */</span></div><div class="line">	<span class="keyword">char</span> *scratch_buffer;	<span class="comment">/* place to hang scratch buffer */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> scratch_length;	<span class="comment">/* length of scratch buffer */</span></div><div class="line">	<span class="keyword">int</span> ext_number;		<span class="comment">/* extension number on this display */</span></div><div class="line">	<span class="keyword">struct</span> _XExten *ext_procs; <span class="comment">/* extensions initialized on this display */</span></div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">	 * the following can be fixed size, as the protocol defines how</span></div><div class="line"><span class="comment">	 * much address space is available.</span></div><div class="line"><span class="comment">	 * While this could be done using the extension vector, there</span></div><div class="line"><span class="comment">	 * may be MANY events processed, so a search through the extension</span></div><div class="line"><span class="comment">	 * list to find the right procedure for each event might be</span></div><div class="line"><span class="comment">	 * expensive if many extensions are being used.</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	Bool (*event_vec[<span class="number">128</span>])(	<span class="comment">/* vector for wire to event */</span></div><div class="line">		Display *	<span class="comment">/* dpy */</span>,</div><div class="line">		XEvent *	<span class="comment">/* re */</span>,</div><div class="line">		xEvent *	<span class="comment">/* event */</span></div><div class="line">		);</div><div class="line">	Status (*wire_vec[<span class="number">128</span>])( <span class="comment">/* vector for event to wire */</span></div><div class="line">		Display *	<span class="comment">/* dpy */</span>,</div><div class="line">		XEvent *	<span class="comment">/* re */</span>,</div><div class="line">		xEvent *	<span class="comment">/* event */</span></div><div class="line">		);</div><div class="line">	KeySym lock_meaning;	   <span class="comment">/* for XLookupString */</span></div><div class="line">	<span class="keyword">struct</span> _XLockInfo *lock;   <span class="comment">/* multi-thread state, display lock */</span></div><div class="line">	<span class="keyword">struct</span> _XInternalAsync *async_handlers; <span class="comment">/* for internal async */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bigreq_size; <span class="comment">/* max size of big requests */</span></div><div class="line">	<span class="keyword">struct</span> _XLockPtrs *lock_fns; <span class="comment">/* pointers to threads functions */</span></div><div class="line">	<span class="keyword">void</span> (*idlist_alloc)(	   <span class="comment">/* XID list allocator function */</span></div><div class="line">		Display *	<span class="comment">/* dpy */</span>,</div><div class="line">		XID *		<span class="comment">/* ids */</span>,</div><div class="line">		<span class="keyword">int</span>		<span class="comment">/* count */</span></div><div class="line">		);</div><div class="line">	<span class="comment">/* things above this line should not move, for binary compatibility */</span></div><div class="line">	<span class="keyword">struct</span> _XKeytrans *key_bindings; <span class="comment">/* for XLookupString */</span></div><div class="line">	Font cursor_font;	   <span class="comment">/* for XCreateFontCursor */</span></div><div class="line">	<span class="keyword">struct</span> _XDisplayAtoms *atoms; <span class="comment">/* for XInternAtom */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mode_switch;  <span class="comment">/* keyboard group modifiers */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_lock;  <span class="comment">/* keyboard numlock modifiers */</span></div><div class="line">	<span class="keyword">struct</span> _XContextDB *context_db; <span class="comment">/* context database */</span></div><div class="line">	Bool (**error_vec)(	<span class="comment">/* vector for wire to error */</span></div><div class="line">		Display     *	<span class="comment">/* display */</span>,</div><div class="line">		XErrorEvent *	<span class="comment">/* he */</span>,</div><div class="line">		xError      *	<span class="comment">/* we */</span></div><div class="line">		);</div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">	 * Xcms information</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="keyword">struct</span> {</div><div class="line">	   XPointer defaultCCCs;  <span class="comment">/* pointer to an array of default XcmsCCC */</span></div><div class="line">	   XPointer clientCmaps;  <span class="comment">/* pointer to linked list of XcmsCmapRec */</span></div><div class="line">	   XPointer perVisualIntensityMaps;</div><div class="line">				  <span class="comment">/* linked list of XcmsIntensityMap */</span></div><div class="line">	} cms;</div><div class="line">	<span class="keyword">struct</span> _XIMFilter *im_filters;</div><div class="line">	<span class="keyword">struct</span> _XSQEvent *qfree; <span class="comment">/* unallocated event queue elements */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> next_event_serial_num; <span class="comment">/* inserted into next queue elt */</span></div><div class="line">	<span class="keyword">struct</span> _XExten *flushes; <span class="comment">/* Flush hooks */</span></div><div class="line">	<span class="keyword">struct</span> _XConnectionInfo *im_fd_info; <span class="comment">/* _XRegisterInternalConnection */</span></div><div class="line">	<span class="keyword">int</span> im_fd_length;	<span class="comment">/* number of im_fd_info */</span></div><div class="line">	<span class="keyword">struct</span> _XConnWatchInfo *conn_watchers; <span class="comment">/* XAddConnectionWatch */</span></div><div class="line">	<span class="keyword">int</span> watcher_count;	<span class="comment">/* number of conn_watchers */</span></div><div class="line">	XPointer filedes;	<span class="comment">/* struct pollfd cache for _XWaitForReadable */</span></div><div class="line">	<span class="keyword">int</span> (*savedsynchandler)( <span class="comment">/* user synchandler when Xlib usurps */</span></div><div class="line">		Display *	<span class="comment">/* dpy */</span></div><div class="line">		);</div><div class="line">	XID resource_max;	<span class="comment">/* allocator max ID */</span></div><div class="line">	<span class="keyword">int</span> xcmisc_opcode;	<span class="comment">/* major opcode for XC-MISC */</span></div><div class="line">	<span class="keyword">struct</span> _XkbInfoRec *xkb_info; <span class="comment">/* XKB info */</span></div><div class="line">	<span class="keyword">struct</span> _XtransConnInfo *trans_conn; <span class="comment">/* transport connection object */</span></div><div class="line">	<span class="keyword">struct</span> _X11XCBPrivate *xcb; <span class="comment">/* XCB glue private data */</span></div><div class="line"></div><div class="line">	<span class="comment">/* Generic event cookie handling */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> next_cookie; <span class="comment">/* next event cookie */</span></div><div class="line">	<span class="comment">/* vector for wire to generic event, index is (extension - 128) */</span></div><div class="line">	Bool (*generic_event_vec[<span class="number">128</span>])(</div><div class="line">		Display *	<span class="comment">/* dpy */</span>,</div><div class="line">		XGenericEventCookie *	<span class="comment">/* Xlib event */</span>,</div><div class="line">		xEvent *	<span class="comment">/* wire event */</span>);</div><div class="line">	<span class="comment">/* vector for event copy, index is (extension - 128) */</span></div><div class="line">	Bool (*generic_event_copy_vec[<span class="number">128</span>])(</div><div class="line">		Display *	<span class="comment">/* dpy */</span>,</div><div class="line">		XGenericEventCookie *	<span class="comment">/* in */</span>,</div><div class="line">		XGenericEventCookie *   <span class="comment">/* out*/</span>);</div><div class="line">	<span class="keyword">void</span> *cookiejar;  <span class="comment">/* cookie events returned but not claimed */</span></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>其中第一个定义是暴露给外部应用程序使用的，第二个定义在 X11 内部使用的。可以看到第一个里面的一些 private* ，在第二个中都有了相应的定义，并且它们所占用的存储空间都是一样的，而且第一个在最后还提示了，后面的部分是 Xlib 私有的。</p>
<ul>
<li><strong>Screen</strong><br>Screen 的层次在 Display 之下，是 X server 显示管理的次级单位。一个 Screen 对应一个根窗口（root window），根窗口的大小与 Screen 相同。如果在命令行执行 “X” 的话，启动了 X server，这时在屏幕上看到一个单调的桌面，以及一个 “X” 形的鼠标，不过因为没有启动 window manager，所以什么都不能做，只能动动鼠标。这时你看到的这个单调的“桌面”正是根窗口。它的数据结构如下：</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 X11/xlib.h 中的定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">	XExtData *ext_data;	<span class="comment">/* hook for extension to hang data */</span></div><div class="line">	<span class="keyword">struct</span> _XDisplay *display;<span class="comment">/* back pointer to display structure */</span></div><div class="line">	Window root;		<span class="comment">/* Root window id. */</span></div><div class="line">	<span class="keyword">int</span> width, height;	<span class="comment">/* width and height of screen */</span></div><div class="line">	<span class="keyword">int</span> mwidth, mheight;	<span class="comment">/* width and height of  in millimeters */</span></div><div class="line">	<span class="keyword">int</span> ndepths;		<span class="comment">/* number of depths possible */</span></div><div class="line">	Depth *depths;		<span class="comment">/* list of allowable depths on the screen */</span></div><div class="line">	<span class="keyword">int</span> root_depth;		<span class="comment">/* bits per pixel */</span></div><div class="line">	Visual *root_visual;	<span class="comment">/* root visual */</span></div><div class="line">	GC default_gc;		<span class="comment">/* GC for the root root visual */</span></div><div class="line">	Colormap cmap;		<span class="comment">/* default color map */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> white_pixel;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> black_pixel;	<span class="comment">/* White and Black pixel values */</span></div><div class="line">	<span class="keyword">int</span> max_maps, min_maps;	<span class="comment">/* max and min color maps */</span></div><div class="line">	<span class="keyword">int</span> backing_store;	<span class="comment">/* Never, WhenMapped, Always */</span></div><div class="line">	Bool save_unders;</div><div class="line">	<span class="keyword">long</span> root_input_mask;	<span class="comment">/* initial root input mask */</span></div><div class="line">} Screen;</div><div class="line"></div></pre></td></tr></table></figure>

<p>其中包括的一些看看注释也就知道是什么了。</p>
<ul>
<li><strong>GC</strong><br>Graphic Context：X11 上的绘图上下文，类似于 MiniGUI 里的 DC 概念。它的数据结构是：</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 X11/xlib.h 中的定义</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Data structure for setting graphics context.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</div><div class="line">	<span class="keyword">int</span> function;		<span class="comment">/* logical operation */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> plane_mask;<span class="comment">/* plane mask */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> foreground;<span class="comment">/* foreground pixel */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> background;<span class="comment">/* background pixel */</span></div><div class="line">	<span class="keyword">int</span> line_width;		<span class="comment">/* line width */</span></div><div class="line">	<span class="keyword">int</span> line_style;	 	<span class="comment">/* LineSolid, LineOnOffDash, LineDoubleDash */</span></div><div class="line">	<span class="keyword">int</span> cap_style;	  	<span class="comment">/* CapNotLast, CapButt,</span></div><div class="line"><span class="comment">				   CapRound, CapProjecting */</span></div><div class="line">	<span class="keyword">int</span> join_style;	 	<span class="comment">/* JoinMiter, JoinRound, JoinBevel */</span></div><div class="line">	<span class="keyword">int</span> fill_style;	 	<span class="comment">/* FillSolid, FillTiled,</span></div><div class="line"><span class="comment">				   FillStippled, FillOpaeueStippled */</span></div><div class="line">	<span class="keyword">int</span> fill_rule;	  	<span class="comment">/* EvenOddRule, WindingRule */</span></div><div class="line">	<span class="keyword">int</span> arc_mode;		<span class="comment">/* ArcChord, ArcPieSlice */</span></div><div class="line">	Pixmap tile;		<span class="comment">/* tile pixmap for tiling operations */</span></div><div class="line">	Pixmap stipple;		<span class="comment">/* stipple 1 plane pixmap for stipping */</span></div><div class="line">	<span class="keyword">int</span> ts_x_origin;	<span class="comment">/* offset for tile or stipple operations */</span></div><div class="line">	<span class="keyword">int</span> ts_y_origin;</div><div class="line">        Font font;	        <span class="comment">/* default text font for text operations */</span></div><div class="line">	<span class="keyword">int</span> subwindow_mode;     <span class="comment">/* ClipByChildren, IncludeInferiors */</span></div><div class="line">	Bool graphics_exposures;<span class="comment">/* boolean, should exposures be generated */</span></div><div class="line">	<span class="keyword">int</span> clip_x_origin;	<span class="comment">/* origin for clipping */</span></div><div class="line">	<span class="keyword">int</span> clip_y_origin;</div><div class="line">	Pixmap clip_mask;	<span class="comment">/* bitmap clipping; other calls for rects */</span></div><div class="line">	<span class="keyword">int</span> dash_offset;	<span class="comment">/* patterned/dashed line information */</span></div><div class="line">	<span class="keyword">char</span> dashes;</div><div class="line">} XGCValues;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Graphics context.  The contents of this structure are implementation</span></div><div class="line"><span class="comment"> * dependent.  A GC should be treated as opaque by application code.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _XGC</div><div class="line"><span class="preprocessor">#ifdef XLIB_ILLEGAL_ACCESS</span></div><div class="line">{</div><div class="line">    XExtData *ext_data;	<span class="comment">/* hook for extension to hang data */</span></div><div class="line">    GContext gid;	<span class="comment">/* protocol ID for graphics context */</span></div><div class="line">    <span class="comment">/* there is more to this structure, but it is private to Xlib */</span></div><div class="line">}</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">*GC;</div><div class="line"></div><div class="line"><span class="comment">// 在 X11/xlibint.h 中的定义</span></div><div class="line"><span class="keyword">struct</span> _XGC</div><div class="line">{</div><div class="line">    XExtData *ext_data;	<span class="comment">/* hook for extension to hang data */</span></div><div class="line">    GContext gid;	<span class="comment">/* protocol ID for graphics context */</span></div><div class="line">    Bool rects;		<span class="comment">/* boolean: TRUE if clipmask is list of rectangles */</span></div><div class="line">    Bool dashes;	<span class="comment">/* boolean: TRUE if dash-list is really a list */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dirty;<span class="comment">/* cache dirty bits */</span></div><div class="line">    XGCValues values;	<span class="comment">/* shadow structure of values */</span></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>和 Display 的定义类似的，暴露的结构数据比较少。</p>
<ul>
<li><strong>Window</strong><br>这个就是 X11 里的窗口的概念了。不过它的定义和别的 GUI 不太一样。它在 X11/X.h 里被简单的定义成： </li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 X11/X.h 中定义</span></div><div class="line"><span class="keyword">typedef</span> CARD32 XID;</div><div class="line"><span class="keyword">typedef</span> XID Window;</div><div class="line"></div><div class="line"><span class="comment">// 在 X11/Xmd.h 中定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> CARD32;</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看得到这个其实是一个 32位 的 ID 号。而不像其它 GUI 中包括一些什么窗口的标题、矩形区域大小、绘图上下文等等。这些可能保存在 X 服务器那一端吧，因为 X11 是 C/S 架构的，所以通过一个唯一的 ID 号来进行传送效率会比较高吧。这里需要说明下，这个就已经是 X11 上能够绘制图像的东西了，可以说类似 MiniGUI Surface 一样的东西了，只不过你无法通过这个变量直接拿到里面的数据。要想获得一些相关的数据，好像需要通过 X11 的协议向 X 服务器发送相应的请求。</p>
<ul>
<li><p><strong>Pixmap</strong><br>这个是 X11 上另一个可以绘制图像的东西。它和上面 Window 的区别在于：Window 的绘制是直接在屏幕上的，而 Pixmap 的绘制是离屏的（类似 MiniGUI 的 on-screen surface 和 off-screen surface）。它在 X11/X.h 中也被简单的定义成：typedef XID Pixmap; 。同样是一个 ID 号。</p>
</li>
<li><p><strong>Drawable</strong><br>这个也是一个 ID 号： typedef XID Drawable; 。上面说了 X11 中可以绘制的东西分为2种：on-screen 的 Window 和 off-sreen 的 Pixmap，这个 Drawable 就是指向其中的某一种的。也就是说一个 Drawable 不是 Window 就是 Pixmap，这里可能是为了方便某些地方的统一处理吧。</p>
</li>
</ul>
<h3 id="基本使用流程">基本使用流程</h3>
<p>下面说下在 X11 上创建一个窗口的基本流程：</p>
<ul>
<li><p><strong>XOpenDisplay</strong><br>首先需要调用 XOpenDisplay  打开显示设备。这个函数会返回一个 Display 指针。一般传入 NULL 会使用环境变量中 DISPLAY 设定的值。</p>
</li>
<li><p><strong>DefaultScreen</strong><br>然后调用 DefaultScreen 得到默认的 Screen。一般是传入 XOpenDisplay 得到的 display。</p>
</li>
<li><p><strong>XCreateWindow</strong><br>然后是通过 XCreateWindow 创建窗口。这个 API 需要传入大量的参数：例如 display 指针、父窗口 ID 号（第一个窗口的父窗口是 root window）、矩形区域、色深、颜色格式、窗口属性数组等等。这个具体的看附件的教程资料吧，东西太多了。有个简单的接口叫 XCreateSimpleWindow 。</p>
</li>
<li><p><strong>XMapWindow</strong><br>创建了窗口后，不会马上显示，需要用这个 API 之后才会显示。</p>
</li>
<li><p><strong>XCreateGC</strong><br>通过之前创建的 display 和 drawable（window）创建 GC，通过这个 GC 就可以在创建的 window 上进行绘图了。 附件里有个小例子。</p>
</li>
</ul>
<h3 id="Xlib_线索">Xlib 线索</h3>
<p>查找了下 Xlib 的 API 手册，没发现有可以直接使用的 API 能拿到像素地址的。不过想想也是，应该是没有哪个 GUI 库会直接提供 API 让应用程序来直接读写 surface 的像素地址的，因为这样对于普通的应用程序来说还是比较危险的，很容易造成显示上的问题。特别是对于 C/S 架构的 X11 来说。并且通过前面的讨论也无法直接从一些核心的图形数据结构上直接拿到（像 Window 这样的类型直接就是一个 ID 号）。API 手册上有几个 API 倒是可以把 Drawable 中的像素数据复制出来，但是是复制出来的，不是 Drawable 原始的像素数据。但是既然它能够从 Drawable 中复制出数据，那就是说明它肯定是可以访问得到 Drawable 原始的像素数据的，至少可以拿得到它的地址。所以我觉得我们可以参照下这些 API 的实现，自己改装下，应该也可以拿得到像素数据地址。其中的一个 API 是：</p>
<ul>
<li><strong>XGetImage</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数的流程是先通过 GetReq 填写向 X 服务器要发送的请求。</span></div><div class="line"><span class="comment">// 然后调用 _XReply 向 X 服务器发送获取给定窗口图像的请求，并且等待服务器返回数据。</span></div><div class="line"><span class="comment">// 然后当 _XReply 正确返回后，调用 _XReadPad 通过 X 服务器返回过来的偏移量计算出图像的像素地址。</span></div><div class="line"><span class="comment">// 然后根据这个像素地址调用 XCreateImage 创建一个新的 XImage ，最后返回。</span></div><div class="line"><span class="comment">// 这里返回的是复制过的，所以我们可以参考它是如果像 X11 拿像素地址的</span></div><div class="line"><span class="comment">// _XReply 和 _XReadPad 的代码就不贴了，都是在 Xlib 库的源代码里的</span></div><div class="line">XImage *XGetImage (</div><div class="line">     <span class="keyword">register</span> Display *dpy,</div><div class="line">     Drawable d,</div><div class="line">     <span class="keyword">int</span> x,</div><div class="line">     <span class="keyword">int</span> y,</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> height,</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> plane_mask,</div><div class="line">     <span class="keyword">int</span> format)	<span class="comment">/* either XYPixmap or ZPixmap */</span></div><div class="line">{</div><div class="line">	xGetImageReply rep;</div><div class="line">	<span class="keyword">register</span> xGetImageReq *req;</div><div class="line">	<span class="keyword">char</span> *data;</div><div class="line">	<span class="keyword">long</span> nbytes;</div><div class="line">	XImage *image;</div><div class="line">	LockDisplay(dpy);</div><div class="line">	GetReq (GetImage, req);</div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">	 * first set up the standard stuff in the request</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	req-&gt;drawable = d;</div><div class="line">	req-&gt;x = x;</div><div class="line">	req-&gt;y = y;</div><div class="line">	req-&gt;width = width;</div><div class="line">	req-&gt;height = height;</div><div class="line">	req-&gt;planeMask = plane_mask;</div><div class="line">	req-&gt;format = format;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (_XReply (dpy, (xReply *) &rep, <span class="number">0</span>, xFalse) == <span class="number">0</span> ||</div><div class="line">	    rep.length == <span class="number">0</span>) {</div><div class="line">		UnlockDisplay(dpy);</div><div class="line">		SyncHandle();</div><div class="line">		<span class="keyword">return</span> (XImage *)NULL;</div><div class="line">	}</div><div class="line"></div><div class="line">	nbytes = (<span class="keyword">long</span>)rep.length &lt;&lt; <span class="number">2</span>;</div><div class="line">	data = (<span class="keyword">char</span> *) Xmalloc((<span class="keyword">unsigned</span>) nbytes);</div><div class="line">	<span class="keyword">if</span> (! data) {</div><div class="line">	    _XEatData(dpy, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) nbytes);</div><div class="line">	    UnlockDisplay(dpy);</div><div class="line">	    SyncHandle();</div><div class="line">	    <span class="keyword">return</span> (XImage *) NULL;</div><div class="line">	}</div><div class="line">        _XReadPad (dpy, data, nbytes);</div><div class="line">        <span class="keyword">if</span> (format == XYPixmap)</div><div class="line">	   image = XCreateImage(dpy, _XVIDtoVisual(dpy, rep.visual),</div><div class="line">		  Ones (plane_mask &</div><div class="line">			(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0xFFFFFFFF</span>) &gt;&gt; (<span class="number">32</span> - rep.depth))),</div><div class="line">		  format, <span class="number">0</span>, data, width, height, dpy-&gt;bitmap_pad, <span class="number">0</span>);</div><div class="line">	<span class="keyword">else</span> <span class="comment">/* format == ZPixmap */</span></div><div class="line">           image = XCreateImage (dpy, _XVIDtoVisual(dpy, rep.visual),</div><div class="line">		 rep.depth, ZPixmap, <span class="number">0</span>, data, width, height,</div><div class="line">		  _XGetScanlinePad(dpy, (<span class="keyword">int</span>) rep.depth), <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!image)</div><div class="line">	    Xfree(data);</div><div class="line">	UnlockDisplay(dpy);</div><div class="line">	SyncHandle();</div><div class="line">	<span class="keyword">return</span> (image);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>不过这个函数需要调用一些 Xlib 内部使用的函数。不知道能不能方便的扣出来使用。并且估计这个拿到的应该是虚拟地址，而不是物理地址。</p>
<h2 id="X_server_分析">X server 分析</h2>
<p>X11 很多东西都是通过向 X server 发送请求来完成的。所有其实有很多核心的东西是在 X server 这边的。包括低层的打开 framebuffer 设备等等，应该都是在 X server 这边实现的。</p>
<h3 id="X_server_基本数据结构">X server 基本数据结构</h3>
<p>之前在 Xlib 那边说过很多结构都是一个 ID 号，其实在 X server 这边都对应一个数据结构。</p>
<ul>
<li><strong>Screen</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Screen {</div><div class="line">    <span class="keyword">int</span>			myNum;	<span class="comment">/* index of this instance in Screens[] */</span></div><div class="line">    ATOM		id;</div><div class="line">    <span class="keyword">short</span>		x, y, width, height;</div><div class="line">    <span class="keyword">short</span>		mmWidth, mmHeight;</div><div class="line">    <span class="keyword">short</span>		numDepths;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>      	rootDepth;</div><div class="line">    DepthPtr       	allowedDepths;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>      	rootVisual;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	defColormap;</div><div class="line">    <span class="keyword">short</span>		minInstalledCmaps, maxInstalledCmaps;</div><div class="line">    <span class="keyword">char</span>                backingStoreSupport, saveUnderSupport;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	whitePixel, blackPixel;</div><div class="line">    GCPtr		GCperDepth[MAXFORMATS+<span class="number">1</span>];</div><div class="line">			<span class="comment">/* next field is a stipple to use as default in</span></div><div class="line"><span class="comment">			   a GC.  we don't build default tiles of all depths</span></div><div class="line"><span class="comment">			   because they are likely to be of a color</span></div><div class="line"><span class="comment">			   different from the default fg pixel, so</span></div><div class="line"><span class="comment">			   we don't win anything by building</span></div><div class="line"><span class="comment">			   a standard one.</span></div><div class="line"><span class="comment">			*/</span></div><div class="line">    PixmapPtr		PixmapPerDepth[<span class="number">1</span>];</div><div class="line">    pointer		devPrivate;</div><div class="line">    <span class="keyword">short</span>       	numVisuals;</div><div class="line">    VisualPtr		visuals;</div><div class="line">    WindowPtr		root;</div><div class="line">    ScreenSaverStuffRec screensaver;</div><div class="line"></div><div class="line">    <span class="comment">/* Random screen procedures */</span></div><div class="line"></div><div class="line">    CloseScreenProcPtr		CloseScreen;</div><div class="line">    QueryBestSizeProcPtr	QueryBestSize;</div><div class="line">    SaveScreenProcPtr		SaveScreen;</div><div class="line">    GetImageProcPtr		GetImage;</div><div class="line">    GetSpansProcPtr		GetSpans;</div><div class="line">    SourceValidateProcPtr	SourceValidate;</div><div class="line"></div><div class="line">    <span class="comment">/* Window Procedures */</span></div><div class="line"></div><div class="line">    CreateWindowProcPtr		CreateWindow;</div><div class="line">    DestroyWindowProcPtr	DestroyWindow;</div><div class="line">    PositionWindowProcPtr	PositionWindow;</div><div class="line">    ChangeWindowAttributesProcPtr ChangeWindowAttributes;</div><div class="line">    RealizeWindowProcPtr	RealizeWindow;</div><div class="line">    UnrealizeWindowProcPtr	UnrealizeWindow;</div><div class="line">    ValidateTreeProcPtr		ValidateTree;</div><div class="line">    PostValidateTreeProcPtr	PostValidateTree;</div><div class="line">    WindowExposuresProcPtr	WindowExposures;</div><div class="line">    CopyWindowProcPtr		CopyWindow;</div><div class="line">    ClearToBackgroundProcPtr	ClearToBackground;</div><div class="line">    ClipNotifyProcPtr		ClipNotify;</div><div class="line">    RestackWindowProcPtr	RestackWindow;</div><div class="line"></div><div class="line">    <span class="comment">/* Pixmap procedures */</span></div><div class="line"></div><div class="line">    CreatePixmapProcPtr		CreatePixmap;</div><div class="line">    DestroyPixmapProcPtr	DestroyPixmap;</div><div class="line"></div><div class="line">    <span class="comment">/* Backing store procedures */</span></div><div class="line"></div><div class="line">    SaveDoomedAreasProcPtr	SaveDoomedAreas;</div><div class="line">    RestoreAreasProcPtr		RestoreAreas;</div><div class="line">    ExposeCopyProcPtr		ExposeCopy;</div><div class="line">    TranslateBackingStoreProcPtr TranslateBackingStore;</div><div class="line">    ClearBackingStoreProcPtr	ClearBackingStore;</div><div class="line">    DrawGuaranteeProcPtr	DrawGuarantee;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * A read/write copy of the lower level backing store vector is needed now</span></div><div class="line"><span class="comment">     * that the functions can be wrapped.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    BSFuncRec			BackingStoreFuncs;</div><div class="line">    </div><div class="line">    <span class="comment">/* Font procedures */</span></div><div class="line"></div><div class="line">    RealizeFontProcPtr		RealizeFont;</div><div class="line">    UnrealizeFontProcPtr	UnrealizeFont;</div><div class="line"></div><div class="line">    <span class="comment">/* Cursor Procedures */</span></div><div class="line"></div><div class="line">    ConstrainCursorProcPtr	ConstrainCursor;</div><div class="line">    CursorLimitsProcPtr		CursorLimits;</div><div class="line">    DisplayCursorProcPtr	DisplayCursor;</div><div class="line">    RealizeCursorProcPtr	RealizeCursor;</div><div class="line">    UnrealizeCursorProcPtr	UnrealizeCursor;</div><div class="line">    RecolorCursorProcPtr	RecolorCursor;</div><div class="line">    SetCursorPositionProcPtr	SetCursorPosition;</div><div class="line"></div><div class="line">    <span class="comment">/* GC procedures */</span></div><div class="line"></div><div class="line">    CreateGCProcPtr		CreateGC;</div><div class="line"></div><div class="line">    <span class="comment">/* Colormap procedures */</span></div><div class="line"></div><div class="line">    CreateColormapProcPtr	CreateColormap;</div><div class="line">    DestroyColormapProcPtr	DestroyColormap;</div><div class="line">    InstallColormapProcPtr	InstallColormap;</div><div class="line">    UninstallColormapProcPtr	UninstallColormap;</div><div class="line">    ListInstalledColormapsProcPtr ListInstalledColormaps;</div><div class="line">    StoreColorsProcPtr		StoreColors;</div><div class="line">    ResolveColorProcPtr		ResolveColor;</div><div class="line"></div><div class="line">    <span class="comment">/* Region procedures */</span></div><div class="line"></div><div class="line">    BitmapToRegionProcPtr	BitmapToRegion;</div><div class="line">    SendGraphicsExposeProcPtr	SendGraphicsExpose;</div><div class="line"></div><div class="line">    <span class="comment">/* os layer procedures */</span></div><div class="line"></div><div class="line">    ScreenBlockHandlerProcPtr	BlockHandler;</div><div class="line">    ScreenWakeupHandlerProcPtr	WakeupHandler;</div><div class="line"></div><div class="line">    pointer blockData;</div><div class="line">    pointer wakeupData;</div><div class="line"></div><div class="line">    <span class="comment">/* anybody can get a piece of this array */</span></div><div class="line">    PrivateRec	*devPrivates;</div><div class="line"></div><div class="line">    CreateScreenResourcesProcPtr CreateScreenResources;</div><div class="line">    ModifyPixmapHeaderProcPtr	ModifyPixmapHeader;</div><div class="line"></div><div class="line">    GetWindowPixmapProcPtr	GetWindowPixmap;</div><div class="line">    SetWindowPixmapProcPtr	SetWindowPixmap;</div><div class="line">    GetScreenPixmapProcPtr	GetScreenPixmap;</div><div class="line">    SetScreenPixmapProcPtr	SetScreenPixmap;</div><div class="line"></div><div class="line">    PixmapPtr pScratchPixmap;		<span class="comment">/* scratch pixmap "pool" */</span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		totalPixmapSize;</div><div class="line"></div><div class="line">    MarkWindowProcPtr		MarkWindow;</div><div class="line">    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;</div><div class="line">    ChangeSaveUnderProcPtr	ChangeSaveUnder;</div><div class="line">    PostChangeSaveUnderProcPtr	PostChangeSaveUnder;</div><div class="line">    ConfigNotifyProcPtr		ConfigNotify;</div><div class="line">    MoveWindowProcPtr		MoveWindow;</div><div class="line">    ResizeWindowProcPtr		ResizeWindow;</div><div class="line">    GetLayerWindowProcPtr	GetLayerWindow;</div><div class="line">    HandleExposuresProcPtr	HandleExposures;</div><div class="line">    ReparentWindowProcPtr	ReparentWindow;</div><div class="line"></div><div class="line">    SetShapeProcPtr		SetShape;</div><div class="line"></div><div class="line">    ChangeBorderWidthProcPtr	ChangeBorderWidth;</div><div class="line">    MarkUnrealizedWindowProcPtr	MarkUnrealizedWindow;</div><div class="line"></div><div class="line">    <span class="comment">/* Device cursor procedures */</span></div><div class="line">    DeviceCursorInitializeProcPtr DeviceCursorInitialize;</div><div class="line">    DeviceCursorCleanupProcPtr    DeviceCursorCleanup;</div><div class="line">} ScreenRec;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 Screen 是 X server 这边使用的，和 Xlib 那边的不一样。其中有很多回调函数指针，从名字可以看到很多都是一些核心的图形功能的，例如创建窗口、创建GC 等等。这些回调函数在初始化时被设置成和 framebuffer 操作相关的函数。这个在 xserver 的代码目录的 fb/fbscreen.c 的 fbSetupScreen 函数里可以看得到，而这个函数会在初始化的时候被调用，具体的大家可以自己去跟下代码。</p>
<ul>
<li><strong>GC</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* there is padding in the bit fields because the Sun compiler doesn't</span></div><div class="line"><span class="comment"> * force alignment to 32-bit boundaries.  losers.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _GC {</div><div class="line">    ScreenPtr		pScreen;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	depth;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	alu;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	lineWidth;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	dashOffset;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	numInDashList;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	*dash;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	lineStyle : <span class="number">2</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	capStyle : <span class="number">2</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	joinStyle : <span class="number">2</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	fillStyle : <span class="number">2</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	fillRule : <span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 	arcMode : <span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	subWindowMode : <span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	graphicsExposures : <span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	clientClipType : <span class="number">2</span>; <span class="comment">/* CT_&lt;kind&gt; */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	miTranslate:<span class="number">1</span>; <span class="comment">/* should mi things translate? */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	tileIsPixel:<span class="number">1</span>; <span class="comment">/* tile is solid pixel */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	fExpose:<span class="number">1</span>;     <span class="comment">/* Call exposure handling */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	freeCompClip:<span class="number">1</span>;  <span class="comment">/* Free composite clip */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	scratch_inuse:<span class="number">1</span>; <span class="comment">/* is this GC in a pool for reuse? */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	unused:<span class="number">13</span>; <span class="comment">/* see comment above */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	planemask;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	fgPixel;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	bgPixel;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * alas -- both tile and stipple must be here as they</span></div><div class="line"><span class="comment">     * are independently specifiable</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    PixUnion		tile;</div><div class="line">    PixmapPtr		stipple;</div><div class="line">    DDXPointRec		patOrg;		<span class="comment">/* origin for (tile, stipple) */</span></div><div class="line">    <span class="keyword">struct</span> _Font	*font;</div><div class="line">    DDXPointRec		clipOrg;</div><div class="line">    DDXPointRec		lastWinOrg;	<span class="comment">/* position of window last validated */</span></div><div class="line">    pointer		clientClip;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	stateChanges;	<span class="comment">/* masked with GC_&lt;kind&gt; */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       serialNumber;</div><div class="line">    GCFuncs		*funcs;</div><div class="line">    GCOps		*ops;</div><div class="line">    PrivateRec		*devPrivates;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The following were moved here from private storage to allow device-</span></div><div class="line"><span class="comment">     * independent access to them from screen wrappers.</span></div><div class="line"><span class="comment">     * --- 1997.11.03  Marc Aurele La France (tsi@xfree86.org)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    PixmapPtr		pRotatedPixmap; <span class="comment">/* tile/stipple rotated for alignment */</span></div><div class="line">    RegionPtr		pCompositeClip;</div><div class="line">    <span class="comment">/* fExpose & freeCompClip defined above */</span></div><div class="line">} GC;</div><div class="line"></div></pre></td></tr></table></figure>

<p>同样是 X server 这边使用的 GC。其中 ops 这个结构里是一大堆类似 GDI 的回调函数指针（），也是在初始化的时候被设置的。具体的还没怎么仔细看。</p>
<ul>
<li><strong>Window</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Window {</div><div class="line">    DrawableRec	drawable;</div><div class="line">    PrivateRec		*devPrivates;</div><div class="line">    WindowPtr		parent;		<span class="comment">/* ancestor chain */</span></div><div class="line">    WindowPtr		nextSib;	<span class="comment">/* next lower sibling */</span></div><div class="line">    WindowPtr		prevSib;	<span class="comment">/* next higher sibling */</span></div><div class="line">    WindowPtr		firstChild;	<span class="comment">/* top-most child */</span></div><div class="line">    WindowPtr		lastChild;	<span class="comment">/* bottom-most child */</span></div><div class="line">    RegionRec		clipList;	<span class="comment">/* clipping rectangle for output */</span></div><div class="line">    RegionRec		borderClip;	<span class="comment">/* NotClippedByChildren + border */</span></div><div class="line">    <span class="keyword">union</span> _Validate	*valdata;</div><div class="line">    RegionRec		winSize;</div><div class="line">    RegionRec		borderSize;</div><div class="line">    DDXPointRec		origin;		<span class="comment">/* position relative to parent */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	borderWidth;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	deliverableEvents; <span class="comment">/* all masks from all clients */</span></div><div class="line">    Mask		eventMask;      <span class="comment">/* mask from the creating client */</span></div><div class="line">    PixUnion		background;</div><div class="line">    PixUnion		border;</div><div class="line">    pointer		backStorage;	<span class="comment">/* null when BS disabled */</span></div><div class="line">    WindowOptPtr	optional;</div><div class="line">    <span class="keyword">unsigned</span>		backgroundState:<span class="number">2</span>; <span class="comment">/* None, Relative, Pixel, Pixmap */</span></div><div class="line">    <span class="keyword">unsigned</span>		borderIsPixel:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>		cursorIsNone:<span class="number">1</span>;	<span class="comment">/* else real cursor (might inherit) */</span></div><div class="line">    <span class="keyword">unsigned</span>		backingStore:<span class="number">2</span>;</div><div class="line">    <span class="keyword">unsigned</span>		saveUnder:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>		DIXsaveUnder:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>		bitGravity:<span class="number">4</span>;</div><div class="line">    <span class="keyword">unsigned</span>		winGravity:<span class="number">4</span>;</div><div class="line">    <span class="keyword">unsigned</span>		overrideRedirect:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>		visibility:<span class="number">2</span>;</div><div class="line">    <span class="keyword">unsigned</span>		mapped:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span>		realized:<span class="number">1</span>;	<span class="comment">/* ancestors are all mapped */</span></div><div class="line">    <span class="keyword">unsigned</span>		viewable:<span class="number">1</span>;	<span class="comment">/* realized && InputOutput */</span></div><div class="line">    <span class="keyword">unsigned</span>		dontPropagate:<span class="number">3</span>;<span class="comment">/* index into DontPropagateMasks */</span></div><div class="line">    <span class="keyword">unsigned</span>		forcedBS:<span class="number">1</span>;	<span class="comment">/* system-supplied backingStore */</span></div><div class="line">    <span class="keyword">unsigned</span>		redirectDraw:<span class="number">2</span>;	<span class="comment">/* COMPOSITE rendering redirect */</span></div><div class="line">    <span class="keyword">unsigned</span>		forcedBG:<span class="number">1</span>;	<span class="comment">/* must have an opaque background */</span></div><div class="line"><span class="preprocessor">#ifdef ROOTLESS</span></div><div class="line">    <span class="keyword">unsigned</span>		rootlessUnhittable:<span class="number">1</span>;	<span class="comment">/* doesn't hit-test */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">} WindowRec;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个就有点类似 MiniGUI 里的 MainWnd 结构了，有剪切域、父子指针、私有结构、DC（Drawable）等这些东西。</p>
<ul>
<li><strong>Pixmap</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Pixmap {</div><div class="line">    DrawableRec		drawable;</div><div class="line">    PrivateRec		*devPrivates;</div><div class="line">    <span class="keyword">int</span>			refcnt;</div><div class="line">    <span class="keyword">int</span>			devKind; <span class="comment">/* This is the pitch of the pixmap, typically width*bpp/8. */</span></div><div class="line">    DevUnion		devPrivate; <span class="comment">/* When !NULL, devPrivate.ptr points to the raw pixel data. */</span></div><div class="line"><span class="preprocessor">#ifdef COMPOSITE</span></div><div class="line">    <span class="keyword">short</span>		screen_x;</div><div class="line">    <span class="keyword">short</span>		screen_y;</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    <span class="keyword">unsigned</span>		usage_hint; <span class="comment">/* see CREATE_PIXMAP_USAGE_* */</span></div><div class="line">} PixmapRec;</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实从 X server 的代码里看，X 中的 surface 都应该是 Pixmap 类型来的。就算是之前说的 Window 类型，它也会从它的结构里取出 Pixmap 变量来进行操作。看代码，估计 pixels 数据就在 devPrivates 这个指针指向的结构里面。不过这个类型的定义我还没看到在哪，不知道被藏到哪个地方去了。</p>
<ul>
<li><strong>Drawable</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Drawable {</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	type;	<span class="comment">/* DRAWABLE_&lt;type&gt; */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	<span class="keyword">class</span>;	<span class="comment">/* specific to type */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	depth;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>	bitsPerPixel;</div><div class="line">    XID			id;	<span class="comment">/* resource id */</span></div><div class="line">    <span class="keyword">short</span>		x;	<span class="comment">/* window: screen absolute, pixmap: 0 */</span></div><div class="line">    <span class="keyword">short</span>		y;	<span class="comment">/* window: screen absolute, pixmap: 0 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	width;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>	height;</div><div class="line">    ScreenPtr		pScreen;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	serialNumber;</div><div class="line">} DrawableRec;</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="GLX_分析">GLX 分析</h2>
<p>GLX 是衔接 OpenGL 和 X11 的桥梁，OpenGL 是通过 GLX 来获取渲染的 Buffer 地址的。也许我们可以通过 GLX 来获取像素地址。</p>
<h3 id="GLX_基本数据结构">GLX 基本数据结构</h3>
<ul>
<li><strong>GLXContext</strong><br>这个是 GLX 的绘图上下文，类似 X11 的 GC，MiniGUI 的 DC。在 Mesa-7.9 里的定义是：</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __GLXcontextRec *GLXContext;</div><div class="line"><span class="keyword">typedef</span> XID GLXPixmap;</div><div class="line"><span class="keyword">typedef</span> XID GLXDrawable;</div><div class="line"><span class="comment">/* GLX 1.3 and later */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __GLXFBConfigRec *GLXFBConfig;</div><div class="line"><span class="keyword">typedef</span> XID GLXFBConfigID;</div><div class="line"><span class="keyword">typedef</span> XID GLXContextID;</div><div class="line"><span class="keyword">typedef</span> XID GLXWindow;</div><div class="line"><span class="keyword">typedef</span> XID GLXPbuffer;</div><div class="line"></div><div class="line"><span class="comment">/* The GLX API dispatcher (i.e. this code) is being built into stand-alone</span></div><div class="line"><span class="comment"> * Mesa.  We don't know anything about XFree86 or real GLX so we define a</span></div><div class="line"><span class="comment"> * minimal __GLXContextRec here so some of the functions in this file can</span></div><div class="line"><span class="comment"> * work properly.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __GLXcontextRec {</div><div class="line">   Display *currentDpy;</div><div class="line">   GLboolean isDirect;</div><div class="line">   GLXDrawable currentDrawable;</div><div class="line">   GLXDrawable currentReadable;</div><div class="line">   XID xid;</div><div class="line">} __GLXcontext;</div><div class="line"></div></pre></td></tr></table></figure>

<p>从注视可以看得到，这个其实并不是 HP mini 上 Meego 使用的 GLX 的定义，因为这个应该是和具体的硬件驱动有关的（drm-intel ？？），但是从上面也看得到这个 GLXContext 的最小结构是什么。包括有 X11 的显示设备指针 Display*、是否是直接渲染的标志（DRI）、当前的 Drawable （这个应该就是 surface）、最后一个是一个 ID 号。</p>
<ul>
<li><p><strong>GLXDrawable</strong><br>这个的定义也在上面，基本上就是等同于 X11 的 Drawable，并且在 OpenGL 的官方文档中也是这么直接了当的说的（官方的 glx 1.3 说明文档在附件中）。它也是可以指向 GLXWindow 或是 GLXPixmap。</p>
</li>
<li><p><strong>GLXWindow</strong><br>上面已经说的很清楚了，等于 X11 的 Window。</p>
</li>
<li><p><strong>GLXPixmap</strong><br>上面也说清楚了，等于 X11 的 Pixmap。</p>
</li>
</ul>
<h3 id="GLX_线索">GLX 线索</h3>
<p>从这里看来从 GLX 的核心数据结构里也无法直接拿到像素地址。最后还是走到 X11 那里去了。不过也许可以通过 GLX 访问 DRI 的一些接口，从而拿到物理的显存地址。不过这个我还没研究过。</p>
<h2 id="SDL_分析">SDL 分析</h2>
<p>SDL 是之前用于 vfb 的一个图形库，它比较简单，接近底层，应该是会有可能从它这里拿到像素地址，并且它已经把 OpenGL 封装好了。</p>
<h3 id="SDL_基本数据结构">SDL 基本数据结构</h3>
<ul>
<li><strong>SDL_Surface</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SDL_Surface {</div><div class="line">	Uint32 flags;				<span class="comment">/**&lt; Read-only */</span></div><div class="line">	SDL_PixelFormat *format;		<span class="comment">/**&lt; Read-only */</span></div><div class="line">	<span class="keyword">int</span> w, h;				<span class="comment">/**&lt; Read-only */</span></div><div class="line">	Uint16 pitch;				<span class="comment">/**&lt; Read-only */</span></div><div class="line">	<span class="keyword">void</span> *pixels;				<span class="comment">/**&lt; Read-write */</span></div><div class="line">	<span class="keyword">int</span> offset;				<span class="comment">/**&lt; Private */</span></div><div class="line"></div><div class="line">	<span class="comment">/** Hardware-specific surface info */</span></div><div class="line">	<span class="keyword">struct</span> private_hwdata *hwdata;</div><div class="line"></div><div class="line">	<span class="comment">/** clipping information */</span></div><div class="line">	SDL_Rect clip_rect;			<span class="comment">/**&lt; Read-only */</span></div><div class="line">	Uint32 unused1;				<span class="comment">/**&lt; for binary compatibility */</span></div><div class="line"></div><div class="line">	<span class="comment">/** Allow recursive locks */</span></div><div class="line">	Uint32 locked;				<span class="comment">/**&lt; Private */</span></div><div class="line"></div><div class="line">	<span class="comment">/** info for fast blit mapping to other surfaces */</span></div><div class="line">	<span class="keyword">struct</span> SDL_BlitMap *<span class="built_in">map</span>;		<span class="comment">/**&lt; Private */</span></div><div class="line"></div><div class="line">	<span class="comment">/** format version, bumped at every change to invalidate blit maps */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> format_version;		<span class="comment">/**&lt; Private */</span></div><div class="line"></div><div class="line">	<span class="comment">/** Reference count -- used when freeing surface */</span></div><div class="line">	<span class="keyword">int</span> refcount;				<span class="comment">/**&lt; Read-mostly */</span></div><div class="line">} SDL_Surface;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个是很直接的一个数据的结构，和 MiniGUI 的 Surface 很像（好像 MiniGUI 也借鉴了 SDL 的一些东西）。其中的 pixels 确实就是像素地址。但是不同的 video （MiniGUI 的 gal 概念），这个值的含义确实不一样的。在 X11 的 video 中这个地址不是直接的窗口的像素地址。而是一个 SDL 自己创建的基于 Display 的一个共享 XImage 对象的内存的地址。SDL 自己创建这个 XImage，然后 SDL 所有的绘制接口都在这个 XImage 上进行，最后在 SDL_UpdateRect 的时候再讲这个共享的 XImage 送到 X11 上，然后屏幕上才会显示更新的。我曾经试过了直接写这个地址，屏幕是不会变化的，必须要调用 SDL_UpdateRect 后，屏幕才会有变化。而且 SDL 的代码里就是这样写的，可以自己去看：在 /src/video/x11/SDL_x11image.c 里。而且这还是要 SDL 能够创建硬件的 surface 才行，要是颜色格式不对，导致 SDL 使用软件 surface 的话，那就完全软件来实现这些画图工作了。并且还有一点，这还不能开启 SDL 的 OpenGL 窗口，如果开启了 OpenGL 窗口的话，这个 surface 就基本没啥用了（这个时候 surface 里的一些相关数据基本上全是0），都必须要用 OpenGL 的接口才能画得出东西来了。如果你想继续画 2D 的东西的话，按照 SDL 官网的建议，要自己创建一个软件的 SDL_Surface ，画好后，把它转化成 OpenGL texture，然后贴到 OpenGL 的模型上。X11 video 的私有结构数据里包括了一些 X11 显示相关的变量：Display、Window 等，代码就不贴了，在 src/video/SDL_x11video.h 里。X11 video 的 gl 私有数据则包括了 GLX 绘图上下文：GLXContext 等，同样不贴代码了，在 src/video/SDL_x11gl_c.h 里。</p>
<h3 id="SDL_线索">SDL 线索</h3>
<p>从上面可以看得出 2D 的 SDL 的话，要获取窗口的像素地址，还是需要走 X11 的路线。而 OpenGL 的 SDL，则需要走 GLX 的路线。看样子从这里得不到什么好处呢。</p>
<h2 id="Mutter（Clutter）分析">Mutter（Clutter）分析</h2>
<p>做为窗口管理系统，它会负责处理当多个窗口重叠在一起时如果混合显示。现在某些桌面开启了某些特效之后，一些窗口会透过底下的窗口显示。因为有些功能，Mutter 这也许可以拿得到窗口的 surface 像素地址。</p>
<h3 id="Clutter_绘制流程">Clutter 绘制流程</h3>
<p>和上面的分析不一样，先介绍下 Mutter（Clutter）的绘制流程（我是跟踪 Mutter 显示一个窗口的流程的）。现在是在 Mutter 这边：</p>
<ol>
<li>在 Mutter 中显示窗口的 API 是 meta_compositor_show_window ，这个函数里会调用 meta_compositor_show_window 。</li>
<li>meta_compositor_show_window 最后回调用 Clutter 的 clutter_actor_show_all 。</li>
</ol>
<p>现在是到 Clutter 这边来了，先说 Clutter 中的一些基本概念。在 Clutter 中有一个叫 Stage 的东西，这个类似 Window 的概念；然后还有一个叫 Actor 的东西，这个类似于 Window 里面的控件、widget 之类的。所有的 Actor 都在 Stage 中，然后各自负责自己的东西（绘制、移动等等），然后在 Stage 上展示出来。从概念上来说将 GUI 类比成演员在舞台上表演、然后开发人员是导演，指挥这些演员演出，感觉还是挺形象的。Clutter 也是采用 backend 的设计来实现跨平台的，在 linux 上的 backend 是 GLX 和 X11 （代码里是只有 GLX 这个 backend 的，但是 GLX 继承自 X11）。</p>
<ol>
<li>clutter_actor_show_all 会调用 ClutterActorClass 的 show_all 函数指针，这个在 ClutterActorClass 类初始化的时候（之前说了 Clutter 是采用 gobject 的东西来设计的）是指向 clutter_actor_show 的。</li>
<li>clutter_actor_show 会调用 clutter_actor_queue_redraw 。</li>
<li>clutter_actor_queue_redraw 会调用 clutter_actor_queue_redraw_with_origin。</li>
<li>clutter_queue_redraw_with_origin 里会发射一个 gtk 的信号，看注释说默认的处理函数是 clutter_redraw。</li>
<li>clutter_redraw 会将一个重绘的标志置为 TRUE，然后开启一个时钟（定时器？？）。</li>
<li>在时钟的回调函数里会调用 _clutter_stage_do_update。</li>
<li>_clutter_stage_do_update 会调用 _clutter_do_redraw。</li>
<li>_clutter_do_redraw 会调用 _clutter_bakcend_redraw。</li>
<li>_clutter_backend_redraw 会调用当前 backend 的 redraw，这里是 clutter_backend_glx_redraw 。</li>
<li>clutter_backend_glx_redraw 会调用 clutter_stage_glx_redraw 。</li>
<li>在 clutter_stage_glx_redraw 会调用 clutter_actor_paint 让 actor 重画（这个函数好像是让 actor 真正的渲染到 display 上，这个 display 应该是 X11 里的那个 display 结构）。然后会根据当前是否支持 copy_sub_buffer 这个操作（这个是根据是否能取得到 glXCopySubBufferMESA 这个函数的实现来决定的），如果支持则调用 copy_sub_buffer，如果不支持则调用 glXSwapBuffers。最后的这个操作感觉像是将渲染好的 buffer 输出到最后的屏幕上显示。Clutter 也不是直接操作屏幕的么？？这个目前还没搞清楚。</li>
</ol>
<p>到这里绘制流程就走得差不多了，这里可以看得到最后还是通过各个 backend 来进行绘制的，和 SDL 差不多。GLX 的 backend 会调用 Cogl 的 API 进行一些渲染（好像不光是 3D 的）。这里 GLX backend 感觉是带 OpenGL 支持的，X11 则是普通的 2D 的。因为从代码里可以看到 Clutter 专门区分了2个窗口：一个是 glxwin，一个是 xwin。</p>
<h3 id="Clutter_基本数据结构">Clutter 基本数据结构</h3>
<p>我们来看看 Clutter backend 的基本数据结构吧：</p>
<ul>
<li><strong>ClutterBackendGLX、ClutterBackendX11</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _ClutterBackendGLX</div><div class="line">{</div><div class="line">  ClutterBackendX11 parent_instance;</div><div class="line"></div><div class="line">  <span class="keyword">int</span>                    error_base;</div><div class="line">  <span class="keyword">int</span>                    event_base;</div><div class="line"></div><div class="line">  <span class="comment">/* Single context for all wins */</span></div><div class="line">  gboolean               found_fbconfig;</div><div class="line">  GLXFBConfig            fbconfig;</div><div class="line">  GLXContext             gl_context;</div><div class="line">  Window                 dummy_xwin;</div><div class="line">  GLXWindow              dummy_glxwin;</div><div class="line"></div><div class="line">  <span class="comment">/* Vblank stuff */</span></div><div class="line">  GetVideoSyncProc       get_video_sync;</div><div class="line">  WaitVideoSyncProc      wait_video_sync;</div><div class="line">  SwapIntervalProc       swap_interval;</div><div class="line">  gint                   dri_fd;</div><div class="line">  ClutterGLXVBlankType   vblank_type;</div><div class="line"></div><div class="line">  CopySubBufferProc      copy_sub_buffer;</div><div class="line"></div><div class="line">  <span class="comment">/* props */</span></div><div class="line">  Atom atom_WM_STATE;</div><div class="line">  Atom atom_WM_STATE_FULLSCREEN;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _ClutterBackendX11</div><div class="line">{</div><div class="line">  ClutterBackend parent_instance;</div><div class="line"></div><div class="line">  Display *xdpy;</div><div class="line">  Window   xwin_root;</div><div class="line">  Screen  *xscreen;</div><div class="line">  <span class="keyword">int</span>      xscreen_num;</div><div class="line">  gchar   *display_name;</div><div class="line"></div><div class="line">  <span class="comment">/* event source */</span></div><div class="line">  GSource *event_source;</div><div class="line">  GSList  *event_filters;</div><div class="line"></div><div class="line">  <span class="comment">/* props */</span></div><div class="line">  Atom atom_NET_WM_PID;</div><div class="line">  Atom atom_NET_WM_PING;</div><div class="line">  Atom atom_NET_WM_STATE;</div><div class="line">  Atom atom_NET_WM_STATE_FULLSCREEN;</div><div class="line">  Atom atom_NET_WM_USER_TIME;</div><div class="line">  Atom atom_WM_PROTOCOLS;</div><div class="line">  Atom atom_WM_DELETE_WINDOW;</div><div class="line">  Atom atom_XEMBED;</div><div class="line">  Atom atom_XEMBED_INFO;</div><div class="line">  Atom atom_NET_WM_NAME;</div><div class="line">  Atom atom_UTF8_STRING;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> xi_event_base;</div><div class="line">  <span class="keyword">int</span> event_types[CLUTTER_X11_XINPUT_LAST_EVENT];</div><div class="line">  gboolean have_xinput;</div><div class="line"></div><div class="line">  Time last_event_time;</div><div class="line"></div><div class="line">  ClutterDeviceManager *device_manager;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>X11 里的是 X11 显示的一些基本变量：Display、Window、Screen 等；而 GLX 的则是 GLX 里的基本东西：GLXContext、GLXWindow 等。</p>
<ul>
<li><strong>ClutterStageGLX、ClutterStageX11</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _ClutterStageGLX</div><div class="line">{</div><div class="line">  ClutterStageX11 parent_instance;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> pending_swaps;</div><div class="line"></div><div class="line">  GLXPixmap glxpixmap;</div><div class="line">  GLXWindow glxwin;</div><div class="line"></div><div class="line">  gboolean initialized_redraw_clip;</div><div class="line">  ClutterGeometry bounding_redraw_clip;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _ClutterStageX11</div><div class="line">{</div><div class="line">  ClutterGroup parent_instance;</div><div class="line"></div><div class="line">  guint        is_foreign_xwin      : <span class="number">1</span>;</div><div class="line">  guint        fullscreening        : <span class="number">1</span>;</div><div class="line">  guint        is_cursor_visible    : <span class="number">1</span>;</div><div class="line">  guint        viewport_initialized : <span class="number">1</span>;</div><div class="line"></div><div class="line">  Window       xwin;</div><div class="line">  gint         xwin_width;</div><div class="line">  gint         xwin_height; <span class="comment">/* FIXME target_width / height */</span></div><div class="line">  gchar       *title;</div><div class="line"></div><div class="line">  ClutterStageState  state;</div><div class="line"></div><div class="line">  ClutterStageX11State wm_state;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> event_types[CLUTTER_X11_XINPUT_LAST_EVENT];</div><div class="line">  GList *devices;</div><div class="line"></div><div class="line">  ClutterStage *wrapper;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里也是和上面的差不多的，至于是不是和上面的是重复的，我还没仔细看。</p>
<h3 id="Clutter_线索">Clutter 线索</h3>
<p>这里也和 SDL 差不多了，最后都是 X11 底层的东西来完成绘制的。不过这里用的是 GLX 的接口（ GLX 也算是用 X11 的了吧）。不过根据这里的线索到 Mesa 的 GLX 去看看，好像能看到像 glXCopySubBufferMESA 这个函数的实现，应该是 src/glx/glxcmds.c 里的 __glXCopySubBufferMESA 吧，这个函数好像类似硬件的 blit 的感觉。这个函数里如果是走 DRI 的话，就直接调用 DRI 的回调函数；如果不是 DRI 的话，就只能通过向 X 服务器发请求的方式来实现。这个也许就是之前说的 GLX 中的线索吧。</p>
<h2 id="Cogl_分析">Cogl 分析</h2>
<p>这个目前还没什么仔细看。</p>
<h2 id="总结">总结</h2>
<p>从上面的讨论看到，如果抛开 OpenGL 的支持不管的话，就光要 Android 能直接画东西到 X11 的屏幕上，估计还是得要通过 Xlib 的接口，自己向 X 服务器发送一些申请，然后计算出像素地址。</p>
<h2 id="附件">附件</h2>
<p><a href="http://s.yunio.com/7xUt2x" title="GLX 1.3 官方说明文档" target="_blank" rel="external">GLX 1.3 官方说明文档</a><br><a href="http://s.yunio.com/AYxGTn" title="Xlib编程指南" target="_blank" rel="external">Xlib编程指南</a><br><a href="http://s.yunio.com/1LPFWz" title="x11_sample" target="_blank" rel="external">x11_sample</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/%E5%BC%80%E5%90%AF%20Android%20SDK%20%E6%89%80%E6%9C%89%E7%9A%84%20API%20%E7%9A%84%E6%96%B9%E6%B3%95/</loc>
    <lastmod>2015-01-27T15:07:16.000Z</lastmod>
    <data>
        <display>
        <title>开启 Android SDK 所有的 API 的方法</title>
        <pubTime>2015-01-27T15:07:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 有很多类的 public 的接口被 google 给屏蔽了，一般做一些高级的操作或者是优化的话，需要访问这些接口或是成员变量。这就需要自己做的小手脚。</p>
<h2 id="编译所有公开的_api_的_jar_包">编译所有公开的 api 的 jar 包</h2>
<p>下载 android 源码。然后你可以编译你想要的所有公开 api 的模块。例如说 framework/base/core/java/android/app 下面的一些类的 api（ActivityManager 等等）。这个时候你需要去 frame/base/ 敲 mm 编译 framework.jar 。但是你要注意，你需要的不是最后在 out/target/product 下最终生成的 framework.jar ，那个是经过 google 屏蔽后的 jar。你需要的是编译时的中间文件。注意看编译时的输出，一般是在 out/target/common/obj/JAVA_LIBRARIES/framework_intermediates 下的 classes.jar 的。你可以对比下这 2 个 jar 的大小就知道了。如果你需要别的模块的话，方法是类似的。</p>
<h2 id="导入到_eclipse">导入到 eclipse</h2>
<p>得到有所有公开 api 的 jar 包后，你需要把这个 jar 导入到你的 eclipse 中，然后你的 android 程序才能使用所有公开的 api。</p>
<h3 id="首先是导入到_eclipse_的环境中：">首先是导入到 eclipse 的环境中：</h3>
<ul>
<li>eclipse -&gt; project -&gt; properties -&gt; Java Build Path -&gt; Libraries -&gt; Add Library -&gt; User Library：点击 new </li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/use-hide-api/1.png" alt=""></p>
<ul>
<li>然后编辑刚刚新创建的 library：点击 Add Jars -&gt; 把之前你编译出来的 jar 添加进来</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/use-hide-api/2.png" alt=""></p>
<ul>
<li>另外你还可以在 jar 中挂载源代码，这样调试的时候会更加的方便。但是一般来说你也可以不用挂载（在 source  attachment 那）</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/use-hide-api/3.png" alt=""></p>
<h3 id="然后是在你_android_工程中添加上一步创建的_user_library：">然后是在你 android 工程中添加上一步创建的 user library：</h3>
<ul>
<li>右键工程 -&gt; properties -&gt; Java Build Path -&gt; Libraries -&gt; Add Library -&gt; User Library：然后点 next，选择上一步创建的 user library</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/use-hide-api/4.png" alt=""></p>
<ul>
<li>在 Java Build Path -&gt; Order and Export：把自己的添加的 user library 提升到 google 官方的 android 库的前面（点击 Up 按钮）</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/use-hide-api/5.png" alt=""></p>
<h2 id="最后一步">最后一步</h2>
<p>然后你就可以在你的 android 程序里使用所有的 public 接口了，然后编译吧。 o(∩∩)o</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/27/%5B%E8%BD%AC%5D%20%E5%A6%82%E4%BD%95%E5%8F%96%E5%BE%97Android%E6%BA%90%E4%BB%A3%E7%A0%81/</loc>
    <lastmod>2015-01-27T14:33:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 如何取得Android源代码</title>
        <pubTime>2015-01-27T14:33:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<p>Git 是 Linux Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的分布式版本控制软件，它不同于Subversion、CVS这样的集中式版本控制系统。在集中式版本控制系统中只有一个仓库（repository），许多个工作目录（working copy），每一个工作目录都包含一个完整仓库，它们可以支持离线工作，本地提交可以稍后提交到服务器上。分布式系统理论上也比集中式的单服务器系统更健壮，单服务器系统一旦服务器出现问题整个系统就不能运行了，分布式系统通常不会因为一两个节点而受到影响。</p>
<p>因为Android是由kernel、Dalvik、Bionic、prebuilt、build等多个Git项目组成，所以Android项目编写了一个名为Repo的Python的脚本来统一管理这些项目的仓库，使得Git的使用更加简单。这几天William为了拿Android最新的sourcecode，学习了一下git和repo的一些基本操作，整理了一个如何取得Android代码的How-To，今天把他贴上来。</p>
<h2 id="1、Git的安装">1、Git的安装</h2>
<p>在Ubuntu 8.04上安装git只要设定了正确的更新源，然后使用apt-get就可以了，有什么依赖问题，就让它自己解决吧。其中cURL是一个利用URL语法在命令行下工作的文件传输工具，会在后面安装Repo的时候用到。</p>
<pre>
sudo apt-get install git-core curl
</pre>

<h2 id="2、安装Repo">2、安装Repo</h2>
<p>首先确保在当前用户的主目录下创建一个/bin目录（如果没有的话），然后把它(~/bin)加到PATH环境变量中。接下来通过cURL来下载Repo脚本，保存到~/bin/repo文件中</p>
<pre>
curl http://android.git.kernel.org/repo >~/bin/repo
</pre>

<p>别忘了给repo可执行权限</p>
<pre>
chmod a+x ~/bin/repo
</pre>

<h2 id="3、初始化版本库">3、初始化版本库</h2>
<p>如果是想把Android当前主线上最新版本的所有的sourcecode拿下来，我们需要repo的帮助。先建立一个目录，比如~/android，进去以后用repo init命令即可。</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git
</pre>

<p>这个过程会持续很长的时间（至少可以好好睡一觉），具体要多少时间就取决于网络条件了。最后会看到 repo initialized in /android这样的提示，就说明本地的版本库已经初始化完毕，并且包含了当前最新的sourcecode。如果想拿某个branch而不是主线上的代码，我们需要用-b参数制定branch名字，比如：</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git -b cupcake
</pre>

<p>另一种情况是，我们只需要某一个project的代码，比如kernel/common，就不需要repo了，直接用Git即可。</p>
<pre>
git clone git://android.git.kernel.org/kernel/common.git
</pre>

<p>这也需要不少的时间，因为它会把整个Linux Kernel的代码复制下来。如果需要某个branch的代码，用git checkout即可。比如我们刚刚拿了kernel/common.get的代码，那就先进入到common目录，然后用下面的命令：</p>
<pre>
git checkout origin/android-goldfish-2.6.27 -b goldfish
</pre>

<p>这样我们就在本地建立了一个名为goldfish的android-goldfish-2.6.27分支，代码则已经与android-goldgish-2.6.27同步。我们可以通过git branch来列出本地的所有分支。</p>
<h2 id="4、同步版本库">4、同步版本库</h2>
<p>使用repo sync命令，我们把整个Android代码树做同步到本地，同样，我们可以用类似</p>
<pre>
repo sync project1 project2 … 
</pre>

<p>这样的命令来同步某几个项目。如果是同步Android中的单个项目，只要在项目目录下执行简单的 git pull 即可。</p>
<h2 id="5、通过GitWeb下载代码">5、通过GitWeb下载代码</h2>
<p>另外，如果只是需要主线上某个项目的代码，也可以通过 GitWeb 下载，在shortlog利用关键字来搜索特定的版本，或者找几个比较新的tag来下载还是很容易的。</p>
<p>Git最初是为Linux内核开发而设计，所以对其他平台的支持并不好，尤其是Windows平台，必须要有Cygwin才可以。现在，得益于 <a href="http://code.google.com/p/msysgit/" title="msysgit" target="_blank" rel="external">msysgit</a> 项目，我们已经可以不需要Cygwin而使用Git了。另外， <a href="http://sourceforge.net/projects/gitextensions/" title="Git Extensions" target="_blank" rel="external">Git Extensions</a> 是一个非常好用的Windows Shell扩展，它能与资源管理器紧密集成，甚至提供了Visual Studio插件。它的官方网站上有一分不错的 说明文档，感兴趣的朋友可以看一看。</p>
<p>至于Git的参考文档，我推荐 <a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/" title="Git Magic" target="_blank" rel="external">Git Magic</a>，这里还有一个 <a href="http://docs.google.com/View?id=dfwthj68_675gz3bw8kj#__07735763982479649" title="Git Magic的中文版" target="_blank" rel="external">Git Magic的中文版</a>。</p>
<p>其实最靠谱的是： <a href="http://source.android.com/source/downloading.html" title="google的官方说明文档" target="_blank" rel="external">google的官方说明文档</a></p>
<p>原始出处： 哎，以前没写转的出处 -_-||</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Framework" url="http://www.light3moon.com/categories/Android-Framework/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/Android%20%E5%9D%91%E7%88%B9%E5%A4%A7%E5%85%A8%20%E2%80%94%E2%80%94%20Paint%20mask%20filter%20%E6%97%A0%E6%95%88/</loc>
    <lastmod>2015-01-26T15:53:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 坑爹大全 —— Paint mask filter 无效</title>
        <pubTime>2015-01-26T15:53:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>android 的 Paint 提供2种边缘效果：一种是 BlurMaskFilter，一种是 EmbossMaskFilter。BlurMaskFilter 是模糊效果，EmbossMaskFilter 是浮雕效果。这里注意下，Paint 提供的只是边缘效果而已（egde），不是整体的效果，例如这个模糊效果不是类似 window vista 那种的整体的背景毛玻璃效果，边缘效果是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-paint-mask-filter/1.jpeg" alt=""> </p>
<p>然后用法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 BlurMaskFilter（设置下参数）设置给 Paint</span></div><div class="line">paint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(radius, BlurMaskFilter.Blur.NORMAL));</div><div class="line"><span class="comment">// 然后 draw 的时候使用这个 Paint 去画就行了</span></div><div class="line">canvas.drawBitmap(bmp, <span class="keyword">null</span>, rect, paint);</div><div class="line"></div></pre></td></tr></table></figure>

<p>BlurMaskFilter 有几个参数： radius 是模糊半径（值越大，模糊范围就越大），mode 是模式，有几个选择：</p>
<ul>
<li>NORMAL： 内外边缘都模糊</li>
<li>INNER： 内边缘模糊</li>
<li>OUTER： 外模糊，（4.4 和 之前的版本效果不一样，有点坑爹）</li>
<li>SOLID： 外边缘模糊</li>
</ul>
<p>从左到右依次是： NORML、INNER、OUTER、SOLID：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-paint-mask-filter/2.jpeg" alt=""></p>
<p>上面 OUTER 是在 4.2 上的效果，在 4.4 上是这样的，可能内部实现变了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-paint-mask-filter/3.jpeg" alt=""></p>
<p>Emboss 效果没贴上来了，可以自己试验。从上面图上可得出，这个东西的算法对于某些图像还是有点缺陷，要使用的话，尽量保证真正的图片内容不要紧靠着边缘（那个兔子的一部贴着边缘了，效果不是很好）。</p>
<p>但是今天说的是坑爹的一点：之前在 4.2 和 4.4 上怎么跑都效果，还以为是代码哪里弄错了，跑去源码看了一下，发现其实是 skia 库只代的 effect 而已，在 java 层拉了几个接口，skia 的 SkBlurMaskFilter 和 SkEmbossMaskFilter（代码在 skia 的 effect 目标下面，在 skia 的 samples 里有示例怎么使用）。</p>
<p>后来想了一下是不是因为开了<strong>硬件加速</strong>的原因，果然把硬件加速关了，效果就出来了（4.0 之后，默认开硬件加速的）。可以在 activity 级别关，也可以在使用的 view 上使用 setLayerType(View.LAYER_TYPE_SOFTWARE, null) 关硬件加速。</p>
<p>想想看，官方文档里说硬件加速（使用 openGL）只支持点、画线、画多边形、贴图、旋转、平移、缩放、aplha渐变这几个吧，这种稍微高级点的东西不支持正常。不过一开始没想到而已。</p>
<p>网上看到有人也发现 4.0 之后这几个效果不生效了，他们的办法是把 targetSDKVersion 改低，但是其实是没什么意义的。主要源头在于硬件加速。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/Android%20%E5%9D%91%E7%88%B9%E5%A4%A7%E5%85%A8%20%E2%80%94%E2%80%94%20SeekBar/</loc>
    <lastmod>2015-01-26T15:48:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 坑爹大全 —— SeekBar</title>
        <pubTime>2015-01-26T15:48:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>一般用 SeekBar 除了 google 自己那一票 app 以及系统，开发者几乎都不会直接用原来的 SeekBar 的图的，都要自己换图。这里就所说 SeekBar 换图的事。</p>
<h2 id="结构">结构</h2>
<p>首先来看看 SeekBar 的构成：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-seek-bar/1.jpeg" alt=""></p>
<p>SeekBar 由一个进度条和上面的滑块构成。一般换图就换这2个东西就 OK 了。一般是要准备3张图片：进度条2张，一张背景（background）、一张滑动的进度（progress）、一张是滑块（thumb）。</p>
<p>拿个例子说事， UI 说界面的亮度调节的视觉是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-seek-bar/2.jpeg" alt=""></p>
<p>然后给了3张图，一般换图么， SeekBar 继承关系是： SeekBar —-&gt; AbsSeekBar —&gt; ProgressBar 。 换个 progressDrawable（ProgressBar的） 和 thumb（AbsSeekBar的） 就行了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">SeekBar</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_width</span>=<span class="value">"300dp"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_centerInParent</span>=<span class="value">"true"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:progressDrawable</span>=<span class="value">"@drawable/seek_drawable"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:thumb</span>=<span class="value">"@drawable/seek_thumb"</span></span></div><div class="line"><span class="tag">    /&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>thumb 的 drawable 直接是滑块的 png 就行。progressDrawable 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">layer-list</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">item</span> </span></div><div class="line"><span class="tag">        <span class="attribute">android:id</span>=<span class="value">"@android:id/background"</span> </span></div><div class="line"><span class="tag">        <span class="attribute">android:drawable</span>=<span class="value">"@drawable/seek_progress_bk"</span></span></div><div class="line"><span class="tag">        &gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@android:id/progress"</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">clip</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/seek_progress"</span> &gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">clip</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="title">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">layer-list</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>progressDrawable 可以用 LayerDrawable 同时指定进度条的背景（background）和进度（progress），progress 的 clip 的意思是说：这个要用这个图片的一部门来表示进度，而不是用图片的全部来表示，想想看进度条的表示方式，就是这样的啦。这个 clip 还可以设置方向，进度条可以是水平的也可以是竖直的。</p>
<p>然后坑就来了。一般 SeekBar 的滑块都会比进度条大，这里 UI 给的是 25x29 ，那个进度是 9-patch 的，20x6。我原来以为 SeekBar 的大小应该是 300 x 29，滑块是 25x29，然后那个进度条高度就是 6，居中显示。但是出来的结果确是滑块的大小确实 25x29，但是进度条却是 13 的高度（居中倒是居中），感觉肥了不少。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-seek-bar/3.jpeg" alt=""></p>
<p>刚开始以为 ProgressBar 可以设啥 padding 之类的东西，但是不找到，然后尝试把进度体的图改称和 thumb 的一样高（png 的用透明填充），但是发现还是达不到预期效果。无奈只好去翻代码了。 </p>
<h2 id="坑爹的设计">坑爹的设计</h2>
<p>先是在 ProgressBar.java 中发现 progressDrawable 设置的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Drawable drawable = a.getDrawable(R.styleable.ProgressBar_progressDrawable);</div><div class="line"><span class="keyword">if</span> (drawable != <span class="keyword">null</span>) {</div><div class="line">    drawable = tileify(drawable, <span class="keyword">false</span>);</div><div class="line">    <span class="comment">// Calling this method can set mMaxHeight, make sure the corresponding</span></div><div class="line">    <span class="comment">// XML attribute for mMaxHeight is read after calling this method</span></div><div class="line">    setProgressDrawable(drawable);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这段在 ProgressBar 的构造函数中，发现 xml 里指定的 progressDrawable 其实调用 setProgressDrawable 来设置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProgressDrawable</span>(Drawable d) {</div><div class="line">    <span class="keyword">boolean</span> needUpdate;</div><div class="line">    <span class="keyword">if</span> (mProgressDrawable != <span class="keyword">null</span> && d != mProgressDrawable) {</div><div class="line">        mProgressDrawable.setCallback(<span class="keyword">null</span>);</div><div class="line">        needUpdate = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        needUpdate = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">            </div><div class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) {</div><div class="line">        d.setCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (canResolveLayoutDirection()) {</div><div class="line">            d.setLayoutDirection(getLayoutDirection());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Make sure the ProgressBar is always tall enough</span></div><div class="line">        <span class="keyword">int</span> drawableHeight = d.getMinimumHeight();</div><div class="line">        <span class="keyword">if</span> (mMaxHeight &lt; drawableHeight) {</div><div class="line">            mMaxHeight = drawableHeight;</div><div class="line">            requestLayout();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    mProgressDrawable = d;</div><div class="line">    <span class="keyword">if</span> (!mIndeterminate) {</div><div class="line">        mCurrentDrawable = d;</div><div class="line">        postInvalidate();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (needUpdate) {</div><div class="line">        updateDrawableBounds(getWidth(), getHeight());</div><div class="line">        updateDrawableState();</div><div class="line">        doRefreshProgress(R.id.progress, mProgress, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">        doRefreshProgress(R.id.secondaryProgress, mSecondaryProgress, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 setProgressDrawable 是把设置的 progressDrawable 保存在了 mProgressDrawable 的成员变量中。然后通过搜索发现根据 ProgressBar 的样式 mProgressDrawable 为被选为 mCurrentDrawable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setIndeterminate</span>(<span class="keyword">boolean</span> indeterminate) {</div><div class="line">    <span class="keyword">if</span> ((!mOnlyIndeterminate || !mIndeterminate) && indeterminate != mIndeterminate) {</div><div class="line">        mIndeterminate = indeterminate;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (indeterminate) {</div><div class="line">            <span class="comment">// swap between indeterminate and regular backgrounds</span></div><div class="line">            mCurrentDrawable = mIndeterminateDrawable;</div><div class="line">            startAnimation();</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mCurrentDrawable = mProgressDrawable;</div><div class="line">            stopAnimation();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后去 onDraw 里面看看，原来 mCurrentDrawable 就是画进度条的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span> </div><div class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onDraw</span>(Canvas canvas) {</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    </div><div class="line">    Drawable d = mCurrentDrawable;</div><div class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// Translate canvas so a indeterminate circular progress bar with padding</span></div><div class="line">        <span class="comment">// rotates properly in its animation</span></div><div class="line">        canvas.save();</div><div class="line">        <span class="keyword">if</span>(isLayoutRtl()) { </div><div class="line">            canvas.translate(getWidth() - mPaddingRight, mPaddingTop);</div><div class="line">            canvas.scale(-<span class="number">1.0</span>f, <span class="number">1.0</span>f);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            canvas.translate(mPaddingLeft, mPaddingTop);</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> time = getDrawingTime();</div><div class="line">        <span class="keyword">if</span> (mHasAnimation) {</div><div class="line">            mAnimation.getTransformation(time, mTransformation);</div><div class="line">            <span class="keyword">float</span> scale = mTransformation.getAlpha();</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                mInDrawing = <span class="keyword">true</span>;</div><div class="line">                d.setLevel((<span class="keyword">int</span>) (scale * MAX_LEVEL));</div><div class="line">            } <span class="keyword">finally</span> {</div><div class="line">                mInDrawing = <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">            postInvalidateOnAnimation();</div><div class="line">        }</div><div class="line">        d.draw(canvas);</div><div class="line">        canvas.restore();</div><div class="line">        <span class="keyword">if</span> (mShouldStartAnimationDrawable && d <span class="keyword">instanceof</span> Animatable) {</div><div class="line">            ((Animatable) d).start();</div><div class="line">            mShouldStartAnimationDrawable = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>onDraw 里面是直接使用 drawable 的 draw 方法来绘制的，那说明肯定是在哪个地方使用 setBounds 来设置 drawable 的 bound 来设置绘制位置的（这里称赞一下 android 的 drawable 家族的设计，真的很棒，抽象的很好，功能也强大，背景不管是 bitmap、9-patch、color、gradient、selector、layer 都只要 draw 就能画出来，只要是 drawable 都能够当作背景参数传入）。</p>
<p>然后搜一下 setBrounds 的地方，发现并不多，然后和 mProgressDrawable 相关的 setBounds 的地方就一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDrawableBounds</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h) {</div><div class="line">    <span class="comment">// onDraw will translate the canvas so we draw starting at 0,0.</span></div><div class="line">    <span class="comment">// Subtract out padding for the purposes of the calculations below.</span></div><div class="line">    w -= mPaddingRight + mPaddingLeft;</div><div class="line">    h -= mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> right = w;</div><div class="line">    <span class="keyword">int</span> bottom = h;</div><div class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mIndeterminateDrawable != <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// Aspect ratio logic does not apply to AnimationDrawables</span></div><div class="line">        <span class="keyword">if</span> (mOnlyIndeterminate && !(mIndeterminateDrawable <span class="keyword">instanceof</span> AnimationDrawable)) {</div><div class="line">            <span class="comment">// Maintain aspect ratio. Certain kinds of animated drawables</span></div><div class="line">            <span class="comment">// get very confused otherwise.</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = mIndeterminateDrawable.getIntrinsicWidth();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> intrinsicHeight = mIndeterminateDrawable.getIntrinsicHeight();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> intrinsicAspect = (<span class="keyword">float</span>) intrinsicWidth / intrinsicHeight;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> boundAspect = (<span class="keyword">float</span>) w / h;</div><div class="line">            <span class="keyword">if</span> (intrinsicAspect != boundAspect) {</div><div class="line">                <span class="keyword">if</span> (boundAspect &gt; intrinsicAspect) {</div><div class="line">                    <span class="comment">// New width is larger. Make it smaller to match height.</span></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> width = (<span class="keyword">int</span>) (h * intrinsicAspect); </div><div class="line">                    left = (w - width) / <span class="number">2</span>;        </div><div class="line">                    right = left + width;          </div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// New height is larger. Make it smaller to match width.</span></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> height = (<span class="keyword">int</span>) (w * (<span class="number">1</span> / intrinsicAspect));</div><div class="line">                    top = (h - height) / <span class="number">2</span>;        </div><div class="line">                    bottom = top + height;         </div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (isLayoutRtl()) {           </div><div class="line">            <span class="keyword">int</span> tempLeft = left;           </div><div class="line">            left = w - right;              </div><div class="line">            right = w - tempLeft;</div><div class="line">        }</div><div class="line">        mIndeterminateDrawable.setBounds(left, top, right, bottom);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mProgressDrawable != <span class="keyword">null</span>) {</div><div class="line">        mProgressDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, right, bottom);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>加点打印看看设置的 bound 是多少（编译出来的是 frameworks.jar），发现是 （0，0，268，29），哎，这里的是 29 的高度啊。在 onDraw 再加点打印（把 drawable 的 getBounds() 打印出来），发现是 (0, 8, 268, 21) ，这里就和显示上的对上了，高度 13 ，肥了很多，那应该在别的地方有设置。</p>
<p>分别去 SeekBar、AbsSeekBar 里搜索下 setBounds，发现 SeekBar 里没有， AbsSeekBar 里有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateThumbPos</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h) {</div><div class="line">    Drawable d = getCurrentDrawable();</div><div class="line">    Drawable thumb = mThumb;</div><div class="line">    <span class="keyword">int</span> thumbHeight = thumb == <span class="keyword">null</span> ? <span class="number">0</span> : thumb.getIntrinsicHeight();</div><div class="line">    <span class="comment">// The max height does not incorporate padding, whereas the height</span></div><div class="line">    <span class="comment">// parameter does</span></div><div class="line">    <span class="keyword">int</span> trackHeight = Math.min(mMaxHeight, h - mPaddingTop - mPaddingBottom);</div><div class="line">        </div><div class="line">    <span class="keyword">int</span> max = getMax();</div><div class="line">    <span class="keyword">float</span> scale = max &gt; <span class="number">0</span> ? (<span class="keyword">float</span>) getProgress() / (<span class="keyword">float</span>) max : <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (thumbHeight &gt; trackHeight) {</div><div class="line">        <span class="keyword">if</span> (thumb != <span class="keyword">null</span>) {</div><div class="line">            setThumbPos(w, thumb, scale, <span class="number">0</span>); </div><div class="line">        }   </div><div class="line">        <span class="keyword">int</span> gapForCenteringTrack = (thumbHeight - trackHeight) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (d != <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Canvas will be translated by the padding, so 0,0 is where we start drawing</span></div><div class="line">            d.setBounds(<span class="number">0</span>, gapForCenteringTrack, </div><div class="line">                    w - mPaddingRight - mPaddingLeft, h - mPaddingBottom - gapForCenteringTrack</div><div class="line">                    - mPaddingTop);</div><div class="line">        }   </div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (d != <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Canvas will be translated by the padding, so 0,0 is where we start drawing</span></div><div class="line">            d.setBounds(<span class="number">0</span>, <span class="number">0</span>, w - mPaddingRight - mPaddingLeft, h - mPaddingBottom</div><div class="line">                    - mPaddingTop);</div><div class="line">        }   </div><div class="line">        <span class="keyword">int</span> gap = (trackHeight - thumbHeight) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (thumb != <span class="keyword">null</span>) {</div><div class="line">            setThumbPos(w, thumb, scale, gap);</div><div class="line">        }   </div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>哎，好多加、减的计算咧，分析上面的代码会发现是这样的： 如果 thumbHeight &gt; trackHeight 的，那么进度条的 bounds 其实是居中。thumbHeight 的是由设置的 thumb 的 drawable 的 IntrinsicHeight 来决定的（一般就是图片的高度）。主要在于 trackHeight 是多少， 打印出来发现是 13 : </p>
<pre>
int trackHeight = Math.min(mMaxHeight, h - mPaddingTop - mPaddingBottom);
</pre>

<p>打印出来发现，padding 是 0，高度 h 是 29，这个高度看 AbsSeekBar 的 onMeasure 函数可以知道如果没有明确指定 view 的高度（使用 wrap_content）的话，由 thumb 和 currentDrawable（progressDrawable） 中 IntrinsicHeight 最大（加上 padding ）的决定。这里 thumb 的 29 明显比 progressDrawable 的 6 要大，所以主要就看 mMaxHeight 了， 这个 mMaxHeight 在 AbsSeekBar 中没有定义，那就是父类 ProgressBar 的，跑去一看发现在构造函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mMaxHeight = a.getDimensionPixelSize(R.styleable.ProgressBar_maxHeight, mMaxHeight);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个东西由 xml 中的 android:maxHeight 决定的，如果不指定，则使用系统 style 中的默认值，这里好像是 13。果然坑爹咧，进度条的高度系统不是用你图片的高度，而是使用 android:maxHeight 来决定（大多数情况下由这个决定，因为很前面的代码发现，这个需要 thumb 图片的高度比进度条的图片高才行，不过一般都是这样的）。</p>
<p>所以我设了下 maxHeight 为 6 （进度条图片高度），果然进度条就不肥了，高度老老实实变成 6 了，官方文档啥都没说。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">SeekBar</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_width</span>=<span class="value">"300dp"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_centerInParent</span>=<span class="value">"true"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:progressDrawable</span>=<span class="value">"@drawable/seek_drawable"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:thumb</span>=<span class="value">"@drawable/seek_thumb"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:maxHeight</span>=<span class="value">"6dp"</span></span></div><div class="line"><span class="tag">    /&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>果然不肥了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/suck-problem-seek-bar/4.jpeg" alt=""></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/hierarchyviewer%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-26T15:39:16.000Z</lastmod>
    <data>
        <display>
        <title>hierarchyviewer 无法使用问题</title>
        <pubTime>2015-01-26T15:39:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>hierarchyviewer 这个 sdk tools 中带了一个工具，我就不多介绍了，调试 layout 神器。但是正常情况下只有在 eng 版本的机器上才能使用。</p>
<h2 id="概述">概述</h2>
<p>在非 eng 机器上是无法使用的。hierarchyviewer 需要在 framework 中启用一个 view server ，然后通过 socket 和 host 上的 hierarchyviewer 进行通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</span></div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Starts the view server on the specified port.</span></div><div class="line"><span class="javadoc">     *</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @param</span> port The port to listener to.</span></div><div class="line"><span class="javadoc">     *</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @return</span> True if the server was successfully started, false otherwise.</span></div><div class="line"><span class="javadoc">     *</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @see</span> com.android.server.wm.ViewServer</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @see</span> com.android.server.wm.ViewServer#VIEW_SERVER_DEFAULT_PORT</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startViewServer</span>(<span class="keyword">int</span> port) {</div><div class="line">        <span class="keyword">if</span> (isSystemSecure()) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!checkCallingPermission(Manifest.permission.DUMP, <span class="string">"startViewServer"</span>)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (port &lt; <span class="number">1024</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mViewServer != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (!mViewServer.isRunning()) {</div><div class="line">                <span class="keyword">try</span> { </div><div class="line">                    <span class="keyword">return</span> mViewServer.start();</div><div class="line">                } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"View server did not start"</span>);</div><div class="line">                }     </div><div class="line">            }     </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">try</span> { </div><div class="line">            mViewServer = <span class="keyword">new</span> ViewServer(<span class="keyword">this</span>, port);</div><div class="line">            <span class="keyword">return</span> mViewServer.start();</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            Slog.w(TAG, <span class="string">"View server did not start"</span>);</div><div class="line">        }     </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSystemSecure</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"1"</span>.equals(SystemProperties.get(SYSTEM_SECURE, <span class="string">"1"</span>)) &&</div><div class="line">                <span class="string">"0"</span>.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, <span class="string">"0"</span>));</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>通过代码可以发现，只要 ro.secure = 0 或是 ro.debuggable = 1 就可以使用 hierarchyviewer。一般发布出去的 android 设备， ro.secure 普遍都是 1， ro.debuggable 大多数是 0，但是也有些的 ro.debuggable 是 1 来的。这2个值可以通过 adb shell 之后 getprop 查看。</p>
<p>网上有讨论怎么在 OEM 的设置上通过 hack（其实就是反编译 services.jar，然后修改 services 中的 smali 字节码，然后修改里面的 isSystemSecure 的返回值）来开启 hierarchyviewer 的支持的。详细看这里：</p>
<p><a href="http://maider.blog.sohu.com/255448342.html" title="如何在Root的手机上开启ViewServer，使得HierachyViewer能够连接" target="_blank" rel="external">如何在Root的手机上开启ViewServer，使得HierachyViewer能够连接</a> </p>
<h2 id="问题">问题</h2>
<p>但是这里不是要讨论 hack 的问题。而是我本来 eng 版本的机子上，突然 hierarchyviewer 就用不了。在 host 上运行 hierarchyviewer 打印就出:</p>
<pre>
10:13:25 E/hierarchyviewer: Unable to get view server version from device xxxxx
10:13:25 E/hierarchyviewer: Unable to get view server protocol version from device xxxxx
10:13:25 E/ViewServerDevice: Unable to debug device: xxxxx
10:13:25 E/hierarchyviewer: Missing forwarded port for xxxx
10:13:25 E/hierarchyviewer: Unable to get the focused window from device xxxx
</pre>

<p>然后按照的说法敲命令：</p>
<pre>
adb shell service call window 3
</pre>

<p>输出如果是：</p>
<pre>
Result: Parcel(00000000 00000000 '........')" 
</pre>

<p>说明 view server 处于关闭状态。输出如果是：</p>
<pre>
Result: Parcel(00000000 00000001 '........')" 
</pre>

<p>说明 view server 处于开启状态。我在我的 eng 的机子试了下，发现输出是 00000000。奇怪了，之前还是能用的，怎么突然 view server 启不来啦？启动代码在上面有，我发现启动 view server 那里有 try catch，然后有句简单的打印。取出来 log 看了下，发现确实有打印： View server did not start。但是也看不出来哪里出错了。</p>
<p>于是我在 try catch 那加了句： e.printStackTrace() 。然后发现了异常：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/hierarchyviewer-problem/1.png" alt=""></p>
<p>唉，这咋是 unable to resolve “localhost” 咧？哦，我突然想起来，最近搞屏蔽应用内广告。然后借鉴了一种简单的方法：就是修改 hosts 文件。然后我在调试的时候把原来的 /system/etc/hosts 给删掉了。原来这个文件中就只有一条 host：</p>
<pre>
127.0.0.1 localhosts
</pre>

<p>哦，我终于知道原来这句话是用来干什么的了，原来是给 view server 用的啊。它在创建 socket 的时候直接写 localhosts 的。重新把这段加到 /system/etc/hosts 里面就好了（如果删掉了，自己创建一个就行了）。</p>
<p>哎呀，hierarchyviewer 又能用啦，舒服～～</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/Android%20%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B0%83%E8%AF%95/</loc>
    <lastmod>2015-01-26T15:37:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 打印函数调用堆栈调试</title>
        <pubTime>2015-01-26T15:37:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="java_层">java 层</h2>
<p>可以利用抛出异常来打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</div><div class="line">here.fillInStackTrace();</div><div class="line">Log.i(TAG, <span class="string">"call statck is"</span>, here);</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="native_层">native 层</h2>
<p>可以利用 android 的 CallStack 来打印：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CallStack <span class="built_in">stack</span>;</div><div class="line"><span class="built_in">stack</span>.update();</div><div class="line"><span class="built_in">stack</span>.dump(<span class="string">"SurfaceFlinger"</span>); </div><div class="line"></div><div class="line"><span class="comment">// 4.4 的接口变了 dump 是用来把 log 保存到文件里面去的</span></div><div class="line"><span class="comment">// 单纯的打印用这个: statck.log("SurfaceFlinger")</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>要调用这个类的方法先插入 CallStack 头文件，然后在 Android.mk 中链接 utils 库就可以： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utils/CallStack.h&gt;</span></div><div class="line">LOCAL_SHARED_LIBRARIES := libutils</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个可以自己去看 CallStack.h 的头文件（frameworks/base/native/include/utils/CallStack.h），方法的定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个参数没去研究啥作用，用默认的1吧，</span></div><div class="line"><span class="comment">// 第二个参数好像是设置追踪的最大调用堆栈深度，默认是 31</span></div><div class="line"><span class="keyword">void</span> update(int32_t ignoreDepth=<span class="number">1</span>, int32_t maxDepth=MAX_DEPTH);</div><div class="line"></div><div class="line"><span class="comment">// 这个就是把调用堆栈信息输出到 android 的 log 里面，</span></div><div class="line"><span class="comment">// 那个参数是 log 前面的前缀</span></div><div class="line"><span class="comment">// Dump a stack trace to the log</span></div><div class="line"><span class="keyword">void</span> dump(<span class="keyword">const</span> <span class="keyword">char</span>* prefix = <span class="number">0</span>) <span class="keyword">const</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>效果如下：(注意 logcat 的 TAG 是 CallStack -_-||)</p>
<pre config="brush:bash;toolbar:false;">
D/CallStack(  101): SurfaceFlinger#00  pc 00028a84  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::captureScreen(android::sp<android::ibinder> const&, android::sp<android::imemoryheap>*, unsigned int*, unsigned int*, int*, unsigned int, unsigned int, unsigned int, unsigned int)+63)
D/CallStack(  101): SurfaceFlinger#01  pc 000262a4  /system/lib/libgui.so (android::BnSurfaceComposer::onTransact(unsigned int, android::Parcel const&, android::Parcel*, unsigned int)+523)
D/CallStack(  101): SurfaceFlinger#02  pc 00029836  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::onTransact(unsigned int, android::Parcel const&, android::Parcel*, unsigned int)+105)
D/CallStack(  101): SurfaceFlinger#03  pc 0001435e  /system/lib/libbinder.so (android::BBinder::transact(unsigned int, android::Parcel const&, android::Parcel*, unsigned int)+57)
D/CallStack(  101): SurfaceFlinger#04  pc 00016f5a  /system/lib/libbinder.so (android::IPCThreadState::executeCommand(int)+513)
D/CallStack(  101): SurfaceFlinger#05  pc 00017380  /system/lib/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+183)
D/CallStack(  101): SurfaceFlinger#06  pc 00000820  /system/bin/surfaceflinger
D/CallStack(  101): SurfaceFlinger#07  pc 00000844  /system/bin/surfaceflinger
D/CallStack(  101): SurfaceFlinger#08  pc 0001271c  /system/lib/libc.so (__libc_init+35)
D/CallStack(  101): SurfaceFlinger#00  pc 00028a84  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::captureScreen(android::sp<android::ibinder> const&, android::sp<android::imemoryheap>*, unsigned int*, unsigned int*, int*, unsigned int, unsigned int, unsigned int, unsigned int)+63)
</android::imemoryheap></android::ibinder></android::imemoryheap></android::ibinder></pre>

]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/dmtracedump%20%E7%9A%84%E7%94%A8%E6%B3%95/</loc>
    <lastmod>2015-01-26T15:35:16.000Z</lastmod>
    <data>
        <display>
        <title>dmtracedump 的用法</title>
        <pubTime>2015-01-26T15:35:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>这个东西是 android sdk 中自带的一个开发工具，用来分析程序的性能的，和 traceview 配合使用。这个工具需要使用 Debug 中的 trace 方法来生成 .trace 文件（具体方法看 android 的开发文档）。</p>
<p>然后通过 .trace 可以生成一个函数调用栈的图像。用法为：</p>
<pre config="brush:bash;toolbar:false;">
dmtracedump -g my.png my.trace
</pre>

<p>会生成一个 png 图片。这个工具的官方文档说明真是水，居然连最基本的用法都没写。这玩意生成的图，怎么分析程序的瓶颈我好像不怎么看得懂，但是我发现用来分析 framework 的一些流程倒是挺不错的 -_-|| 。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/apk%20%E6%8D%95%E8%8E%B7%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/</loc>
    <lastmod>2015-01-26T15:11:16.000Z</lastmod>
    <data>
        <display>
        <title>apk 捕获全局异常</title>
        <pubTime>2015-01-26T15:11:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>某些时候我们写的程序会意外崩溃。有些时候的崩溃是必然出现的，有些时候是随机的出现的。随机出现的崩溃问题，一般查找崩溃的原因需要花费很多时间，不过如果要是有崩溃的 log ，就能很快的定位到问题的所在了。相信大家有些对 SQA 打的一些随机一次、有规律重现的 bug 都很头痛吧。现在介绍一个办法能抓住崩溃的现场 log 日志，这样就能快速的定位崩溃的原因。</p>
<h2 id="原理">原理</h2>
<p>这个办法就是：捕获全局异常。java 程序的大多数崩溃都是异常引起的（注意这里说的是一般，这个方法其实是有限制的，具体的后面会说到）。如果发生了异常，你捕获了，那么系统会把让你的程序来处理异常，如果你没有捕获，那么系统最后会自己处理：那就是挂掉你的程序，然后打印一些崩溃信息。我们现在要做的处理这些没有被程序捕获（处理）的异常（这些异常会引起崩溃），这就是捕获全局异常的原理。但是要注意的一点是：<strong>这里捕获全局异常的作用，仅仅是抓取异常（崩溃）的现场日志，方便查找问题而已，不能防止程序崩溃</strong>。也就是说就算你捕获了全局异常，也无法阻止你出错的程序挂掉。</p>
<h2 id="实现">实现</h2>
<p>我们就来看看如何来实现这个功能吧。首先是新建一个异常处理类 CrashHandler 实现 UncaughtExceptionHandler，这个接口有一个 uncaughtException 方法。当发生了崩溃异常的时候，就会调用这个方法让你来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrashHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span>(Thread thread, Throwable ex) {</div><div class="line">        <span class="keyword">if</span> (!handleException(ex) && <span class="keyword">null</span> != mDefaultHandler) {</div><div class="line">            mDefaultHandler.uncaughtException(thread, ex);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">.... ....</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleException</span>(Throwable ex) {</div><div class="line">        <span class="keyword">if</span> (ex == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// show the crash to the logcat.</span></div><div class="line">        ex.printStackTrace();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!needCatchCrash()) {</div><div class="line">            selfKill();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        collectCrashDeviceInfo();</div><div class="line">        saveCrashInfoToFile(ex);</div><div class="line"></div><div class="line">        <span class="comment">// if need upload we send the log file to server.</span></div><div class="line">        <span class="keyword">if</span> (needUpload()) {</div><div class="line">            sendCrashReportToServer(getLastCrashReportFile());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needReport()) {</div><div class="line">            autoRestart();</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            selfKill();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看到 handleException 处理流程是：</p>
<ol>
<li>调用 ex.printStackTrace 打印当前的异常信息。</li>
<li>收集运行崩溃程序的设备信息。</li>
<li>将崩溃的时候堆栈信息（log）保存到文件。</li>
<li>显示崩溃报告界面。</li>
</ol>
<p>这里有一个可以添加的功能：那就是如果以后有服务器支持，可以向服务器发送崩溃日志信息（类似于一些手机平台sdk，像友盟这种），这样在正式发布产品的时候如果出了错误，也能第一时间发现（当然最好是不出问题）。</p>
<p>收集运行崩溃程序的设备信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectCrashDeviceInfo</span>() {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        PackageManager pm = mContext.getPackageManager();</div><div class="line">        PackageInfo pi = pm.getPackageInfo(mContext.getPackageName(),</div><div class="line">                PackageManager.GET_ACTIVITIES);</div><div class="line">        <span class="keyword">if</span> (pi != <span class="keyword">null</span>) {</div><div class="line">            mDeviceCrashInfo.put(VERSION_NAME,</div><div class="line">                    pi.versionName == <span class="keyword">null</span> ? <span class="string">"unknow"</span> : pi.versionName);</div><div class="line">            mDeviceCrashInfo.put(VERSION_CODE,</div><div class="line">                    String.valueOf(pi.versionCode));</div><div class="line">            <span class="comment">// collect the upload info.</span></div><div class="line">            mVersionName = (pi.versionName == <span class="keyword">null</span> ? <span class="string">"unknow"</span> : pi.versionName);</div><div class="line">            mVersionCode = pi.versionCode;</div><div class="line">        }</div><div class="line">    } <span class="keyword">catch</span> (NameNotFoundException e) {</div><div class="line">        <span class="keyword">if</span> (DEBUG) LogUtils.e(TAG, <span class="string">"Error while collect package info"</span>, e);</div><div class="line">    }</div><div class="line"></div><div class="line">    Field[] fields = Build.class.getDeclaredFields();</div><div class="line">    <span class="keyword">for</span> (Field field : fields) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            field.setAccessible(<span class="keyword">true</span>);</div><div class="line">            String key = field.getName();</div><div class="line">            Object value = field.get(<span class="keyword">null</span>);</div><div class="line">            <span class="comment">//if (DEBUG) LogUtils.d(TAG, key + " : " + value);</span></div><div class="line">            mDeviceCrashInfo.put(key,</div><div class="line">                    value != <span class="keyword">null</span> ? value.toString() : value);</div><div class="line">            <span class="comment">// collect the upload info.</span></div><div class="line">            <span class="keyword">if</span> (PRODUCT.equals(key)) {</div><div class="line">                mProduct = (value != <span class="keyword">null</span> ? value.toString() : <span class="string">"unknow"</span>);</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            <span class="keyword">if</span> (DEBUG) LogUtils.e(TAG, <span class="string">"Error while collect crash info"</span>, e);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里首先会收集崩溃程序的版本号（VersionCode），然后会收集崩溃程序运行的系统的一些信息（系统的一些编译信息），然后保存在一个 Properties 对象（mDeviceCrashInfo）中。</p>
<p>接下来是保存崩溃时候的堆栈信息了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveCrashInfoToFile</span>(Throwable ex) {</div><div class="line">    Writer info = <span class="keyword">new</span> StringWriter();</div><div class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(info);</div><div class="line">    <span class="comment">// printStackTrace(PrintWriter s)</span></div><div class="line">    ex.printStackTrace(printWriter);</div><div class="line"></div><div class="line">    Throwable cause = ex.getCause();</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != cause) {</div><div class="line">        cause.printStackTrace(printWriter);</div><div class="line">        cause = cause.getCause();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//String result = info.toString();</span></div><div class="line">    String result = formatStackTrace(info.toString());</div><div class="line">    printWriter.close();</div><div class="line">    mDeviceCrashInfo.put(STACK_TRACE, result);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> {</div><div class="line"></div><div class="line">        String logPath = resolveLogPath();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == logPath) {</div><div class="line">            LogUtils.e(TAG, <span class="string">"log path invalid, can't save crash log file !!"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        String fileName = resolveLogFileName();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == fileName) {</div><div class="line">            LogUtils.e(TAG, <span class="string">"log file name invalid, can't save crash log file !!"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// check save directory whether existed.</span></div><div class="line">        String filePath = logPath + File.separator + fileName;</div><div class="line">        <span class="keyword">if</span> (!StoreUtils.checkFileDirExisted(filePath)) {</div><div class="line">            LogUtils.e(TAG, <span class="string">"save crash info: create crash file dir error !"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// check the cache size.</span></div><div class="line">        checkCacheSize();</div><div class="line"></div><div class="line">        <span class="comment">//FileOutputStream trace = mContext.openFileOutput(fileName,</span></div><div class="line">        <span class="comment">//      Context.MODE_PRIVATE);</span></div><div class="line">        FileOutputStream trace = <span class="keyword">new</span> FileOutputStream(filePath);</div><div class="line"></div><div class="line">        mDeviceCrashInfo.store(trace, <span class="string">""</span>);</div><div class="line">        trace.flush();</div><div class="line">        trace.close();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG) LogUtils.e(TAG, <span class="string">"save a crash file: "</span> + logPath + fileName);</div><div class="line"></div><div class="line">    } <span class="keyword">catch</span> (Exception e) {</div><div class="line">        <span class="keyword">if</span> (DEBUG) LogUtils.e(TAG, <span class="string">"an error occured while writing report file..."</span>, e);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看得到，抓取崩溃的堆栈信息是通过将 java 系统抛出的异常 Throwable 打印到我们之前的那个变量 mDeviceCrashInfo 中，然后再把这个变量里面的信息（全都是 String）保存到指定文件来实现的。这里的保存路径（resolveLogPath），我是做了个接口，可以让程序自由设置的。然后这里还限制了一下崩溃文件的大小，如果保存的崩溃文件数量大小超过一定限制，就会去清理一下。具体的代码我这里就不贴了，大家可以自己去看看。 </p>
<p>然后最后显示下崩溃报告界面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoRestart</span>() {</div><div class="line">    Intent intent;</div><div class="line">    intent = <span class="keyword">new</span> Intent(mContext, CrashReportActivity.class);</div><div class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK</div><div class="line">            | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</div><div class="line">            | Intent.FLAG_ACTIVITY_CLEAR_TOP</div><div class="line">            | Intent.FLAG_ACTIVITY_NO_ANIMATION);</div><div class="line">    PendingIntent contentIntent = PendingIntent.getActivity(mContext, <span class="number">0</span>,</div><div class="line">            intent, PendingIntent.FLAG_UPDATE_CURRENT);</div><div class="line"></div><div class="line">    AlarmManager mgr = (AlarmManager) mContext</div><div class="line">            .getSystemService(Context.ALARM_SERVICE);</div><div class="line"></div><div class="line">    <span class="comment">// record re-start count</span></div><div class="line">    recordReStartCount();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isReStartTooMany()) {</div><div class="line">        <span class="comment">// if re-start count is too many, we abandon it and cancel the old re-start intent.</span></div><div class="line">        mgr.cancel(contentIntent);</div><div class="line">        <span class="comment">// leave the clean count record in application init.</span></div><div class="line">        <span class="comment">//cleanReStartCount();</span></div><div class="line">        selfKill();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// the re-start don't set too short, if is too short,</span></div><div class="line">    <span class="comment">// we have not enough time to cancel it.</span></div><div class="line">    <span class="comment">//mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 100,</span></div><div class="line">    mgr.set(AlarmManager.RTC, System.currentTimeMillis() + <span class="number">300</span>,</div><div class="line">            contentIntent);</div><div class="line">    <span class="keyword">if</span> (DEBUG) LogUtils.d(TAG, <span class="string">"we restart the app"</span>);</div><div class="line"></div><div class="line">    selfKill();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里的崩溃报告界面（CrashReportActivity）是程序中的一个专门用来显示刚刚保存的崩溃信息的 activity 。这里显示这个 activity 的原理是，设一个短时间的闹钟，然后自己杀死已经发生崩溃了的进程，闹钟到时间后，启动显示崩溃信息的 activity 。这里注意，必须杀是原来已经崩溃了的进程，然后重新启动，才能正常启动程序中的 activity，因为原来的进程已经发生了崩溃异常了，程序已经不正常了，不杀死重启的话，是无法再启动 activity 的。这也是前面的说的为什么这个方法无法阻止程序挂掉的原因。</p>
<p>这个 activity 会调用 CrashHandler 的 loadLastCrashReport 接口来读取最后一次保存的崩溃信息来显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String <span class="title">loadLastCrashReport</span>() {</div><div class="line">    StringWriter sw = <span class="keyword">new</span> StringWriter();</div><div class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(sw);</div><div class="line"></div><div class="line">    Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">    String crFile = getLastCrashReportFile();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != crFile) {</div><div class="line">        File cr = <span class="keyword">new</span> File(crFile);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            FileInputStream is;</div><div class="line">            is = <span class="keyword">new</span> FileInputStream(cr);</div><div class="line">            properties.load(is);</div><div class="line">            <span class="comment">//properties.list(pw);</span></div><div class="line">            pw.println(crFile + <span class="string">" -----"</span>);</div><div class="line">            <span class="comment">//pw.println(properties.get(STACK_TRACE));</span></div><div class="line">            printProperties(properties, pw);</div><div class="line">            properties.clear();</div><div class="line">            pw.println();</div><div class="line">            pw.println();</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sw.toString();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>activity 的代码我就不贴了，具体的大家也可以去看代码。</p>
<p>最后弄一个设置处理未获取异常的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(Context context) {</div><div class="line">    <span class="comment">// the path must be public for upload service can access it.</span></div><div class="line">    <span class="comment">//String defLogPath = context.getCacheDir().toString()</span></div><div class="line">    <span class="comment">//      + File.separator + ".crash" + File.separator;</span></div><div class="line">    String defLogPath = DEFAULT_CRASH_LOG_PATH</div><div class="line">            + context.getPackageName() + File.separator;</div><div class="line">    init(context, CRASH_HANDLE_FLAG_CATCH,</div><div class="line">            defLogPath, DEFAULT_CRASH_CACHE_SIZE);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(Context context, <span class="keyword">int</span> flag, String logPath, <span class="keyword">long</span> crashCacheSize) {</div><div class="line">    mContext = context;</div><div class="line">    mPkgName = context.getPackageName();</div><div class="line"></div><div class="line">    mHandleFlag = flag;</div><div class="line">    mLogPath = logPath;</div><div class="line">    mCrashCacheSize = crashCacheSize;</div><div class="line"></div><div class="line">    <span class="comment">// we use app self cache path as re-start count file save path</span></div><div class="line">    mCountFilePath = context.getCacheDir().toString() + File.separator + <span class="string">"CrashLaunchCount.sav"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCrashHandler</span>() {</div><div class="line">    mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();</div><div class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="使用方法">使用方法</h2>
<p>自定义一个 Application ，然后在 onCreate 的时候设置一下捕获全局异常的处理就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ActivityLifecycleCallbacks</span> </span>{</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>() {</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        init();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span>() {</div><div class="line">        <span class="comment">// 初始化全局异常处理</span></div><div class="line">        CrashHandler.getInstance().init(<span class="keyword">this</span>);</div><div class="line">        setCrashLogPath();</div><div class="line">        CrashHandler.getInstance().setCrashCacheSize(CRASH_CACHE_SIZE);</div><div class="line">        CrashHandler.getInstance().registerCrashHandler();</div><div class="line">        ... ...</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里调用 CrashHandler 提供的设置捕获全局异常的接口（init），然后设置了一下保存崩溃文件的路径和崩溃文件的大小限制。如果在某些情况下不想要这个功能，你可以弄个开关，注释掉这3句话就行了，使用起来还是很简单的。因为要写文件，最后别忘记在 manifest 中加上写文件权限和把 application 设置为自己自定义的就行了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="tag">&lt;<span class="title">application</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:name</span>=<span class="value">".lib.CustomApplication"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_launcher"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme"</span></span></div><div class="line"><span class="tag">        &gt;</span></div><div class="line">... ...</div><div class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="限制">限制</h2>
<p>这个方法也不是万能，也存在一些限制：</p>
<ol>
<li>它只能捕获崩溃挂掉的情况。也就是说，如果不是挂掉的问题，而是一些逻辑 bug 或是界面刷新不对的，这个方法是没用的。</li>
<li>它只能捕获有异常发生的情况。如果是 JNI 里面导致一些内存访问越界而导致程序崩溃，这个方法也是没用的。</li>
<li>它不能用来拯救程序的，原因之前说过了，这个方法的功能简单来话说：仅仅是抓 log 。 </li>
</ol>
<p>最后上个效果图（demo里面一个故意的空指针访问）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/crash-catch/1.jpeg" alt=""></p>
<p>附上参考代码（后续改进了下，project 直接编不过的，需要稍微改一下）： <a href="http://pan.baidu.com/s/1ZOwm" title="ApplicationDemo.tar.gz" target="_blank" rel="external">ApplicationDemo.tar.gz</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/Android%20%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</loc>
    <lastmod>2015-01-26T15:00:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 优秀开源网络框架</title>
        <pubTime>2015-01-26T15:00:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>mark 一下现有的 android 一些优秀的开源网络框架，以后有用的时候可以直接用，或者参考以下。</p>
<h2 id="Volley">Volley</h2>
<p>google code 代码： <a href="https://android.googlesource.com/platform/frameworks/volley" title="Volley google code" target="_blank" rel="external">Volley google code</a><br>csdn 上也有介绍这个框架： <a href="http://blog.csdn.net/t12x3456/article/details/9221611" title="Volley 简介" target="_blank" rel="external">Volley 简介</a></p>
<h2 id="Android-Universal-Image-Loader">Android-Universal-Image-Loader</h2>
<p>这是一个异步从网络取图片的框架，同样比较好用， git hub 上的代码： <a href="https://github.com/nostra13/Android-Universal-Image-Loader" title="Android-Universal-Image-Loader code" target="_blank" rel="external">Android-Universal-Image-Loader code</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/26/%5B%E8%BD%AC%5D%20Android%20%E8%AE%A9%E5%BA%94%E7%94%A8%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</loc>
    <lastmod>2015-01-26T14:58:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Android 让应用手动管理应用的数据目录</title>
        <pubTime>2015-01-26T14:58:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>在应用程序管理器点击软件显示的页面，我们可以点击清除数据按钮，这样所有关于该 app 的缓存在手机的数据都清除掉了。类似于新安装的一样。但是有时候，用户不想全部删除，比如登录信息等。就有需求如果应用能够手动管理应用的数据目录的需求，那么 android 系统支持这个功能吗？当然支持了，如图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/manage-app-data/1.png" alt=""></p>
<p>红框处，显示的叫管理空间，而不是我们常常见到的清除数据。当点击这个按钮能够跳转到我们的空间管理页面就做到了，那么如何实现呢？只需要在 AndroidManifest.xml 中的 application 标签添加一个 android:manageSpaceActivity 指定一个 Activity 来管理数据。实例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">application</span> </span></div><div class="line"><span class="tag">    <span class="attribute">android:manageSpaceActivity</span>=<span class="value">"com.test.ManageSpaceActivity"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>ManageSpaceActivity 当然也要在 AndroidManifest.xml 声明为 activity 。综上所述，如果想自己管理数据目录，则可以使用 android:manageSpaceActivity 属性来控制，而不是默认的全部清除了 /data/data/packagename/ 里面的所有文件。当然我们还可以扩展，比如清除 SD 卡上的数据，如果拥有 root 权限，还可以用它当成垃圾清理。</p>
<p><a href="http://blog.csdn.net/mingli198611/article/details/22671919" title="原始出处" target="_blank" rel="external">原始出处</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E8%AE%BE%E7%BD%AE%E5%B9%BF%E6%92%AD%E6%A0%87%E5%BF%97%E5%90%AF%E5%8A%A8%E8%BF%98%E6%B2%A1%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/</loc>
    <lastmod>2015-01-25T15:35:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 设置广播标志启动还没启动程序</title>
        <pubTime>2015-01-25T15:35:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>在 android 中可以通过 context.sendBroadcast(Intent intent) 发送广播，让监听了该广播的程序处理业务。其中 Intent 中有一个 flag：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * If set, this intent will always match any components in packages that</span></div><div class="line"><span class="comment"> * are currently stopped.  This is the default behavior when</span></div><div class="line"><span class="comment"> * {@link #FLAG_EXCLUDE_STOPPED_PACKAGES} is not set.  If both of these</span></div><div class="line"><span class="comment"> * flags are set, this one wins (it allows overriding of exclude for</span></div><div class="line"><span class="comment"> * places where the framework may automatically set the exclude flag).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_INCLUDE_STOPPED_PACKAGES = <span class="number">0x00000020</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>设置了这个 flag 之后，能够让还没启动的程序（如果这个程序在 AndroidManifest 里面静态注册了该广播的话）也能处理这个广播。当然相应的还有一个标志： FLAG_EXCLUDE_STOPPED_PACKAGES 就是相反的功能（好像默认就是这个）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</loc>
    <lastmod>2015-01-25T15:34:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 资源文件夹命名规则</title>
        <pubTime>2015-01-25T15:34:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Android 不同的 dpi、sw、横、竖屏的资源文件夹命名。具体的含义、优先级、规范可以在官方文档的一个专题的看到，有详细说明的：<a href="http://developer.android.com/guide/topics/resources/providing-resources.html#top" title="Android 资源说明" target="_blank" rel="external">Android 资源说明</a> 。里面有张很详细的表，然后后面说明了，资源后缀的排放顺序要按着表从上到下才行。这里就说这一点，其它去看这个文档吧。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%20Preference/</loc>
    <lastmod>2015-01-25T15:32:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 自定义 Preference</title>
        <pubTime>2015-01-25T15:32:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>有些时候系统提供的 Preference 不满足我们的要求的时候，我们就需要自己定制了。现在产品要求 ChekBoxPreference 的 summary 的颜色要能动态改变，在关闭的时候是默认颜色，在开启的时候变成红色。现在我们就可以自己定制啦。</p>
<h2 id="简单的修改_xml">简单的修改 xml</h2>
<p>先说说简单的情况。如果字体颜色只是静态的话，可以不用改代码，改改 layout xml 就好了。系统自己的 xml 是 framework/base/core/res/res/layout/preference.xml 。把这个文件复制，然后在其基础上改改 text 的属性就好了，然后在使用 CheckBoxPreference 的时候指定自己定制的 xml（这里我叫 custom_preference.xml）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></div><div class="line"><span class="comment">&lt;!-- Copyright (C) 2006 The Android Open Source Project</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     Licensed under the Apache License, Version 2.0 (the "License");</span></div><div class="line"><span class="comment">     you may not use this file except in compliance with the License.</span></div><div class="line"><span class="comment">     You may obtain a copy of the License at</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">          http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">     Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment">     distributed under the License is distributed on an "AS IS" BASIS,</span></div><div class="line"><span class="comment">     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment">     See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment">     limitations under the License.</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Layout for a Preference in a PreferenceActivity. The</span></div><div class="line"><span class="comment">     Preference is able to place a specific widget for its particular</span></div><div class="line"><span class="comment">     type in the "widget_frame" layout. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span> </span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:minHeight</span>=<span class="value">"?android:attr/listPreferredItemHeight"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:gravity</span>=<span class="value">"center_vertical"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:paddingRight</span>=<span class="value">"?android:attr/scrollbarSize"</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="title">RelativeLayout</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"15dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginRight</span>=<span class="value">"6dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"6dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginBottom</span>=<span class="value">"6dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_weight</span>=<span class="value">"1"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:id</span>=<span class="value">"@+android:id/title"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:singleLine</span>=<span class="value">"true"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:textAppearance</span>=<span class="value">"?android:attr/textAppearanceLarge"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:ellipsize</span>=<span class="value">"marquee"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:fadingEdge</span>=<span class="value">"horizontal"</span> /&gt;</span></div><div class="line">            </div><div class="line">        // 就是在这里改啦，加一个 textColor 属性</div><div class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:id</span>=<span class="value">"@+android:id/summary"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_below</span>=<span class="value">"@android:id/title"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_alignLeft</span>=<span class="value">"@android:id/title"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:textAppearance</span>=<span class="value">"?android:attr/textAppearanceSmall"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:textColor</span>=<span class="value">"#FFFF0000"</span> </span></div><div class="line"><span class="tag">            <span class="attribute">android:maxLines</span>=<span class="value">"4"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- Preference should place its actual preference widget here. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">android:id</span>=<span class="value">"@+android:id/widget_frame"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:gravity</span>=<span class="value">"center_vertical"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 改好后，在用 CheckBoxPreference 的时候，指定自己的 xml layout</div><div class="line"><span class="tag">&lt;<span class="title">CheckBoxPreference</span> <span class="attribute">android:key</span>=<span class="value">"lock_screen"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:title</span>=<span class="value">"@string/settings_lock_screen_title"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:defaultValue</span>=<span class="value">"false"</span> </span></div><div class="line"><span class="tag">        <span class="attribute">android:layout</span>=<span class="value">"@layout/custom_preference"</span></span></div><div class="line"><span class="tag">    	<span class="attribute">android:summaryOff</span>=<span class="value">"@string/settings_lock_screen_off_summary"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:summaryOn</span>=<span class="value">"@string/settings_lock_screen_on_summary"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:summary</span>=<span class="value">"@string/settings_lock_screen_off_summary"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">CustomCheckBoxPreference</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="扩展代码">扩展代码</h2>
<p>如果需要复杂点的功能，就需要继承 CheckBoxPreference ，然后自己定制代码了。这里以动态的改字体颜色为例：继承 CheckBoxPreference 后，重载父类的 onBindView 函数（这个函数好像是在将数据显示到视图上的时候调用的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCheckBoxPreference</span> <span class="keyword">extends</span> <span class="title">CheckBoxPreference</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">CustomCheckBoxPreference</span>(Context context, AttributeSet attrs,</div><div class="line">			<span class="keyword">int</span> defStyle) {</div><div class="line">		<span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindView</span>(View view) {</div><div class="line">		<span class="keyword">super</span>.onBindView(view);</div><div class="line">		</div><div class="line">		<span class="keyword">boolean</span> isChecked = isChecked();</div><div class="line">		Resources res = view.getResources();</div><div class="line">		</div><div class="line">		TextView summaryView = (TextView)view.findViewById(com.android.internal.R.id.summary);</div><div class="line">		<span class="keyword">if</span> (summaryView != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">if</span> (isChecked) {</div><div class="line">				summaryView.setTextColor(res.getColor(R.color.red));</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				<span class="comment">//summaryView.setTextAppearance(getContext(), com.android.internal.R.attr.textAppearanceSmall);</span></div><div class="line">				summaryView.setTextColor(res.getColor(com.android.internal.R.color.secondary_text_light));</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>写好自己的类之后，在用的时候把原来的 CheckBoxPreference 换成自己的类就可以了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">cn.fmsoft.launcher2.CustomCheckBoxPreference</span> <span class="attribute">android:key</span>=<span class="value">"lock_screen"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:title</span>=<span class="value">"@string/settings_lock_screen_title"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:defaultValue</span>=<span class="value">"false"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:summaryOff</span>=<span class="value">"@string/settings_lock_screen_off_summary"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:summaryOn</span>=<span class="value">"@string/settings_lock_screen_on_summary"</span> </span></div><div class="line"><span class="tag">    	<span class="attribute">android:summary</span>=<span class="value">"@string/settings_lock_screen_off_summary"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">cn.fmsoft.launcher2.CustomCheckBoxPreference</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="参考">参考</h2>
<p>参考出处：<a href="http://www.cnblogs.com/franksunny/archive/2011/10/21/2219890.html" title="Preference 使用小结" target="_blank" rel="external">Preference 使用小结</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20OpenGLES%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-25T15:28:16.000Z</lastmod>
    <data>
        <display>
        <title>Android OpenGLES 学习笔记</title>
        <pubTime>2015-01-25T15:28:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>opengl </tag>
         
         <content><![CDATA[<h2 id="GL10">GL10</h2>
<h3 id="纹理问题">纹理问题</h3>
<p>贴纹理的时候最好是要 2^n 字节对齐，这里说的是最后绑定到 GL 的那个图片（如果这个图片是由别的图片组合的，则组合的小图片没有这个要求）。还有纹理的大小不能超过 GL 最大纹理大小的限制。查询方法： （这里是 GL 标准的，应该还有些特定硬件的扩展的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最大绑定纹理大小, N x N , 应该是字节，我自己试验的结果。</span></div><div class="line">glGetIntegerv(GL10.GL_MAX_TEXTURE_SIZE, statusBuffer) ;</div><div class="line"></div><div class="line"><span class="comment">// 最大绑定纹理的个数。</span></div><div class="line">glGetIntegerv(GL10.GL_MAX_TEXTURE_UNITS, statusBuffer);</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="纹理渲染和颜色渲染冲突">纹理渲染和颜色渲染冲突</h3>
<p>开启了纹理渲染后，好像会对颜色渲染有影响，所以好的习惯是需要纹理渲染时，再打开，渲染完了后，马上关掉，不要让它一直开着。颜色渲染的同理。</p>
<h2 id="GL20">GL20</h2>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20Create%20Bitmap%20Out%20Of%20Memory/</loc>
    <lastmod>2015-01-25T15:25:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Create Bitmap Out Of Memory</title>
        <pubTime>2015-01-25T15:25:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="问题">问题</h2>
<p>Android 对图片的解码、创建是有内存限制的，在弄一些图片多的程序，不小心很容易出 Out of Memory（OOM）的错误。图片用的内存好像是 native 的内存，由于 4.0 普通 UI 也使用了 GPU 硬件加速，导致系统有不少 UI 的缓冲，所以在高分辨率 4.0 的手机上这个问题更加明显（Galaxy Note、Galaxy Neuxs 等等，估计 native 分配给图片的内存用得差不多了）。在网上找了下资料，发现一个比较有用的方法来避免这个问题。在解码图片的时候，指定一些参数来优化下内存使用情况： BitmapFactory.Options 。这个是 Android 解码图片的参数。</p>
<h2 id="解决方法">解决方法</h2>
<h2 id="BitmapFactory-Options-inSampleSize">BitmapFactory.Options.inSampleSize</h2>
<p>这个值是设置解码图片大小的。 &lt;= 1 的话就是图片原始大小。 &gt; 1 的话就会缩小图片， 例如： 4 就是 1/4 。如果你用的图片大小比原始图片要小的话，合理的设置这个值可以降低系统在解码图片时候所使用的内存。PS：文档说这个值如果是 2^n 次方速度会比较快。BitmapFactory.Options 还有个参数 inJustDecodeBounds 可以让系统只是计算图片的一些信息（原始大小），单是不解码，也就是不占用内存。可以配合这个计算出合适的 inSampleSize。</p>
<h3 id="BitmapFactory-Options-inPurgeable">BitmapFactory.Options.inPurgeable</h3>
<p>设置这个值可以让系统在回收内存的时候把图片 pixels 占用的内存回收掉。被回收的图片如果需要再次显示的话，系统会重新解码、载入。这个好像比弱引要好用不少。</p>
<h3 id="参考代码">参考代码</h3>
<p>上个参考代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeBitmap</span>(InputStream is, <span class="keyword">int</span> targetW, <span class="keyword">int</span> targetH){</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == is) {</div><div class="line">			Log.e(TAG, <span class="string">"InputStream is null!"</span>);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">	    Bitmap bmp = <span class="keyword">null</span>;</div><div class="line">	    </div><div class="line">	    <span class="keyword">try</span> {</div><div class="line">	        <span class="comment">// decide target image size.</span></div><div class="line">	        BitmapFactory.Options bfSizeOp = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">	        bfSizeOp.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">	        </div><div class="line">	        BitmapFactory.decodeStream(is, <span class="keyword">null</span>, bfSizeOp);</div><div class="line"></div><div class="line">	        <span class="keyword">int</span> scale = <span class="number">1</span>;</div><div class="line">	        <span class="keyword">if</span> (targetW &lt;= <span class="number">0</span> && targetH &lt;= <span class="number">0</span> ) {</div><div class="line">	        	scale = <span class="number">1</span>;</div><div class="line">	        } <span class="keyword">else</span> {</div><div class="line">	        	<span class="keyword">if</span> (bfSizeOp.outHeight &gt; targetW || bfSizeOp.outWidth &gt; targetH) {</div><div class="line">	        		scale = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, </div><div class="line">	        				(<span class="keyword">int</span>) Math.round(</div><div class="line">	        						Math.log(targetW / (<span class="keyword">double</span>) Math.max(bfSizeOp.outHeight, bfSizeOp.outWidth)) / Math.log(<span class="number">0.5</span>)));</div><div class="line">	        	}</div><div class="line">	        }</div><div class="line">	        </div><div class="line">	        <span class="comment">// decode with inSampleSize and let it auto-gc.</span></div><div class="line">	        BitmapFactory.Options bfOp = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">	        bfOp.inSampleSize = scale;</div><div class="line">	        bfOp.inPurgeable = <span class="keyword">true</span>;</div><div class="line">	        bmp = BitmapFactory.decodeStream(is, <span class="keyword">null</span>, bfOp);</div><div class="line">	        </div><div class="line">	    } <span class="keyword">catch</span> (Exception e) {</div><div class="line">	    	e.printStackTrace();</div><div class="line">	    	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	    }</div><div class="line">	    </div><div class="line">	    <span class="keyword">return</span> bmp;</div><div class="line">	}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>虽然上面的方面可以缓解高分辨率 4.0 手机上创建 bitmap oom 的问题，但是也不能完全依赖这种方法。还需要针对应用进行优化才行。例如说，只持有显示时候的图片，后台不显示的图片要即使释放掉，等等。还有一个有效的方法，在图片多的地方，持有图片使用软件引用（<code>SoftReference&lt;Bitmap&gt;</code>），这样系统就能够即使的回收不使用的图片的内存，当然你得自己处理图片被回收后，重新加载的问题。</p>
<p><strong>PS</strong><br>其实这个问题在新的 Android sdk doc 里的 Android Training —&gt; Advanced Training —&gt; Displaying Bitmaps Efficiently 里就有说明。这个就当是翻译了吧。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-25T15:15:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 布局笔记</title>
        <pubTime>2015-01-25T15:15:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>说实在我个人觉得 Android 搞这套玩意比 MiniGUI 麻烦多了。以前没怎么系统的研究、学习，遇到了不少问题。现在记一下。</p>
<h2 id="onMeasure">onMeasure</h2>
<p>实现 onMeasure 方法基本需要完成下面三个方面的事情（最终结果是你自己写相应代码得出测量值并调用view的一个方法进行设置，告诉给你的view安排位置大小的父容器你要多大的空间）。</p>
<ul>
<li>传递进来的参数：widthMeasureSpec 和 heightMeasureSpec 是你对你应该得出来的测量值的限制。</li>
</ul>
<p>The overidden onMeasure() method is called with width and height measure specifications(widthMeasureSpec and heightMeasureSpec parameters,both are integer codes representing dimensions) which should be treated as requirements for the restrictions on the width and height measurements you should produce.</p>
<ul>
<li>你在 onMeasure 计算出来设置的 width 和 height 将被用来渲染组件。应当尽量在传递进来的 width 和 height 声明之间。虽然你也可以选择你设置的尺寸超过传递进来的声明。但是这样的话，父容器可以选择，如 clipping, scrolling, 或者抛出异常，或者（也许是用新的声明参数）再次调用 onMeasure 。</li>
</ul>
<p>Your component’s onMeasure() method should calculate a measurement width and height which will be required to render the component.it should try to stay within the specified passed in.although it can choose to exceed them(in this case,the parent can choose what to do,including clipping,scrolling,throwing an excption,or asking the onMeasure to try again,perhaps with different measurement specifications).</p>
<ul>
<li>一但 width 和 height 计算好了，就应该调用 View.setMeasuredDimension(int width,int height) 方法，否则将导致抛出异常。</li>
</ul>
<p>Once the width and height are calculated,the setMeasureDimension(int width,int height) method must be called with the calculated measurements.Failure to do this will result in an exceptiion being thrown.</p>
<h3 id="例子分析">例子分析</h3>
<p>在 Android 提提供的一个自定义 View 示例中（在 API Demos 中的 view/LabelView）可以看到一个重写 onMeasure 方法的实例，也比较好理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * @see android.view.View#measure(int, int)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span>(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec) {</div><div class="line">    setMeasuredDimension(measureWidth(widthMeasureSpec),</div><div class="line">            measureHeight(heightMeasureSpec));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Determines the width of this view</span></div><div class="line"><span class="comment"> * @param measureSpec A measureSpec packed into an int</span></div><div class="line"><span class="comment"> * @return The width of the view, honoring constraints from measureSpec</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWidth</span>(<span class="keyword">int</span> measureSpec) {</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY) {</div><div class="line">        <span class="comment">// We were told how big to be</span></div><div class="line">        result = specSize;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// Measure the text</span></div><div class="line">        result = (<span class="keyword">int</span>) mTextPaint.measureText(mText) + getPaddingLeft()</div><div class="line">                + getPaddingRight();</div><div class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) {</div><div class="line">            <span class="comment">// Respect AT_MOST value if that was what is called for by measureSpec</span></div><div class="line">            result = Math.min(result, specSize);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Determines the height of this view</span></div><div class="line"><span class="comment"> * @param measureSpec A measureSpec packed into an int</span></div><div class="line"><span class="comment"> * @return The height of the view, honoring constraints from measureSpec</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureHeight</span>(<span class="keyword">int</span> measureSpec) {</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    mAscent = (<span class="keyword">int</span>) mTextPaint.ascent();</div><div class="line">    <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY) {</div><div class="line">        <span class="comment">// We were told how big to be</span></div><div class="line">        result = specSize;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// Measure the text (beware: ascent is a negative number)</span></div><div class="line">        result = (<span class="keyword">int</span>) (-mAscent + mTextPaint.descent()) + getPaddingTop()</div><div class="line">                + getPaddingBottom();</div><div class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) {</div><div class="line">            <span class="comment">// Respect AT_MOST value if that was what is called for by measureSpec</span></div><div class="line">            result = Math.min(result, specSize);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>直接看 measureWidth 首先看到的是参数，分别代表宽度和高度的 MeasureSpec。 Android2.2 文档中对于 MeasureSpec 中的说明是：</p>
<ol>
<li>一个 MeasureSpec 封装了从父容器传递给子容器的布局需求。</li>
<li>每一个MeasureSpec代表了一个宽度，或者高度的说明。</li>
<li>一个MeasureSpec是一个大小跟模式的组合值。一共有三种模式：</li>
</ol>
<p>A MeasureSpec encapsulates the layout requirements passed from parent to child Each MeasureSpec represents a requirement for either the width or the height.A MeasureSpec is compsized of a size and a mode.There are three possible modes:</p>
<ul>
<li><strong>1. UPSPECIFIED：</strong><br>父容器对于子容器没有任何限制，子容器想要多大就多大。</li>
</ul>
<p>UNSPECIFIED The parent has not imposed any constraint on the child.It can be whatever size it wants.</p>
<ul>
<li><strong>2.EXACTLY：</strong><br>父容器已经为子容器设置了尺寸，子容器应当服从这些边界，不论子容器想要多大的空间。</li>
</ul>
<p>EXACTLY The parent has determined and exact size for the child.The child is going to be given those bounds regardless of how big it wants to be.</p>
<ul>
<li><strong>3.AT_MOST：</strong><br>子容器可以是声明大小内的任意大小。</li>
</ul>
<p>AT_MOST The child can be as large as it wants up to the specified size.</p>
<h3 id="MeasureSpec">MeasureSpec</h3>
<p>MeasureSpec 是 View 类下的静态公开类。MeasureSpec 中的值作为一个整型是为了减少对象的分配开支。此类用于将 size 和 mode 打包或者解包为一个整型。</p>
<p>MeasureSpecs are implemented as ints to reduce object allocation.This class is provided to pack and unpack the size,mode tuple into the int.</p>
<p>我比较好奇的是怎么样将两个值打包到一个int中，又如何解包。MeasureSpec 类代码如下（注释已经被我删除了，因为在上面说明了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>{</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    	 </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span>(<span class="keyword">int</span> size, <span class="keyword">int</span> mode) {</div><div class="line">        <span class="keyword">return</span> size + mode;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span>(<span class="keyword">int</span> measureSpec) {</div><div class="line">        <span class="keyword">return</span> (measureSpec & MODE_MASK);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span>(<span class="keyword">int</span> measureSpec) {</div><div class="line">        <span class="keyword">return</span> (measureSpec & ~MODE_MASK);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我无聊的将他们的十进制值打印出来了：</p>
<pre>
mode_shift=30, 
mode_mask=-1073741824, 
UNSPECIFIED=0, 
EXACTLY=1073741824, 
AT_MOST=-2147483648
</pre>

<p>然后觉得也应该将他们的二进制值打印出来，如下：</p>
<pre>
mode_shift=11110, // 30
mode_mask=11000000000000000000000000000000,
UNSPECIFIED=0, 
EXACTLY=1000000000000000000000000000000, 
AT_MOST=10000000000000000000000000000000
</pre>

<p>MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT ：也就是说 MODE_MASK 是由11左移30位得到的。因为 Java 用补码表示数值.最后得到的值最高位是1所以就是负数了。对于上面的数值我们应该这样想,不要把0x3看成3而要看成二进制的11，而把 MODE_SHIFF 就看成30。那为什么是二进制的11呢？因为只有三各模式,如果有四种模式就是111了因为111三个位才可以有四种组合对吧。我们这样来看：</p>
<pre>
UNSPECIFIED=00000000000000000000000000000000, 
EXACTLY=01000000000000000000000000000000, 
AT_MOST=10000000000000000000000000000000
</pre>

<p>也就是说 0, 1, 2 对应 00, 01, 10。当跟11相与时 00 &amp;11 还是得到 00, 11&amp;01 -&gt; 01, 10&amp;11 -&gt; 10。</p>
<h2 id="onLayout">onLayout</h2>
<p>onLayout 的调用在 onMeasure 之后，主要是决定子 View 如何摆放的。 需要注意的是，如果自定义的 View 只重载了 onLayout 而没重载 onMeasure 的话，就会导致子 View 布局不正确（如果 View 自己都没有在 onMeasure 里设置自己的话，自己的布局都会不对，例如 View 不是继承现有的 View）。要想子 View 布局正确，需要在 onMeasuer 里调用子 View 的 measure 方法设置子 View 的大小，然后在 onLayout 里对子 View 进行布局，才会正确显示。 </p>
<h2 id="一些系统属性分析">一些系统属性分析</h2>
<h3 id="padding_和_margin_的区别">padding 和 margin 的区别</h3>
<p>在 android 默认 view 中 padding (android:paddingTop) 是用于 view 外部的边界距离（例如说 layout 中子 view 之间的）。而 margin (android:layout_marginLeft) 是 view 内部的边界距离（例如说 Button 中字体的距边界的距离）。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20Gesture%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</loc>
    <lastmod>2015-01-25T15:03:16.000Z</lastmod>
    <data>
        <display>
        <title>Android Gesture 使用简介</title>
        <pubTime>2015-01-25T15:03:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Gesture 中文名字叫：手势。就是类似一些浏览器（chrome、Firefox、傲游等）里用鼠标快速的画出一些图像（手势），然后根据这些图像执行某些功能（例如：前进、后退、刷新等）。Android 里自带了手势的功能，只要 import android.gesture 下的一些包就可以使用了。先介绍下相关的类：</p>
<h2 id="手势相关的类">手势相关的类</h2>
<ul>
<li><p><strong>GestureOverlayView</strong><br>这个是一个 view。手势需要在一个 view 里画出来，android 里已经帮我们提供了专门画手势的 view 了。这个 view 一般是放在别的 view （使用手势的应用程序的界面）的上面的。或者说别的 view 要放到 GestureOverlayView 里面。这样就可以在应用程序的整个界面上画手势了。通过 GestureOverlayView 可以得到一个 Gestrue 。</p>
</li>
<li><p><strong>GestureLibrary</strong><br>这个是保存 Gesture 的集合。就和它的名字一样， GestureLibrary 里包含了很多个 Gesture ，然后通过 GestureLibrary 来操作 Gesture ：添加手势、删除手势、匹配手势、加载手势、保存手势等。</p>
</li>
<li><p><strong>GestureLibrarys</strong><br>名字上和 GestureLibrary 很像。这个类的方法全部是 static 的。一般是通过 GestureLibrarys 得到 GestureLibrary 。一般是通过打开文件之类的， Gesture 可以别保存到文件里。</p>
</li>
<li><p><strong>Gesture</strong><br>一个手势就是一个 Gesture 。它好像是一个路径，通过保存一些系列点（好像有个最大值）包记录这个路径。然后比较的时候就通过这些点，来进行比较。 Gesture 可以分为单笔画（手指一抬起就结束，只能画一次的）和多笔画类型（在一个短的时间可以画多次）。我在这里暂时只讨论单笔画。</p>
</li>
</ul>
<h2 id="使用流程">使用流程</h2>
<p>一般的使用流程如下：</p>
<ol>
<li>添加 GestureOverlayView 到你需要使用手势的 Activity 中。然后可以设置一些 view 的属性（例如手势的颜色、笔画、监听函数等）。</li>
<li>通过已经保存的文件得到 GestureLibrarys （文件不存在的话，则会创建一个新的文件），然后通过 GestureLibrarys 得到 GestureLibrary。</li>
<li>通过 GestureLibrary 加载文件中的 Gesture 数据。</li>
<li>在 GestureOverlayView 中画 Gesture，然后可以把这个 Gesture 添加到 GestureLibrary 中（添加完成后，可以保存到文件）。</li>
<li>最后可以把从 GestureOverlayView 中得到的 Gesture 和 GestureLibrary 这已有的 Gesture 进行比较（识别），然后根据 Gesture 的定义执行不同的操作。</li>
</ol>
<h2 id="使用方法">使用方法</h2>
<h3 id="GestureOverlayView">GestureOverlayView</h3>
<ul>
<li>首先要在 Activity 里添加 GestureOverlayView ，在 Activity 的 xml 中添加如下代码：（别用 eclipse 自带的拖界面的方式，很不好用，手动写比较好）</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 注意如下 xml 的放置方式，把 activity 别的 view 放到 GestureOverlayView 的里面。</div><div class="line">// 这样的话就 GestureOverlayView 就覆盖了整个界面了，这样就可以在整个界面画手势。</div><div class="line">// 否则的话 GestureOverlayView 不会覆盖整个界面的。</div><div class="line"><span class="tag">&lt;<span class="title">android.gesture.GestureOverlayView</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:id</span>=<span class="value">"@+id/match_gov"</span> </span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span> </span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_weight</span>=<span class="value">"1.0"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:gestureColor</span>=<span class="value">"#FF00FF00"</span></span></div><div class="line"><span class="tag">    &gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">ListView</span> </span></div><div class="line"><span class="tag">        <span class="attribute">android:id</span>=<span class="value">"@+id/gesture_lv"</span> </span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> </span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span> </span></div><div class="line"><span class="tag">        &gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">ListView</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">android.gesture.GestureOverlayView</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>然后可以设置 GestureOverlayView 的一些属性，例如：</li>
</ul>
<p>1: void setGestureStrokeType(int gestureStrokeType) : 这个是设置 Gesture 笔画的。可以设置为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 多笔画</span></div><div class="line">GESTURE_STROKE_TYPE_MULTIPLE</div><div class="line"></div><div class="line"><span class="comment">// 单笔画</span></div><div class="line">GESTURE_STROKE_TYPE_SINGLE</div><div class="line"></div></pre></td></tr></table></figure>

<p>笔画是指：从手指在触屏上开始画，到手指离开触屏，这个算一笔。多笔画就是说 Gesture 可以由多个笔画组成。单笔画那就是 Gesture 只能由一笔组成啦。</p>
<p>2: void setGestureColor(int color) : 设置 Gesture 的颜色。</p>
<p>3: void addOnGestureListener(GestureOverlayView.OnGestureListener listener) : 这个是设置监听 GestureOverlayView 事件相应函数，其中参数是一个接口，需要实现的接口有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 暂时不太清楚这个接口是什么时候调用的</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onGesture</span> (GestureOverlayView overlay, MotionEvent event)</div><div class="line"></div><div class="line">// 当 gesture 别取消的时候调用，我目前还不太清楚什么情况下 gesture 会被取消</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onGestureCancelled</span> (GestureOverlayView overlay, MotionEvent event)</div><div class="line"></div><div class="line">// 当完成一个 gesture 的时候调用，最有用的一个接口。这个接口需要注意一点：</div><div class="line">// 当你设置 GestureOverlayView 是多笔画的时候，没画完一笔这个接口都会被调用一次，</div><div class="line">// 要想分辨多笔画 gesture 是否完成，可以通过 Gesture 的接口 <span class="title">getStrokesCount</span>() 查询当前 gesture 的笔画来确定</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onGestureEnded</span> (GestureOverlayView overlay, MotionEvent event)</div><div class="line"></div><div class="line">// 当一个 gesture 开始画的时候调用，比较有用的一个接口</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onGestureStarted</span> (GestureOverlayView overlay, MotionEvent event)</div><div class="line"></div></pre></td></tr></table></figure>

<p>4: 还有一些别的属性可以设置，可以自己去查看 android 的 sdk docs。</p>
<h3 id="GestureLibrarys">GestureLibrarys</h3>
<p>这个全都是 static 的方法，主要是用来读取 Gesture 文件的。它的主要方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过一个 java file io 来得到 GestureLibrary</span></div><div class="line"><span class="keyword">static</span> GestureLibrary fromFile(File path)</div><div class="line"></div><div class="line"><span class="comment">// 通过一个文件路径来打开文件得到 GestureLibrary</span></div><div class="line"><span class="keyword">static</span> GestureLibrary fromFile(String path)</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="GestureLibrary">GestureLibrary</h3>
<p>从 GestureLibrarys 得到 GestureLibrary 后，就可以操作 Gesture 了：</p>
<ul>
<li><p><strong>abstract boolean load() :</strong><br>这个接口用来从文件中加载 Gesture 数据。注意从上面的 GestureLibrarys 得到 GestureLibrary，但是文件里的 Gesture 数据并没有马后加载到内存中的。需要调用这个接口才会真正的加载。</p>
</li>
<li><p><strong>void addGesture(String entryName, Gesture gesture) :</strong><br>这个接口用来向 GestureLibrary 中添加一个 Gesture 。在 GestureLibrary 中 Gesture 的保存形式是以类似于 Map 的形式来保存的。一个 Gesture 对应一个名字，如果有重复的则会忽略（所以说如果要覆盖原有的一个 Gesture，你需要把原来的删掉才行）。 可以通过 GestureOverlayView 的 getGesture() 函数获取在 GestureOverlayView 中绘制的 Gesutre，然后通过这个接口，加入到 GestureLibrary 中。</p>
</li>
<li><p><strong>void removeEntry(name) :</strong><br>从 GestureLibrary 中删除一个 Gesture，在上面那个接口也提到了。</p>
</li>
<li><p><strong>abstract boolean save() :</strong><br>将 GestureLibrary 中的 Gesture 保存到文件中。注意使用 addGesture 不会马上保存到文件中的，要调用这个接口才会真正保存到文件中。</p>
</li>
<li><p><strong>Set<string> getGestureEntries() :</string></strong><br>返回 GestureLibrary 中所有的 Gesture 的名字。</p>
</li>
<li><p><strong>ArrayList<gesture> getGestures(String entryName) :</gesture></strong><br>通过 Gesture 的名字返回 Gesture 。目前我还是没怎么搞明白为什么它会返回一个数组，而不是单一个 Gesture ，反正一般来说用这个数组的第一个元素就行了。 sdk 里也没说明。</p>
</li>
<li><p><strong>ArrayList<prediction> recognize(Gesture gesture) :</prediction></strong><br>用给定的 Gesture 配置 GestureLibrary 中保存的 Gesture。这个接口返回的是一个 Prediction 类型的数组。这个 Prediction 有2个比较重要的属性：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配的 Gesture 的名字</span></div><div class="line">String name;</div><div class="line"></div><div class="line"><span class="comment">// 匹配的分数。越高就表示匹配程度越高。一般来说低于 1.00 的就是连大致形状都不像的。</span></div><div class="line"><span class="comment">// 一般来说你需要设定一个判定的分数线。至于是多少就需要自己调试一下了。</span></div><div class="line">doulbe score</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="Gesture">Gesture</h3>
<p>Gesture 是一个路径，通过一系列点来表示。如果你画类似的 Gesture，但是路径的顺序相反的话，那就是不同的 Gesture 来的。Gesure 的操作一般都集中在 GestureLibrary 里了。 Gesure 本身目前来说我用到的就一个接口：</p>
<ul>
<li><strong>Bitmap toBitmap(int width, int height, int inset, int color) :</strong><br>将 Gesture 转化为指定大小、颜色的 Bitmap 。这样的话就可以方便的在 ImageView 这种 view 中显示出当前 Gesture 的形状。</li>
</ul>
<h2 id="小结">小结</h2>
<p>使用 Gesutre 的时候注意要申请写 sdcard 的权限，不然 Gesture 不能正常保存的。附件里有一个例子，可以自定义3个 Gesture 来启动 android 自带的3个应用（点击相应的 Gesture 进行编辑），附上运行效果：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/gesture-sample/1.png" alt=""></p>
<h2 id="附件">附件</h2>
<p><a href="http://s.yunio.com/H73fAq" title="gesture sample" target="_blank" rel="external">gesture sample</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/%E5%8F%8D%E7%BC%96%E8%AF%91%20Android%20apk/</loc>
    <lastmod>2015-01-25T14:50:16.000Z</lastmod>
    <data>
        <display>
        <title>反编译 Android apk</title>
        <pubTime>2015-01-25T14:50:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>如果 java 程序编译的时候没有混淆代码的话，就可以比较容易的反编译。但是反编译不一定就能 100% 的得到原始的代码，不过已经可以拿来做参考了。</p>
<h2 id="apk_—&gt;_xml">apk —&gt; xml</h2>
<p>从 google code (<a href="http://code.google.com/p/android-apktool/" title="apktool下载" target="_blank" rel="external">apktool下载</a>) 下载 apktool 工具，按照 google code 上的说明：</p>
<ol>
<li>Download apktool-install-linux-* file</li>
<li>Download apktool-* file</li>
<li>Unpack both to /usr/local/bin directory (you must have root permissions)</li>
</ol>
<p>设置好 PATH 路径，让系统能找到 apktool。然后 apktool d -f xx.apk /home/mingming/tmp/apk 解压出 apk 完成的 xml 和 资源文件。</p>
<h2 id="class_—&gt;_jar">class —&gt; jar</h2>
<p>从 google code (<a href="http://code.google.com/p/dex2jar/downloads/list" title="dex2jar 下载" target="_blank" rel="external">dex2jar 下载</a>) 下载 dex2jar 工具。然后把 apk 文件改后缀为 .zip ，然后解压出 zip。在里面找到 class.dex ，然后把 class.dex 复制到 dex2jar 目录下。然后执行 dex2jar.sh class.dex (可能之前需要把 dex2jar.sh 增加可执行属性)。成功的话会在本目录下生成 classes.dex.dex2jar.jar 。</p>
<h2 id="jar_—&gt;_java">jar —&gt; java</h2>
<p>从 这里 (<a href="http://jd.benow.ca/" title="jd-gui 下载" target="_blank" rel="external">jd-gui 下载</a>) 下载 jd-gui 工具。然后运行 jd-gui 打开上一步生成的 jar 包，然后就可以在 jd-gui 里看到 jar 里的源代码里。可以使用 jd-gui 的 file 菜单里的 save all source 命令，把源代码导出成一个 zip 包里。</p>
<h2 id="总结">总结</h2>
<p>结合第一步得到的 xml 文件 和 res 文件，以及第三步得到的 java 源代码，就差不多可以还原 apk 程序了。</p>
<h2 id="重新打包">重新打包</h2>
<p>参考： <a href="http://nitinzzz.blogspot.com/" target="_blank" rel="external">http://nitinzzz.blogspot.com/</a> (注：这个被墙了 !!=_=!!)</p>
<ul>
<li><p>首先，准备工具</p>
<ul>
<li>apktool apk_manager ， <a href="http://u.115.com/file/aq38jnat" title="点这里下载" target="_blank" rel="external">点这里下载</a></li>
<li>zip 的 管理工具 ，这个 ubuntu 底下默认有了。</li>
<li>jdk 的 jarsigner ， 我这里路径为 /home/nxliao/tool/android/jvm/java/jdk1.6.0_25/bin/jarsigner</li>
<li>android sdk 的 debug.keystore ，在ubuntu下为 ~/.android/debug.keystore</li>
</ul>
</li>
<li><p>准备实验对象<br>Fishing Joy ， <a href="http://u.115.com/file/bh5nw429" title="点这里下载" target="_blank" rel="external">点这里下载</a></p>
</li>
<li><p>改装</p>
<ul>
<li>用 zip 管理工具打开这个 apk，删除里面的 META-INF 目录</li>
<li>用 apktool 解压处理过的 apk <pre>
$ ./apktool d ~/tmp/jianjiuhongchenfengha_V1.0_mumayi_85342.apk ~/tmp/jianjiuhongchenfengha
</pre></li>
<li>用 vi 打开目标代码 <pre>
$ vi ~/tmp/jianjiuhongchenfengha/smali/com/sg/android/fish/FishActivity.smali
</pre></li>
<li>转到第 330行（在 .method private init()V 内），将 const/16 v6, 0xc8 修改成 const/16 v6, 0x647d （也可以设置成其它数值），即可将初始金钱改成 0x647d =25752</li>
<li>保存退出</li>
<li>用 apktool 重新打包 apk <pre>
$ ./apktool b ~/tmp/jianjiuhongchenfengha ~/tmp/jian.apk
</pre></li>
<li>这时候新的apk还不能直接安装，需要打上签名。用jdk的 jarsigner 打上签名 <pre>
$ jarsigner -verbose -storepass android -keystore ~/.android/debug.keystore ~/tmp/jian.apk androiddebugkey
</pre>

</li>
</ul>
</li>
</ul>
<h2 id="odex_转_dex">odex 转 dex</h2>
<p>odex文件无法直接使用dex2jar进行直接反编译成jar，必须先转为dex，才能继续反编译。用到的工具 baksmali smali</p>
<p>下载地址：<a href="http://code.google.com/p/smali/downloads/list" target="_blank" rel="external">http://code.google.com/p/smali/downloads/list</a> </p>
<p>步骤：</p>
<ul>
<li>1，分解odex文件 java -jar baksmali-1.2.4.jar -x ../TEST.odex 这时候出现问题：</li>
</ul>
<pre>
Error occured while loading boot class path files. Aborting. 
org.jf.dexlib.Util.ExceptionWithContext: Cannot locate boot class path file core.odex 
at org.jf.dexlib.Code.Analysis.ClassPath.loadBootClassPath(ClassPath.java:237) 
at org.jf.dexlib.Code.Analysis.ClassPath.initClassPath(ClassPath.java:145) 
at org.jf.dexlib.Code.Analysis.ClassPath.InitializeClassPathFromOdex(ClassPath.java:110) 
at org.jf.baksmali.baksmali.disassembleDexFile(baksmali.java:96) 
at org.jf.baksmali.main.main(main.java:278) 
</pre>

<p>这是由于缺少core.odex, ext.odex, framework.odex, android.policy.odex, services.odex, bouncycastle.odex, core-junit.odex, 这7个文件的问题，将framework下的这5个odex文件一并考到同级目录下，在运行命令即可。</p>
<ul>
<li>2，生成classes.dex</li>
</ul>
<p>java -Xmx512M -jar smali-1.2.4.jar out -o classes.dex</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%E4%B8%AD%20Error%20generating%20final%20archive%20Debug%20Certificate%20expired%20on%20xx%20%E7%9A%84%E9%94%99%E8%AF%AF/</loc>
    <lastmod>2015-01-25T14:49:16.000Z</lastmod>
    <data>
        <display>
        <title>Android中 Error generating final archive Debug Certificate expired on xx 的错误</title>
        <pubTime>2015-01-25T14:49:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="问题概述：">问题概述：</h2>
<p>在导入一个app后提示如下错误：</p>
<p>“Error generating final archive: Debug Certificate expired on 10/09/18 16:30”</p>
<h1 id="原因分析：">原因分析：</h1>
<p>android要求所有的程序必须有签名，否则就不会安装该程序。在我们开发过程中，adt使用debug keystore，在 preference-&gt;android-&gt;buid中设置。debug的keystore默认有效期为一年，如果你是从一年前开始完android程序，那么在一年后导入这个app的时候很可能出现debug keystore过期，导致你无法生成 apk文件。</p>
<p>此时你只要删除debug keystore就行，系统又会为你生成有效期为一年的私钥。 </p>
<h2 id="解决方法：">解决方法：</h2>
<p>进入C:\Documents and Settings\Administrator.android 删除路径下的debug.keystore及 ddms.cfg。</p>
<p>（不同环境下的目录可能略有不同，可在eclipse中查找此路径：Window-&gt;Preferences-&gt;Android-&gt;Build下 Default debug keystore）</p>
<p>然后重新打开 eclipse 就OK了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/%5B%E8%BD%AC%5D%20linux%20%E4%B8%8B%20ndk-build%20%E5%87%BA%E7%8E%B0%20Invalid%20attribute%20name%20package%20%E9%94%99%E8%AF%AF/</loc>
    <lastmod>2015-01-25T14:47:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) linux 下 ndk-build 出现 Invalid attribute name package 错误</title>
        <pubTime>2015-01-25T14:47:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>在 ubuntu 上 ndk 编译时遇到以下错误： Invalid attribute name: package non-numeric second argument to `wordlist’ function: ‘’. Stop.</p>
<p>原因：项目是从 Windows 制过来的， 所以 The AndroidManifest.xml file had Windows carriage control (\r\n) which was messing up the ndk-gdb script.</p>
<p>解决：用 vim 打开 AndroidManifest.xml，在命令模式下输入”set filetype=unix”，保存退出即可。或其把所有的 ^M 替换掉也可以。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20sdk%20content%20loader%200%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</loc>
    <lastmod>2015-01-25T14:43:16.000Z</lastmod>
    <data>
        <display>
        <title>Android sdk content loader 0 的解决方法</title>
        <pubTime>2015-01-25T14:43:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>有些时候打开 eclipse + adt 会出现 Android sdk content loader 一直卡在 0% 那里。这种时候是没办法编译、调试 apk 的。网上搜罗了几套办法，哎 google 搞开源的还是没 MS 的 VS 省心，但是 VS 又太庞大。</p>
<h2 id="断网">断网</h2>
<p>断网重启 eclipse，这招对我最管用。估计 google 的 adt 又去他的官网检查啥更新去了，在天朝这不是蛋疼么。</p>
<h2 id="删掉_-android">删掉 .android</h2>
<p>把 .android 文件夹删掉，重启 eclipse。其实也不用完全删掉 .android， debugkey 还是可以留着的。</p>
<h2 id="删除_-metadata">删除 .metadata</h2>
<p>删除 workspace 下面的 .metadata 文件夹，重启 eclipse 。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Linux%20%E4%B8%8B%20adb%20usb%20%E8%BF%9E%E6%8E%A5%20usb%20%E8%AE%BE%E5%A4%87%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-25T14:39:16.000Z</lastmod>
    <data>
        <display>
        <title>Linux 下 adb usb 连接 usb 设备问题总结</title>
        <pubTime>2015-01-25T14:39:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>在 linux 上一般刚开始用 usb 数据线 adb 连接 android 设备会出现 “???????????? no permissions” 的提示。这个是因为要使用 usb 来调试需要 root 权限，使用一下的方法将使用 root 权限来使用 usb 设备。</p>
<h2 id="修改_udev_配置">修改 udev 配置</h2>
<p>在 /etc/udev/rules.d/ 下新建一个文件：70-android.rules。其中前面的数字 70 可以是别的数字，但是名字开头数字大文件中记录的规则会覆盖名字开头数字小的文件中的规则，所以你需要尽可能设置的文件名大一些，一般 70 就够用了。然后编辑如下规则：</p>
<pre>
SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", MODE="0666"
</pre>

<p>运行命令，重启udev：</p>
<pre config="brush:bash;toolbar:false;">
$sudo chmod a+rx /etc/udev/rules.d/70-android.rules
$sudo service udev restart
</pre>

<h2 id="添加设备_id_号">添加设备 id 号</h2>
<p>有些时候写了 udev 这个文件，还是连接不上，这个时候需要配置下设备的设备 id 号。在 home 目录下的 .android/adb_usb.ini（没有的话自己新建一个就行） 中加入设备 id 号（usb 连接设备后，可以用 lsusb 看到）。例如：</p>
<pre config="brush:bash;toolbar:false;">
0x2207
0x04e8
</pre>

<h2 id="重新启动_adb">重新启动 adb</h2>
<p>拔掉usb重新连上再执行：</p>
<pre config="brush:bash;toolbar:false;">
adb kill-server

# 然后你就可以看到你的 android 设备了
adb devices

adb shell

# 你 android 设备 root 后，进入 shell 后还可以这样，root 后终端提示符号变成 # 则表示成功
su
</pre> 

<h2 id="adb_网络连接">adb 网络连接</h2>
<p>如果你有安装 Android SDK,应该会知道有一个 ADB 工具，这个工具可以在命令行下控制、调试你的Android 设备，这个工具不仅支持通过 USB 链接，而且可以通过 TCP/IP 来连接，也就是说不需要数据线，通过 wifi 就可以连接了。但是在默认情况下，是无法连接的。下面来讲怎么设置通过 wifi 来连接ADB。在菜场里找一个Android 的终端工具，我用的是 Terminal Emulator ，然后在终端里，依次输入</p>
<pre>
setprop service.adb.tcp.port 5555
stop adbd
start adbd
</pre>

<p>然后，在你的电脑（WIN/LINUX) 里命令行启动 adb，输入 adb connect your-phone-ip</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E7%A8%8B%E5%BA%8F%E7%AD%BE%E5%90%8D%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-25T14:34:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 程序签名问题</title>
        <pubTime>2015-01-25T14:34:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="一、多个开发环境具有相同的_debug_签名">一、多个开发环境具有相同的 debug 签名</h2>
<p>在多台机器用 Eclipse 开发 Android 程序的时候，签名不一致导致要反反复复删除原程序才能安装、调试很不爽吧。其实让 Eclipse 用一样的 debug 签名就好了。方法是选中其中一个 Eclipse 自动生成的 debug 签名（我曾经试过了用自己的签名，Eclipse 的 ADT 不知道密码，而且也没地方自己输入密码，所以只好用 Eclipse 自己生成的 debug 签名了），然后把签名复制到其他 Eclipse 机子上（linux 下的签名是 ~/.android/debug.keystore，window 的是 C:\Users\Administrator.android\debug.keystore）。然后在 Window —&gt;  Preferences —&gt; Andrid —&gt; Build 中的 Custom debug keystore：选中从别的 Eclipse copy 过来的 keystore 就可以。然后你把自己的工程（例如 git 上的）重新 clean、build 一次，就可以直接装上调试了。On Yeah ~~ (≧∇≦)</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/keystore/1.jpeg" alt=""></p>
<h2 id="二、生成自己签名时要注意的问题">二、生成自己签名时要注意的问题</h2>
<p>用 Eclipse 或者 命令行（keytool）生成的教程网上很多。这里简单记录下就行了。用 Eclipse 的话，右键工程 —&gt; Export —&gt; Android —&gt; Export Android Application ，然后选择一个 Android 工程，然后选择 Create new keystore，然后后面就填自己的一些个人信息。这里需要注意的问题是：<strong>Alias 这里的名字要和前面 key 的名字一样，否则在签名的时候会报 keystore 的证书链不存在的问题的。然后这个 key 最好自己保管好。</strong></p>
<p>eclipse android debug key 的密码是 android，自己生成的 key 密码要和这个一样，否则无法使用。</p>
<p>要查看 keystore 信息可以用 keytool 来查看： </p>
<p>keytool -list -v -keystore [enter keystore name] -storepass [enter keystore password]</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20sdk%20%E6%9C%AC%E5%9C%B0%E6%96%87%E6%A1%A3%E5%8A%A0%E8%BD%BD%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</loc>
    <lastmod>2015-01-25T14:33:16.000Z</lastmod>
    <data>
        <display>
        <title>Android sdk 本地文档加载慢的解决办法</title>
        <pubTime>2015-01-25T14:33:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Android sdk 最近的版本本地文档加载很慢。后来上网百度了下，发现是在联网状态下它会去 google 官网上去加载一个 JS 文件。由于身处天朝，所以这个过程会很慢。据说最新的 sdk 解决了这个问题，我是 20 的，然后 API Level 16 （4.1.2）的 sdk ，这个问题依旧。我记得以前我还是 4.0 的 sdk 的时候没这个问题的（谁说解决了的）。</p>
<p>还有一个办法就是不然它联网。这个最简单的办法就是自己断网，不过这个也太不爽了。我系统上有2个浏览器——IE 和 Chrome，平常我用 Chrome，上网银等关键时刻就换 IE。IE 有在工具的菜单下有个叫“脱机状态”的菜单，勾上后，IE 就处于脱机状态了（断网）。嘿嘿~~就是看文档可以用脱机状态的 IE，上网可以用 Chorme。如果你不用 IE 和 Chrome 我就不知道还有什么别的好办法了，我反正是这么解决的。果然脱机的 IE 开文档快多了，几乎是秒快。<br>对于这个问题，我其实很想说一句：卧槽，你都离线了，还去加载啥在线的 JS 文件。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B0%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-25T14:30:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 应用程序开发小问题总结</title>
        <pubTime>2015-01-25T14:30:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>新手问题多多 -_-|| </p>
<h2 id="权限问题">权限问题</h2>
<p>使用某些 api 进行操作时需要申请特定的权限的（最典型的就是写sdcard）。这类 api 一般来 sdk 文档中会有说明的，看的时候看仔细点，并且养成 catch 异常，并且把异常输出到 log 的好习惯。这样如果是因为权限问题失败的话，可以马上从 logcat 中看到类似 “Permission Denied” 输出。申请特定权限，编辑 AndroidManifest.xml 文件。点击 Premission 标签页，add Use Premission ，然后在下拉列表中选择对应的权限就可以了。当然你可以手动在 xml 中添加，但是使用 eclipse 带的编辑器比较方便。添加了权限后，会在安装 apk 的时候有提示。</p>
<h2 id="切换_activity_的问题">切换 activity 的问题</h2>
<p>一般来说一个应该是由多个 activity 组成的。这个时候就需要涉及到 activity 之间的切换了。一般来说启动别的 activity 可以使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一般启动使用 Intent，Intent 的第一参数一般是填发起启动 activity 的 activity。</span></div><div class="line"><span class="comment">// 第二个参数就是你要启动的 activity 的 class。</span></div><div class="line"><span class="comment">// 后面那个可以设置一些启动参数，具体的可以去看 sdk docs</span></div><div class="line">Intent editIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, EditGestureActivity.<span class="keyword">class</span>);</div><div class="line">editIntent.setFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line"></div><div class="line"><span class="comment">// 这个可以用于 activity 之间交换数据</span></div><div class="line">gestureName = (String)(item.get(<span class="string">"ivText"</span>));</div><div class="line"><span class="keyword">if</span> (gestureName != null)</div><div class="line">	editIntent.putExtra(<span class="string">"gestureName"</span>, gestureName);</div><div class="line"></div><div class="line"><span class="comment">// 然后通过 startActivity 启动 activity</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">	startActivity(editIntent);</div><div class="line">} <span class="keyword">catch</span> (ActivityNotFoundException e) {</div><div class="line">	Log.d(<span class="string">"Mylog"</span>, <span class="string">"Error: "</span> + e.toString());</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>不过这个需要注意2点：</p>
<ul>
<li>如果你是启动你应用中的一个非主应用，那么你需要手动在 AndroidManifest.xml 文件的 <code>&lt;application&gt;</code> 标签上添加你的 activity 的标识，否则 startActivity 是无法启动你指定的 activity 的：</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span></div><div class="line">   ... ...</div><div class="line">        </div><div class="line">   // 你要启动的 activity 类</div><div class="line">   <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".EditGestureActivity"</span></span></div><div class="line"><span class="tag">       <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>如果你是启动别的应用程序的主应用，就是你应用程序启动时候的第一个 activity，在 xml 文件的 <code>&lt;activity&gt;</code> 标签中有这样的标识的：</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>那在上面的 Intent 设置中还需要加上 editIntent.addCategory(android.content.Intent.CATEGORY_LAUNCHER); 这样的代码才行。这样就可以启动别的应用程序了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</loc>
    <lastmod>2015-01-25T14:27:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 模拟器使用心得</title>
        <pubTime>2015-01-25T14:27:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<h2 id="加快模拟器速度">加快模拟器速度</h2>
<p>可以去设置里把自动转屏的功能去掉。</p>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>Home: Home</li>
<li>Menu(left softkey) : F2 or Page-up button</li>
<li>Star (right softkey) : Shift-F2 or Page Down</li>
<li>Back : ESC</li>
<li>Call/dial button : F3 </li>
<li>Hangup/end call button : F4 </li>
<li>Search : F5 </li>
<li>Power button : F7 </li>
<li>Audio volume up button : KEYPAD_PLUS, Ctrl-5 </li>
<li>Audio volume down button : KEYPAD_MINUS, Ctrl-F6 </li>
<li>Camera button : Ctrl-KEYPAD_5, Ctrl-F3 </li>
<li>屏幕旋转 Switch to previous layout orientation : <font color="#ff0000">Ctrl-F11</font> </li>
<li>屏幕旋转 Switch to next layout orientation : <font color="#ff0000">Ctrl-F12</font> </li>
<li>Toggle cell networking on/off : F8 </li>
<li>Toggle code profiling : F9 </li>
<li>Toggle fullscreen mode : Alt-Enter </li>
<li>轨迹球 Toggle trackball mode : <font color="#ff0000">F6 （调出后，鼠标移动控制）</font></li>
<li>Enter trackball mode temporarily (while key is pressed) : Delete </li>
<li>DPad left/up/right/down : KEYPAD_4/8/6/2 </li>
<li>DPad center click : KEYPAD_5 </li>
<li>Onion alpha increase/decrease : KEYPAD_MULTIPLY(*) / KEYPAD_DIVIDE(/)</li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/%5B%E8%BD%AC%5D%20Android%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%85%A8%E7%A8%8B%E6%BC%94%E7%A4%BA%5Bjdk+eclipse+android%20sdk%5D/</loc>
    <lastmod>2015-01-25T14:08:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) Android 开发环境搭建全程演示（jdk+eclipse+android sdk）</title>
        <pubTime>2015-01-25T14:08:16.000Z</pubTime>
        
        <tag>android </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<h2 id="一_相关下载">一 相关下载</h2>
<ul>
<li>(1) java JDK下载:</li>
</ul>
<p>进入该网页: <a href="http://java.sun.com/javase/downloads/index.jsp" title="下载页面" target="_blank" rel="external">下载页面</a> (或者直接点击下载)，如下图:<br>选择 Download JDK 只下载JDK，无需下载jre.</p>
<p>图1（挂鸟）</p>
<ul>
<li>(2)eclipse下载</li>
</ul>
<p>进入该网页: <a href="http://www.eclipse.org/downloads/" title="下载页面" target="_blank" rel="external">下载页面</a> ， 如下图:</p>
<p>图2（挂鸟）</p>
<p>我们选择第一个(即eclipse IDE for java EE Developers)</p>
<ul>
<li>(3)下载Android SDK</li>
</ul>
<p>说明: Android SDK两种下载版本，一种是包含具体版本的SDK的，一种是只有升级工具，而不包含具体的SDK版本，后一种大概20多M，前一种70多M。<a href="https://dl-ssl.google.com/android/repository/android-2.1_r01-windows.zip" title="完全版下载" target="_blank" rel="external">完全版下载</a> (android sdk 2.1 r01)，<a href="http://dl.google.com/android/android-sdk_r04-windows.zip" title="升级版下载" target="_blank" rel="external">升级版下载</a> (建议使用这个，本例子就是使用这个这里面不包含具体版本，想要什么版本在Eclipse里面升级就行)</p>
<h2 id="二_软件安装">二 软件安装</h2>
<ol>
<li>安装jdk 6u19，安装完成即可，无需配置环境变量</li>
<li>解压eclipse，eclipse无需安装，解压后，直接打开就行</li>
<li>解压android sdk，这个也无需安装，解压后供后面使用</li>
<li>最终有三个文件夹，如下图:</li>
</ol>
<p>图3（挂鸟）</p>
<h2 id="三_Eclipse配置">三 Eclipse配置</h2>
<h2 id="1_安装android_开发插件">1 安装android 开发插件</h2>
<p>打开Eclipse, 在菜单栏上选择 help-&gt;Install New SoftWare 出现如下界面:</p>
<p>图4（挂鸟）</p>
<p>点击 Add按钮,出现如下界面</p>
<p>图5（挂鸟）</p>
<p>输入网址: <a href="https://dl-ssl.google.com/android/eclipse/" target="_blank" rel="external"></a>    (如果出错，请将https改成http)，名称: Android (这里可以自定义)，点击OK，将出现如下界面</p>
<p>图6（挂鸟）</p>
<p>点击 Next按钮 ，出现如下界面:</p>
<p>图7（挂鸟）</p>
<p>点击Next按钮，出现如下界面:</p>
<p>图8（挂鸟）</p>
<p>选择 I accept the terms of the license agreements   点击Next,进入安装插件界面</p>
<p>图9（挂鸟）</p>
<p>安装完成后，出现如下界面</p>
<p>图10（挂鸟）</p>
<p>点击Yes按钮，重启Eclipse</p>
<h3 id="2_配置android_sdk">2 配置android sdk</h3>
<ul>
<li>(1)点击菜单window-&gt;preferences,进入如下界面</li>
</ul>
<p>图11（挂鸟）</p>
<p>选择你的android SDK解压后的目录，选错了就会报错，这个是升级工具，目前还没有一个版本的SDK</p>
<ul>
<li>(2)升级SDK版本,选择菜单 window-&gt;Android sdk and avd manager 出现如下界面</li>
</ul>
<p>图12（挂鸟）</p>
<p>选择update all按钮，出现如下界面</p>
<p>图13（挂鸟）</p>
<p>选择左边的某一项，点击accept表示安装，点击reject表示不安装，我这里只选了SDK 2.1 和samples for api 7 , 自己可以任意自定义，确定后，选择install按钮，进入安装界面如下:</p>
<p>图14（挂鸟）</p>
<p>安装完成如下:</p>
<p>图15（挂鸟）</p>
<ul>
<li>(3)新建AVD(android vitural device)    和上面一样，进入android sdk and avd manager,选中Vitural Devices 在点击New按钮</li>
</ul>
<p>点击New按钮后，进入如下界面:</p>
<p>图16（挂鸟）</p>
<p>名称可以随便取，target选择你需要的SDK版本，SD卡大小自定义,点击 Create AVD,得到如下结果</p>
<p>图17（挂鸟）</p>
<p>如上显示创建AVD完毕</p>
<h3 id="3_新建Android项目">3 新建Android项目</h3>
<ul>
<li>(1)选择菜单file-&gt;new-&gt;other 进入如下界面:</li>
</ul>
<p>图18（挂鸟）</p>
<p>选择新建Android Project项目，点击Next按钮，进入如下界面</p>
<p>图19（挂鸟）</p>
<p>名称自定义，应用程序名自定义，报名必须包含一个点以上，min SDK version里面必须输入整数，点击Next出现如下界面:</p>
<p>图20（挂鸟）</p>
<p>注: 若有错误如: Project … is missing required source folder: ‘gen’ ,则将gen-&gt;Android.Test-&gt;R.java这个文件删掉，Eclipse会为我们重新生成这个文件，并且不会报错。</p>
<ul>
<li>(3)配置运行</li>
</ul>
<p>右键项目-&gt;Run as -&gt; Run Configuration 进入如下界面:</p>
<p>图21（挂鸟）</p>
<p>该界面，点击Browse 按钮，选择你要运行的项目，选择Target切换到以下界面：</p>
<p>图22（挂鸟）</p>
<p>该界面选择运行的AVD，将AVD前面的方框设置为选择状态。</p>
<ul>
<li>(4)测试项目运行</li>
</ul>
<p>右键项目名称-&gt;run as -&gt;Android Application 即可启动运行该Android程序，如下所示:</p>
<p>图23（挂鸟）</p>
<p>正在进入：</p>
<p>图24（挂鸟）</p>
<p>测试程序运行结果</p>
<h2 id="四_结束语">四 结束语</h2>
<p>至此，android开发环境搭建完毕，有问题请留言。在这里要注意，我这里只是下载了android sdk r4升级工具，没有下载具体的SDK，而是通过在Eclipse里面的Android Sdk管理工具升级的，你也可以直接下载具体的SDK版本，如: Android sdk 2.1 r1 上面有这个的下载链接，但我任务用升级工具更好。</p>
<hr>
<h2 id="更新">更新</h2>
<p>上面转载的可以统统不用管，忘记步骤的去官网看下文档就行： <a href="http://developer.android.com/tools/help/adt.html" title="Eclipse with ADT" target="_blank" rel="external">Eclipse with ADT</a> (请自备 vpn，啥百度教程都抵不上官方的)。</p>
<h3 id="java_版本过低问题">java 版本过低问题</h3>
<p>最近更新了 5.1 的 sdk，挂 vpn 下载后，把 ADT 也更新到最新的了，但是打开 eclipse 发现报这个错误： </p>
<pre>
"Loading data for Android 5.0" has encountered a problem.

Parsing Data for android-21 failed
unsupported major.minor version 51.0
</pre>

<p>刚开始没注意，但是发现用 5.0 的 sdk 编任何工程都出错，换成 4.4 的就能编过了，刚开始还没搞明白咋回事，后面 google 才知道是 java 的版本太低了（当时装的是 jdk6），51.0 要至少 jdk7 以上的，把 jdk6 换成 jdk7 以上的就好了。重新装 jdk 有“困难”的看这里： <a href="http://light3moon.com/2015/01/19/ubuntu 安装 jdk" title="ubuntu 安装 jdk" target="_blank" rel="external">ubuntu 安装 jdk</a> </p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Android%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-25T14:03:16.000Z</lastmod>
    <data>
        <display>
        <title>Android 命令备忘</title>
        <pubTime>2015-01-25T14:03:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>新手问题多多 -_-|| </p>
<h2 id="adb_logcat">adb logcat</h2>
<p>adb logcat -v time： 可以显示每一条 log 的时间戳。</p>
<h2 id="mount">mount</h2>
<p>如果 adbd 是 root 运行的，直接 adb remount 就可以挂载 system 为可读写的。如果 adbd 不是 root 的，shell 进入先 su（系统要 root 之后），然后需要自己手动 mount system 分区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先敲 mount 可以查看系统上已经挂载的分区信息，可以找到 system 的分区</span></div><div class="line">$ mount</div><div class="line"></div><div class="line"><span class="comment"># 例如像下面这样的</span></div><div class="line">tmpfs /dev tmpfs rw,nosuid,relatime,mode=<span class="number">755</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">devpts /dev/pts devpts rw,relatime,mode=<span class="number">600</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">none /dev/cpuctl cgroup rw,relatime,cpu <span class="number">0</span> <span class="number">0</span></div><div class="line">proc /proc proc rw,relatime <span class="number">0</span> <span class="number">0</span></div><div class="line">sysfs /sys sysfs rw,relatime <span class="number">0</span> <span class="number">0</span></div><div class="line">/sys/kernel/debug /sys/kernel/debug debugfs rw,relatime <span class="number">0</span> <span class="number">0</span></div><div class="line">none /acct cgroup rw,relatime,cpuacct <span class="number">0</span> <span class="number">0</span></div><div class="line">tmpfs /mnt/secure tmpfs rw,relatime,mode=<span class="number">700</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">tmpfs /mnt/asec tmpfs rw,relatime,mode=<span class="number">755</span>,gid=<span class="number">1000</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">tmpfs /mnt/obb tmpfs rw,relatime,mode=<span class="number">755</span>,gid=<span class="number">1000</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">/dev/block/platform/emmc/by-name/system /system ext4 ro,relatime,barrier=<span class="number">1</span>,data=ordered <span class="number">0</span> <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment"># 就可以这么敲了</span></div><div class="line">$ mount -r -o remount,rw /dev/block/platform/emmc/by-name/system /system</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="am_(activity_manager)">am (activity manager)</h2>
<p>adb shell 进入 android 的 console 输入的命令<br>am start -n package/activity 可以用来启动一个 activity 例如：<br>am start -n com.eebbk.mingming.k7ui.demo/.K7UIDemo</p>
<p>am startservice package/service 可以启动一个 service 例如：<br>am startservice com.android.systemui/.SystemUIService </p>
<h2 id="pm_(package_manager)">pm (package manager)</h2>
<p>adb shell 进入 android 的 console 输入的命令<br>pm list packages: 可以显示本地已经安装的 app（包名）</p>
<h2 id="getprop_(setprop)">getprop (setprop)</h2>
<p>adb shell 进入 android 的 console 输入的命令<br>获取（打印）系统当前保存的 property</p>
<p>setprop 是设置 property： setprop key value</p>
<h2 id="/system/bin/busybox">/system/bin/busybox</h2>
<p>adb shell 进入 android 的 console 输入 /system/bin/busybox xx<br>这个基本要是在 eng 模式才会有这个东西，当然 root 之后可以自己放 busybox 进去。 busybox 不解释了，有了这个玩意，基本啥 linux 命令都有了。</p>
<h2 id="dmesg">dmesg</h2>
<p>adb shell，打印最近 kernel 的 log。</p>
<h2 id="top_-t(ps_-t)">top -t(ps -t)</h2>
<p>adb shell， top 不带参数是显示当前的进程运行的情况，如果 top -t 则显示每个进程中的线程运行的情况。这个可以用来查看 native 程序线程的情况，java 层的用 DDMS 的带的线程查看工具比较方便。ps -t 也可以，这个就和 DDMS 里面看线程一样了。</p>
<h2 id="dumpsys">dumpsys</h2>
<p>adb shell， dump 系统服务的调试信息，可以接参数（服务的名字，例如 “activity”，这个名字是在 ServiceManager 中注册的名字），不接的话，则是 dump 所有服务的信息。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Java%20%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-25T10:50:16.000Z</lastmod>
    <data>
        <display>
        <title>Java 反射的参数问题</title>
        <pubTime>2015-01-25T10:50:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>在 java 开发中有时候会用到反射（虽然不推荐频繁使用，但是某些时候确实很方便）。至于怎么用直接看 java docs 或者网上就能找到一大堆（或者看我以前写的东西可以）。但是有些时候一些函数比较高级，在使用反射调用的时候就需要注意了。</p>
<h2 id="基本类型数组参数">基本类型数组参数</h2>
<p>例如这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIntsWithArray</span>(<span class="keyword">int</span>[] ints) {</div><div class="line">	mInt1 = ints[<span class="number">0</span>];</div><div class="line">	mInt2 = ints[<span class="number">1</span>];</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这种还算简单的。直接使用相关类型的数组的 class 就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ReflectUtils.invokeMethod(Target.class, targetObj, </div><div class="line">	<span class="string">"setIntsWithArray"</span>, </div><div class="line">	<span class="keyword">new</span> Class[] {<span class="keyword">int</span>[].class}, </div><div class="line">	<span class="keyword">new</span> <span class="keyword">int</span>[] {<span class="number">45</span>, <span class="number">55</span>});</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后那个 invokeMethod 是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"><span class="javadoc"> * Invoke specified class method.</span></div><div class="line"><span class="javadoc"> * </span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @param</span> objClass</span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @param</span> object</span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @param</span> methodName</span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @param</span> paramTypes</span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @param</span> args</span></div><div class="line"><span class="javadoc"> *<span class="javadoctag"> @return</span></span></div><div class="line"><span class="javadoc"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Object <span class="title">invokeMethod</span>(Class&lt;?&gt; objClass, Object object, </div><div class="line">		String methodName, Class&lt;?&gt;[] paramTypes, Object... args) {</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == objClass || <span class="keyword">null</span> == object ||  </div><div class="line">			<span class="keyword">null</span> == methodName) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	Method method = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		method = objClass.getDeclaredMethod(methodName, paramTypes);</div><div class="line">		method.setAccessible(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> method.invoke(object, args);</div><div class="line">    } <span class="keyword">catch</span> (Exception e) {</div><div class="line">        e.printStackTrace();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="对象类型数组参数">对象类型数组参数</h2>
<p>上面那个还算简单的，但是这种就有点麻烦了。这种的函数原型是类似这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mTest1;</div><div class="line">	<span class="keyword">public</span> <span class="title">Test</span>() {</div><div class="line">		mTest1 = -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="title">Test</span>(<span class="keyword">int</span> test) {</div><div class="line">		mTest1 = test;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIntsWithClassArray</span>(Test[] tests) {</div><div class="line">	mInt1 = tests[<span class="number">0</span>].mTest1;</div><div class="line">	mInt2 = tests[<span class="number">1</span>].mTest1;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这种就不能直接像上那样直接传递 Test[] 过去。这样话，穿过去的参数数目会不对的。例如函数的参数只是一个 Test[] 数组，如果你传一个 Test[2] 过去，参数会变成2个。正确的做法是像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Test[] tests = <span class="keyword">new</span> Test[] {</div><div class="line">	<span class="keyword">new</span> Test(<span class="number">65</span>),</div><div class="line">	<span class="keyword">new</span> Test(<span class="number">75</span>)</div><div class="line">};</div><div class="line">Class&lt;?&gt; testClassArray = Class.forName(</div><div class="line">		<span class="keyword">new</span> Test[] {}.getClass().getName());</div><div class="line"></div><div class="line">ReflectUtils.invokeMethod(Target.class, targetObj, <span class="string">"setIntsWithClassArray"</span>, </div><div class="line">		<span class="keyword">new</span> Class[] {Test[].class}, </div><div class="line">		testClassArray.cast(tests));</div><div class="line"></div></pre></td></tr></table></figure>

<p>这样参数数目才对。至于原因我也不是很清楚，反正参考了下度娘的结果，然后自己试了几次发现这样可以。</p>
<p>以后遇到别的什么一些特殊的参数或是返回值可以一起记录在这里 … …</p>
]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/25/Java%20%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-25T10:48:16.000Z</lastmod>
    <data>
        <display>
        <title>Java 备忘</title>
        <pubTime>2015-01-25T10:48:16.000Z</pubTime>
        
        <tag>android </tag>
         
         <content><![CDATA[<p>Java 小菜鸟的备忘。</p>
<h2 id="方法和成员变量的默认权限">方法和成员变量的默认权限</h2>
<p>在类里面的方法，如果不加修饰权限关键字（public, protected, private 等），那默认就是包权限（package）。同一个包里的可以在类外面访问。不过个人感觉在编码中前面加上 <code>/* package */</code> 会更好。</p>
<h2 id="静态代码段">静态代码段</h2>
<p>在类里面，成员变量可以定义为 static，表示所有该类的实例都共享这一个变量。同时如果只想初始化一次这个 static 变量的话，就可以使用静态代码段，入下面所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class test {</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> Canvas();</div><div class="line">	</div><div class="line">    <span class="keyword">static</span> {</div><div class="line">        mCanvas.setDrawFilter(<span class="keyword">new</span> PaintFlagsDrawFilter(Paint.DITHER_FLAG,</div><div class="line">                Paint.FILTER_BITMAP_FLAG));</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="Android Development" url="http://www.light3moon.com/categories/Android-Development/"/>
          
        </display>
    </data>
    </url>

    
    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/%E8%81%94%E8%8A%AF%E9%80%8F%E6%98%8E%E7%AA%97%E4%BD%93%E6%94%AF%E6%8C%81%E6%96%B9%E6%A1%88/</loc>
    <lastmod>2015-01-21T13:35:16.000Z</lastmod>
    <data>
        <display>
        <title>联芯透明窗体支持方案</title>
        <pubTime>2015-01-21T13:35:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<h2 id="需求">需求</h2>
<ul>
<li>底下窗体内容会变化。</li>
<li>接口简单，使用方便。</li>
<li>内存占用少，效率高。</li>
<li>透明窗体弹出时，屏幕上所包含的窗体及个数不限定。</li>
<li>支持透明主窗体、透明非模态对话框、透明模态对话框。</li>
<li>能移动透明窗体和非透明窗体。</li>
<li>在创建了透明窗体后能继续创建非透明窗体。</li>
<li>能动态设置与撤销双缓冲。</li>
</ul>
<h2 id="问题">问题</h2>
<p>这里先要说明下现有 MiniGUI 框架实现透明窗体的问题。如果光光是要窗体能透明还是比较好办的。在双缓冲回调函数中设置下 memdc 的层 alpha ，然后 BitBlt 到屏幕就可以了。但是这里主要存在的问题是透明的窗体的更新的问题。就是透明窗体下面的窗体更新、或是透明窗体本身更新时怎样才能得到正确的图像。这里分2点：</p>
<ul>
<li><p>透明自身窗体更新：由于是透明窗体的，所以透明窗体的图像需要与屏幕做 alpha 混合。非透明窗体直接将自己的图像更新到屏幕就行了。但是如果透明窗体直接这么做的话，会导致与上一次的图像重叠，结果是图像越来越不透明。因此就需要将背景刷新掉。这就需要处在透明窗体下的非透明窗体更新图像。但是现有 MiniGUI 的框架是不会更新下面的窗体的，因为下面的窗体处于透明窗体之下，被挡住了，是会被剪切掉的。</p>
</li>
<li><p>非透明窗体更新：如果处于透明窗体下的非透明窗体更新的话，由于是透明窗体，所以应该能看得到底下的非透明窗体的更新。这就需要透明窗体更新。和上面一点一样， MiniGUI 的现有框架是不会更新透明窗体的。因为透明窗体位于非透明窗体的之上，MiniGUI 认为底下的窗体不会引起上面的窗体的更新。</p>
</li>
</ul>
<h2 id="解决方案">解决方案</h2>
<p>根据上面提到的问题，我们可以在应用层使用 MiniGUI 双缓冲机制来实现。双缓冲提供了一个更新回调函数，窗体有更新时就会调用这个函数。因此我们可以自己设置这个更新函数，然在里面手动更新透明窗体。总结起来分为下面几点：</p>
<ul>
<li>透明窗体和桌面上所有的非透明窗体必须使用双缓冲，透明窗体设置 <code>WS_EX_TRANSPARENT</code> 风格标志。</li>
<li>收集桌面中所有的非透明窗体，按照 zorder 保存在链表中，存放在透明窗体的 adddata2 中。</li>
<li>在透明窗体的更新函数中，遍历该链表，看其中的非透明窗体是否与透明窗体相交，是则将该非透明窗体的相应区域的图像更新到透明区域（更新透明区域的背景）。</li>
<li>在非透明窗体的更新函数，遍历桌面所有其他主窗体，找出具有 <code>WS_EX_TRANSPARENT</code> 风格的透明窗体。判断其更新区域是否与透明窗体相交，如果相交则要强制透明窗体更新。</li>
</ul>
<h2 id="限制条件">限制条件</h2>
<p>根据如上解决方案，本透明窗体的实现，具有一定的限制性，超出限制可能出现不可预料的问题。</p>
<ul>
<li>屏幕上同时只能创建1个透明主窗体。</li>
<li>不要让透明窗体透出桌面（保证其在一个窗体内）。</li>
<li>暂时不支持窗口滚动。</li>
</ul>
<h2 id="接口">接口</h2>
<p>提供如下接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 设置透明窗体附件数据2 */</span></div><div class="line">DWORD SetTransparentWindowAddData2 (HWND hWnd, DWORD newData);</div><div class="line"></div><div class="line"><span class="comment">/* 设置透明窗体 alpha 值 */</span></div><div class="line"><span class="keyword">void</span> SetTransparentWindowAlpha (HWND hWnd, Uint8 alpha);</div><div class="line"></div><div class="line"><span class="comment">/* 获取透明窗体附件数据2 */</span></div><div class="line">DWORD GetTransparentWindowAddData2 (HWND hWnd);</div><div class="line"></div><div class="line"><span class="comment">/* 获取透明窗体 alpha 值 */</span></div><div class="line">Uint8 GetTransparentWindowAlpha (HWND hWnd);</div><div class="line"></div><div class="line"><span class="comment">/* 创建透明主窗体 */</span></div><div class="line">HWND CreateTransparentMainWindow (PMAINWINCREATE pCreateInfo);</div><div class="line"></div><div class="line"><span class="comment">/* 创建透明非模态对话框 */</span></div><div class="line">HWND CreateTransparentMainWindowIndirectParam (</div><div class="line">        PDLGTEMPLATE pDlgTemplate, HWND hOwner,</div><div class="line">        WNDPROC WndProc, LPARAM lParam);</div><div class="line"></div><div class="line"><span class="comment">/* 创建透明模态对话框 */</span></div><div class="line"><span class="keyword">int</span> TransparentDialogBoxIndirectParam (PDLGTEMPLATE pDlgTemplate,</div><div class="line">        HWND hOwner, WNDPROC DlgProc, LPARAM lParam, Uint8 alpha);</div><div class="line"></div><div class="line"><span class="comment">/* 销毁透明主窗体 */</span></div><div class="line">BOOL DestroyTransparentMainWindow (HWND hWnd);</div><div class="line"></div><div class="line"><span class="comment">/* 销毁透明非模态对话框 */</span></div><div class="line">BOOL DestroyTransparentMainWindowIndirect (HWND hWnd);</div><div class="line"></div><div class="line"><span class="comment">/* 销毁透明模态对话框 */</span></div><div class="line">BOOL EndTransparentDialog (HWND hDlg, <span class="keyword">int</span> endCode);</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="实现">实现</h2>
<h3 id="数据结构">数据结构</h3>
<p>这里链表使用的是 linux 内核的链表实现。保存主窗体的链表数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* dc flags */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> TRANS_NORMAL  0</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> TRANS_HAVE_SECONDARYDC  1</span></div><div class="line"></div><div class="line"><span class="comment">/* main window list */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _hwnd_list {</div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 主窗口句柄 */</span></div><div class="line">    HWND hwnd;</div><div class="line"></div><div class="line">    <span class="comment">/* 主窗体 dc flags</span></div><div class="line"><span class="comment">     * 如果原来主窗体有双缓冲风格则不需要手动设置，也不需要手动销毁 */</span></div><div class="line">    <span class="keyword">int</span> dc_flags;</div><div class="line">} hwnd_list_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* transparent window private data */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _trans_wnd_data {</div><div class="line">    <span class="keyword">struct</span> list_head hwnd_head;</div><div class="line"></div><div class="line">    <span class="comment">/* 透明窗体 alpha 值 */</span></div><div class="line">    Uint8 alpha;</div><div class="line"></div><div class="line">    <span class="comment">/* 透明窗体附加数据2</span></div><div class="line"><span class="comment">     * 原来的被用保存链表信息了，额外提供一个给应用程序使用 */</span></div><div class="line">    DWORD addData;</div><div class="line">} trans_wnd_data_t;</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="创建透明主窗体">创建透明主窗体</h3>
<p>CreateTansparentMainWindow、CreateTransparentMainWindowIndirectParam 和 TransparentDialogBoxIndirectParam 其实流程都是差不多。都是先调用对应的 MiniGUI 原有的 API，然后初始化私有数据（就是保存桌面主窗体的链表）。这里主要是就是要实现初始化私有数据，主要流程是：</p>
<ul>
<li>初始化链表（申请内存）。</li>
<li>使用 GetNextMainWindow 取得当前桌面的所有主窗体（注意要区分透明窗体自己）。使用 GetNextMainWindow（<code>HWND_NULL</code>） 做为遍历的开始就能保证 zorder。遍历结束的条件是 GetNextMainWindow 得到的句柄是 <code>HWND_NULL</code> 。</li>
<li>将遍历得到的主窗体句柄保存到链表中。</li>
<li>判断遍历到的主窗体是否有双缓冲风格，如果没有则手动帮其设置上。并设置链表中相应主窗体的 dc flags。</li>
<li>遍历完成，将链表保存到透明窗体的 adddata2 中。</li>
</ul>
<p>这里要注意一点：应该是由于是联芯修改 MiniGUI 源代码的问题，刚开始没办法更新非客户区，所以要在后面手动发送 <code>MSG_NCPAINT</code> 强制更新非客户区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">BOOL init_transparent_data (HWND hWnd)</div><div class="line">{</div><div class="line">    HDC hdc_mainwnd;</div><div class="line">    HDC hdc_secondary;</div><div class="line">    HWND hwnd_main = <span class="number">0</span>;</div><div class="line">    trans_wnd_data_t* data = NULL;</div><div class="line">    hwnd_list_t* wnd_list = NULL;</div><div class="line"></div><div class="line">    <span class="comment">/* init transparent data */</span></div><div class="line">    data = (trans_wnd_data_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(trans_wnd_data_t));</div><div class="line">    <span class="keyword">if</span> ( NULL == data ) </div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&data-&gt;hwnd_head);</div><div class="line">    data-&gt;alpha = <span class="number">255</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* find all other visable main windows */</span></div><div class="line">    hwnd_main = GetNextMainWindow(HWND_NULL);</div><div class="line">    <span class="keyword">while</span> ( hwnd_main ) {</div><div class="line">        <span class="keyword">if</span> ( hwnd_main == hWnd ) {</div><div class="line">            hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        wnd_list = (hwnd_list_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(hwnd_list_t));</div><div class="line">        wnd_list-&gt;hwnd = hwnd_main;</div><div class="line">        list_add(&wnd_list-&gt;<span class="built_in">list</span>, &data-&gt;hwnd_head);</div><div class="line"></div><div class="line">        <span class="comment">/* check if the main window whether has WS_EX_AUTOSECONDARYDC */</span></div><div class="line">        <span class="keyword">if</span> ( !(GetWindowExStyle(hwnd_main) & WS_EX_AUTOSECONDARYDC) ) {</div><div class="line">            hdc_mainwnd = GetDC(hwnd_main);</div><div class="line">            hdc_secondary = CreateCompatibleDC(hdc_mainwnd);</div><div class="line">            SetSecondaryDC(hwnd_main, hdc_secondary, on_update_normal);</div><div class="line">            ReleaseDC(hdc_mainwnd);</div><div class="line"></div><div class="line">            wnd_list-&gt;dc_flags = TRANS_NORMAL;</div><div class="line">            IncludeWindowExStyle(hwnd_main, WS_EX_AUTOSECONDARYDC);</div><div class="line"></div><div class="line">            <span class="comment">/* make main window draw on the secondary dc */</span></div><div class="line">            UpdateWindow(hwnd_main, TRUE);</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            wnd_list-&gt;dc_flags = TRANS_HAVE_SECONDARYDC;</div><div class="line">            hdc_secondary = GetSecondaryDC(hwnd_main);</div><div class="line">            SetSecondaryDC(hwnd_main, hdc_secondary, on_update_normal);</div><div class="line">        }</div><div class="line">        </div><div class="line">        hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* make window to draw */</span></div><div class="line">    ShowWindow(hWnd, SW_SHOWNORMAL);</div><div class="line"></div><div class="line">    <span class="comment">/* set secondary dc update callback function */</span></div><div class="line">    hdc_secondary = GetSecondaryDC(hWnd);</div><div class="line">    SetSecondaryDC(hWnd, hdc_secondary, on_update_transparent);</div><div class="line"></div><div class="line">    <span class="comment">/* store the tranparent data */</span></div><div class="line">    SetWindowAdditionalData2(hWnd, (DWORD)data);</div><div class="line"></div><div class="line">    <span class="comment">/* update the no-client */</span></div><div class="line">    SendMessage(hWnd, MSG_NCPAINT, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="销毁透明主窗体">销毁透明主窗体</h3>
<p>DestroyTransparentMainWindow、DestroyTransparentMainWindowIndirect 和 EndTransparentDialog 的流程也差不多的。都是先销毁私有数据（就是保存桌面主窗体的链表），然后再调用 MiniGUI 对应的 API 销毁。这里主要销毁私有数据，主要流程是：</p>
<ul>
<li>遍历链表，查看主窗体的 dc flags 标志，看主窗体原来是否有双缓冲。如果没有则手动删除双缓冲数据，并还原主窗体设置。</li>
<li>逐一删除链表的节点，释放链表节点内存。</li>
<li>最后删除链表本身内存。</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">BOOL deinit_transparent_data (HWND hWnd)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (HWND_INVALID == hWnd)</div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line">    HDC hdc_secondary;</div><div class="line">    trans_wnd_data_t* data = (trans_wnd_data_t*)GetWindowAdditionalData2(hWnd);</div><div class="line">    hwnd_list_t* wnd_list = NULL;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( NULL == data )</div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line">    <span class="comment">/* free transparent data */</span></div><div class="line">    <span class="keyword">while</span> ( !list_empty(&data-&gt;hwnd_head) ) {</div><div class="line">        wnd_list = (hwnd_list_t*)data-&gt;hwnd_head.prev;</div><div class="line"></div><div class="line">        <span class="comment">/* if it's manual set secondary dc, delete it */</span></div><div class="line">        <span class="keyword">if</span> (HWND_INVALID != wnd_list-&gt;hwnd && TRANS_NORMAL == wnd_list-&gt;dc_flags) {</div><div class="line">            hdc_secondary = GetSecondaryDC(wnd_list-&gt;hwnd);</div><div class="line">            SetSecondaryDC(wnd_list-&gt;hwnd, HDC_SCREEN, ON_UPDSECDC_DONOTHING);</div><div class="line">        }</div><div class="line"></div><div class="line">        list_del(data-&gt;hwnd_head.prev);</div><div class="line">        <span class="built_in">free</span>(wnd_list);</div><div class="line">    }</div><div class="line">    <span class="built_in">free</span>(data);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="透明窗体更新">透明窗体更新</h3>
<p>由于能够支持在创建透明窗体后继续创建非透明主窗体，以及先销毁非透明主窗体。所以需要时时检测是否有新非透明窗体创建，或是有存在的非透明窗体销毁，然后更新保存非透明主窗体的链表。然后更新方式就和前面解决方案里说的是一样的了。更新一次的流程是：</p>
<ul>
<li>使用 GetNextMainWindow 遍历现有的主窗体，和链表中保存的窗体比较，以检查是否有新窗体创建或是有原有的窗体销毁。</li>
<li>如果检测出有新窗体创建或是有原有窗体销毁，则按照 zorder 重新构建链表。</li>
<li>遍历链表中的主窗体，判断这些窗体的区域是否与透明窗体的更新区域相交。如果相交则将对应区域的非透明窗体的图像 BitBlt 到透明窗体的区域（这里就解释了为什么需要桌面上所有的非透明窗体都是双缓冲，以及保存必须按照 zorder）。</li>
<li>最后根据透明窗体的 alpha 值，设置透明窗体 memdc 的 src alpha，然后 BitBlt 透明窗体的 memdc 。</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> rebuild_trans_wnd_data (HWND hWnd)</div><div class="line">{</div><div class="line">    HWND hwnd_main;</div><div class="line">    <span class="keyword">struct</span> list_head* i;</div><div class="line">    <span class="keyword">struct</span> list_head  new_head;</div><div class="line">    hwnd_list_t* wnd_list;</div><div class="line">    trans_wnd_data_t* data = (trans_wnd_data_t*)GetWindowAdditionalData2(hWnd);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( NULL == data )</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* rebuild the main window list according to zorder */</span></div><div class="line">    INIT_LIST_HEAD(&new_head);</div><div class="line"></div><div class="line">    hwnd_main = GetNextMainWindow(HWND_NULL);</div><div class="line">    <span class="keyword">while</span> ( hwnd_main ) {</div><div class="line">        <span class="keyword">if</span> ( hwnd_main == hWnd ) {</div><div class="line">            hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* keep the main window property */</span></div><div class="line">        list_for_each(i, &data-&gt;hwnd_head) {</div><div class="line">            wnd_list = (hwnd_list_t *)i;</div><div class="line">        </div><div class="line">            <span class="comment">/* destroy the prev list and build tmp list */</span></div><div class="line">            <span class="keyword">if</span> ( hwnd_main == wnd_list-&gt;hwnd ) {</div><div class="line">                list_del(i);</div><div class="line">                list_add(i, &new_head);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* build the new main window list */</span></div><div class="line">    INIT_LIST_HEAD(&data-&gt;hwnd_head);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ( !list_empty(&new_head) ) {</div><div class="line">        i = new_head.prev;</div><div class="line">        list_del(new_head.prev);</div><div class="line">        list_add(i, &data-&gt;hwnd_head);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">BOOL check_normal_mainwnd (HWND hWnd)</div><div class="line">{</div><div class="line">    BOOL is_exist = FALSE; </div><div class="line">    HDC hdc_mainwnd;</div><div class="line">    HDC hdc_secondary;</div><div class="line">    HWND hwnd_main;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head* i;</div><div class="line">    hwnd_list_t* wnd_list;</div><div class="line">    trans_wnd_data_t* data = (trans_wnd_data_t*)GetWindowAdditionalData2(hWnd);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( NULL == data )</div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* check whehter there is an new main window created */</span></div><div class="line">    hwnd_main = GetNextMainWindow(HWND_NULL);</div><div class="line">    <span class="keyword">while</span> ( hwnd_main ) {</div><div class="line">        <span class="keyword">if</span> ( hwnd_main == hWnd ) {</div><div class="line">            hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        is_exist = FALSE;</div><div class="line"></div><div class="line">        list_for_each(i, &data-&gt;hwnd_head) {</div><div class="line">            wnd_list = (hwnd_list_t *)i;</div><div class="line">        </div><div class="line">            <span class="keyword">if</span> ( wnd_list-&gt;hwnd == hwnd_main ) {</div><div class="line">                is_exist = TRUE;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* this main window is new created */</span></div><div class="line">        <span class="keyword">if</span> ( FALSE == is_exist ) {</div><div class="line">            wnd_list = (hwnd_list_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(hwnd_list_t));</div><div class="line">            wnd_list-&gt;hwnd = hwnd_main;</div><div class="line">            list_add(&wnd_list-&gt;<span class="built_in">list</span>, &data-&gt;hwnd_head);</div><div class="line">            </div><div class="line">            <span class="comment">/* check if the main window whether has WS_EX_AUTOSECONDARYDC */</span></div><div class="line">            <span class="keyword">if</span> ( !(GetWindowExStyle(hwnd_main) & WS_EX_AUTOSECONDARYDC) ) {</div><div class="line">                hdc_mainwnd = GetDC(hwnd_main);</div><div class="line">                hdc_secondary = CreateCompatibleDC(hdc_mainwnd);</div><div class="line">                SetSecondaryDC(hwnd_main, hdc_secondary, on_update_normal);</div><div class="line">                ReleaseDC(hdc_mainwnd);</div><div class="line"></div><div class="line">                wnd_list-&gt;dc_flags = TRANS_NORMAL;</div><div class="line">                IncludeWindowExStyle(hwnd_main, WS_EX_AUTOSECONDARYDC);</div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                wnd_list-&gt;dc_flags = TRANS_HAVE_SECONDARYDC;</div><div class="line">                hdc_secondary = GetSecondaryDC(hwnd_main);</div><div class="line">                SetSecondaryDC(hwnd_main, hdc_secondary, on_update_normal);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* must rebuild the main window list */</span></div><div class="line">            rebuild_trans_wnd_data(hWnd);</div><div class="line"></div><div class="line">            <span class="comment">/* this is only can create one main window once */</span></div><div class="line">            <span class="keyword">return</span> TRUE;</div><div class="line">        }</div><div class="line">        </div><div class="line">        hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* check whether there is an exist main window destroyed */</span></div><div class="line">    list_for_each(i, &data-&gt;hwnd_head) {</div><div class="line">        wnd_list = (hwnd_list_t *)i;</div><div class="line">        is_exist = FALSE;</div><div class="line"></div><div class="line">        hwnd_main = GetNextMainWindow(HWND_NULL);</div><div class="line">        <span class="keyword">while</span> ( hwnd_main ) {</div><div class="line">            <span class="keyword">if</span> ( hwnd_main == hWnd ) {</div><div class="line">                hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( wnd_list-&gt;hwnd == hwnd_main ) {</div><div class="line">                is_exist = TRUE;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            hwnd_main = GetNextMainWindow(hwnd_main);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* this main window destroyed */</span></div><div class="line">        <span class="keyword">if</span> ( FALSE == is_exist ) {</div><div class="line">            list_del(i);</div><div class="line">            <span class="built_in">free</span>(wnd_list);</div><div class="line"></div><div class="line">            <span class="comment">/* this is only can destroy one main window once */</span></div><div class="line">            <span class="keyword">return</span> TRUE;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* no new create main window, no main window destroyed */</span></div><div class="line">    <span class="keyword">return</span> FALSE;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> on_update_transparent (HWND hWnd, HDC secondary_dc,HDC real_dc,</div><div class="line">        <span class="keyword">const</span> RECT* secondary_rc, <span class="keyword">const</span> RECT* real_rc, <span class="keyword">const</span> RECT* main_update_rc)</div><div class="line">{</div><div class="line">    RECT update_rc;</div><div class="line">    RECT normal_rc;</div><div class="line">    HDC hdc_normal = <span class="number">0</span>;</div><div class="line">    HDC hdc_trans = <span class="number">0</span>;</div><div class="line">    PCLIPRGN pRgn = NULL;</div><div class="line">    HWND hwnd_normal;</div><div class="line">    <span class="comment">/* the param hWnd can be an control handle, so get the main window handle */</span></div><div class="line">    HWND hwnd_trans = GetMainWindowHandle(hWnd);</div><div class="line">    trans_wnd_data_t* data = (trans_wnd_data_t*)GetWindowAdditionalData2(hwnd_trans);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head* i;</div><div class="line">    hwnd_list_t* wnd_list;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( NULL == data )</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* check whether has an new main window */</span></div><div class="line">    <span class="keyword">if</span> ( TRUE == check_normal_mainwnd(hwnd_trans) ) {</div><div class="line">        InvalidateRect(hwnd_trans, NULL, TRUE);</div><div class="line">        SendNotifyMessage(hwnd_trans, MSG_NCPAINT, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* get the screen dc(limit in window rect) */</span></div><div class="line">    hdc_trans = GetDC(hwnd_trans);</div><div class="line"></div><div class="line">    <span class="comment">/* update desktop to the transparent */</span></div><div class="line">    update_rc = *main_update_rc;</div><div class="line">    </div><div class="line">    WindowToScreen(hwnd_trans, &update_rc.left,  &update_rc.top);</div><div class="line">    WindowToScreen(hwnd_trans, &update_rc.right, &update_rc.bottom);</div><div class="line"></div><div class="line">    SendMessage(HWND_DESKTOP, MSG_ERASEDESKTOP, <span class="number">0</span>, (LPARAM)&update_rc);</div><div class="line"></div><div class="line">    <span class="comment">/* make the update background dc has the same clip region with the transparent window dc.</span></div><div class="line"><span class="comment">     * note: it's only update no-client to set the clip region.</span></div><div class="line"><span class="comment">     * real_rc equal to main_update_rc means there is no-client, </span></div><div class="line"><span class="comment">     * except transparent window don't contain caption and border.</span></div><div class="line"><span class="comment">     * but if the transparent window don't contain caption and border there is no worry to about it. */</span></div><div class="line">    <span class="keyword">if</span> ( EqualRect((<span class="keyword">const</span> RECT*)real_rc, (<span class="keyword">const</span> RECT*)main_update_rc) ) {</div><div class="line">        pRgn = CreateClipRgn();</div><div class="line">        <span class="keyword">if</span> ( NULL == pRgn ) {</div><div class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">"on_update_transparent: CreateClipRgn failed\n"</span>);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> ( -<span class="number">1</span> != GetClipRegion(real_dc, pRgn) ) { </div><div class="line">            SelectClipRegion(hdc_trans, (<span class="keyword">const</span> CLIPRGN*)pRgn);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* update all visable main window to the transparent*/</span></div><div class="line">    list_for_each(i, &data-&gt;hwnd_head) {</div><div class="line">        wnd_list = (hwnd_list_t *)i;</div><div class="line">        hwnd_normal = wnd_list-&gt;hwnd;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ( hwnd_normal != HWND_INVALID ) {</div><div class="line">            <span class="comment">/* this API return screen coordinates */</span></div><div class="line">            GetWindowRect(hwnd_normal, &normal_rc);</div><div class="line"></div><div class="line">            update_rc = *main_update_rc;</div><div class="line"></div><div class="line">            WindowToScreen(hwnd_trans, &update_rc.left,  &update_rc.top);</div><div class="line">            WindowToScreen(hwnd_trans, &update_rc.right, &update_rc.bottom);</div><div class="line"></div><div class="line">            <span class="comment">/* if update rect intersect normal window, then update it */</span></div><div class="line">            <span class="keyword">if</span> ( TRUE == DoesIntersect(&update_rc, &normal_rc) ) {</div><div class="line">                ScreenToWindow(hwnd_normal, &update_rc.left,  &update_rc.top);</div><div class="line">                ScreenToWindow(hwnd_normal, &update_rc.right, &update_rc.bottom);</div><div class="line"></div><div class="line">                hdc_normal = GetSecondaryDC(hwnd_normal);</div><div class="line">                BitBlt(hdc_normal, update_rc.left, update_rc.top, RECTW(update_rc), RECTH(update_rc), </div><div class="line">                        hdc_trans, main_update_rc-&gt;left, main_update_rc-&gt;top, <span class="number">0</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    ReleaseDC(hdc_trans);</div><div class="line"></div><div class="line">    <span class="comment">/* blit the transparent window */</span></div><div class="line">    SetMemDCAlpha(secondary_dc, MEMDC_FLAG_SRCALPHA, data-&gt;alpha);</div><div class="line">    BitBlt(secondary_dc, secondary_rc-&gt;left, secondary_rc-&gt;top, </div><div class="line">            RECTWP(secondary_rc), RECTHP(secondary_rc),</div><div class="line">            real_dc, real_rc-&gt;left, real_rc-&gt;top, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( NULL != pRgn )</div><div class="line">        DestroyClipRgn(pRgn);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="非透明窗体更新">非透明窗体更新</h3>
<p>非透明窗体的更新函数除了更新自己的图像以为，还需要通知透明窗体，让其也更新。主要流程是：</p>
<ul>
<li>使用 GetNextMainWindow 遍历现有的主窗体查找到有 WS_EX_TRANSPARENT 的透明窗体（注意区分自己）。</li>
<li>判断非透明窗体的更新区域是否与透明窗体相交。如果相交则调用 InvalidateRect 和 SendNotifyMessage 让透明窗体的客户区和非客户区重绘。</li>
<li>BitBlt 将自己的 memdc 输出到屏幕上。</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> on_update_normal (HWND hWnd, HDC secondary_dc,HDC real_dc,</div><div class="line">        <span class="keyword">const</span> RECT* secondary_rc, <span class="keyword">const</span> RECT* real_rc, <span class="keyword">const</span> RECT* main_update_rc)</div><div class="line">{</div><div class="line">    RECT trans_rc;</div><div class="line">    RECT trans_nc_rc = *main_update_rc;</div><div class="line">    RECT update_rc = *main_update_rc;</div><div class="line">    HWND hwnd_normal = GetMainWindowHandle(hWnd);</div><div class="line">    HWND hwnd_trans = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* find out transparent main window to update it */</span></div><div class="line">    hwnd_trans = GetNextMainWindow(HWND_NULL);</div><div class="line">    <span class="keyword">while</span> ( hwnd_trans ) {</div><div class="line">        <span class="keyword">if</span> (hwnd_trans == hWnd) {</div><div class="line">            hwnd_trans = GetNextMainWindow(hwnd_trans);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ( GetWindowExStyle(hwnd_trans) & WS_EX_TRANSPARENT ) {</div><div class="line">            <span class="comment">/* this API return screen coordinates */</span></div><div class="line">            GetWindowRect(hwnd_trans, &trans_rc);</div><div class="line"></div><div class="line">            WindowToScreen(hwnd_normal, &update_rc.left,  &update_rc.top);</div><div class="line">            WindowToScreen(hwnd_normal, &update_rc.right, &update_rc.bottom);</div><div class="line"></div><div class="line">            <span class="comment">/* if update rect intersect transparent window, then update it */</span></div><div class="line">            <span class="keyword">if</span> ( TRUE == DoesIntersect(&update_rc, &trans_rc) ) {</div><div class="line">                ScreenToClient(hwnd_trans, &update_rc.left,  &update_rc.top);</div><div class="line">                ScreenToClient(hwnd_trans, &update_rc.right, &update_rc.bottom);</div><div class="line"></div><div class="line">                WindowToScreen(hwnd_normal, &trans_nc_rc.left,  &trans_nc_rc.top);</div><div class="line">                WindowToScreen(hwnd_normal, &trans_nc_rc.right, &trans_nc_rc.bottom);</div><div class="line"></div><div class="line">                ScreenToWindow(hwnd_trans, &trans_nc_rc.left,  &trans_nc_rc.top);</div><div class="line">                ScreenToWindow(hwnd_trans, &trans_nc_rc.right, &trans_nc_rc.bottom);</div><div class="line"></div><div class="line">                <span class="comment">//InvalidateRect(hwnd_trans, &update_rc, TRUE);</span></div><div class="line">                InvalidateRect(hwnd_trans, NULL, TRUE);</div><div class="line">                <span class="comment">//SendNotifyMessage(hwnd_trans, MSG_NCPAINT, 0, (LPARAM)&trans_nc_rc);</span></div><div class="line">                SendNotifyMessage(hwnd_trans, MSG_NCPAINT, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">            }</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        hwnd_trans = GetNextMainWindow(hwnd_trans);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* blit the normal window */</span></div><div class="line">    BitBlt(secondary_dc, secondary_rc-&gt;left, secondary_rc-&gt;top, </div><div class="line">            RECTWP(secondary_rc), RECTHP(secondary_rc),</div><div class="line">            real_dc, real_rc-&gt;left, real_rc-&gt;top, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="使用范例">使用范例</h2>
<p>使用起来非简单，但有如下约定：</p>
<ul>
<li>必须使用对应的透明主窗体创建接口创建透明主窗体。</li>
<li>必须使用对应的透明主窗体销毁接口销毁透明主窗体。</li>
<li>只能创建一个透明主窗体。要创建下一个透明窗体时，必须要先销毁之前创建的。</li>
</ul>
<p>具体例子见 <a href="http://s.yunio.com/HRfqEc" title="附件" target="_blank" rel="external">附件</a> 的 main.c 。(哎呦，好像链接失效了，哪天有空去翻翻看代码还不在不)</p>
<hr>
<h2 id="2011-2-16：改动1——支持逐点_alpha（包括在缓冲dc中）">2011.2.16：改动1——支持逐点 alpha（包括在缓冲dc中）</h2>
<h3 id="问题-1">问题</h3>
<ul>
<li><p>在之前的实现中是没办法支持逐点 alpha 的（典型的例子使用 png 图片进行贴图）。因为在目前 MiniGUI 的 BitBlt 实现中，如果有开启了层 alpha （透明窗体的透明实现就是应用层 alpha），就会忽略掉逐点 alpha。典型问题就是如果你用 png 图片进行贴图，然后使用  BitBlt 又开启了 MEMDC_FLAGS_SRCALPHA 的话，就会看到你 png 图片本来透明的部分变黑（一般是 memdc 的默认颜色）。 </p>
</li>
<li><p>关于应用逐点 alpha 还有一个问题。如果是在 memdc 中使用的话，那么还有一个默认 dc 背景颜色的问题。当把 memdc BitBlt 到屏幕 dc 上的时候，逐点 alpha 会透出 memdc 默认的背景颜色（一般是黑色）。如果是在屏幕 dc 上，可以通过不绘制 MiniGUI 的背景来解决（截获 <code>MSG_ERASEBKGND</code> ，然后直接返回）。</p>
</li>
</ul>
<h3 id="解决办法">解决办法</h3>
<p>从以上的问题直接得到的解决办法是：</p>
<ul>
<li><p>多建立一个 memdc ，然后先 BitBlt 进行逐点 alpha 混合，然后再 BitBlt 到屏幕 dc，进行层 alpha 混合。</p>
</li>
<li><p>在 32bit 颜色格式下，可以使用完全透明的颜色，将 memdc 的背景填充一次，这样在 alpha 混合的时候就可以完全透过 memdc 的背景色了。不过这个要求是 32bit 颜色格式的。16bit 色深下十分麻烦，要在 32bit 的memdc 上进行绘制，然后再转到 16bit 的屏幕 dc 上。这个就要求所有的图像加载参考 dc 都要是 32bit 的，并且所有 gdi 相关的参考 dc 都要是 32 bit 的。这个对于联芯来说，改动肯定很大，估计他是不会接受的。</p>
</li>
</ul>
<p>从上面的讨论我们可以看到其实现在透明最大的问题的就是透明的背景问题。为了解决上面的问题可以采用这样的解决办法：</p>
<ul>
<li><p>将透明窗体下窗体的图像复制到透明窗体的缓存 dc 中做为透明的背景（这步可以在透明窗体的 <code>MSG_ERASEBKGND</code> 的消息里进行）。然后在缓冲 dc 里进行带逐点 alpha 的绘制。最后再用带层 alpha BitBlt 到屏幕 dc 上。这样缓冲 dc 里已经有正确的背景了，而且也已经正确的透过了，所以就算没了逐点 alpha 也是正确的了。并且这样还能解决 16bit 色下 memdc 透过默认背景的问题。</p>
</li>
<li><p>这样在方案实现中增加2个接口：DefaultTransparentMainWinProc 和 DefaultTransparentDialogProc 用来封装 <code>MSG_ERASEBKGND</code> 消息处理。使用透明窗体要使用这2个接口替代 MiniGUI 原来的 DefaultMainWinProc 和 DefaultDialogProc 。</p>
</li>
</ul>
<h3 id="本质问题分析">本质问题分析</h3>
<p>上面的实现方式算是比较偏的了（也包括最开始的通过双缓冲来更新透明窗体的背景的实现）。其实如果要从正常逻辑实现透明窗体的话，应该提供如下2个条件：</p>
<ul>
<li>z 序支持，从底到上，逐步重绘透明窗体的背景。</li>
<li>32 bit 颜色格式。</li>
</ul>
<p>更新下实现代码和示例。最开始写的代码有些地方不正确的。附近里的才是最新的。顺带上个效果图，show 一下，现在的 MiniGUI 也能做到这样的效果哦。 :-D</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/leadcore-trans-window/1.png" alt=""></p>
<h2 id="2011-3-24：改动2——一些小修正">2011.3.24：改动2——一些小修正</h2>
<h3 id="问题-2">问题</h3>
<ul>
<li>很多无需收集的窗体，例如 窗口区域为0，不可见的。（联芯他们的 goku 框架里后台一大堆这样的窗口 <code>-_-||</code>）</li>
<li>被隐藏的窗口绘制不正确。</li>
<li>给普通窗体动态添加双缓冲，第一次更新双缓冲中的图片，导致闪烁。</li>
<li>透明窗体刷新速度慢</li>
</ul>
<h3 id="解决办法-1">解决办法</h3>
<ul>
<li>这个可以在透明窗体的更新函数里判断下，如果是不可见的窗体着跳过这个窗体的更新：</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> on_update_transparent (HWND hWnd, HDC secondary_dc, HDC real_dc,</div><div class="line">        <span class="keyword">const</span> RECT* secondary_rc, <span class="keyword">const</span> RECT* real_rc, <span class="keyword">const</span> RECT* main_update_rc)</div><div class="line">{</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    <span class="comment">/* update all visable main window to the transparent */</span></div><div class="line">    list_for_each(i, &data-&gt;hwnd_head) {</div><div class="line">        wnd_list = (hwnd_list_t *)i;</div><div class="line">        hwnd_normal = wnd_list-&gt;hwnd;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ( hwnd_normal != HWND_INVALID && IsWindowVisible(hwnd_normal) ) {</div><div class="line">            <span class="comment">/* this API return screen coordinates */</span></div><div class="line">            GetWindowRect(hwnd_normal, &normal_rc);</div><div class="line"></div><div class="line">            ... ...</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    ... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li><p>这个和上面一样的解决办法</p>
</li>
<li><p>这个在第一次更新时图像到双缓冲上的时候，应该不让双缓冲更新到屏幕上，也就是把双缓冲更新函数设置成 DONOTHING ：</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> BOOL init_transparent_data (HWND hWnd)</div><div class="line">{</div><div class="line">    ... ...</div><div class="line">    </div><div class="line">        <span class="comment">/* check if the main window whether has WS_EX_AUTOSECONDARYDC */</span></div><div class="line">        <span class="keyword">if</span> ( !(GetWindowExStyle(hwnd_main) & WS_EX_AUTOSECONDARYDC) ) {</div><div class="line">            hdc_mainwnd = GetDC(hwnd_main);</div><div class="line">            hdc_secondary = CreateCompatibleDC(hdc_mainwnd);</div><div class="line"></div><div class="line">            <span class="comment">/* just update the secondary dc, not update the real dc</span></div><div class="line"><span class="comment">             * this cat avoid screen blink */</span></div><div class="line">            SetSecondaryDC(hwnd_main, hdc_secondary, ON_UPDSECDC_DONOTHING);</div><div class="line"></div><div class="line">            ReleaseDC(hdc_mainwnd);</div><div class="line"></div><div class="line">            wnd_list-&gt;dc_flags = TRANS_NORMAL;</div><div class="line">            IncludeWindowExStyle(hwnd_main, WS_EX_AUTOSECONDARYDC);</div><div class="line"></div><div class="line">            <span class="comment">/* update the image in the secondary dc */</span></div><div class="line">            UpdateWindow(hwnd_main, TRUE);</div><div class="line">            SetSecondaryDC(hwnd_main, hdc_secondary, on_update_normal);</div><div class="line">        }</div><div class="line"></div><div class="line">    ... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>这个在联芯的实际使用情况中还是有点明显的。根据他们提出改进建议，在他们的使用情况中，有很大几率的情况会遇到在刷新链表中，某个普通窗体的更新区域（普通窗体与透明窗体相交的区域）正好是透明窗体的更新区域，这样就不需在更新后面的普通窗体的背景到透明窗体中来了。不过这样需要将保存的链表反序遍历，并且比较找到是否存在这样的普通窗体，还要记下这个链表位置（或者说记下这个窗体的句柄？？）。仔细分析下，这种思路，在某些情况下应该是能提高效率的。不过我暂时没有实现这个，据说联芯他们在自己改。</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/leadcore-trans-window/2.png" alt=""></p>
<h3 id="代码路径">代码路径</h3>
<p>最开始的代码已经有很多地方不对了。这里就不在上传代码在本文档里了。现在的代码已经在 svn 中（在 3rd-party/transparent 里，devsrv 就是 10.10.0.9）：</p>
<pre>
URL: svn+ssh://devsrv/home/projects/svn/minigui/branches/rel-3-0-arena
</pre>

<h2 id="2011-4-19：改动3——支持动态设置/去除窗口透明属性">2011.4.19：改动3——支持动态设置/去除窗口透明属性</h2>
<h3 id="问题-3">问题</h3>
<p>联芯需要新加一系列动态设置透明窗体属性与动态去掉透明窗体属性的接口。他们需要有个需求，是因为想绕过透明窗体实现方案中的同时只能存在一个透明窗体的限制。他们想在透明窗体存在的时候，弹出一个普通窗体，然后去掉原来透明窗体的属性，最后再给弹出来的普通窗体加上透明属性。</p>
<h3 id="解决办法-2">解决办法</h3>
<p>这个就目前的实现方法来说，并不是很难实现，灵活的运用现有的代码就能很轻松的实现了。新增加一个接口就可以了：</p>
<p><pre><br>BOOL EnableWindowTransparent(HWND hWnd, BOOL isEnable);<br></pre><br>可以通过后一个 BOOL 参数来决定是将普通窗体变成透明窗体，还是把透明窗体变成普通窗体。而这个函数内部可以简单调用内部2个实现函数就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL EnableWindowTransparent(HWND hWnd, BOOL isEnable)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (HWND_INVALID == hWnd)</div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (TRUE == isEnable)</div><div class="line">        <span class="keyword">return</span> enable_win_transparent(hWnd);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> disable_win_transparent(hWnd);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>至于内部的这个函数实现的流程如下：</p>
<ul>
<li><p>enable_win_transparent:</p>
<ol>
<li>如果当前窗体已经具有透明窗体属性，者直接返回。</li>
<li>判断当前窗体是否有双缓冲，如果没有，这动态的设置上双缓冲属性。</li>
<li>调用 <code>init_transparent_data()</code> 申请并初始化透明窗体数据。</li>
<li>更新当前窗体，使其呈现出透明窗体特性。</li>
</ol>
</li>
<li><p>disable_win_transparent:</p>
<ol>
<li>如果当前窗体</li>
<li>去除当前窗口</li>
</ol>
</li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/STi7167%20GAL%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-21T13:25:16.000Z</lastmod>
    <data>
        <display>
        <title>STi7167 GAL 开发笔记</title>
        <pubTime>2015-01-21T13:25:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>以前没弄过和板子相关，包里的howto文档不太具体，所以这次把一些基本的步骤也记下来。 </p>
<h2 id="硬件环境搭建">硬件环境搭建</h2>
<p>STi7167开发板、HDMI接口线、usb转com口线、网线、1080p显示器、开发宿主机。用接口线这这些设备连接起来，注意宿主机和开发版都要接入同一个局域网。</p>
<h2 id="软件环境搭建">软件环境搭建</h2>
<p>开发环境使用 minicom 连接开发板，通过uboot使用nfs挂载宿主机的根文件系统启动。板子上跑的是 STLinux，图像驱动库是 DirectFB 或者是 ST 自己的 ioctl。DirectFB 是经过封装的，稍微上层点的。其实 DirectFB 的加速插件也就是使用 ST 的 ioctl 的。</p>
<h3 id="安装STLinux">安装STLinux</h3>
<ul>
<li><p>先在宿主机上搭建nfs服务。nfs-client, nfs-common, nfs-kernel-server, nfs-server（用 sudo apt-get install 安装）。然后修改 /etc/exports 设置nfs目录(这里设置的是 /home 为nfs目录。然后 /home/nfs 目录增加响应权限。)：</p>
<pre config="brush:bash;toolbar:false;">
/home/  *(rw,sync,no_subtree_check,anonuid=1007,anongid=125)
/home/nfs *(rw,sync,no_subtree_check,no_root_squash,anonuid=1007,anongid=125)
</pre>
</li>
<li><p>解压 STM.tar.gz（要sudo解压，其中要创建一些链接节点）。将 /STLinux-2.3/devkit/sh4/target 文件夹放到 /home/mingming/nfs 下。要把target文件夹的权限改一下。</p>
</li>
<li><p>在宿主机启动 minicom（配置文件在用户目录/.minirc.dlf）。ctrl+A+Z改下配置。查看下/dev/下的usb节点是哪个（一般第一是ttyUSB0），修改串口端口为相应的usb端口（例如ttyUSB0）。关掉硬件、软件流控制。打开 linewrap 功能（因为后面的配置命令很长）。</p>
</li>
<li><p>上电启动板子，在 minicom 的终端按任意键进入配置命令行。根据实际情况修改howto文档里给出的配置命令：</p>
<pre config="brush:bash;toolbar:false;">
setenv bootargs console=ttyAS0,115200 ip=192.168.1.233:192.168.1.101:192.168.1.1:255.255.0.0::eth0:off nwhwconf=device:eth0,hwaddr:00:FA:E0:FA:E0:00 rw root=/dev/nfs nfsroot=/home/mingming/nfs/target,nfsvers=2,tcp bigphysarea=2000 
</pre>

</li>
</ul>
<p>这里宿主机的ip是 192.168.1.101，板子的ip是 192.168.1.233，网关为 192.168.1.1，子网掩码为 255.255.0.0。然后saveenv，reset重启，之后就可以正常启动了。在根文件系统中的 /root/ 下有个 load_fb.sh 的脚本，可以通过修改里面的参数设置 framebuffer 的颜色格式（FULLHD 那里，format0 可以改成 RGB565，就可以改掉逐点 alpha 的颜色格式，一般就用这2种颜色格式）：</p>
<pre config="brush:bash;toolbar:false;">
# Resolution for main output 
# --------------------------
if [ $# -eq 0 ] || [ $1 = "PAL" ]; then
    mode0=720x576-50i
    mem0=4
    format0=ARGB1555
    ratio0="4TO3"
else if [ $1 = "HD" ]; then
    mode0=1280x720-50
    mem0=7
    format0=ARGB1555
    ratio0="4TO3"
else if [ $1 = "FULLHD" ]; then
    mode0=1920x1080-50i
    mem0=10
    format0=ARGB1555
    ratio0="4TO3"
fi
fi
fi
</pre>

<h3 id="DirectFB_测试例子">DirectFB 测试例子</h3>
<p>启动STLinux后，用root登录。在/bin目录下，ln -s telnetd busybox，用busybox链接出telneted。然后用telneted命令启动telnetd服务。之后就可以按照howto文档里说的加载模块，启动DirectFB，在宿主机的另外一个终端用telnet登录到板子上，然后运行 df_dok 的测试例子。</p>
<h3 id="验证交叉工具链">验证交叉工具链</h3>
<p>宿主机终端命令： export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin/:$PATH （这里的PATH是解压STLinux平台交叉编译工具的路径）。然后在终端试试能运行 sh4-linux-gcc —version 查看交叉工具链的版本号。从hwoto文档里给出的 DirectFB 的网站里下载到填充背景和画线的simple，用 sh4-linux-gcc simple.c -I/opt/STM/STLinux-2.3/devkit/sh4/target/usr/include/directfb/ -ldirectfb -o dfbsimple 交叉编译（注意这里的路径要是你自己解压的路径）。然后把编译出来的程序复制到之前的 nfs 根文件系统的一个位置（例如/roo/test/）。然后telnet登录的终端就可以运行编译出来的程序。能看到HDMI输出填充指定背景颜色和画线就说明交叉工具链正常。</p>
<h2 id="基于_DirectFB_的_GAL">基于 DirectFB 的 GAL</h2>
<p>… …</p>
<h2 id="基于_stgfb_ioctl_的_GAL">基于 stgfb_ioctl 的 GAL</h2>
<p>这个是使用更加底层的方式，直接调用ST提供的ioctl操作，不使用 DirectFB 封装。优点是更加灵活，直接的操作ST的底层芯片，能够使用ST芯片的所有功能，不受封装库的限制。缺点就是比较麻烦，ST的底层ioctl命令参数很多。7167的2D图像加速硬件叫 STBlit ，有2种方式可以访问：</p>
<ul>
<li><p>通过调用 stblit 的封装函数。这些函数是对 stblit_ioctl 的封装。见图1。</p>
</li>
<li><p>直接使用 stgfb_ioctl，这个是 STBlit 扩展的 FrameBuffer 的 ioctl 操作（也就是7167 2D图像硬件特有的ioctl操作，这里就叫做 stgfb_ioctl）。见图2。<br>ST 是推荐使用第2种方式，因为第二种方式不需要经过 stblit 函数的封装，速度更快。我是选择使用第2种方式的，倒不是因为 ST 的推荐，而是因为我手头上只有第2种方式的例子。ST 的那个 stapi 的源代码，看得我头都晕了。这里要特别感谢佐朝同志提供的示例。</p>
</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/sti7167-gal/1.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/sti7167-gal/2.png" alt=""></p>
<h3 id="基本流程">基本流程</h3>
<p>使用 stgfb 的基本流程如下：</p>
<ul>
<li><p>首先要加载 7167 上 ST 和图像相关的驱动模块：stblit_ioctl.ko, stlayer_ioctl.ko 等。这些在前面说的按照 howto 文档里加载内核模块驱动的时候就已经加载好了。</p>
</li>
<li><p>打开 FrameBuffer 设备。按前面的加载好内核模块，并加载 fb 设备的话。fb 的设备节点应该是 /dev/fb0, /dev/fb1，fb0是主屏，fb1是副屏。这里只使用到了主屏。这里的打开代码可以参照 MiniGUI fb GAL 部分的代码。</p>
</li>
<li><p>获取视图（ViewPort）处理句柄（Handler）。</p>
</li>
<li><p>初始化 7167 主显示层（layer）。首先要打开层管理设备（/dev/stapi/stlayer_ioctl），然后通过 ioctl 发送使能命令激活该层，最后通过 ioctl 获取该层的一些信息（也就是屏幕的信息）。</p>
</li>
<li><p>到这里初始化工作就完成了。可以通过 fb 设备文件描述符号（这个就是之前打开的 FrameBuffer 设备），使用 stgfb_ioctl 发送 STGFB_IO_BLIT_COMMAND 命令（要填写响应的命令参数），让 STBlit 进行图像绘制操作。</p>
</li>
<li><p>退出的时候，关闭之前打开的设备即可。</p>
</li>
</ul>
<h3 id="stgfb_io_接口命令">stgfb io 接口命令</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_SET_OVERLAY_COLORKEY       _IOW('B', 0x1, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_ENABLE_FLICKER_FILTER      _IOW('B', 0x2, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_DISABLE_FLICKER_FILTER     _IOW('B', 0x3, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_BLIT_COMMAND               _IOW('B', 0x4, STGFB_BLIT_Command_t)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_SET_OVERLAY_ALPHA          _IOW('B', 0x5, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_GET_LAYER_HANDLE           _IOW('B', 0x6, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_GET_VIEWPORT_HANDLE        _IOW('B', 0x7, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_SET_FB_POSITION            _IOW('B', 0x8, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_SYNC_BLITTER               _IOW('B', 0x9, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_SET_WINDOW                 _IOW('B', 0x10, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_ENABLE_LAYER               _IOW('B', 0x11, int)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STGFB_IO_SET_PREMULTIPLIED          _IOW('B', 0x12, int)</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="ViewPort_Handler">ViewPort Handler</h3>
<p>通过 STGFB_IO_GET_VIEWPORT_HANDLE 命令发送，设备是 fb 设备。参数为 STLAYER_ViewPortHandle_t ，这应该是一个地址。该句柄在是后面获取 layer 信息的参数，一定要取得。</p>
<h3 id="Layer">Layer</h3>
<ul>
<li><p>首先是要激活一个 layer。通过 STGFB_IO_ENABLE_LAYER 命令发送，设备是 fb 设备。参数为 int，1为激活，0为禁用，注意传的时候，要传入该变量的地址，而不是把该变量的值传过去。</p>
</li>
<li><p>激活后，就可以通过 STLAYER_IOC_GETVIEWPORTPARAMS 命令发送获取层信息，注意这时候的设备是 layer 的设备（就是 /dev/stapi/stlayer_ioctl）。参数是 STLAYER_Ioctl_GetViewPortParams_t 。其中的 VPHandle 是传入参数，就是之前获取的那个。STLAYER_Ioctl_FlatViewPortParams_t 是输出参数，具体的参数就在里面。在 ST 内部，图像是以 STGXOBJ_Bitmap_t 为单位的，一个图像就是这么一个位图。从这个结构体定义就可以知道屏幕的一些重要信息了（以下的注释是我自己写的，非官方的）：</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STGXOBJ_Bitmap_s</div><div class="line">{</div><div class="line">  STGXOBJ_ColorType_t                   ColorType;          <span class="comment">// 颜色格式，RGB565, ARGB1555 等</span></div><div class="line">  STGXOBJ_BitmapType_t                  BitmapType;         <span class="comment">// 图像类型，作用未知</span></div><div class="line">  BOOL                                  PreMultipliedColor;       <span class="comment">// 这个也暂时不知道是干啥的，好像是某种逐点特效（应该不是逐点alpha）</span></div><div class="line">  STGXOBJ_ColorSpaceConversionMode_t    ColorSpaceConversion;     <span class="comment">// 颜色转化空间，作用未知</span></div><div class="line">  STGXOBJ_AspectRatio_t                 AspectRatio;         <span class="comment">// 长宽比</span></div><div class="line">  U32                                   Width;               <span class="comment">// 宽</span></div><div class="line">  U32                                   Height;              <span class="comment">// 高</span></div><div class="line">  U32                                   Pitch;               <span class="comment">// Pitch值</span></div><div class="line">  U32                                   Offset;              <span class="comment">// 地址偏移1，这个应该是显存偏移</span></div><div class="line">  <span class="keyword">void</span>*                                 Data1_p;             <span class="comment">// 物理地址1，这是物理显存地址，这个和用fb获取到的地址是一样的</span></div><div class="line">  <span class="keyword">void</span>*                                 Data1_Cp;            <span class="comment">// 物理地址1，这个是cache地址</span></div><div class="line">  <span class="keyword">void</span>*                                 Data1_NCp;           <span class="comment">// 物理地址2，这个是uncache地址</span></div><div class="line">  U32                                   Size1;               <span class="comment">// 地址1的长度</span></div><div class="line">  <span class="keyword">void</span>*                                 Data2_p;</div><div class="line">  <span class="keyword">void</span>*                                 Data2_Cp;</div><div class="line">  <span class="keyword">void</span>*                                 Data2_NCp;</div><div class="line">  U32                                   Size2;</div><div class="line">  STGXOBJ_SubByteFormat_t               SubByteFormat;</div><div class="line">  BOOL                                  BigNotLittle;        <span class="comment">// TRUE：大端存储；FALSE：小端存储</span></div><div class="line">  U32                                   Pitch2;</div><div class="line">  U32                                   Offset2;</div><div class="line">  YUV_ScalingFactor_t                   YUVScaling;</div><div class="line">} STGXOBJ_Bitmap_t;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STLAYER_Ioctl_FlatViewPortSource_s</div><div class="line">{    </div><div class="line">    STLAYER_ViewPortSourceType_t    SourceType;    <span class="comment">// 源数据类型，就是告诉你下面的Data联合体是哪个：是位图还是视频流</span></div><div class="line">    <span class="keyword">union</span></div><div class="line">    {</div><div class="line">        STGXOBJ_Bitmap_t           BitMap;</div><div class="line">        STLAYER_StreamingVideo_t   VideoStream;</div><div class="line">    }                              Data;</div><div class="line">    STGXOBJ_Palette_t              Palette;</div><div class="line">} STLAYER_Ioctl_FlatViewPortSource_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STLAYER_Ioctl_FlatViewPortParams_s</div><div class="line">{</div><div class="line">    STLAYER_Ioctl_FlatViewPortSource_t  Source;</div><div class="line">    STGXOBJ_Rectangle_t             InputRectangle;</div><div class="line">    STGXOBJ_Rectangle_t             OutputRectangle;</div><div class="line">} STLAYER_Ioctl_FlatViewPortParams_t;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">    <span class="comment">/* Error code retrieved by STAPI function */</span></div><div class="line">    ST_ErrorCode_t                      ErrorCode;</div><div class="line"></div><div class="line">    <span class="comment">/* Parameters to the function */</span></div><div class="line">    STLAYER_ViewPortHandle_t            VPHandle;</div><div class="line">    STLAYER_Ioctl_FlatViewPortParams_t  FlatParams;</div><div class="line"></div><div class="line">} STLAYER_Ioctl_GetViewPortParams_t;</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="Blit">Blit</h3>
<p>blit 使用 STGFB_IO_BLIT_COMMAND 命令来实现。stgfb 的 blit 参数主要是设置源和目标（STGXOBJ_Bitmap_t）以及一些 blit 时的一些参数：例如 colorkey、层alpha等。这里调用 ioctl 的设置是 fb 的设备。下面就这些参数分析下吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* stblit ioctl 参数 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">    STGFB_BLIT_Operation_t Operation;     <span class="comment">// Blit 类型，见下面，Blit、FillRect、DrawRect 都是用同一个 io 命令的</span></div><div class="line">	<span class="keyword">union</span></div><div class="line">	{</div><div class="line">        STGFB_BLIT_FillRectangleParams_t    FillRectangle;      <span class="comment">// Blit 类型为 FillRect 时的参数</span></div><div class="line">        STGFB_BLIT_DrawRectangleParams_t    DrawRectangle;      <span class="comment">// Blit 类型为 DrawRect 时的参数</span></div><div class="line">        STGFB_BLIT_BlitParams_t             Blit;               <span class="comment">// Blit 类型为 Blit 时的参数</span></div><div class="line">    } Params;</div><div class="line">    ST_ErrorCode_t Result;          <span class="comment">// 错误代码</span></div><div class="line"></div><div class="line">} STGFB_BLIT_Command_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* Blit 操作类型 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">{</div><div class="line">    STGFB_BLIT_UNKNOWN = <span class="number">0</span>,</div><div class="line">    STGFB_BLIT_FILLRECTANGLE,</div><div class="line">    STGFB_BLIT_DRAWRECTANGLE,</div><div class="line">    STGFB_BLIT_BLIT,</div><div class="line">    STGFB_BLIT_COPYRECTANGLE</div><div class="line">} STGFB_BLIT_Operation_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* Blit 操作命令参数 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">    STBLIT_Handle_t         Handle;  <span class="comment">// blit handle，这个没什么特殊要求的话，可以设置成0，底层有自己的handle的</span></div><div class="line"></div><div class="line">    <span class="comment">/* source 2 */</span></div><div class="line">    STBLIT_SourceType_t     Src2Type;  <span class="comment">// 第二个源，这个支持2个源混合后 blit 到目标，但是 MiniGUI 不支持，没用到</span></div><div class="line">    <span class="keyword">void</span>*                   Src2Data_p;</div><div class="line">    STGXOBJ_Rectangle_t     Src2Rectangle;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/* source */</span></div><div class="line">    STBLIT_SourceType_t     SrcType;   <span class="comment">// 第一个源的类型，见下面的</span></div><div class="line">    <span class="keyword">void</span>*                   SrcData_p;   <span class="comment">// 第一个源的数据指针，如果是位图的话（blit），就是指向 STGXOBJ_Bitmap_t 的指针</span></div><div class="line">    STGXOBJ_Rectangle_t     SrcRectangle;  <span class="comment">// 第一个源的区域大小</span></div><div class="line"></div><div class="line">    <span class="comment">/* destination */</span></div><div class="line">    STGXOBJ_Bitmap_t        DestBitmap;    <span class="comment">// 目标位图</span></div><div class="line">    STGXOBJ_Rectangle_t     DestRectangle;  <span class="comment">// 目标区域</span></div><div class="line"></div><div class="line">    STBLIT_BlitContext_t    Context;  <span class="comment">// blit 的上下文参数，见下面，主要是设置 colorkey，层alpha等信息</span></div><div class="line">    STGFB_BLIT_Effect_t     Effect;   <span class="comment">// 暂时没研究用处</span></div><div class="line">    <span class="keyword">void</span>                    *Palette_p;</div><div class="line">} STGFB_BLIT_BlitParams_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* blit 源类型 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> STBLIT_SourceType_e</div><div class="line">{</div><div class="line">    STBLIT_SOURCE_TYPE_COLOR,   <span class="comment">// 单色，用于 fill 或是 draw</span></div><div class="line">    STBLIT_SOURCE_TYPE_BITMAP,  <span class="comment">// 位图，用于 blit</span></div><div class="line">    STBLIT_SOURCE_TYPE_COLOR_PREMULTIPLIED    <span class="comment">// 这个暂时还没研究是干啥的</span></div><div class="line">} STBLIT_SourceType_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* blit 上下文参数 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STBLIT_BlitContext_s</div><div class="line">{</div><div class="line">    STBLIT_ColorKeyCopyMode_t       ColorKeyCopyMode;   <span class="comment">// colorkey 标志，见下面</span></div><div class="line">    STGXOBJ_ColorKey_t              ColorKey;    <span class="comment">// colorkey 颜色，一个colorkey，ST你整那么复杂干啥，见下面</span></div><div class="line">    STBLIT_AluMode_t                AluMode;    <span class="comment">// alpha 混合标志（层alpha），见下面</span></div><div class="line">    BOOL                            EnableMaskWord;  <span class="comment">// 是否允许 Mask 值，MiniGUI 不支持</span></div><div class="line">    U32                             MaskWord;      <span class="comment">// Mask 值</span></div><div class="line">    BOOL                            EnableMaskBitmap;    <span class="comment">// 是否允许 Mask 位图，MiniGUI 不支持</span></div><div class="line">    STGXOBJ_Bitmap_t*               MaskBitmap_p;    <span class="comment">// Mask 位图指针</span></div><div class="line">    STGXOBJ_Rectangle_t             MaskRectangle;  <span class="comment">// Mask 位图区域</span></div><div class="line">    <span class="keyword">void</span>*                           WorkBuffer_p;                             </div><div class="line">    BOOL                            EnableColorCorrection;</div><div class="line">    STGXOBJ_Palette_t*              ColorCorrectionTable_p;</div><div class="line">    STBLIT_Trigger_t                Trigger;</div><div class="line">    U8                              GlobalAlpha;       <span class="comment">// 层alpha数值，注意范围是 0～128！！</span></div><div class="line">    BOOL                            EnableClipRectangle;    <span class="comment">// 是否允许 blit 剪切域，这个 MiniGUI 处理了，可以禁掉</span></div><div class="line">    STGXOBJ_Rectangle_t             ClipRectangle;    <span class="comment">// blit 剪切域</span></div><div class="line">    BOOL                            WriteInsideClipRectangle;</div><div class="line">    BOOL                            EnableFlickerFilter;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(STBLIT_OBSOLETE_USE_RESIZE_IN_BLIT_CONTEXT)</span></div><div class="line">    BOOL                            EnableResizeFilter;</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    STBLIT_JobHandle_t              JobHandle;    <span class="comment">// job handle，一般设置为0</span></div><div class="line">    <span class="keyword">void</span>*                           UserTag_p;       <span class="comment">// 通知回调用户参数，这个是用来同步用的，具体的后面解释</span></div><div class="line">    BOOL                            NotifyBlitCompletion;     <span class="comment">// 是否允许完成 blit 调用通知回调</span></div><div class="line">    STEVT_SubscriberID_t            EventSubscriberID;  <span class="comment">// 通知回调订阅ID</span></div><div class="line">} STBLIT_BlitContext_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* blit colorkey 标志 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> STBLIT_ColorKeyCopyMode_e</div><div class="line">{</div><div class="line">    STBLIT_COLOR_KEY_MODE_NONE,  <span class="comment">// 不使用 colorkey</span></div><div class="line">    STBLIT_COLOR_KEY_MODE_SRC,  <span class="comment">// 使用源的 colorkey，MiniGUI 仅支持这种</span></div><div class="line">    STBLIT_COLOR_KEY_MODE_DST   <span class="comment">// 使用目标的 colorkey</span></div><div class="line">} STBLIT_ColorKeyCopyMode_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* colorkey 参数 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STGXOBJ_ColorKey_s</div><div class="line">{</div><div class="line">  STGXOBJ_ColorKeyType_t           Type;   <span class="comment">// colorkey 类型</span></div><div class="line">  STGXOBJ_ColorKeyValue_t          Value;  <span class="comment">// colorkey 数值</span></div><div class="line">} STGXOBJ_ColorKey_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* colorkey 类型，ST 你不用分这么多种吧～～不就一个像素值么 -_-|| */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> STGXOBJ_ColorKeyType_e</div><div class="line">{ </div><div class="line">  STGXOBJ_COLOR_KEY_TYPE_CLUT1,   <span class="comment">// 1位调色板</span></div><div class="line">  STGXOBJ_COLOR_KEY_TYPE_CLUT8,   <span class="comment">// 8位调色板</span></div><div class="line">  STGXOBJ_COLOR_KEY_TYPE_RGB888,  <span class="comment">// RGB888</span></div><div class="line">  STGXOBJ_COLOR_KEY_TYPE_YCbCr888_SIGNED,  <span class="comment">// 这个好像是色差分量的颜色表示方式，反正 MiniGUI 之用调色板和RGB &gt;_&lt;</span></div><div class="line">  STGXOBJ_COLOR_KEY_TYPE_YCbCr888_UNSIGNED,</div><div class="line">  STGXOBJ_COLOR_KEY_TYPE_RGB565   <span class="comment">// RGB565</span></div><div class="line">} STGXOBJ_ColorKeyType_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* colorkey 数值参数，上面那么多类型每个对应一个成员变量～～我晕咯 -_-|| */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> STGXOBJ_ColorKeyValue_u</div><div class="line">{</div><div class="line">  STGXOBJ_ColorKeyCLUT_t           CLUT1;</div><div class="line">  STGXOBJ_ColorKeyCLUT_t           CLUT8;</div><div class="line">  STGXOBJ_ColorKeyRGB_t            RGB888;   <span class="comment">// 这里我们只用关心 RGB 类型的 colorkey</span></div><div class="line">  STGXOBJ_ColorKeySignedYCbCr_t    SignedYCbCr888;</div><div class="line">  STGXOBJ_ColorKeyUnsignedYCbCr_t  UnsignedYCbCr888;</div><div class="line">  STGXOBJ_ColorKeyRGB_t            RGB565;</div><div class="line">} STGXOBJ_ColorKeyValue_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* RGB 类型的 colorkey 参数，看到还有这么多参数我再次晕了～～ </span></div><div class="line"><span class="comment">   应该是为了精准，所以设置了RGB每个分量的范围。但是我感觉这个更难用。</span></div><div class="line"><span class="comment">   上层 MiniGUI 传过来的是一个像素值，怎么转化这个范围。嘿嘿，这里我把 dfb 的代码复制了过来。</span></div><div class="line"><span class="comment">    dfb 不管 16位、还是32位，统一设置成 RGB888 类型的 colorkey。让每个分量的最小值等于最大值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STGXOBJ_ColorKeyRGB_s</div><div class="line">{ </div><div class="line">  U8      RMin;                   <span class="comment">// R 分量的最小值</span></div><div class="line">  U8      RMax;                  <span class="comment">// R 分量的最大值</span></div><div class="line">  BOOL    ROut;                <span class="comment">// 是否允许 R 分量超出最小值和最大值的范围</span></div><div class="line">  BOOL    REnable;           <span class="comment">// 是否启动 R 分量</span></div><div class="line">  </div><div class="line">  U8      GMin;</div><div class="line">  U8      GMax;</div><div class="line">  BOOL    GOut;</div><div class="line">  BOOL    GEnable;</div><div class="line">  </div><div class="line">  U8      BMin;</div><div class="line">  U8      BMax;</div><div class="line">  BOOL    BOut;</div><div class="line">  BOOL    BEnable;</div><div class="line">} STGXOBJ_ColorKeyRGB_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* alpha 混合标志，那么多我目前用到的就2种 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  STBLIT_AluMode_e</div><div class="line">{</div><div class="line">    STBLIT_ALU_CLEAR            = <span class="number">0</span>,</div><div class="line">    STBLIT_ALU_AND              = <span class="number">1</span>,</div><div class="line">    STBLIT_ALU_AND_REV          = <span class="number">2</span>,</div><div class="line">    STBLIT_ALU_COPY             = <span class="number">3</span>,            <span class="comment">// copy alpha ，就是不使用alpha</span></div><div class="line">    STBLIT_ALU_AND_INVERT       = <span class="number">4</span>,</div><div class="line">    STBLIT_ALU_NOOP             = <span class="number">5</span>,</div><div class="line">    STBLIT_ALU_XOR              = <span class="number">6</span>,</div><div class="line">    STBLIT_ALU_OR               = <span class="number">7</span>,</div><div class="line">    STBLIT_ALU_NOR              = <span class="number">8</span>,</div><div class="line">    STBLIT_ALU_EQUIV            = <span class="number">9</span>,</div><div class="line">    STBLIT_ALU_INVERT           = <span class="number">10</span>,</div><div class="line">    STBLIT_ALU_OR_REVERSE       = <span class="number">11</span>,</div><div class="line">    STBLIT_ALU_COPY_INVERT      = <span class="number">12</span>,</div><div class="line">    STBLIT_ALU_OR_INVERT        = <span class="number">13</span>,</div><div class="line">    STBLIT_ALU_NAND             = <span class="number">14</span>,</div><div class="line">    STBLIT_ALU_SET              = <span class="number">15</span>,</div><div class="line">    STBLIT_ALU_ALPHA_BLEND      = <span class="number">16</span>    <span class="comment">// alpha 混合</span></div><div class="line">} STBLIT_AluMode_t;</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="FillRectangle">FillRectangle</h3>
<p>FillRectangle 可以用2种命令来实现（都是STGFB_IO_BLIT_COMMAND，只是参数不同而已）：</p>
<ul>
<li>blit 时使用 STGFB_BLIT_FillRectangleParams_t 参数。这个好像不能带 colorkey 和 alpha，不推荐用这种。</li>
<li>blit 时使用 STGFB_BLIT_BlitParams_t 参数。这个可以带 colorkey 和 alpha，推荐用这种。</li>
</ul>
<p>这里就说说推荐的第二种方法吧。这种方法， ioctl 的参数类型和 blit 是一样的，但是设置值不一样，主要是在 blit 上下文参数那里的 SrcType 设置成 STBLIT_SOURCE_TYPE_COLOR （这里可以参看上面的blit），然后 SrcData_p 这个指针指向一个 STGXOBJ_Color_t 的地址。在 STGXOBJ_Color_t 里设置你要填充的颜色。colorkey 和 alpha 的设置和 blit 是一样的。下面来看看 STGXOBJ_Color_t 参数吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 颜色结构体 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STGXOBJ_Color_s</div><div class="line">{</div><div class="line">  STGXOBJ_ColorType_t            Type;      <span class="comment">/* 颜色类型 */</span></div><div class="line">  STGXOBJ_ColorValue_t           Value;     <span class="comment">/* 颜色值 */</span></div><div class="line">} STGXOBJ_Color_t;</div><div class="line"></div><div class="line"><span class="comment">/* 颜色类型 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> STGXOBJ_ColorType_e</div><div class="line">{</div><div class="line">  STGXOBJ_COLOR_TYPE_ARGB8888,</div><div class="line">  STGXOBJ_COLOR_TYPE_RGB888,</div><div class="line">  STGXOBJ_COLOR_TYPE_ARGB8565,</div><div class="line">  STGXOBJ_COLOR_TYPE_RGB565,</div><div class="line">  STGXOBJ_COLOR_TYPE_ARGB1555,</div><div class="line">  STGXOBJ_COLOR_TYPE_ARGB4444,</div><div class="line"></div><div class="line">  STGXOBJ_COLOR_TYPE_CLUT8,</div><div class="line">  STGXOBJ_COLOR_TYPE_CLUT4,</div><div class="line">  STGXOBJ_COLOR_TYPE_CLUT2,</div><div class="line">  STGXOBJ_COLOR_TYPE_CLUT1,</div><div class="line">  STGXOBJ_COLOR_TYPE_ACLUT88,</div><div class="line">  STGXOBJ_COLOR_TYPE_ACLUT44,</div><div class="line"></div><div class="line">  STGXOBJ_COLOR_TYPE_SIGNED_YCBCR888_444,</div><div class="line">  STGXOBJ_COLOR_TYPE_UNSIGNED_YCBCR888_444,</div><div class="line">  STGXOBJ_COLOR_TYPE_SIGNED_YCBCR888_422,</div><div class="line">  STGXOBJ_COLOR_TYPE_UNSIGNED_YCBCR888_422,</div><div class="line">  STGXOBJ_COLOR_TYPE_SIGNED_YCBCR888_420,</div><div class="line">  STGXOBJ_COLOR_TYPE_UNSIGNED_YCBCR888_420,</div><div class="line">  STGXOBJ_COLOR_TYPE_UNSIGNED_AYCBCR6888_444,</div><div class="line">  STGXOBJ_COLOR_TYPE_SIGNED_AYCBCR8888,</div><div class="line">  STGXOBJ_COLOR_TYPE_UNSIGNED_AYCBCR8888,</div><div class="line"></div><div class="line">  STGXOBJ_COLOR_TYPE_ALPHA1,</div><div class="line">  STGXOBJ_COLOR_TYPE_ALPHA4,</div><div class="line">  STGXOBJ_COLOR_TYPE_ALPHA8,</div><div class="line">  STGXOBJ_COLOR_TYPE_BYTE,</div><div class="line"></div><div class="line">  STGXOBJ_COLOR_TYPE_ARGB8888_255,</div><div class="line">  STGXOBJ_COLOR_TYPE_ARGB8565_255,</div><div class="line">  STGXOBJ_COLOR_TYPE_ACLUT88_255,</div><div class="line">  STGXOBJ_COLOR_TYPE_ALPHA8_255</div><div class="line"></div><div class="line">} STGXOBJ_ColorType_t;</div><div class="line"></div><div class="line"><span class="comment">/* 颜色值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> STGXOBJ_ColorValue_u</div><div class="line">{</div><div class="line">  STGXOBJ_ColorARGB_t           ARGB8888;</div><div class="line">  STGXOBJ_ColorRGB_t            RGB888;</div><div class="line">  STGXOBJ_ColorARGB_t           ARGB8565;</div><div class="line">  STGXOBJ_ColorRGB_t            RGB565;</div><div class="line">  STGXOBJ_ColorARGB_t           ARGB1555;</div><div class="line">  STGXOBJ_ColorARGB_t           ARGB4444;</div><div class="line"></div><div class="line">  U8                            CLUT8;</div><div class="line">  U8                            CLUT4;</div><div class="line">  U8                            CLUT2;</div><div class="line">  U8                            CLUT1;</div><div class="line">  STGXOBJ_ColorACLUT_t          ACLUT88 ;</div><div class="line">  STGXOBJ_ColorACLUT_t          ACLUT44 ;</div><div class="line"></div><div class="line">  STGXOBJ_ColorSignedYCbCr_t    SignedYCbCr888_444;</div><div class="line">  STGXOBJ_ColorUnsignedYCbCr_t  UnsignedYCbCr888_444;</div><div class="line">  STGXOBJ_ColorSignedYCbCr_t    SignedYCbCr888_422;</div><div class="line">  STGXOBJ_ColorUnsignedYCbCr_t  UnsignedYCbCr888_422;</div><div class="line">  STGXOBJ_ColorSignedYCbCr_t    SignedYCbCr888_420;</div><div class="line">  STGXOBJ_ColorUnsignedYCbCr_t  UnsignedYCbCr888_420;</div><div class="line">  STGXOBJ_ColorUnsignedAYCbCr_t UnsignedAYCbCr6888_444;</div><div class="line">  STGXOBJ_ColorSignedAYCbCr_t   SignedAYCbCr8888;</div><div class="line">  STGXOBJ_ColorUnsignedAYCbCr_t UnsignedAYCbCr8888;</div><div class="line"></div><div class="line">  U8                            ALPHA1;</div><div class="line">  U8                            ALPHA4;</div><div class="line">  U8                            ALPHA8;</div><div class="line">  U8                            Byte;</div><div class="line"></div><div class="line">} STGXOBJ_ColorValue_t;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* ARGB 颜色值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STGXOBJ_ColorARGB_s</div><div class="line">{</div><div class="line">  U8 Alpha;    <span class="comment">// 这里的alpha值范围依旧是： 0 ~ 128</span></div><div class="line">  U8 R;</div><div class="line">  U8 G;</div><div class="line">  U8 B;</div><div class="line">} STGXOBJ_ColorARGB_t;</div><div class="line"></div><div class="line"><span class="comment">/* RGB 颜色值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> STGXOBJ_ColorRGB_s</div><div class="line">{</div><div class="line">  U8 R;</div><div class="line">  U8 G;</div><div class="line">  U8 B;</div><div class="line">} STGXOBJ_ColorRGB_t;</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="同步">同步</h3>
<p>同步的意思就是说，等待底层 blit 命令完成后，再执行后面的操作。如果不同步的话，就会遇到我日志里的问题。这里同步的方法理论上有2种，但是目前我只弄成功了一种：</p>
<ul>
<li><p>使用 ST 的通知回调。前面看到过，blit 的上下文参数里有一个就是设置回调参数的。这个回调是在 blit 完成后，底层调用的。不过要用这个比较麻烦。流程好像是：</p>
<ul>
<li>先要打开 stevt_ioctl 这个设备，取得stevt设置handle。</li>
<li>然后注册通知设备（这个好像是说哪个blit设备吧，这里没太搞清楚）。</li>
<li>通过得到的 handle 在 blit 上下文参数设置回调函数（通过 stevt 设备的 ioctl 命令）。</li>
<li>使用完后，删除注册通知设备。</li>
<li>退出时，关闭 stevt 设备。<br>具体的可以看看 ST 那个控制台的代码。不过我弄了下，发现不行，在 blit 上下文那些一设置回调就包内核错误了 -_-||。估计是哪里没弄对。算了，不管了，下面有比这个更好用的～～嘿嘿（这个就算回调弄成功了，回调里锁这、锁那的也麻烦）。</li>
</ul>
</li>
<li><p>使用 stgfb 提供的blit设备同步 ioctl 命令。上面列出的的 stgfb io 接口里有这个一个接口：STGFB_IO_SYNC_BLITTER 。用这个就可以了。这个命令其实是没有参数的，ioctl 最后那个参数直接赋值0就可以了。在 blit ioctl 后面调用这个，能保证 blit 完成后，ioctl 才返回。这个正是我们需要的功能。用这个简单的 ioctl 命令就OK了，不用使用 ST 的底层事件功能了：</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* sync the blitter, no need any params */</span></div><div class="line"><span class="keyword">if</span> (wait_sync) {</div><div class="line">    <span class="keyword">if</span> (ioctl(fd, STGFB_IO_SYNC_BLITTER, <span class="number">0</span>) != <span class="number">0</span>) { </div><div class="line">        perror(strerror(errno));</div><div class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">"STAPI_Blit &gt;&gt; Sync Engine failed\n"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="显存管理">显存管理</h3>
<p>板子上可用来分配给 MiniGUI memdc（离屏surface） 的显存一般是除去了屏幕暂用的显存（pitch x 屏幕高度）之后所剩余的（一般板子上的显存都会比屏幕大，用总显存减去屏幕所暂用的显存就可以得到剩下的显存大小了）。这样就需要一定的管理策略来有效的管理这些显存（要求分配到的显存要是连续的）。目前的 GAL 采用的办法是：</p>
<ol>
<li><p>将显存分块（block）。用双向链表（借用linux内核的链表实现）来管理这些块（bucket）。块中保存了块的pitch、高度、相对于显存首地址的偏移、以及是已经使用的标志。初始化时，将所有的显存创建成一个标记未使用过的大块。</p>
</li>
<li><p>当新申请一块显存时（传入所需块的pitch和高度）：通过传入的参数计算所需要申请的显存大小。从链表头开始查找没有使用过的并且足够大的块。如果找到了就把这个块拆成2块：一块是申请的大小（新插入到这个块的前面），一块是原来剩余，并且把新申请到的块标记为使用的；如果没找到就返回失败。</p>
</li>
<li><p>当释放一块显存时（传入block的指针）：分别向这块显存的前一个和后一个块检查。看临近的这2块的标记是否是未使用的，如果是则合并这2块（在链表中删掉其中一块，并把这一块的大小加入到未删除块上，修改未删除块相应的偏移信息），并设置标志为未使用。这样坐的目的是为了尽可能的保持未使用的显存的连续性，从而尽量保证申请显存的成功率。</p>
</li>
</ol>
<p>下面举个简单的例子：显存有10M，初始化时，分配屏幕显存（1920x1080-16bpp），需要一个 640x480-16bpp 的 surface （图中没写偏移地址）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/sti7167-gal/3.png" alt=""></p>
<p>然后使用完成后，就要释放。会先查找前面一个块，这个块是正在使用的，不合并；然后查找到后面一个块，这个块是没有使用的，所以就要合并。如果是前、后都在使用的，那就简单的把这个块标记为未使用即可（从图中可以看出，这种策略的特点：第一个块一般是屏幕的显存，最后一个块一般是最大的未使用的块；链表中间有可能会出现一些小的未使用的块，但是随着临近块的释放，这些块会慢慢的合并到最后的大块中）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/sti7167-gal/4.png" alt=""></p>
<p>贴贴代码，对着看下呗：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> vmbucket_init(vmbucket_t *bucket, <span class="keyword">unsigned</span> <span class="keyword">char</span> *start, <span class="keyword">int</span> size) {</div><div class="line">    bucket-&gt;start = start;</div><div class="line">    bucket-&gt;size = size;</div><div class="line">    INIT_LIST_HEAD(&bucket-&gt;block_head);</div><div class="line"></div><div class="line">    {</div><div class="line">        vmblock_t *block;</div><div class="line">        block = (vmblock_t *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*block));</div><div class="line">        block-&gt;offset = <span class="number">0</span>;</div><div class="line">        block-&gt;height = <span class="number">1</span>;</div><div class="line">        block-&gt;pitch = size;</div><div class="line">        list_add(&block-&gt;<span class="built_in">list</span>, &bucket-&gt;block_head);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> vmbucket_destroy(vmbucket_t *bucket) {</div><div class="line">    <span class="keyword">while</span> (! list_empty(&bucket-&gt;block_head)) {</div><div class="line">        vmblock_t *block = (vmblock_t *)bucket-&gt;block_head.prev;</div><div class="line">        list_del(bucket-&gt;block_head.prev);</div><div class="line">        <span class="built_in">free</span>(block);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> TEST_BIT(a, bit) ((a) & (bit))</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> SET_BIT(a, bit) ((a) |= (bit))</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> UNSET_BIT(a, bit) ((a) &= ~(bit))</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BLOCK_SIZE(block) ((block)-&gt;height * (block)-&gt;pitch)</span></div><div class="line"></div><div class="line">vmblock_t *vmbucket_alloc(vmbucket_t *bucket, <span class="keyword">int</span> pitch, <span class="keyword">int</span> height) {</div><div class="line">    <span class="keyword">struct</span> list_head *i;</div><div class="line">    <span class="keyword">int</span> required_size = height * pitch;</div><div class="line"></div><div class="line">    list_for_each(i, &bucket-&gt;block_head) {</div><div class="line">        vmblock_t *block;</div><div class="line">        block = (vmblock_t *)i;</div><div class="line">        <span class="keyword">if</span> (! TEST_BIT(block-&gt;flag, VMBLOCK_FLAG_USED)) {</div><div class="line">            <span class="keyword">int</span> block_size = BLOCK_SIZE(block);</div><div class="line">            <span class="keyword">if</span> (required_size &gt; block_size) {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (required_size &lt; block_size) {</div><div class="line">                vmblock_t *new_block;</div><div class="line">                new_block = (vmblock_t *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*new_block));</div><div class="line">                new_block-&gt;offset = block-&gt;offset + required_size;</div><div class="line">                new_block-&gt;pitch = block_size - required_size;</div><div class="line">                new_block-&gt;height = <span class="number">1</span>;</div><div class="line">                list_add(&new_block-&gt;<span class="built_in">list</span>, &block-&gt;<span class="built_in">list</span>);</div><div class="line">            }</div><div class="line">            block-&gt;height = height;</div><div class="line">            block-&gt;pitch = pitch;</div><div class="line">            SET_BIT(block-&gt;flag, VMBLOCK_FLAG_USED);</div><div class="line">            <span class="keyword">return</span> block;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> vmbucket_free(vmbucket_t *bucket, vmblock_t *block)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> size = BLOCK_SIZE(block);</div><div class="line">    vmblock_t *near_block;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!TEST_BIT(block-&gt;flag, VMBLOCK_FLAG_USED)) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">"videomem-bucket: can't free an unuse block!\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    UNSET_BIT(block-&gt;flag, VMBLOCK_FLAG_USED);</div><div class="line"></div><div class="line">    <span class="comment">/* look for prev */</span></div><div class="line">    <span class="keyword">if</span> (block-&gt;<span class="built_in">list</span>.prev != &(bucket-&gt;block_head)) {</div><div class="line">        near_block = (vmblock_t *)block-&gt;<span class="built_in">list</span>.prev;</div><div class="line">        <span class="keyword">if</span> (!TEST_BIT(near_block-&gt;flag, VMBLOCK_FLAG_USED)) {</div><div class="line">            size += BLOCK_SIZE(near_block);</div><div class="line">            block-&gt;offset = near_block-&gt;offset;</div><div class="line">            block-&gt;height = <span class="number">1</span>;</div><div class="line">            block-&gt;pitch = size;</div><div class="line">            list_del(&near_block-&gt;<span class="built_in">list</span>);</div><div class="line">            <span class="built_in">free</span>(near_block);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* look for next */</span></div><div class="line">    <span class="keyword">if</span> (block-&gt;<span class="built_in">list</span>.next != &(bucket-&gt;block_head)) {</div><div class="line">        near_block = (vmblock_t *)block-&gt;<span class="built_in">list</span>.next;</div><div class="line">        <span class="keyword">if</span> (!TEST_BIT(near_block-&gt;flag, VMBLOCK_FLAG_USED)) {</div><div class="line">            size += BLOCK_SIZE(near_block);</div><div class="line">            block-&gt;height = <span class="number">1</span>;</div><div class="line">            block-&gt;pitch = size;</div><div class="line">            list_del(&near_block-&gt;<span class="built_in">list</span>);</div><div class="line">            <span class="built_in">free</span>(near_block);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="overlapped_blit">overlapped blit</h3>
<p>overlapped blit 的意思就是说：源数据地址与目的数据地址有重叠，见下面的图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/sti7167-gal/5.png" alt=""></p>
<p>如果是软件 blit 的话（使用 framebuffer 映射到的内存来 memcpy），是不需要考虑这种情况的。或是有些硬件处理了这种情况，也不需要考虑。7167 底层没处理，所以就要自己处理。overlapped 造成的问题是：一般来说底层的复制是逐行、逐行的复制的，所以上面的这种情况，上面的数据会把重叠的地方的给覆盖了，当复制到重叠的地方（就是源数据的下面部分）就会把被覆盖后的数据复制到目标区域，这样就会原来的图像就不正确了。解决办法有2个：</p>
<ol>
<li><p>创建一个和源一样大的临时显存块，把源先 blit 到临时显存块，然后再把临时显存块 blit 到目标区域，最后释放临时显存块。</p>
</li>
<li><p>把源区域分块 blit ，保证不重叠。</p>
</li>
</ol>
<p>第一种方法不许要计算分块，blit 次数固定为2；但是需要创建临时显存块，如果源比较大，并且显存使用比较多的情况下，会造成 blit 失败。所以采用第2种方法。分块的策略为（这里以图中的垂直向下为例，垂直向上，水平向左、水平向右是类似的）：</p>
<ol>
<li><p>计算出相交的区域矩形大小（图中绿色的部分）。</p>
</li>
<li><p>用相交区域的高与源区域的高相减得到未相交区域的大小（delta）。</p>
</li>
<li><p>将源区域每次按 delta 大小从下向上 blit，当最后区域不足 delta 时就取最后剩下区域的大小（这样做的目的就是为了每次 blit 都不相交）。</p>
</li>
</ol>
<p>这里讨论了水平、垂直的情况（4种），还有剩下4种斜的情况。因为斜的情况，水平、垂直的策略都适用，但是不同的情况使用不同的策略速度会不同。仔细看下相交区域：当相交区域的高比较大的时候，垂直分块策略会比较慢；当相交区域的宽比较大的情况下，水平分块策略会比较慢。所以这里如果是斜的情况，可以根据相交区域来选择最快的分块策略。贴一下代码吧，这样对着看会比较清晰些：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> own_overlapped_bitblit(GAL_blit real_blit, <span class="keyword">struct</span> GAL_Surface *src, GAL_Rect *srcrect,</div><div class="line">        <span class="keyword">struct</span> GAL_Surface *dst, GAL_Rect *dstrect) {</div><div class="line">    <span class="keyword">int</span> w, W, x;</div><div class="line">    <span class="keyword">int</span> h, H, y;</div><div class="line">    <span class="keyword">int</span> delta;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    RECT intersect, src_rc, dst_rc;</div><div class="line"></div><div class="line">    assert(srcrect-&gt;w == dstrect-&gt;w || srcrect-&gt;h == dstrect-&gt;h);</div><div class="line"></div><div class="line">    galrect_2_rect(srcrect, &src_rc);</div><div class="line">    galrect_2_rect(dstrect, &dst_rc);</div><div class="line"></div><div class="line">    <span class="comment">/* don't intersect or horizontal left or up or left-up overlapped blit directly */</span></div><div class="line">    <span class="keyword">if</span> (! IntersectRect(&intersect, &src_rc, &dst_rc)</div><div class="line">            || (dst_rc.top &lt;= src_rc.top && dst_rc.left &lt;= src_rc.left)) {</div><div class="line">        <span class="keyword">return</span> real_blit(src, srcrect, dst, dstrect);</div><div class="line">    }</div><div class="line"></div><div class="line">    GAL_Rect src1, dst1;</div><div class="line"></div><div class="line">    <span class="comment">/* vertical overlapped. </span></div><div class="line"><span class="comment">     * if left-up right-up left-down right-down, horizontal is faster than vertical than use horizonatl mode. */</span></div><div class="line">    <span class="keyword">if</span> ( (dst_rc.left == src_rc.left) </div><div class="line">            || ((dst_rc.top != src_rc.top) && (RECTH(intersect) &lt;= RECTW(intersect))) ) {</div><div class="line">        h = RECTH(intersect);</div><div class="line">        H = RECTH(src_rc);</div><div class="line">        delta = H - h;</div><div class="line"></div><div class="line">        <span class="comment">/* down or left-down or right-down overlapped, separate into per not-Intersect rect to blit,</span></div><div class="line"><span class="comment">         * from bottom to up */</span></div><div class="line">        <span class="keyword">if</span> (dst_rc.top &gt; src_rc.top) {</div><div class="line">            <span class="keyword">for</span> (y = H; y &gt; <span class="number">0</span>; y -= delta) {</div><div class="line">                <span class="keyword">if</span> (y &lt; delta) {</div><div class="line">                    delta = y;</div><div class="line">                }</div><div class="line">                src1.x = src_rc.left;</div><div class="line">                src1.y = src_rc.top + y - delta;</div><div class="line">            </div><div class="line">                dst1.x = dst_rc.left;</div><div class="line">                dst1.y = dst_rc.top + y - delta;</div><div class="line">            </div><div class="line">                src1.w = dst1.w = srcrect-&gt;w;</div><div class="line">                src1.h = dst1.h = delta;</div><div class="line"></div><div class="line">                ret |= real_blit(src, &src1, dst, &dst1);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">/* up or left-up or right-up overlapped, just the same down except from up to bottom */</span></div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; H; y += delta) {</div><div class="line">                <span class="keyword">if</span> (y + delta &gt; H) {</div><div class="line">                    delta = H - y;</div><div class="line">                }</div><div class="line">                src1.x = src_rc.left;</div><div class="line">                src1.y = src_rc.top + y;</div><div class="line">            </div><div class="line">                dst1.x = dst_rc.left;</div><div class="line">                dst1.y = dst_rc.top + y;</div><div class="line">            </div><div class="line">                src1.w = dst1.w = srcrect-&gt;w;</div><div class="line">                src1.h = dst1.h = delta;</div><div class="line"></div><div class="line">                ret |= real_blit(src, &src1, dst, &dst1);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/* horizontal overlapped */</span></div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        w = RECTW(intersect);</div><div class="line">        W = RECTW(src_rc);</div><div class="line">        delta = W - w;</div><div class="line">        </div><div class="line">        <span class="comment">/* horizontal right overlapped, separate into per not-Intersect rect to blit,</span></div><div class="line"><span class="comment">         * from right to left */</span></div><div class="line">        <span class="keyword">if</span> (dst_rc.left &gt; src_rc.left) {</div><div class="line">            <span class="keyword">for</span> (x = W; x &gt; <span class="number">0</span>; x -= delta) {</div><div class="line">                <span class="keyword">if</span> (x &lt; delta) {</div><div class="line">                    delta = x;</div><div class="line">                }</div><div class="line">                src1.x = src_rc.left + x - delta;</div><div class="line">                src1.y = src_rc.top;</div><div class="line">            </div><div class="line">                dst1.x = dst_rc.left + x - delta;</div><div class="line">                dst1.y = dst_rc.top;</div><div class="line">            </div><div class="line">                src1.w = dst1.w = delta;</div><div class="line">                src1.h = dst1.h = srcrect-&gt;h;</div><div class="line"></div><div class="line">                ret |= real_blit(src, &src1, dst, &dst1);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">/* horizontal left overlapped. just the same right except from left to right.</span></div><div class="line"><span class="comment">         * this just for optimization overlapped blit speed. */</span></div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; W; x += delta) {</div><div class="line">                <span class="keyword">if</span> (x + delta &gt; W) {</div><div class="line">                    delta = W - x;</div><div class="line">                }</div><div class="line">                src1.x = src_rc.left + x;</div><div class="line">                src1.y = src_rc.top;</div><div class="line">            </div><div class="line">                dst1.x = dst_rc.left + x;</div><div class="line">                dst1.y = dst_rc.top;</div><div class="line">            </div><div class="line">                src1.w = dst1.w = delta;</div><div class="line">                src1.h = dst1.h = srcrect-&gt;h;</div><div class="line"></div><div class="line">                ret |= real_blit(src, &src1, dst, &dst1);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="进程版">进程版</h3>
<p>MiniGUI 的多进程间通信通过 Unix socket ，采用 C/S 模型（桌面是服务器，其它的应用进程是客户端）。 在线程版的基础修改以下的地方：</p>
<ul>
<li><p>初始化的时候，需要的设备（framebuffer、stlayer等）每个进程都要打开。frambuffer 的内存映射（mmap）每个进程要做，因为 mmap 是映射到当前进程的地址空间，所以如果只有服务器映射的话，就算给了客户端地址，客户端也无法访问。每个进程都要计算屏幕相应的内存映射地址偏移（这个是用户空间的地址，每个进程的都不一样的，因为之前各自映射各自的，所以每个客户端都要做）。只在服务器初始化显存管理链表（之前说的bucket），同时申请屏幕显存（分配硬件显存地址，一般只能做一次，所以只在服务器进程分配）。</p>
</li>
<li><p>退出时，每个进程都要关闭打开的设备（因为之前每个进程都打开了）。每个进程都要卸载 framebuffer 的内存映射（munmap）。只在服务器销毁显存管理链表（因为只在服务器创建了）。</p>
</li>
<li><p>客户端向服务器发申请显存请求；服务器响应客户端请求并分配显存。客户端向服务器发送释放显存请求；服务器响应客户端请求并释放显存。这里要注意一点：一个进程是不允许访问另外一个进程的内存地址空间的（这里的是指用户态的，虚拟的内存地址），除非是创建共享内存（这个好像稍微麻烦点）。这样不管是服务器向客户端发送数据分配的显存数据（MiniGUI 里一般是一个 void* 类型，保证的是数据的地址），还是客户端向服务器发送要释放的显存数据；如果像多线程那样直接访问的话，是要出信号失败的错误的。解决办法一个是创建共享内存（这个说了会麻烦点）；还有一个就是不要访问地址（指针），只访问数值。这里的技巧就是：</p>
<ul>
<li><p>显存申请时：服务器分配显存是会申请一个 block（这是个结构体），这里把 block 指针、block 的 offset 和 pitch 发送给客户端。客户端得到数据后，把服务器发过来的 block 指针保存下来，这里注意仅仅是保存下这个指针（地址）就行了，不要去访问（原因前面说了）。然后根据得到的 block 的 offset 和 pitch 计算出物理显存地址和映射的framebuffer地址（客户端需要的 block 数据仅仅是 offset 和 pitch）。这样显存申请就 OK 了。</p>
</li>
<li><p>显存释放时：客户端把之前服务器发过来的 block 地址发送给服务器。服务器就可以拿着这个 block 地址调用 bucket 的释放函数释放显存了。这里的 block 是服务器的进程创建的，所以服务器端就可以访问。</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用_stapi_的注意事项">使用 stapi 的注意事项</h3>
<ul>
<li><p>要包括 ST 的一些头文件（我把这些复制到 MiniGUI 源码树里去了）：</p>
<pre config="brush:bash;toolbar:false;">
  * src/newgal/stgfb/st_include/stblit_ioctl.h
  * src/newgal/stgfb/st_include/stddefs.h
  * src/newgal/stgfb/st_include/stcommon.h
  * src/newgal/stgfb/st_include/stevt_ioctl.h
  * src/newgal/stgfb/st_include/linuxwrapper.h
  * src/newgal/stgfb/st_include/stblit.h
  * src/newgal/stgfb/st_include/stlite.h
  * src/newgal/stgfb/st_include/stevt.h
  * src/newgal/stgfb/st_include/stgfb.h
  * src/newgal/stgfb/st_include/stdevice.h
  * src/newgal/stgfb/st_include/linuxcommon.h
  * src/newgal/stgfb/st_include/stavmem.h
  * src/newgal/stgfb/st_include/stlayer_ioctl.h
  * src/newgal/stgfb/st_include/stgxobj.h
  * src/newgal/stgfb/st_include/stlayer.h
  * src/newgal/stgfb/st_include/stsys.h
  * src/newgal/stgfb/st_include/layer_rev.h
  * src/newgal/stgfb/st_include/stos.h
</pre>
</li>
<li><p>要加上几个编译宏：</p>
<pre>
CFLAGS="$CFLAGS -DST_OSLINUX -DST_7105 -DARCHITECTURE_ST40 -DDEFINED_BOOL"
</pre>
</li>
<li><p>编译环境要包括 linux 内核头文件。这个在 ST 的根文件系统的包里有，我默认安装就在这：</p>
<pre>
/opt/STM/STLinux-2.3/devkit/sources/kernel/linux-sh4
</pre>

</li>
</ul>
<h2 id="编译、运行_MiniGUI_（DirectFB）">编译、运行 MiniGUI （DirectFB）</h2>
<p>… …</p>
<h2 id="编译、运行_MiniGUI_（stgfb）">编译、运行 MiniGUI （stgfb）</h2>
<h3 id="MiniGUI_source">MiniGUI source</h3>
<p>rel-3-0 分支 svn 13675 以上： URL: svn+ssh://devsrv/home/projects/svn/minigui/branches/rel-3-0</p>
<h3 id="编译环境设置">编译环境设置</h3>
<p>按上面写的安装好 STLinux。这里假设你安装的路径是 /opt/STM/STLinux-2.3，那么：</p>
<ul>
<li>交叉工具链路径是： /opt/STM/STLinux-2.3/devkit/sh4/bin</li>
<li>根文件系统路径是： /opt/STM/STLinux-2.3/devkit/sh4/target</li>
<li>kernel源码路径是： /opt/STM/STLinux-2.3/devkit/sources/kernel/linux-sh4</li>
</ul>
<p>要编译基于 stgfb GAL 的 MiniGUI 的话要设置如下的 CFLAGS 和 LDFLAGS：</p>
<pre config="brush:bash;toolbar:false;">

/* 设置安装路径 */
export PREFIX="/home/mingming/nfs/st7167_procs"

/* 设置根文件系统的头文件路径  */
export SH4_ROOT=/opt/STM/STLinux-2.3/devkit/sh4
export KERNEL_ROOT=/opt/STM/STLinux-2.3/devkit/sources/kernel/linux-sh4

/* 要特别设置下 c++ 的头文件路径，编译 mgplus、mdolphin、mdtv 用 */
cxx_path="${SH4_ROOT}/target/usr/include/c++/4.2.1"

/* 设置 CFLAGS，包括根文件系统自带的一些头文件、和内核头文件 */
export CFLAGS="-I. -I.. -I${PREFIX}/include  -I${SH4_ROOT}/include -I${SH4_ROOT}/target/usr/include -I${SH4_ROOT}/taget/usr/local/include -I${KERNEL_ROOT}/include"

/* 设置 C++ flag，除了包括 CFLAGS 的一些头文件路径还要包括 c++ 文件路径 */
export CPPFLAGS="${CFLAGS} -I${cxx_path} -I${cxx_path}/sh4-linux"
export CXXFLAGS=$CPPFLAGS

/* 设置 pkg 路径，包括编译安装路径和根文件系统的，这个不设置的话，编译会报错 */
export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig:$SH4_ROOT/target/usr/lib/pkgconfig

/* 设置 LDFLAGS，注意如果 MiniGUI 打开了 freetype，要自己编译个高版本的 freetype（用 2.3.9 版本的），根文件系统自带的不行。
 * 所以设置的路径要把安装路径设置到根文件系统的前面 */
export libs_base="-L${PREFIX}/lib -Wl,-rpath-link=${PREFIX}/lib -L${SH4_ROOT}/target/lib -L${SH4_ROOT}/target/usr/lib -L${SH4_ROOT}/target/usr/local/lib -Wl,-rpath-link=${SH4_ROOT}/target/lib -Wl,-rpath-link=${SH4_ROOT}/target/usr/lib -Wl,-rpath-link=${SH4_ROOT}/target/usr/local/lib"
export extra_libs="-lm -lpthread -ljpeg -lpng -lfreetype"
export LDFLAGS="${libs_base} ${extra_libs}"

/* 设置 bin 路径，这里主要设置交叉编译链路径和一些库的 config 路径，注意先后顺序 */
extra_path="${SH4_ROOT}/bin"
export PATH=$PREFIX/bin:$extra_path:/home/mingming/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

</pre>

<h3 id="MiniGUI_编译配置">MiniGUI 编译配置</h3>
<pre>
configure --prefix=$PREFIX \
    --build=i386-linux \
    --host=sh4-linux \
    --enable-videofbcon \
    --enable-videostgfb \
    --enable-procs \
    --disable-videoqvfb \
    --disable-pcxvfb \
    --disable-qvfbial \
    --with-ttfsupport=ft2 \
    --enable-ttfcache \
    --enable-jpgsupport \
    --enable-pngsupport \
    --disable-splash \
    --disable-screensaver
</pre>

<h3 id="MiniGUI_运行时配置">MiniGUI 运行时配置</h3>
<p>可以使用不带加速的 fbcon 来验证下带加速的 stgfb 。如果鼠标设备位置不对，可以改为 mdev=/dev/mouse0。framebuffer 的颜色格式设置可以参看上面写的改 load_fb.sh 里的设置。</p>
<pre>
[system]
# GAL engine and default options
#gal_engine=fbcon
gal_engine=stgfb
defaultmode=1920x1080-16bpp

# IAL engine
ial_engine=console
mdev=/dev/input/mice
mtype=IMPS2
</pre>

<p>最后还要设置下系统运行时环境，这里提供一个脚本（要先安装howto文档里，先把 ST 的控制台先跑来， 然后另外一个console telnet登录上去运行该脚本；注意脚本的运行方式：soucre xx.sh 或是 . ./xx.sh）：</p>
<pre config="brush:bash;toolbar:false;">
/* howto 文档里写的加载 framebuffer 设备，分辨率 1920x1080 */
source /root/load_fb.sh FULLHD PAL 

/* 挂载 sawp，没有的话，可以删掉这个 */
mkswap /dev/sda
swapon /dev/sda

/* 设置动态库路径，非重重要。这里我将 MiniGUI 的安装路径设上去了。 */
export LD_LIBRARY_PATH=/root/nfs_ths/lib:$LD_LIBRARY_PATH
export MG_CFG_PATH=/root/nfs_ths/myetc
export MG_RES_PATH=/root/nfs_ths/share/minigui/res

/* 挂载 nfs，上面的 MiniGUI 安装路径就是这里挂载上去的 */
umount /root/nfs_ths
mount 192.168.1.102:/home/mingming/nfs/st7167 /root/nfs_ths -o nolock

/* 设置 ST 环境，这个可有、可无，最好还是加上 */
source modules/load_env.sh
</pre>

<h3 id="注意事项">注意事项</h3>
<ul>
<li><p>链接时，会出现乱链库的情况。这个时候要去把根文件系统下把那些自带库的 .la 文件里的路径改对；还有一些 bin 下的 config 文件，也要改对。</p>
</li>
<li><p>板子出现无法解析host的情况，修改 /etc/resolv.conf 文件，设置正确的 nameserver ，例如，目前深圳这边的设置为 192.168.1.1</p>
</li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20DC%20%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-21T13:15:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI DC 分析</title>
        <pubTime>2015-01-21T13:15:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<h2 id="相关术语">相关术语</h2>
<p>这里先解释下相关术语吧（呃～～是按我的理解）：</p>
<ul>
<li><p><strong>GDI</strong><br>GDI（Graphics Device Interface）: 图形设备接口。这应该是一个抽象层，在这一些为上层应用程序提供了一系列图形绘制相关的接口：例如画点、画线、矩形填充、块传送、加载图片文件等等。它衔接底层硬件层与上层应用层。</p>
</li>
<li><p><strong>DC</strong><br>DC（Device Context）：设备上下文。这个是 gdi 层的基本单位。包含了像素颜色信息、填充函数、图像缩放函数等等，上层应用程序通过 gdi 接口操作封装在里面的底层图像数据。</p>
</li>
<li><p><strong>HDC</strong><br>HDC（Handle Device Context）： dc 的句柄。其实可以理解为 dc 的指针。MiniGUI 里本来也就是这么处理的。</p>
</li>
<li><p><strong>GAL</strong><br>GAL（Graphics Abstract Layer）：图形抽象层。这个层直接和硬件打交到，是 MiniGUI 的图形驱动。这个抽象了一些列的接口规范，供上层（GDI层）使用，不同的硬件平台使用自己硬件平台提供的接口（直接的 IO 操作或是封装过的库）完成这些接口就完成了 MiniGUI 的图形驱动。</p>
</li>
<li><p><strong>Surface</strong><br>Surface：哎～～这个我还真不知道要怎么翻译好，干脆就直接用英文吧。surface 是 GAL 层的基本单位，包括最基本的像素数据（图像数据）、颜色格式、图形驱动回调函数等等。dc 中包含了这个基本单位。</p>
</li>
<li><p><strong>层次图如下：</strong><br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/minigui-dc/1.png" alt="" title="层次图"></p>
</li>
</ul>
<h2 id="DC_的创建与销毁">DC 的创建与销毁</h2>
<p>从应用层来看，要绘制图形，首先要获取 dc。来看看总体情况吧，MiniGUI 3.0.x 现有的 dc 创建相关的 API 大致有以下几个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">HDC GetDC (HWND hwnd);</div><div class="line">HDC GetClientDC (HWND hwnd);</div><div class="line">HDC GetSubDC (HDC hdc, <span class="keyword">int</span> off_x, <span class="keyword">int</span> off_y, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</div><div class="line"></div><div class="line">HDC CreateCompatibleDCEx (HDC hdc, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</div><div class="line">HDC CreateMemDCEx (<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> depth, DWORD flags, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask, <span class="keyword">void</span>* bits, <span class="keyword">int</span> pitch);</div><div class="line">HDC CreateSubMemDC (HDC parent, <span class="keyword">int</span> off_x, <span class="keyword">int</span> off_y, <span class="keyword">int</span> width, <span class="keyword">int</span> height, BOOL comp_to_parent);</div><div class="line"></div><div class="line">HDC CreatePrivateDC (HWND hwnd);</div><div class="line">HDC CreatePrivateClientDC (HWND hwnd);</div><div class="line">HDC CreatePrivateSubDC(HDC hdc, <span class="keyword">int</span> off_x, <span class="keyword">int</span> off_y, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</div><div class="line">HDC GetPrivateClientDC (HWND hwnd);</div><div class="line"></div><div class="line">HDC CreateSecondaryDC (HWND hwnd);</div><div class="line">HDC GetSecondaryDC (HWND hwnd);</div><div class="line">HDC GetSecondaryClientDC (HWND hwnd);</div><div class="line">HDC GetSecondarySubDC (HDC secondary_dc, HWND hwnd_child, BOOL client);</div><div class="line"></div><div class="line"><span class="keyword">void</span> ReleaseDC (HDC hdc);</div><div class="line"><span class="keyword">void</span> ReleaseSecondaryDC (HWND hwnd, HDC hdc);</div><div class="line"><span class="keyword">void</span> ReleaseSecondarySubDC (HWND hwnd, HDC hdc);</div><div class="line"><span class="keyword">void</span> DeleteMemDC (HDC mem_dc);</div><div class="line"><span class="keyword">void</span> DeletePrivateDC (HDC hdc);</div><div class="line"><span class="keyword">void</span> DeleteSecondaryDC (HWND hwnd);</div><div class="line"></div></pre></td></tr></table></figure>

<p>以上一系列 API ，可以从几个方面分类：</p>
<ul>
<li><p><strong>存储位置：</strong><br>MiniGUI 内部有一个叫 dc 池的缓冲区，启动 MiniGUI 的时候就分配好了内存空间，是一系列静态变量，在 MiniGUI 周期中是常驻内存的。无需动态申请和释放。有部分 API 是从这个里面创建的，这类 API 通常使用频率较高，创建速度快（仅仅需要简单把 dc 池中的一些标志位设置一些即可，无需内存申请操作）。有部分则是自己申请内存创建的。</p>
</li>
<li><p><strong>像素数据类型：</strong><br>有些 API 是以屏幕的像素数据为内容来创建 dc 的。操作这类 API 创建的 dc ，立刻就能在屏幕上体现。有些则不是，需要手动调用位块传送 API 输出到屏幕才能体现来（BitBlt, StrechBlt 等）。</p>
</li>
<li><p><strong>API之间的对比：</strong> </p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">API</th>
<th style="text-align:center">存储位置</th>
<th style="text-align:center">像素数据类型</th>
<th style="text-align:center">区域</th>
<th style="text-align:center">特性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GetDC</td>
<td style="text-align:center">dc 池</td>
<td style="text-align:center">on-screen</td>
<td style="text-align:center">整个窗体</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">GetClientDC</td>
<td style="text-align:center">dc 池</td>
<td style="text-align:center">on-screen</td>
<td style="text-align:center">窗体的非客户区</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">GetSubDC</td>
<td style="text-align:center">dc 池</td>
<td style="text-align:center">使用父 dc 的像素数据，但必须是 off-screen</td>
<td style="text-align:center">参数指定大小，但无法超过父 dc 的大小</td>
<td style="text-align:center">与父 dc 共用用一块像素地址，子 dc 的操作将会影响到父</td>
</tr>
<tr>
<td style="text-align:left">CreateCompatibleDCEx</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">off-screen</td>
<td style="text-align:center">参数指定大小</td>
<td style="text-align:center">创建的 dc，将会与传入的参考 dc 有相同的颜色格式。CreateCompatibleDC 是创建与参考 dc 同样大小的 dc，是对该 API 的简单封装</td>
</tr>
<tr>
<td style="text-align:left">CreateMemDCEx</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">off-screen</td>
<td style="text-align:center">参数指定大小</td>
<td style="text-align:center">能自己指定色深、颜色格式，以及初始的像素数据。CreateMemDC 创建的 dc 初始像素数据为0，是该 API 的简单封装</td>
</tr>
<tr>
<td style="text-align:left">CreateSubMemDC</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">使用父dc的像素数据，应该是 off-screen 的吧</td>
<td style="text-align:center">参数指定大小，但无法超过父 dc 的大小</td>
<td style="text-align:center">参数指定是否与父 dc 具有相同的剪切域</td>
</tr>
<tr>
<td style="text-align:left">CreatePrivateDC</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">on-screen</td>
<td style="text-align:center">整个窗体</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">CreatePrivateClientDC</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">on-screen</td>
<td style="text-align:center">窗体的非客户区</td>
<td style="text-align:center">好像是用于窗口或是控件的一个风格（WS_EX_USEPRIVATECDC、CS_OWNDC）</td>
</tr>
<tr>
<td style="text-align:left">CreatePrivateSubDC</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">使用父 dc 的像素数据</td>
<td style="text-align:center">参数指定大小，但无法超过父 dc 的大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">GetPrivateClientDC</td>
<td style="text-align:center">已经存在的变量</td>
<td style="text-align:center">应该是 on-screen</td>
<td style="text-align:center">未知</td>
<td style="text-align:center">简单的返回 PMAINWIN 的 privCDC 变量</td>
</tr>
<tr>
<td style="text-align:left">CreateSecondaryDC</td>
<td style="text-align:center">动态内存</td>
<td style="text-align:center">off-screen</td>
<td style="text-align:center">整个窗体</td>
<td style="text-align:center">最后调用 CreateCompatibleDCEx 创建通过 GetDC 获取兼容的 dc</td>
</tr>
<tr>
<td style="text-align:left">GetSecondaryDC</td>
<td style="text-align:center">不确定</td>
<td style="text-align:center">应该是 on-screen</td>
<td style="text-align:center">不确定</td>
<td style="text-align:center">这个函数比较复杂，后面再分析</td>
</tr>
<tr>
<td style="text-align:left">GetSecondaryClientDC</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">和 GetSecondaryDC 类似，只不过区域是非客户区而已</td>
</tr>
<tr>
<td style="text-align:left">GetSecondarySubDC</td>
<td style="text-align:center">dc 池</td>
<td style="text-align:center">应该是 off-screen</td>
<td style="text-align:center">参数指定大小，但无法超过父 dc 大小</td>
<td style="text-align:center">这个 API 主要是 secondary dc 的获取 sub dc 版</td>
</tr>
<tr>
<td style="text-align:left">ReleaseDC</td>
<td style="text-align:center">释放 dc 池（只是简单设置标志位而已）</td>
<td style="text-align:center">on-screen 数据不能销毁</td>
<td style="text-align:center"></td>
<td style="text-align:center">从 dc 池创建的 dc，都应该由这个 API 释放</td>
</tr>
<tr>
<td style="text-align:left">ReleaseSecondaryDC</td>
<td style="text-align:center">释放 dc 池</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">根据不同的情况调用 ReleaseDC 或是 ReleaseSecondarySubDC</td>
</tr>
<tr>
<td style="text-align:left">ReleaseSecondarySubDC</td>
<td style="text-align:center">释放 dc 池</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">对 ReleaseDC 的简单封装</td>
</tr>
<tr>
<td style="text-align:left">DeleteMemDC</td>
<td style="text-align:center">释放内存</td>
<td style="text-align:center">销毁 off-screen 数据</td>
<td style="text-align:center"></td>
<td style="text-align:center">申请动态内存，使用 off-screen 像素数据的 dc 都应该由这个 API 销毁</td>
</tr>
<tr>
<td style="text-align:left">DeletePrivateDC</td>
<td style="text-align:center">释放内存</td>
<td style="text-align:center">on-screen 数据不能销毁</td>
<td style="text-align:center"></td>
<td style="text-align:center">由 CreatePrivateDC 创建的 dc 要使用该 API 销毁</td>
</tr>
<tr>
<td style="text-align:left">DeleteSecondaryDC</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">对 DeleteMemDC 的简单封装</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>情况复杂的API：</strong><br>GetSecondaryDC：这个函数首先分为是主窗口还是控件，其实再看主窗口或是控件的风格：</p>
<ul>
<li><p>主窗口：如果有 <code>WS_EX_AUTOSECONARYDC</code> 风格，则返回 PMAINWIN 的 secondaryDC 变量（这个变量通过 SetSeconaryDC 设置，一般是 off-screen dc 来的）。否则则返回 <code>HDC_SCREEN</code> （屏幕dc）。</p>
</li>
<li><p>控件：如果父窗体有 <code>WS_EX_AUTOSECONARYDC</code> 风格，控件如果没有 <code>WS_EX_CTRLASMAINWIN</code> 风格，则返回父窗体 secondary dc 的子 dc （通过 GetSeconarySubDC 获取）；控件如果有 <code>WS_EX_CTRLASMAINWIN</code> 风格的话，则会通过 GetClientDC 获取；控件如果有 <code>WS_EX_USEPRIVATECDC</code> 则会返回控件的 privCDC 变量。如果父窗体没有 <code>WS_EX_AUTOSECONARYDC</code> 风格的话，则返回 <code>HDC_SCREEN</code>。</p>
</li>
</ul>
</li>
</ul>
<p>哎，说得头晕，还不如直接上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">HDC GUIAPI GetSecondaryDC (HWND hwnd)</div><div class="line">{</div><div class="line">    PMAINWIN pWin;</div><div class="line">    pWin = MG_GET_WINDOW_PTR (hwnd);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (MG_IS_MAIN_WINDOW(hwnd) && pWin-&gt;secondaryDC) {</div><div class="line">        <span class="keyword">return</span> pWin-&gt;secondaryDC;</div><div class="line">    } </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pWin-&gt;pMainWin-&gt;secondaryDC){</div><div class="line">        <span class="keyword">return</span> get_valid_dc (pWin, FALSE);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> HDC_SCREEN;</div><div class="line">} </div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> HDC get_valid_dc (PMAINWIN pWin, BOOL client)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (!(pWin-&gt;dwExStyle & WS_EX_CTRLASMAINWIN) </div><div class="line">            && (pWin-&gt;pMainWin-&gt;secondaryDC)) {</div><div class="line">        <span class="keyword">if</span> (client && (pWin-&gt;dwExStyle & WS_EX_USEPRIVATECDC)) {</div><div class="line">            <span class="keyword">return</span> pWin-&gt;privCDC;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> GetSecondarySubDC (pWin-&gt;pMainWin-&gt;secondaryDC, </div><div class="line">                    (HWND)pWin, client);</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (client && (pWin-&gt;dwExStyle & WS_EX_USEPRIVATECDC)) {</div><div class="line">            <span class="keyword">return</span> pWin-&gt;privCDC;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (client) {</div><div class="line">            <span class="keyword">return</span> GetClientDC ((HWND)pWin);</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">return</span> GetDC ((HWND)pWin);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还有一对 API 用来获取和释放 dc 的：BeginPaint 和 EndPaint 。首先这一对 API 正常情况应该只用于 <code>MSG_PAINT</code> 消息处理里。BeginPaint 是通过内联函数 <code>get_valid_dc</code> 来获取。所以主窗体（或是控件）不同的风格获取到的 dc 是不同的。一般来说有双缓冲风格的获取到的一般是 off-screen 的 dc （之前设置的双缓冲 dc，控件得到的是父窗体缓冲的子 dc）；没有双缓冲的就是 on-screen dc 。并且这个 API 获取的 dc 是非客户区的区域的（这里是最大矩形区域），然后是经过剪切的（就是 MiniGUI 窗口系统通过窗口重叠、遮挡计算后，设置剪切好不需要绘制的区域了的）。然后由这个 API 获取到的 dc 一般要由  EndPaint 来释放，因此 EndPaint 不光光会释放 dc，如果有双缓冲风格的话，还会在这里调用双缓冲的更新函数（默认是将缓冲 dc 更新到屏幕）。</p>
<h2 id="DC_工作原理">DC 工作原理</h2>
<p>通过上面的 API 获取（或是创建）了 dc 后，再调用 GDI 层提供的一系列图形绘制函数就可以画出图像了。从上层应用程序调用一个图形绘制 API 到真正在屏幕上显示，这一个过程是怎么样的？我以前用 MiniGUI 的时候一直有这么一个疑问。现在把我自己的一些理解总结下：</p>
<h3 id="基本流程">基本流程</h3>
<p>现在以 FillBox (HDC hdc, int x, int y, int w, int h) 这样一个GDI 层的简单的 API 为例，走下 MiniGUI 的流程。首先这个 API 的作用是使用 dc 的画刷（可以使用 SetBrushColor 设置，默认为白色）颜色来填充 dc 中的指定矩形区域。它的基本流程是：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/minigui-dc/2.png" alt="" title="dc流程"></p>
<ul>
<li>通过上面的一些 API 中的一个取得 dc（这里以 on-screen 类的 dc 为例子）。</li>
<li>设置你获取的 dc 的画刷颜色（不设置就是之前的颜色，默认为白色）。</li>
<li>根据 dc 的剪切域来填充矩形。</li>
<li>根据 dc 中 surface 的类型选用填充函数。</li>
<li>填充函数完成图像数据填充。</li>
<li>on-screen 数据被修改（填充）直接表现在屏幕上。</li>
</ul>
<h3 id="要点分析">要点分析</h3>
<p>上面的步骤看似简单，但是其中有些步骤是包括很多事情的。下面来分析下上面步骤中一些需要注意的地方：</p>
<ul>
<li><strong>dc 剪切域：</strong><br>上面提到的 MiniGUI 会根据 dc 中的剪切域来填充指定的矩形。剪切域上面也有提到过的，是 MiniGUI 窗口系统通过一系列窗口遮挡关系计算出来的，保证看不到的地方不绘制，用以提高绘制效率的机制。MiniGUI 会调用内部的填充函数分别填充剪切域。如果被遮挡过的（或是调用专门的接口设置过），那一般矩形会被分割成几个部分（需要绘制的部分，就是把不需要绘制的部分从原来矩形里剔除了）。所以你在上层传入的一个块区域信息，但是到了 MiniGUI 内部不一定一次就填充完成。很有可能这块区域被分成了几块小的区域，填充多次。MiniGUI 里绘制一些不规则的图形就是通过剪切域来实现的。</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/minigui-dc/3.png" alt="" title="剪切域示例"></p>
<ul>
<li><strong>surface 的类型：</strong><br>上面说的根据 surface 的类型选用填充函数。surface 分为软件的还硬件的。软件的意思是说这个 surface 的像素数据是使用系统内存来存储的，各项图形（像素）操作是通过 CPU 来实现的。而硬件 surface 则是像素数据使用显存存储，各项图形（像素）操作是通过 GPU 来实现。这里说 GPU 有点夸张，很多芯片或是平台上，都是只有一块简单的图形处理芯片而已，有些则是集成在了 CPU 里。这里很明显可以看得出硬件 surface 的好处。首先它的像素数据不占用系统内存，其次它的各种图形操作可以通过专用的图形芯片进行加速处理。通常图形芯片处理图像数据比处理通用数据的 CPU 要快得很多，特别是图像数据在显存中的时候。</li>
</ul>
<p>那什么时候时候 dc 用的 surface 是硬件的，什么时候用的是软件的呢？要想使用硬件的 surface ，首先你运行 MiniGUI 的平台要有图形处理芯片（硬件支持）。其次 MiniGUI 有该图形芯片对应的 GAL （硬件驱动）。还要你 MiniGUI 的运行配置要使用该 GAL （MiniGUI.cfg 中的 gal_engine 设置）。最后你创建 dc 时，要告诉 MiniGUI 你要创建硬件 surface 的 dc （通过指定 <code>MEMDC_FLAG_HWSURFACE</code> 或是兼容硬件 dc 来创建）。还有一个关键因素，创建硬件 suraface 要满足底层硬件的条件，例如创建的时候显存要足够、必须是在硬件支持的颜色格式中等等。当你的 MiniGUI 不满足上面任意一个条件时，就会创建软件 surface 的 dc。</p>
<ul>
<li><p><strong>图像数据操作：</strong><br>这里要分开2种情况来讨论： </p>
<ul>
<li><p><strong>软件的 surface：</strong><br>软件的 surface 的图像数据处理，其实就是一些列的写点操作。MiniGUI 的软件 surface 图形操作函数，就是将 surface 里的图像数据写成指定的颜色（简单的赋值操作），只不过某些颜色格式（例如4字节对齐的32位）会用到一些优化的赋值算法。这里再说说图像数据吧。一般计算机用的是 RGB 颜色，这里以32位为例，RGB 每个分量从 0 ～ 255 （占用8位，1个字节），然后组合成各种不同的颜色。在 RGB 颜色方式中，一个像素点的数据就是一个 RGB 数值，所以一张图像就是一系列连续的这些像素点的集合，也就是一系列连续的 RGB 数值。这个就是图像数据，占用一片连续的存储空间（软件的就占用系统内存）。所以说软件的图像操作，都是操作这些 RGB 数值，可以简单的理解为 C 语言里的数组操作。</p>
</li>
<li><p><strong>硬件的 surface：</strong><br>硬件的 surface 图像处理，就调用不同的图形处理芯片的接口来进行的。一般的 2D 图形处理芯片对于色块的传送有比较明显的加速。一般表现为一次一片、一片的处理，比软件的一次一个点要快得多。同时有些硬件还支持一些像素混合的加速功能（alpha、colorkey 等）。</p>
</li>
<li><p><strong>屏幕显示：</strong><br>屏幕显示。不管是软件还是硬件的 surface ，操作它们的数据，是怎么影响到屏幕的呢？我们这个例子的 surface 数据是 on-screen 类型的。这个就比较直接了。软件的话，屏幕的图像数据就是内存中的那些 RGB数值（上面分析了的），所以你直接修改它们，就能马上显示到屏幕上。硬件的，虽然它们需要经过硬件图形芯片的处理，但是显存里面的数据还是屏幕的。所以图形芯片处理过后，屏幕上的图像也马上就更新了。但是 MiniGUI 硬件 surface 也是支持 off-screen 的，这又是怎么回事呢。没错，显存确实是屏幕的，但是一般来说显存都比屏幕大。这句话怎么理解呢。举个例子：假设屏幕是 640x480-16bpp 的，那么以 RGB 颜色格式来说一个屏幕说占用的显存大小就是 600kb，假设显存有10Mb，那么 off-screen 显存的大小就是 10Mb - 600kb = 9.4Mb 。这就说虽然这 9.4Mb 是屏幕的数据，但是由于屏幕只有 640x480 这么大，你操作了这些数据，理论上来说是应该马上在屏幕上显示的，但是由于用户其实是看不到这些内容的（前面说了，屏幕没这么大）。如果要想在屏幕上显示这部分显存的内容，需要色块传 API （也就是 MiniGUI 里的 BitBlt 接口）把这些显存的内容复制到能在屏幕上显示的显存的地址才行。所以硬件的 surface 也是能够有 off-screen dc 这种用法的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="其它话题">其它话题</h2>
<h3 id="颜色运算">颜色运算</h3>
<p>不管是颜色填充（FillBox）还是色块传送（BitBlt），最终都是要做颜色运算。现在填充 MiniGUI 支持的颜色运算就是颜色覆盖和 alpha 混合。</p>
<ul>
<li><p>颜色覆盖就是直接拿源颜色的数值赋值给目标颜色。上面讲解中例子的用法的话，就是把屏幕图像数据中的某个一片数值改成了 dc 画刷的颜色（RGB值）。</p>
</li>
<li><p>alpha 混合就是通过一个指定颜色公式，使用颜色值中的 alpha 信息将源颜色和目的颜色进行混合，从而达到混合后的颜色信息带有目的颜色的目的。这个就是通常说的透明效果。一般来说 alpha 范围为 0 ～ 255，一般的混合公式为下面代码。从上面的公式可以看得出如果 alpha 值越小，那么目标颜色残留的就越多，源颜色的透明度也就越高（通俗的说就是源颜色很淡，而目标颜色很浓，透过源颜色能看到能多的目标颜色）。另外 alpha 混合的方式有很多种，例如是使用源颜色的 alpha 值做为混合标准（<code>MEMDC_FLAG_SRCALPHA</code>），还是使用目标颜色的 alpha 值做为混合标准；将不将源颜色的 alpha 值写入到目标颜色的 alpha 中去。目前 MiniGUI 的 alpha 混合只支持以源颜色的 alpha 为标准进行运算，并且不将源颜色的 alpha 值写入目标颜色的 alpha 中。经过上面的分析就能解释一个比较常见的问题：画透明图像的时候，在更新时透明图像会越叠越深，数次更新后，就不透明了。引起这个问题的主要原因就是，透明图像的背景没有被更新。这样的话透明图像（源颜色）第一次和透过的背景图像（目标颜色）进行 alpha 混合时，是正常的。随后，如果够过的背景图像没有被更新的话，那么透明图像就会和第一次混合后的图像进行混合。从上面的分析就可以看出，混合后的图像就像是把透明图像再次叠加到背景上一样（事实本来也是这样）。要想得到正确的效果，每次都必须更新背景图像，也就是说每次都要让透明图像和没有被混合后的图像进行混合。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MiniGUI 32 位 alpha 混合代码</span></div><div class="line">DUFFS_LOOP4(</div><div class="line">{</div><div class="line">    Uint32 s;</div><div class="line">    Uint32 d;</div><div class="line">    Uint32 s1;</div><div class="line">    Uint32 d1;</div><div class="line">    Uint32 sA;</div><div class="line">    Uint32 dA;</div><div class="line">    s = *srcp;</div><div class="line">    d = *dstp;</div><div class="line">    sA = s &gt;&gt; <span class="number">24</span>;</div><div class="line">    dA = d &gt;&gt; <span class="number">24</span>;</div><div class="line">    dA = sA + dA - ((sA * dA) &gt;&gt; <span class="number">8</span>);</div><div class="line">    <span class="keyword">if</span>(dA &gt; <span class="number">255</span>) dA = <span class="number">255</span>; <span class="comment">//alpha may be greater than 255</span></div><div class="line">    alpha = s &gt;&gt; <span class="number">24</span>;</div><div class="line">    s1 = s & <span class="number">0xff00ff</span>;</div><div class="line">    d1 = d & <span class="number">0xff00ff</span>;</div><div class="line">    d1 = (d1 + (((s1 - d1) * alpha) &gt;&gt; <span class="number">8</span>)) & <span class="number">0xff00ff</span>;</div><div class="line">    s &= <span class="number">0xff00</span>;</div><div class="line">    d &= <span class="number">0xff00</span>;</div><div class="line">    d = (d + (((s - d) * alpha) &gt;&gt; <span class="number">8</span>)) & <span class="number">0xff00</span>;</div><div class="line">    *dstp = d1 | d | (dA &lt;&lt; <span class="number">24</span>);</div><div class="line">    ++srcp;</div><div class="line">    ++dstp;</div><div class="line">}, w);</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>colorkey：这个也有2种模式的，一种是以源颜色的 colorkey 颜色值做为标准（<code>MEMDC_FLAG_SRCCOLORKEY</code>），一种是以目标颜色的 colorkey 颜色值做为标准。这个在进行颜色填充或是色块传送的时候，如果遇到和 colorkey 颜色值一样的颜色，就会跳过这些颜色，不进行像素操作。这样就能形成一些不规则图形的填充（把背景颜色做为 colorkey 过滤掉）。目前 MiniGUI 只支持以源颜色 colorkey 颜色值做为标准。</li>
</ul>
<h3 id="绘制图像导致屏幕闪烁">绘制图像导致屏幕闪烁</h3>
<p>导致这个问题的一般原因是，直接在屏幕上进行大规模的图像更新操作。这样绘制过程就会在屏幕上展现出来，这样就会感觉屏幕在闪烁（屏幕更新了多次）。在应用程序上导致这个问题的最常见的情况就是获取或是创建了 on-screen dc，然后绘制操作都在这个 dc 上进行。这样 dc 中的每个图像数据点的操作都会反映到屏幕上。短时间内颜色的频繁变化，在人的视觉上就会造成一种突变的感觉，就是通俗上说的闪烁。从上面分析可以看得出要避免这个问题，就是要避免在绘制过程中屏幕多次的改变。这里注意，即便是在应用程序中仅仅调用一次 FillBox 填充一块区域，如果是直接在 on-screen dc 上操作的话，屏幕的变化不仅仅是一次。如果是软件的 surface 应该说是这块区域有多少个像素点就有多少次，当然这个还和屏幕的刷新率有关。所以在应用程序中避免这样的问题，就需要在 off-screen dc 中把需要更新到屏幕的图像完全绘制好，然后使用色块传送 API 把这些绘制好的图像复制到屏幕上。在某些硬件上这个操作几乎可以说就是一次性完成的，计算是 MiniGUI 的软件 surface 操作的话，也在色块传送上也有专门的优化。这样能极大的减少短时间内屏幕的变化次数，从而缓解因为图像更新导致的屏幕闪烁问题。MiniGUI 3.0 的新特性双缓冲机制就是针对解决这个问题而提出的。</p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</loc>
    <lastmod>2015-01-21T13:12:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 源码分析笔记</title>
        <pubTime>2015-01-21T13:12:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>随手记记，免得忘记。</p>
<h2 id="线程版启动的线程">线程版启动的线程</h2>
<p>线程版的 MiniGUI 在 InitGUI 后，会启动额外3个线程：</p>
<ul>
<li><p>__mg_desktop（pthread_t）：桌面线程，线程函数 DesktopMain。这个线程用于运行桌面处理函数，处理各种桌面消息，以及分发各种消息给所需要的窗口。</p>
</li>
<li><p>__mg_parsor：事件循环线程，线程函数 EventLoop。这个线程用于不停的接受底层驱动事件（鼠标、键盘等），然后转化为 MiniGUI 消息放入消息队列。</p>
</li>
<li><p>__mg_timer：全局计数线程，线程函数 TimerEntry。这个线程用于提供 MiniGUI 最小计数单位（定时器用）。</p>
</li>
</ul>
<p>所以，加上 MiniGUI 应用程序本身，如果不再额外创建线程的话，线程版的 MiniGUI 一共有4个线程。</p>
<h2 id="有层_alpha_的时候会忽略逐点_alpha">有层 alpha 的时候会忽略逐点 alpha</h2>
<p>目前的 MiniGUI 是这样的，如果既要有层 alpha 有要逐点 alpha，只能分2次混合，一次使用逐点 alpha，一次使用层 alpha，中间使用 memdc 倒一次。这个可以看看 GAL_UpperBlit、GAL_LowerBlit、GAL_MapSurface、GAL_CalculateBlit、GAL_CalculateBlitN 等等这些函数。有空最好把目前 MiniGUI BitBlt 的流程总结下。哎～～以前写 GAL 的时候有点印象的，隔了段时间又忘记了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-21T13:07:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 消息机制源码分析</title>
        <pubTime>2015-01-21T13:07:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>现在不少的GUI都是基于消息机制的。所谓的消息机制我个人的理解是：当用户与GUI交互时发生了一些事件（如按下键盘、点击鼠标等），这个时候就要告诉GUI发生了某个事件（发送消息），GUI在监听是不是有事件发生（获取消息），当GUI得知有事件发生时就要做出某些动作来响应用户的这些事件（消息处理函数），当GUI处理完一个事件的响应函数后会继续监听别的事件直到GUI退出位置（消息循环）。大致应该是这样，不过其实还有不少东西的：例如，同步、异步处理，消息优先级，消息队列等。具体的来看看 MiniGUI 的实现吧。</p>
<p>N早以前开了个头～～MS放弃写了～～ -_-|| 留个名吧～～</p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B7/</loc>
    <lastmod>2015-01-21T09:48:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程7</title>
        <pubTime>2015-01-21T09:48:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。这次给大家介绍的是界面美观的进度条控件。它功能上和MiniGUI原有的进度条控件（CTRL_PROGRESSBAR）是一样的（其实进度条也就是那些功能，哪还能整出别点什么花样哦）。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<ol>
<li>要具有MiniGUI原有进度条控件的所有功能，像设置范围，设置步进值，设置当前位置等；垂直、水平风格；还有一些通知码。因为本控件的主要目的是美观，但是这要保证实用性，所以原有的功能必需要有。</li>
<li>可以设置2套图片，分别用来表示进度条本身和背景。每套图片分为3个部分：头、身体、尾。头和尾可有，可无；背景也是可有，可无。图片格式支持bmp、gif、jpg、png（jpg、png依赖于MiniGUI的配置）。</li>
</ol>
<p>最终效果见下图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control7/1.jpeg" alt="" title="图 1 CTRL_PROGRESSBAREX效果图"></p>
<h2 id="二、概要设计">二、概要设计</h2>
<p>我把控件取名为CTRL_PROGRESSBAREX，自己重新写（继承顶层的DefaultContorl）。虽然ProgressBarEx需要MiniGUI原有控件的功能，但是我认为实现这些功能的代码量都不大；并且自己重新写能有更高的灵活性，权衡了一下我还是选择自己重新写。其实这里主要工作在于用图片表现控件的外观上了。</p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>为了实现ProgressBarEx最基本功能，用4个int型来保存当前控件的进度的最大值、最小值、当前位置和步进值。控件有2套图片，每套3张，一共是6个bitmap指针（这里采用和之前ButtonEx同样的方式，控件只保存指针）。然后是用一个BOOL变量保存是否实现百分比文本，用2个gal_pixel变量保存进图条超过文本和没超过时的2种不同的颜色。最后是我在测试的时候发现的问题，在有些平台上进度条重绘会闪烁，所以我增加了一个条件编译是否使用内存DC（绘图缓冲）。ProgressBarEx的数据结构如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ProgressBarEx 数据数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _pbarexdata_st</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> nMin;               <span class="comment">// 最大值</span></div><div class="line">    <span class="keyword">int</span> nMax;               <span class="comment">// 最小值</span></div><div class="line">    <span class="keyword">int</span> nPos;               <span class="comment">// 当前位置</span></div><div class="line">    <span class="keyword">int</span> nStep;              <span class="comment">// 步进值</span></div><div class="line">        </div><div class="line">    PBITMAP pbmpHead;       <span class="comment">// 进度条头部图片指针</span></div><div class="line">    PBITMAP pbmpBody;       <span class="comment">// 进度条身体图片指针</span></div><div class="line">    PBITMAP pbmpTrail;      <span class="comment">// 进度条尾部图片指针</span></div><div class="line">        </div><div class="line">    PBITMAP pbmpBkHead;     <span class="comment">// 进度条背景头部图片指针</span></div><div class="line">    PBITMAP pbmpBkBody;     <span class="comment">// 进度条背景身体图片指针</span></div><div class="line">    PBITMAP pbmpBkTrail;    <span class="comment">// 进度条背景尾部图片指针</span></div><div class="line">         </div><div class="line">    BOOL bShowPrecent;      <span class="comment">// 是否显示百分比</span></div><div class="line">    gal_pixel pixelOff;     <span class="comment">// 进度还没到文本区域时文本的颜色</span></div><div class="line">    gal_pixel pixelOn;      <span class="comment">// 进度条已经达到文本区域时文本的颜色</span></div><div class="line">        </div><div class="line">    HDC hMemDC;             <span class="comment">// 绘图内存DC </span></div><div class="line">        </div><div class="line">} PBAREXDATA;</div><div class="line"><span class="keyword">typedef</span> PBAREXDATA* PPBAREXDATA;</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>注册和卸载的接口，老规矩了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterProgressBarExControl (<span class="keyword">void</span>);</div><div class="line">BOOL UnregisterProgressBarExControl (<span class="keyword">void</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>消息为什么定义成下面这个样子，也是老规矩了的，25*3是因为之前已经有了3个自定义控件了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_PBEXMBASE   (0xEFFF-25*3)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_PBEXMXX     MSG_PBEXMBASE – 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>1：设置控件数据。这个和ButtonEx的设计思路一样了：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEX_IMAGE      0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEX_PRECENT    0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEX_ALL        ((PBEX_IMAGE) | (PBEX_PRECENT))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETDATA   MSG_PBEXMBASE – 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>2：获取控件数据。和设置相对应：wParam传入获取PBAREXDATA，lParam传入需要获取的变量：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_GETDATA   MSG_PBEXMBASE - 2</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>3：以下这些是与MiniGUI原有进度条控件消息接口相对应的，具体的可以查阅MiniGUI的API手册：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETRANGE      MSG_PBEXMBASE - 3</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETSTEP       MSG_PBEXMBASE - 4</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_SETPOS        MSG_PBEXMBASE - 5</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_DELTAPOS      MSG_PBEXMBASE - 6</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXM_STEPIT        MSG_PBEXMBASE - 7</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="3：通知码">3：通知码</h3>
<p>这里也是和MiniGUI原有的进度条控件的通知码相对应的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXN_REACHMAX 	 1</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXN_REACHMIN 	 2</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="4：风格">4：风格</h3>
<p>这里也是和MiniGUI原有的进度条控件的风格相对应： -_-||</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXS_NOTIFY        0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PBEXS_VERTICAL      0x00000002L</span></div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="四、功能实现">四、功能实现</h2>
<p>这里主要说说如何用图片正确的表现进度条外观了。我这里设计成进度条的外观由3个部分组成：头、身体、尾；每个部分由一张图片组成；其中头和尾可有，可无；由于进度条的特性，身体的图片只要能表现本进度条步进的最小单位即可。这样整个控件外观都由图片来表现，图片好的话，控件就会很漂亮。在绘制控件的时候，主要就是处理用图片正确的拼凑当前进度，这个要注意以下几个问题：</p>
<ul>
<li><p>1: 背景。控件的背景是可有、可无的。没有当然就不要说什么了。如果有的话，背景是不管当前进度如何，都是显示100%的，这个很好理解。可以看看上面效果图的第2个控件实例。</p>
</li>
<li><p>2: 进度条身体的拼凑。这个首先来看看没有头、尾的情况。没有头、尾，那进度条就只有身体的图片组成，这个主要就是计算当前进度的区域长度（垂直的是高度），然后这个长度，需要多少张当前的身体图片来拼凑。有头、尾的话，就把头和尾的图片贴上去，然后在计算剩下的部分需要多少身体图片。可以参照下面的图，应该就比较好理解了：</p>
</li>
</ul>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control7/2.jpeg" alt="" title="图 2 进度条身体拼凑"></p>
<ul>
<li>3: 透明。这个问题其实在ButtonEx中已经讨论过了。我这里不提供非png格开启的透明颜色的选项。因为如果要用bmp或是jpg的话，请把图片背景弄成窗口背景颜色就行了。如果窗口背景是图片的话，您还是用png吧 -_-|| 。这里也顺带说说，为什么要把这些图片弄成3张。其实弄成一张也可以，而且这样还方便PS处理。但是这样做有个问题，就是集合在一张里的话，就要用MiniGUI的图像处理API去分割图片；这在16bit的运行环境下处理32bit的png的话，就造成透明颜色的失真。这个也是在ButtonEx中说过了的。</li>
</ul>
<h2 id="五、注意问题">五、注意问题</h2>
<p>这里也没什么需要注意的问题了，因为需要注意的地方之前的教程都说过了。这里顺带说下，之前说的那个画面闪烁的问题。可以使用内存DC缓冲解决；当然代价就是多一点点系统内存开销。这个可以根据实际情况是否开启（开关条件编译宏即可）。因为不同的硬件平台不一样，有的会闪烁，有的就不会。</p>
<p>到这里我就全部介绍完我之前自己写的那些MiniGUI自定义控件了。目前先到这里吧，看看以后还有没有需要更新的地方了。如果对之前我写的控件有什么好的改进建议或是开发别的MiniGUI控件，欢迎和我一起讨论 ^_^。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="http://download.csdn.net/detail/mingming_killer/4045894" target="_blank" rel="external">下载地址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B6/</loc>
    <lastmod>2015-01-21T08:07:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程6</title>
        <pubTime>2015-01-21T08:07:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。之前就已经介绍完MiniGUI 2.0以前本人掌握的自定义控件的方法了（3.0的好像不太一样了呢，目前本人还没研究过）。恩，让我们来回顾下先：</p>
<ol>
<li>对已经创建了的控件实例进行子类化。</li>
<li>对某个控件的子类进行子类化；这个又可以分为针对某个已有的控件（继承父类，类似之前的SLEditEx），重新自己写（继承自最顶层的DefaultControl，类似之前的ButtonEx）。</li>
</ol>
<p>这里主要是把ControlEx工程中剩下的2个自定义控件RollShow和ProgressBarEx的实现过程也介绍下，这里都是采用第2种方法。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<p>滚动控件，顾名思义，就是像街上某些广告牌一样，能将一条字符串信息在指定的空间内滚动的显示。我这里是学习目的，所以功能上就简化些：</p>
<ol>
<li>控件自定判断当前的字符能否在当前的矩形空间里显示完全，能则正常显示，不能则滚动显示。</li>
<li>滚动只要从右到左滚动就可以，能够持续的滚动，直到显示的字符串改变能够在空间内完整显示为止。</li>
</ol>
<p>最终效果见下图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control6/1.jpeg" alt="" title="图 1 CTRL_ROLLSHOW效果图"></p>
<h2 id="二、概要设计">二、概要设计</h2>
<p>我把控件取名为CTRL_ROLLSHOW，自己重新写（继承顶层的DefaultContorl）。因为它主要就是一些显示功能，MiniGUI原有的控件的一些功能也不能有效的“帮上什么忙”，所以选择自己重新写，这样灵活性还高些。</p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>ROLLSHOW的主要是用来显示字符串，我设计成控件只保存当前显示字符串的指针，这样外部可以方便的修改，而且控件也无需管理字符串的缓冲空间。滚动的效果用定时器来实现，本来我是想设计成所有的ROLLLSHOW控件只创建一个定时器来管理滚动效果的，不过我发现这样以我目前的水平来实现有些困难。所以我弄成每一个ROLLSHOW实例都自己创建一个定时器，这里要注意下，MiniGUI有限定thread下一个应该用程序最多只能创建16个定时器（这个和MiniGUI的内部实现有关）。不过其实也不要紧，因为一般这个ROLLSHOW控件在显示的界面中不会创建好很多个的，所以这个方案也凑活行得通了^_^ 。用一个int来保存滚动的速度（定时器的间隔）。然后用2个变量分别保存当前的文字显示颜色和背景颜色。最后用一个RECT变量来保存当前文本滚动的区域：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RollShow 数据数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _rsdata_st</div><div class="line">{</div><div class="line">    <span class="keyword">char</span>* pstrText;         <span class="comment">// 显示字符串指针</span></div><div class="line">        </div><div class="line">    <span class="keyword">int</span> nStep;              <span class="comment">// 滚动步长</span></div><div class="line">    <span class="keyword">int</span> nTimerSpeed;        <span class="comment">// 定时器时间</span></div><div class="line">        </div><div class="line">    gal_pixel pixelText;    <span class="comment">// 文本颜色</span></div><div class="line">    gal_pixel pixelBk;      <span class="comment">// 背景颜色</span></div><div class="line">        </div><div class="line">        </div><div class="line">    RECT rcText;            <span class="comment">// 文本显示区域</span></div><div class="line">        </div><div class="line">} RSDATA;</div><div class="line"><span class="keyword">typedef</span> RSDATA* PRSDATA;</div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>注册和卸载的接口，老规矩了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterRollShowControl (<span class="keyword">void</span>);</div><div class="line">BOOL UnregisterRollShowControl (<span class="keyword">void</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>消息为什么定义成下面这个样子，也是老规矩了的，25*2是因为之前已经有了2个自定义控件了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_RSMBASE     (0xEFFF-25*2)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_RSMXX       MSG_RSMBASE – 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>1：设置控件数据。这个和ButtonEx的设计思路一样了：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_TEXT         0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_COLOR        0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_SPEED        0x00000004L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RS_ALL          ((RS_TEXT) | (RS_COLOR) | (RS_SPEED))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RSM_SETDATA     MSG_RSMBASE – 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>2：获取控件数据。和设置相对应：wParam传入获取PRSDATA，lParam传入需要获取的变量：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RSM_GETDATA     MSG_RSMBASE - 2</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>3：通知控件显示字符串已被修改。这个消息用于让控件重新计算当前显示字符串的空间，重新判断是否要滚动显示：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> RSM_TEXTMODIFIED    MSG_RSMBASE - 3</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>3：通知码 本控件目前不需要通知码。</li>
</ul>
<h2 id="四、功能实现">四、功能实现</h2>
<p>这里最主要的就是滚动的动态功能实现了。这里如果要用自己方法弄也可以，但是既然我们用的MiniGUI，咋要就要好好挖掘MiniGUI的API，这个时候你就会发现MiniGUI有几个API为ROLLSHOW的实现提供了很好的解决办法。一个是GetTextExtent()、一个是DrawText()。GetTextExtent能够计算出给定字符串在指定的DC中输出所需要的空间大小，这个API可以用来实现判断当前字符串是否需要滚动显示的功能。</p>
<p>DrawText 是在给定的一个RECT空间内按照预定的几种对齐格式进行文本输出。好了，先来让我们想象一下——拿一张白纸，然后再拿一张上面写了字的白纸；然后以一定的速度拿着写了字的白纸从没有字的白纸上从右到左的移动。OK，我们看到了什么——这个就是我们要的滚动效果啊。那张没字的白纸就相当于控件的客户区，有字的白纸就相当于DrawText中指定的RECT空间，我只要在定时器中以一定的速度改变这个RECT的位置就可以实现滚动功能了。我这里只是调用这些上层的API而已，剩下的事情就交给MiniGUI解决吧 ^_^。想象能力差点的，请看下面的图，黑色的矩形表示控件客户区，红色的矩形表示显示文本的DrawText的RECT空间：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control6/2.jpeg" alt="" title="图 2 滚动效果实现图"></p>
<h2 id="五、注意问题">五、注意问题</h2>
<p>那些自定控件实现方法需要注意的问题我前面的教程已经说过了，这里说下专门针对实现本控件需要注意的问题吧。我认为这里需要注意点的问题，第一个前面的说的定时器数量的问题，我用的MiniGUI版本的thread模式最多只能同时存在16个，这个在使用的时候需要注意，不过创建太多的本控件实例就没啥问题。 第二个就是控件的背景透明问题。如果是父窗口没有使用背景图片的，就把控件的背景颜色设置成父窗口的背景颜色就行了。如果父窗口使用了背景图片的，也好办，使用CreateWindowEx创建控件实例并指定WS_EX_TRANSPARENT风格也可以解决问题。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="http://download.csdn.net/detail/mingming_killer/4045894" target="_blank" rel="external">下载地址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/21/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B5/</loc>
    <lastmod>2015-01-21T06:40:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程5</title>
        <pubTime>2015-01-21T06:40:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。上次以ButtonEx控件的开发为例介绍了如果自己完全重新开始写控件，这次我以一个扩展单行编辑框控件为例介绍如何在原有控件的基础上扩展自定义功能（继承原有控件功能）。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<p>MiniGUI原来的单行编辑框控件 <code>CTRL_SLEdit</code> 除了具有编辑框的基本编辑功能外，就提供了一个限制输入字符长度的功能。没有类似MFC中CEdit限制输入类型，字符还是数字，数字还可以限制范围（不过CEdit是在输入完之后才能判断的）。不过这些功能对于应用程序还是比较有用的。于是我决定在CTRL_SLEDIT的基础上扩展这些功能：</p>
<ol>
<li>2种编辑模式：文本；数字。文本模式可以输入任意字符，数字模式只能输入0~9、+、-和小数点。</li>
<li>文本模式提供过滤输入字符的功能，能够指定屏蔽掉特定的字符；提供反向过滤功能，就是能够指定只允许输入特定的字符。</li>
<li>数字模式提供指定是否限定输入整数；并在此基础上提供指定输入范围功能。</li>
</ol>
<h2 id="二、概要设计">二、概要设计</h2>
<p>这里因为继承了 <code>CTRL_SLEDIT</code>，所有只需专注控件的扩展功能就行了。要实现以上功能，最关键的就是在 <code>CTRL_SLEDIT</code> 接受到键盘输入之后，把输入显示到屏幕上之前，进行自己的过滤算法判定；当输入的是不符合用户设定的字符则截断，不发送给父类 CTRL_SLEDIT 处理（这样它就显示不出来了）；当输入是符合用户设定的字符就发送给父类处理（这样它就能正常显示出来）。流程图如下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control5/1.jpeg" alt="图 1 CTRL_SLEDIT流程图"></p>
<ul>
<li>1：EEXMODE_TEXT</li>
</ul>
<p>文本模式能让用户指定不允许输入某些字符（过滤），还是只允许输入某些字符（反过滤）。不过注意，这里针对的是字符，而不是字符串。字符串又要麻烦很多了。这个模式我只是顺带做了一下，下面的数字模式才是比较实用的。（汉字是占2个字符(字节)，所以这里MS也不能过滤了 -_-||）</p>
<ul>
<li>2：EEXMODE_DIGITAL</li>
</ul>
<p>首先数字编辑模式就只能输入’0~9’、’+’、’-‘、’.’这些字符。在此基础上能让用户选择能否输入小数，开启的话就能输入小数；关闭的话就能输入整数。还能让用户指定数值的输入范围（闭区间）。</p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>SLEditEx 的控件变量都是实例变量。控件变量数据结构我命名为EEXDATA：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typdef <span class="keyword">struct</span> _eexdata_st</div><div class="line">{</div><div class="line">    ... ...</div><div class="line">} EEXDATA;</div><div class="line">typdef EEXDATA* PEEXDATA;</div><div class="line"></div></pre></td></tr></table></figure>

<p>首先需要一个变量能保存当前的编辑模式。这里我没有使用控件本身的风格变量，因为父类CTRL_SLEDIT把那低16bit用得差不多了，我懒得去搅和了，自己拿一个变量来保存得了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编辑模式定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _eexmode_en</div><div class="line">{</div><div class="line">    EEXMODE_TEXT,         <span class="comment">// 文本编辑模式</span></div><div class="line">    EEXMODE_DIGITAL,      <span class="comment">// 数字编辑模式</span></div><div class="line">        </div><div class="line">} EEXMODE;</div><div class="line"></div><div class="line">EEXMODE nMode;            <span class="comment">// 编辑模式</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>由于继承原有控件，所以控件数据占用了留给应用程序的dwAdditionalData1（附加数据1，忘记了怎么回事的赶快回头看教程2 ^_^），所以还要多加一个DWORD：</p>
<pre>
DWORD dwUserAddData; // 用户控件附加数据
</pre>

<p>文本模式需要一个标志来表示当前是过滤还是反过滤；我把过滤（反过滤）的字符存入一个静态字符数组中（不用动态链表了，那个麻烦，我把这个数组大小设置成512，应该够了）：</p>
<pre>
char strFilterChar[EEX_MAXCHAR];    // 过滤字符串 
BOOL bFilter;                       // 过滤模式标志
</pre>

<p>数字编辑模式也需要一个标志来表示当前是否允许输入小数；还需要2个浮点型来保存允许输入的最大值和最小值（浮点型可以表示整型的整数部分，但是整型就无法表示浮点型的小数部分了，所以要用浮点型）。如果设置的最小值大于最大值的话，我就把这种情况设计成不限制输入范围。这里我还多设计了一个范围的数据结构，其实为了下面的消息接口，因为一个消息只能传递2个参数，我把范围和允许输入小数的开关的设置放到一个接口里去了。但是这需要传递3个参数，所以我就弄了一个范围的数据结构出来，把2个参数整合成1个来传递。（其实完全可以用之前ButtonEx控件的那个钟传递参数的方法：1个参数传递控件变量指针，1个参数传递要设置的变量类型；不过这2个中传递方法我也说不上哪种好，哪种不好，我这里都用了，大家看自己喜欢了。其实MiniGUI原来的控件里也是这2种都用了的，例如：CTRL_LISTVIEW）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 限定输入数字范围数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _eexrange_st</div><div class="line">{</div><div class="line">    <span class="keyword">double</span> dMin;      <span class="comment">// 最小值</span></div><div class="line">    <span class="keyword">double</span> dMax;      <span class="comment">// 最大值</span></div><div class="line">        </div><div class="line">} EEXRANGE;</div><div class="line"><span class="keyword">typedef</span> EEXRANGE* PEEXRANGE;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">double</span> dMin;       <span class="comment">// 允许输入最小值</span></div><div class="line"><span class="keyword">double</span> dMax;       <span class="comment">// 允许输入最大值</span></div><div class="line">BOOL  bInteger;    <span class="comment">// 输入是否是整数标志</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>注册和卸载的接口，之前的教程说过了的：</p>
<pre>
BOOL RegisterSLEditExControl (void);
BOOL UnregisterSLEditExControl (void);
</pre>

<p>消息为什么定义成下面这个样子，之前的教程也数过了的。这里为什么减去25咧。因为我的这些控件都是在一个工程里的，当然要防止消息定义冲突啦，我给之前的ButtonEx预留了25个消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_EEXMBASE    (0xEFFF-25)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_EEXMXX      MSG_EEXMBASE – 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>1：设置控件附加数据。这个之前教程说过了的（我MS重复这句话很多次了-_-||）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DWORD* pdwAddData;</div><div class="line">wParam = (WPARAM)pdwAddData;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETADDDATA     MSG_EEXMBASE - 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>2：获取控件附加数据和设置相对应：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DWORD* pdwAddData; </div><div class="line">wParam = (WPARAM)pdwAddData;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETADDDATA     MSG_EEXMBASE - 2</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>3：设置当前编辑模式。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nMode;</div><div class="line">wParam = (WPARAM)nMode;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETEDITMODE    MSG_EEXMBASE - 3</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>4：获取当前编辑模式。和设置对应，直接用返回值获取</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wParam = <span class="number">0</span>;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETEDITMODE    MSG_EEXMBASE - 4</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>5：设置数字模式下的编辑属性。包括是否允许输入小数，输入范围：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PEEXRANGE pRange; </div><div class="line">BOOL bInteger;</div><div class="line">wParam = (WPARAM)pRange;</div><div class="line">lParam = (LPARAM)bInteger;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETDIGITALRANGE    MSG_EEXMBASE - 5</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>6：获取数字模式下输入范围，和设置相对应，允许输入小数标志用返回值获取：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PEEXRANGE pRange;</div><div class="line">wParam = (WPARAM)pRange;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETDIGITALRANGE    MSG_EEXMBASE - 6</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>7：设置文本编辑模式下过滤字符：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* pstrFilter; </div><div class="line">BOOL bFilter;</div><div class="line">wParam = (WPARAM)pstrFilter;</div><div class="line">lParam = (LPARAM)bFilter;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_SETFILTERCHAR      MSG_EEXMBASE - 7</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>8：获取文本模式过滤字符，和设置相对应，过滤标志用返回值获取：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* pstrFilter; </div><div class="line">wParam = (WPARAM)pstrFilter;</div><div class="line">lParam = <span class="number">0L</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> EEXM_GETFILTERCHAR      MSG_EEXMBASE - 8</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="3：通知码">3：通知码</h3>
<ul>
<li>1：输入非法通知码。当输入不符合设置的规则时发送。这里定义成3是因为父类把0~2用掉了，这个要注意啊。</li>
</ul>
<pre>
#define EEXN_INPUTINVALID 3
</pre>

<h2 id="四、功能实现">四、功能实现</h2>
<h3 id="1：文本模式过滤">1：文本模式过滤</h3>
<p>这个功能实现起来很简单。就是拿当前输入的字符去和设置的过滤字符想比较可以了，在过滤字符里就不符合，不在就符合。这里说一下我在判断函数（<code>EEX_ValidateInput</code>）用到的一些strex开头的函数（像strexFind()、strexInsert()等）。这些strex开头的函数也是我自己写的，主要用于实现像CString里的一些常用的字符串操作功能，C语言原来的字符串操作函数很多功能没有，只好自己写了。具体的大家可以去看工程里include里的StringEx.h，这里我是打包成了另外一个库了的，里面还包括了一些常用的数据结构的C语言实现（链表、队列等）。大家其实完全可以自己实现的，我个人感觉我写的也不是特别好 -_-||，又需要的话我再放代码上来吧。</p>
<h3 id="2：数字模式过滤">2：数字模式过滤</h3>
<p>这里我判断的方法是：</p>
<ol>
<li>首先拿当前输入和”0123456789-+.”比较，也就是说首先只允许输入0~9、-、+、.（如果设置了只能输入整数的话，则不允许输入.）。</li>
<li>对于通过了1的字符来说，只要再同时满足一下2个条件就是有效的数字： “-“, “+”只能出现一次并且只能在第一个位置。 “.”只能出现一次。</li>
<li>对于通过了2的字符来说，只需要再验证当前输入的数字是否在设置的范围内就完成了判断了。</li>
</ol>
<p>我感觉我的方法应该还是对的，不知道大家还什么更好的方法没有 ^_^ 。不过这里有个小问题：就是在最后判断范围的时候，在判断下限的时候我使用整数判断。因为我是在显示到屏幕之前进行判断的，如果是小数的话会有问题。例如下限是1.5，本来用户是想输入1.7的，先输入的是1；如果是小数判断的话，1比1.5要小，不在范围内，就会被判定成不合法，从而屏蔽掉输入。所以这里我判断下限的时候采用了整数判断的方法，会造成下限范围设置成小数时，只能限制整数的问题，但总比不能输入要好，不知道大家有什么好办法解决没有。</p>
<h2 id="五、注意问题">五、注意问题</h2>
<p>其实前面那些看代码也能明白，现在说说最关键的，就是继承父类控件需要注意的一些问题（同时也包括了实现本控件需要注意的一些问题 ^_^）。</p>
<ul>
<li>1：调用父类过程处理函数</li>
</ul>
<p>就是在自己的控件过程处理函数最后，把自己不处理的消息都转发给父类控件过程处理函数处理。这样才能享有父类控件原有的功能，而且这样才能叫得上“继承啊“。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">WNDCLASS EEXClass;</div><div class="line"></div><div class="line">EEXClass.spClassName = CTRL_SLEDIT;</div><div class="line">EEXClass.opMask = <span class="number">0x00FF</span>;</div><div class="line"><span class="keyword">if</span> (GetWindowClassInfo (&EEXClass) == FALSE)</div><div class="line"> 	<span class="keyword">return</span> FALSE;</div><div class="line"></div><div class="line">old_ctrl_proc = EEXClass.WinProc;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">return</span> (*old_ctrl_proc) (hCtrl, message, wParam, lParam);</div><div class="line"></div></pre></td></tr></table></figure>

<p>至于获取时候的注意事项，忘记了的要回头去看教程2了哦。然后继承的方式也需要在使用前注册，使用完成后卸载，也是只能使用CreateWindow()来创建，方法和教材4中的一样。</p>
<ul>
<li>2：为每份控件实例保存数据</li>
</ul>
<p>这个上面也提到了的，方法和教程2的一样，要用附加数据1保存，然后自己多加一个DWORD的变量出来提供给外部应用程序使用即可。</p>
<ul>
<li>3：其它</li>
</ul>
<ol>
<li><p>判断输入消息选用 <code>MSG_CHAR</code>。为什么选用这个，而不用 <code>MSG_KEYDOWN</code> 呢。因为 <code>MSG_CHAR</code> 是经过字符翻译了的。我们的控件判断只关心有意义的字符，像delete、insert、home、pageup、pagedown、left、right、up、down之类的我们根本不用管。正好 <code>MSG_CHAR</code> 是不会翻译这些按键消息的 ^_^。</p>
</li>
<li><p>有关MSG_GETDLGCODE。还记上次教程我说过控件在dialog中要想正确获取按键所有就要处理这个消息的吗。没错像编辑框这种控件确实是要正确处理这个消息才能正确的获取所有的键盘输入。但是这里我建议大家不要画蛇添足，因为父类已经帮我们处理，直接把这条消息扔给父类的处理函数就行了。</p>
</li>
<li><p>编辑框控件有个能用鼠标选中一串字符然后用输入的字符代替掉选中字符的功能。这个功能在数字模式下要进行特别的处理，这个、这个大家还是看我代码吧，这里不好说呢 ^_^ 。</p>
</li>
</ol>
<h2 id="六、总结">六、总结</h2>
<p>好了，我觉得需要注意的就是这么多了，其它的大家看代码就OK了。其实扩展原有控件类（继承）的方法和自己重新开始写，大体上来说基本类似，就是注意下以下的问题就行了：</p>
<ol>
<li>最后调用的父类处理函数。继承的当然是调用父类的啦（注意获取父类处理函数的注意事项）；自己重新开始写是调用 DefaultControlProc()。</li>
<li>注意一些已经被父类用掉了的资源。像保存实例数据变量的附加数据，风格变量、通知码等。扩展的需要注意，重新写的就不用在意啦，放心用 ^_^。所以大家在写自己的自定义控件的时，一开始就确定好，到底是继承还是重新开始写。</li>
</ol>
<p>好，到这里MiniGUI2.0版本以前本人会的自定义控件的方法就全部介绍完了。据说3.0的自定义控件的方法比2.0的简单了很多，更接近于OOP。但是本人最近一直没什么时间用3.0，所以只好“落伍“一下了 -_-||。 我写的ControlEx中还有2个扩展控件：进度条和滚动显示。后面的教程都只是说我写的这些控件的具体实现的了，就不说MiniGUI自定义控件的方法了。</p>
<p>哎，2月3号的起的头，又拖到8号才写完。发现我越来越懒了，杯具 -_-|| 。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="http://download.csdn.net/detail/mingming_killer/4045894" target="_blank" rel="external">下载地址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/20/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B4/</loc>
    <lastmod>2015-01-20T09:35:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程4</title>
        <pubTime>2015-01-20T09:35:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。上次介绍了ButtonEx控件的设计，这次介绍ButtonEx的具体实现。这里我不打算说C语言的语法和简单的MiniGUI API调用，我就只说一些需要注意的问题。因为我认为这些才是大家真正需要了解的。</p>
<h2 id="注册类">注册类</h2>
<p>不管你是自己完全重新开始写控件类，还是继承现有的控件类。自己的控件类被外部程序使用前就必需要注册（通常是应用程序初始化的时候）。我目前还没深入看MiniGUI内部创建控件的过程。但是只有注册了的控件类，才能被CreateWindow()创建（自己外部写的控件只能通过CreateWindow来创建，能使用对话框模板的控件数据来创建）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterButtonExControl (<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    WNDCLASS BEXClass;</div><div class="line">        </div><div class="line">    … …</div><div class="line">        </div><div class="line">    <span class="comment">// 填写控件类信息</span></div><div class="line">    BEXClass.spClassName    = CTRL_BUTTONEX;</div><div class="line">    BEXClass.dwStyle        = WS_NONE;</div><div class="line">    BEXClass.dwExStyle      = WS_EX_NONE;</div><div class="line">    BEXClass.iBkColor       = PIXEL_lightwhite;</div><div class="line">    BEXClass.hCursor        = GetSystemCursor (IDC_HAND_POINT);</div><div class="line">    BEXClass.WinProc        = ButtonExProc;</div><div class="line">    BEXClass.dwAddData      = (DWORD)pCData;</div><div class="line">        </div><div class="line">    … …</div><div class="line">        </div><div class="line">    <span class="comment">// 注册ButtonEx 类</span></div><div class="line">    <span class="keyword">return</span> RegisterWindowClass (&BEXClass);</div><div class="line">        </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得在教程2里提到的获取控件类信息的函数GetWindowClassInfo()吗。那里获取的信息正是你这里注册的信息。注意这里要把WNDCLASS的所有变量都填满，不然当应用程序程序使用你的控件时程序会出错的。填满好信息后，调用RegisterWindowClass()注册控件类。在控件使用前要进行注册，当控件使用完后（通常是应用程序退出前），就要注销之前注册的控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BOOL UnregisterButtonExControl (<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    … …</div><div class="line">        </div><div class="line">    <span class="comment">// 卸载ButtonEx 类</span></div><div class="line">    <span class="keyword">return</span> UnregisterWindowClass (CTRL_BUTTONEX);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>调用UnregisterWindowClass()来注销控件类，传入的参数是之类注册的控件类名字（字符串）。</p>
<h2 id="类变量">类变量</h2>
<p>在教程2中介绍了实例变量的保存方法（复习下：使用每个窗口的dwAdditionalData2保存控件数据变量指针 ^_^），这里说下类变量如何保存。其实这个MS根本就不用说，因为实例变量是每个控件实例都有一份的，所有要特殊处理下。这个所有的控件都共用一份的，直接弄个全局变量就行了。建议使用static变量，这样能让类变量只具有文件范围，防止外部随便访问（谁让C语言没有类呢）。</p>
<h2 id="继承父类">继承父类</h2>
<p>虽然我把这个叫做完全自己写控件类，但是实际上它还是继承了一个父类的，就是所有的控件的父类（相当于CObject）。这个其实就是一个函数的调用，在之前也说过了的。这个函数就是：</p>
<pre>
DefaultControlProc (HWND, int, WPARAM, LPARAM);
</pre>

<p>在控件的过程处理函数结尾，调用父类的这个处理函数，让其处理一些本控件不处理的系统消息。</p>
<h2 id="功能实现">功能实现</h2>
<p>其实光是完全自己重新写控件需要注意的问题，上面就已经说完了。但是既然我的这个例子是Button功能的控件，就说下和这个控件相关功能实现注意的一些问题吧。先说功能相关的实现，界面图形表现的实现放在下面说。</p>
<h3 id="1：在对话框中正确得到键盘输入">1：在对话框中正确得到键盘输入</h3>
<p>这里涉及到一个关键的消息的返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> MSG_GETDLGCODE:</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> DLGC_PUSHBUTTON;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个消息API手册解释的非常简单，仅仅只是把这个消息的名字复制了一下。但是如果这个消息处理不正确，你的控件就无法在对话框（Dialog）中正确的得到键盘输入。不过这里的ButtonEx控件和这个没多大的关系，但是还是说明一下吧。这个消息的含义是获取对话框码。因为你如果创建的窗口是对话框的话，它会比一般的窗口多处理一些消息，这些消息包括某些按键的响应。因为对话框有些功能：tab、left、right、up、down遍历WS_TAPSTOP风格控件；esc发送IDCANCEL；BS_DEFPUSHBUTTON响应enter按键。就是说如果你不不响应这个消息（默认返回值为0），你的控件在对话框下就无法得到收到tab、left、right、up、down、enter、esc这些按键的消息。但是某些控件是需要这些值的，例如listview、listbox、eidt等。这时就要给予MSG_GETDLGCODE消息正确的返回值，告诉对话框你的控件要处理这些按键消息。这样对话框处理函数才会“放过”这些按键的消息，发送到你的控件处理。这些值包括如下（可以用或来同时获得）：</p>
<pre>
DLGC_WANTARROWS     要处理上下左右按键
DLGC_WANTTAB        要处理tab键
DLGC_WANTALLKEYS    要处理所有的按键
DLGC_WANTENTER      要处理enter键
</pre>

<h3 id="2：使用控件风格">2：使用控件风格</h3>
<p>你可以给你的控件设计多种风格，然后通过创建控件时，指定不同的风格获得不同的功能。我不太清楚从MiniGUI多少版本起，开始有2个变量来保存风格了：一个普通的风格，一个扩展风格。控件风格用的是普通的风格变量，这是一个32bit DWORD类型，每一位代表一个风格，然后通过位运算得到当前风格的设置情况。高16bit被MiniGUI用来保存通用窗口的风格了（WS_TABSTOP、WS_VISABLE等），留给控件用的是低16bit，这点要清楚，不然如果你自己控件的风格定义成高16bit的话，就会出现逻辑错误了。然后通过GetWindowStyle()来获取当前普通风格。ButtonEx的风格定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_TYPEMASK   0x0000FFFFL</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_IMAGE      0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_BKIMAGE    0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXS_DRAW       0x00000004L</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="3：发送通知码">3：发送通知码</h3>
<p>给父窗口发送通知码的API是这个：</p>
<p>NotifyParent (HWND parent, int id, int code);</p>
<p>第一个、和最后一个参数没什么好说的，第二个参数是当前控件的ID号，这个通过GetDlgCtrlID ()函数获取。这里是虽然是简单的API调用，可以编程指南里没写，网上又搜不到，我是看源代码才知道，要这么用的 -_-|| 。</p>
<h3 id="4：判断鼠标点击">4：判断鼠标点击</h3>
<p>MiniGUI原来的Button是只要在控件客户区弹起鼠标左键才会发送点击通知码的。不仅仅MiniGUI的Button这样，MFC、.net、java等GUI的Button都是这样（不知道谁先这么规定的）。要实现这个功能，要在鼠标左键按下时捕获鼠标，然后弹起鼠标后再释放，这样才能判断弹起的鼠标左键的坐标。这里提示下，本来MSG_LBUTTONUP得到的鼠标坐标是client坐标的，但是一捕获鼠标后就变成srceen坐标了，注意坐标转换。</p>
<h2 id="界面表现实现">界面表现实现</h2>
<p>这里主要说的MiniGUI中一些图像API的使用，以及需要注意的一些问题。这里先说下颜色的一些基本知识吧（知道了的可以忽略）。图片由像素组成，例如一张90x40的bmp（位图），就由90x40个像素组成。每个像素又由如干位（bit）组成，例如8bit、16bit、24bit，这个就是我们说的色深。计算机里的颜色一般用用得最普遍的RGB（红、绿、蓝）三色组成。现在用一个数值分别表示这三种颜色的亮度，例如范围为255，值越小就越黑，值越大就越亮，这样由3个0~255的数值混合可以组合成很多种颜色（这个叫做像素值，pixel）。这里就可以看到刚刚说范围是0~255，这样一种颜色就需要8bit（2^8），3种颜色就是24bit（3x8），这就是我们平常说的24色深。这样的颜色组合能够达到2^24=16777216种，已经达到人眼的分辨率极限。但是一般在嵌入式中，一般显示屏幕达不到这么高的颜色显示，现在一般带GUI的嵌入式产品的主流色深是16bit，就说分给RGB每个分量的位数不足8bit，这样有些颜色就会显示不出来。所以这里要特别注意，在ButtonEx控件中使用的图片，如果是24bit的话是会有可能失真的。不过不用太担心，因为16bit的能够显示大多数常用的颜色的，所以只要使用的图片颜色渐变效果不是特别夸张都不会有太大的失真（一般界面那些花哨的效果都是由颜色渐变弄出来的）。</p>
<p>不过大家在用的桌面操作系统的色深是32bit，那除了刚刚说的24bit用于RGB之外，还有8bit是用来干什么了咧？32bit的色深还有8bit用来表示alpha通道，这个通道用来表示颜色的透明度（我至今不明白为什么叫alpha -_-||）。在8bit的情况下，数值越小透明度越高，0表示完全透明，255表示完全不透明。大家在网上看到的png格式的图片就是带alpha通道的。</p>
<p>这里再说说图片格式。bmp最高是24bit色深，bmp不带alpha通道信息，因此bmp本身不带透明信息。并且bmp是没有压缩过的图片格式，所以一般bmp格式的图片都比较大（这个很好理解：例如一张1024x768x24bit的bmp大小就是：1024x768x24/8x2^20=2.25MB）。MiniGUI无需外部库就支持bmp格式图片（因为直接读取它的数据就是图片信息，要不然怎么叫位图咧）。jpg最高也是24bit的，同样也不带alpha通道信息，但是这种图片格式是经过压缩算法的，所以同样大小的图片，jpg格式的能比bmp格式的小得多。MiniGUI需要外部jpeg库才能支持这样格式的图片。png图片，最高色深32bit，这个是带alpha通道信息的，而且也是经过压缩算法的，体检很小，所以网上那些透明的很好看的图片一般都是png的（又可以透明，体积又小）。MiniGUI同样需要外部png库才能支持这种格式。gif么，我不太清楚，它一般是用于动画的，不过也可以用来表示静态图片（一帧动画不就是静态的么-_-||）。gif也可以带alpha通道，MiniGUI无需外部库就可以支持这种格式。我这里只是说说一般嵌入式产品用到的图片格式，还有其它的一些专业的格式，我就不说了，而且我本人也不是太了解。</p>
<p>上面罗嗦这么多，其实主要是ButtonEx要使用到以上说到的那些格式的图片，如果你连图片的特性都不清楚的话，是不可能很好的应用它们的。好，现在就说说如何应用这些图片来使我们的ButtonEx变得好看起来。</p>
<h3 id="1：背景图片">1：背景图片</h3>
<p>这里说的背景图片不光光单指BEXS_BKIMAGE的背景，也包括BEXS_IMAGE，BEXS_IMAGE其实所有的都通过图片来表现了（这里没BEXS_DRAW什么事了）。背景推荐用bmp。因为一般按钮不会太大，所以图片不会太大，jpg也省不了多少空间。但是jpg的压缩是失真的，能不用就尽量不用啦。bmp虽然不带alpha通道信息，但是一般作为button的背景不太需要这个，而且就算需要，也有办法代替。如果用png的话，就我的测试发现，稍微大点的32bit的png用在16bit上就能看出失真了（这个不能算明显，但肉眼也能看得出，大家看我教程3中有一张中的第1个按钮和第3个按钮就知道了），所以还是用bmp的效果好。这里如果要做到一些类似圆角的按钮效果的话，其实用不带alpha通道的bmp也能做到，而且在16bit色深下bmp效果还好些。</p>
<p>如果窗口没有背景图片。这种情况最好办，窗口如果不带背景图片，那它就是单一的一种RGB颜色。可以通过种种方法得到窗口的背景颜色。然后把图片的背景弄成这种颜色，哈哈，这样用户一看就感觉按钮时圆角的啦。但是建议这样不规则形状的图片，不要弄得太夸张，因为就2.0.4版本的MiniGUI还是不支持不规则窗口的，所以响应鼠标还是以矩形来算的，弄得太夸张的话，很容易就露馅了。经我测试这种方法既不需要开启透明颜色，效果也是最好的。如果窗口窗口有背景图片，就稍微麻烦一点了。因为如果有背景图片的话，用上面那种方法就不行了，因为背景图片可不是单一的一种颜色了。这个时候如果用bmp的话，就需要开启透明颜色。这里就说之前设计说那个开启背景透明颜色的功能了。这里主要用到MiniGUI BITMAP结构里的bmType、bmColorkey这2个变量。这个看API手册和飞漫的mde里那个高级的绘图例子就清楚了，你看我的源代码也可以清楚 ^_^ 。不过这里提醒一下，用这个方法，MiniGUI在用图片绘图图像的时候是只能透明掉你指定的那一种颜色的；但是目前一些的图像处理软件，如PS，是会很“好心”的帮你的图片的图层和背景过渡的部分加上适当的过渡颜色的。所以出来的效果就是有锯齿，因为那些过渡的颜色没有被透明掉。目前的处理办法是：1：采用“抗锯齿”的算法。其实只要把那些过渡的颜色在内存中换成透明的颜色就行了，它们之间的RGB值差别不是很大的。不过我现在还没怎么研究MiniGUI中RGB值到pixel值之间的转化，所以这个函数也是没弄。2：处理图片。就是手动把那些过渡值换成背景颜色（这个把图片放大就看出来了）。</p>
<h3 id="2：图标图片">2：图标图片</h3>
<p>主要是BEXS_BKIMAGE和BEXS_DRAW风格用到这个了。这个推荐用png图片。原因其实上面已经说了，因为按钮的背景是图片（BEXS_DRAW的虽然不是图片，但是也不是单一的颜色），不是单一的颜色，用bmp透明效果不怎么好。一般图标比较小（一般是16x16、32x32），所以即使是32bit的png用到16bit上也不怎么失真。带alpha透明通道后效果很好。这里说一下，MiniGUI载入图片，不管原来图片存储的是什么格式的，载入后在内存中都是BITMAP变量（MiniGUI通过图片的后缀自行判断）。正常状态的图标没什么好说的，直接载入，然后用绘图函数画就是了。</p>
<p>现在说说 <code>BEXUI_DISABLE</code> 状态的特效。这个特效是使图标呈现一定的透明效果。注意这里说的透明不是说png图片自己带alpha信息。这里再说说，png原来带的alpha通道叫做逐点alpha信息。是每个像素都有的（32bit中的8bit），能够精确到每个像素点。我这里说的是不管它原来逐点的alpha信息是什么，整个图片以一个统一的alpha值进行透明（这个又叫做alpha混合）。不过这里提醒下，BITMAP结构里有一个bmAlphaPixelFormat的变量，叫做私有像素格式。所谓的私有像素格式就是和MiniGUI使用的图像格式不一样的格式。例如我使用的miniugi是1280x1024-16bpp，就是16bit的色深，但是我载入的png是32bit的，它们的颜色格式肯定不一样。所以这个私有像素格式就保存了图片自己的图像格式。经过我实验，凡是有私有像素格式的BITMAP变量，均无法使用bmAlpha、bmColorKey变量。就是说如果我们载入的是32bit带alpha的png就无法使用BITMAP的alpha变量来实现alpha混合效果。但是咋有“曲线救国”办法：MiniGUI的内存DC结构也有alpha变量可以设置。我们可以把png先绘制到一个内存DC里，然后设置内存DC的alpha变量，就可以显示BEXUI_DISALBE状态的alpha混合效果了。这里的内存DC可以看成是一张画布，我们把png图片完整的信息绘制到画布上，然后把这个画布弄成“半透明”，最后再把这张画布贴到控件的客户区上。效果见教程3中的Disable图片，很cool吧。这也就是之前设计图标变量时，为什么还会有一个HDC变量。不过开启这个效果是要额外占用资源的，因为每个控件都额外需要创建一个HDC，所以资源比较紧张的情况下还是关掉吧（关掉的话ButtonEx不会创建这个alpha混合用的HDC的）。</p>
<p>至于 BEXS_DRAW 风格的那个颜色渐变算法是照搬飞漫2.0.4中fashion风格下Button的绘制算法的。我只是稍微改了一点点而已，我自己也没啥好说的，因为基本算是照抄。不过用这个风格可以省去自己P图了，直接去网上找一些png图标就可以了。</p>
<p>上面说了这么多，感觉好像也挺混乱的。哎~~因为本来我对这些东西就接触不多，都是临时自己琢磨的。说得不对的请大家指正。可能光看我写的文字还是没啥子感觉，不过这个算是个思路吧。具体还是看代码吧，我的代码里为什么用这个API，为什么这样做，都有详细注释的，相信大家都能看的懂。</p>
<p>这里顺带介绍下附带的代码。这个是用source insight建立的工程，共有4个自定义控件：ButtonEx、SLEditEx、RollShow、ProgressbarEx。分别是按钮自定义控件（这次介绍的就是它了），单行编辑框自定义控件，滚动显示控件，进度条控件。这是我到目前为止用MiniGUI写的自定义控件，里面都有详细的功能、说明、注释，大家可以参考、参考。后面几次的教程也是以这个工程为例子的。</p>
<p>这次介绍了如何自己完全从头开始写MiniGUI的控件，并且也“趁机”介绍了下MiniGUI中一些图片，绘图处理的方法。下次我将介绍如果通过继承MiniGUI原有的控件，来扩展原有控件的功能。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="http://download.csdn.net/detail/mingming_killer/4045894" target="_blank" rel="external">下载地址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B3/</loc>
    <lastmod>2015-01-19T12:52:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程3</title>
        <pubTime>2015-01-19T12:52:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<p>接着上次的教程继续。之前介绍了子类化已有的控件实例的方法，现在介绍子类化类和完全自己重新开始写控件类的方法。这个2种区别就是：子类化类，其实就是OOP里的继承，继承一个已有的控件类，在其基础上作扩展。完全自己重新开始写控件类是我自己的叫法，可以理解为MFC（我个人对MFC相对来说熟悉些，就拿这个做类比了）里的继承自CObject。 这次先介绍完全自己重新开始写控件类的方法。这里我以我自己写的一个MiniGUI的扩展控件类为例子来介绍。MiniGUI里原来的有CTRL_BUTTON这个控件类。刚开始2.0.4 classic风格我觉得不怎么好看（其实是我头头觉得不怎么好看），后来折腾了下弄成fashion风格了的，BS_AUTOCHECKBOX和 BS_RADIOBUTTON已经感觉不错了，不输给台式机的那些控件库了，不过基本的Button功能和那些.net，java的Button比起来还是有一定差距。其实最主要的是我接手的一个项目里，之前负责人，弄了一个类似.net，java，winXP那样的Button，就是鼠标放上去会有外观变化的，然后全部用图片来表现Button。刚开始感觉不错，后来拿到代码一看。额的个神啊，他竟然每个窗口里使用一些CTRL_STATIC来充当Button，然后窗口相应鼠标事件，检测当鼠标移动到某个STATIC上的时候就加载不同的图片。额的个神、额的个神，光光是这些判断代码都快烦死了，而已都是一大堆、一大堆的坐标计算；最要命的是每个窗口都有。一个项目那么多个界面（窗口），要我维护这个，想整死我啊。以前用MFC起手的我，立刻想到了把这玩意封装成控件。他原意其实就是要Button好看点，好我就以这个扩展的Button为例子来说明。</p>
<h2 id="一、功能确定">一、功能确定</h2>
<p>首先我把这个扩展控件取名为CTRL_BUTTONEX（”button_ex”）。ButtonEx首先就要尽量具备MiniGUI CTRL_BUTTON BS_PUSHBUTTON的基本功能，这样才能在功能上不影响使用者的使用。其次，就是美观，这也是扩展这个控件的原始目的。看看.net，java的Button，他们首先Button的背景都比较好看；其实他们支持在Button上放图标（icon），并且放了图标后还能写文本上去；最后他们Disable的状态也比较好看。所以我们基本就可以确定ButtonEx的功能了。（其实以下这些功能是经过我好几个版本的更新才得到的，其中参考了MiniGUI原来Button的实现和网上不少其他扩展控件的实现）：</p>
<ol>
<li>Button的基本功能。能发送按钮按下通知码；在WS_TABSTOP风格下能在Dialog中使用TAB键遍历焦点；在焦点状态能使用Space和Enter键执行按下操作。这些都是MiniGUI PushButton? 的基本功能。</li>
<li>Button原有的界面表现。正常状态，按下状态，焦点状态和无效状态。新增鼠标移动到控件客户区时自动进入焦点状态。</li>
<li>支持图标文本混合显示方式。</li>
</ol>
<h2 id="二、概要设计">二、概要设计</h2>
<p>好，功能确定了，下面进行设计。首先我把这个控件取名为CTRL_BUTTONEX（”button_ex”）。然后先设计ButtonEx的最基本功能Button它有4种状态：正常（Normal），控件在没有焦点，使能情况下的状态；焦点（Focus），控件出处输入焦点的状态；点击、按下（Click），控件在焦点状态下被按下或者鼠标点击的状态；无效（Disable），控件被EnableWindow设置成无效时的状态。这4种状态的转化我在MiniGUI原来基础上新增鼠标移入客户区进入Focus状态。其他就是MiniGUI原来Button的状态转化了：Noraml就多说了。控件在tab（left、up、right、down）便利到的情况下下进入Focus状态；在Focus下，按下鼠标左键、space、enter键进入到Click状态；在Click下，鼠标左键在客户区弹起、space、enter键弹起，进入到Focus状态（并判定发送Click事件，向父窗口发送Click通知码）；如果鼠标左键在客户区之外弹起则进入Normal状态（并判定无Click事件发生，不向父窗口发送通知码）；Disable windows事件发生进入到Disable状态；Enable window事件发送进入到Normal状态。状态图转化详见下图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/1.jpeg" alt="&quot;图 1 状态转化图&quot;"></p>
<p>然后控件能在WS_TABSTOP风格下在Dialog中能被tab、left、up、right、down便利焦点。在焦点状态下按下space、enter键发送按下事件。这些靠处理MSG_KEYDOWN来实现。<br>最后我们来设计ButtonEx的外观表现形式。这里我经过了几个版本的升级，参考了MiniGUI原来Button的表现手法和网上一些扩展控件的表现方法，决定设计出几种不同的风格来供使用者选择。</p>
<h3 id="1：BEXS_IMAGE">1：BEXS_IMAGE</h3>
<p>我把这个叫做图片风格。分别用4张不同的图片来表现4种状态。图片支持bmp（支持透明色）、png（支持alpha通道）、gif、jpeg（支持透明色）。外观全部交由图片负责，因此这个风格不支持显示文本。好不好看全靠外部图片PS处理。这里说明下，现在一般使用MiniGUI的色深是16bit，但是载入24bit的bmp只要PS里颜色渐变不是特别BT，不会有太大的失真。32bit带alpha通道的png在2.0.4的API下也能保留alpha通道信息。因此这种可以做出外观上不规则的Button（它响应鼠标还是以矩形来算的）。bmp、jpg在设置了透明色后也能有这种效果，不过图层边缘的渐变造成透明时的锯齿问题（这里的透明平滑算法我至今还没弄出来，现在只能在图像处理软件里弄）。最终效果如下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/2.jpeg" alt="&quot;图 2 BEXS_IMAGE效果&quot;"></p>
<h3 id="2：BEXS_BKIMAGE">2：BEXS_BKIMAGE</h3>
<p>我把这个风格叫做背景图片风格。它用4张不同的图片来变现4种状态的背景。然后能在其基础上放置图标（icon），写文本，图标和文本能在Click中显示动态效果，图标能在Disable状态下表现alpha混合特效。它的背景图片模式与BEXS_IMAGE一致，支持bmp、png、gif、jpeg，也能透过alpha通道或是透明色变现出不规则形状。Icon支持的图片格式和背景图片一样。可以显示文本，在有icon的情况下显示文本。Icon和文本的动态点击效果其实只要在Focus和Click下稍微改动下Icon和文本位置形成一定的位置偏差就即可看到动态效果。至于Disable下Icon的alpha混合特效，是应用了2.0.4的newgal接口提供的高级图像处理API来完成的。方法是在Disable下把Icon以一定的alpha值，半透明的绘制在背景上，这样看上去就像背景透过了一部分Icon一样，从而达到表现Dsiable状态的效果。文本让用户设置2种不同的颜色，分别在Disable和非Disable下显示。这些其实就是.net，java里Button控件的功能。不过这个风格用好了，效果不低于.net，java的Button控件哦。不过折腾这些东西实现费了我不少时间。最终效果如下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/3.jpeg" alt="&quot;图 3 BEXS_BKIMAGE效果&quot;"></p>
<h3 id="3：BEXS_DRAW">3：BEXS_DRAW</h3>
<p>我把这个风格叫做编程绘制风格。顾名思意，4种状态的背景表现方式全部通过代码编程的方式绘制。其实这个风格是我学习之用的，基本上没什么实用价值，因为它的特效BEXS_BKIMAGE中都有，但是又没BEXS_BKIMAGE花哨。而且这个风格的核心颜色渐变算法我是照抄MiniGUI 2.0.4 fashion里Button的。但是在表现形式上有些不同。Normal状态基本一样，都是用2种颜色来混合渐变效果，由中间的基色调向上、下渐变至第2种颜色；不过ButtonEx里可以设置这2种颜色。Focus状态也基本一样，在外围画一圈虚线，ButtonEx也可是设置虚线的颜色。Click状态有所不同，ButtonEx里我强制用Click动态效果来表现这个状态，因为MiniGUI里用了另外2种颜色来渐变，我试了下在加Icon的情况下效果不怎么好，于是就采用动态效果来表现了。Disable状态我另外用一种颜色来进行单一填充，然后Icon alpha混合上这种颜色，类似于winXP上按钮Disable的效果。控件边框用实线画成一个带圆角的矩形，在Disable和非Disable下有2种不同颜色选择。文本和Icon同BEXS_BKIMAGE。不过这个风格还是有点好处的，就是使用者不用PS背景图片了，对于不会PS的人来说比较方便，之用去网上下一些Icon就可以了（一般网上下的Icon可以直接使用了，但是网上一般下不到Button背景图片）。其实这个风格最终效果也还是可以的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control3/4.jpeg" alt="&quot;图 4 BEXS_DRAW效果&quot;"></p>
<h2 id="三、详细设计">三、详细设计</h2>
<h3 id="1：数据结构">1：数据结构</h3>
<p>控件有3个风格，有些成员变量能够几个风格公用，有些是类变量（C++ Class中的static变量），有些则是实例变量（C++ Class中的普通变量）。我将BEXS_DRAW风格的一些变量设计成类变量，因为我觉得这种风格的背景基本上应该都是一样的，其它2个风格的设计成实例变量。实例变量数据结构我将其命名为BEXDATA：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _bexdata_st</div><div class="line">{</div><div class="line">    … …</div><div class="line">} BEXDATA;</div><div class="line"><span class="keyword">typedef</span> BEXDATA* PBEXDATA;</div><div class="line"></div></pre></td></tr></table></figure>

<p>类变量数据结构我将其命名为BEXCDATA：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typdef <span class="keyword">struct</span> _bexcdata_st</div><div class="line">{</div><div class="line">    … …</div><div class="line">} BEXCDATA;</div><div class="line">typdef BEXCDATA* PBEXCDATA;</div><div class="line"></div></pre></td></tr></table></figure>

<p>根据上面的说明，控件一共有4中状态，因为我们需要一个变量在保存当前控件的状态，设计一个枚举类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _bexuistate_en</div><div class="line">{</div><div class="line">    BEXUI_NORMAL = <span class="number">0</span>,   <span class="comment">// 正常状态</span></div><div class="line">    BEXUI_FOCUS,        <span class="comment">// 焦点状态</span></div><div class="line">    BEXUI_CLICK,        <span class="comment">// 按下状态</span></div><div class="line">    BEXUI_DISABLE       <span class="comment">// 禁用状态</span></div><div class="line">        </div><div class="line">} BEXUISTATE;</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>成员数据结构：</li>
</ul>
<p>BEXS_IMAGE 和 BEXS_BKIMAGE 都需要4张图片，并且都支持图片透明色。所以设计如下变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PBITMAP pbmpButton[<span class="number">4</span>];  <span class="comment">// 图片指针数组</span></div><div class="line">BOOL bTrans;            <span class="comment">// 是否使用图片透明颜色</span></div><div class="line">POINT pointTrans;       <span class="comment">// 透明像素点位置</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>这里图片控件内部只引用外部应用程序的图片，图片的加载和卸载都交由外部应用程序负责（我认为这样比较好，因为外部程序的初始化和销毁正好可以做这些事情）。bTrans表示当前控件是否要使用透明颜色，pointTrans是一个点（x，y）的变量，保存当前透明颜色在控件使用的图片中的坐标。BEXS_BKIMAGE和BEXS_DRAW能够在控件中显示文本，因为MiniGUI的基本窗口结构中就保存了窗口的标题文本，所以这里只要设计保存文本颜色的变量就够了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gal_pixel pixelTextNormal;      <span class="comment">// 正常文本颜色</span></div><div class="line">gal_pixel pixelTextDisable;     <span class="comment">// 控件无效文本颜色</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>所有的风格都支持点击（BEXUI_CLICK）动态效果，设计如下2个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL bClickEffect;  <span class="comment">// 是否使用Click 状态特效</span></div><div class="line"><span class="keyword">int</span>  nClickEffect;  <span class="comment">// Click 状态特效幅度</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>BEXS_BKIMAGE和BEXS_DRAW能够放置图标在控件上；图标支持透明色；设置摆放位置；无效状态特效；设计如下变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PBITMAP pbmpIcon;       <span class="comment">// 图标图片指针</span></div><div class="line">BOOL bIconTrans;        <span class="comment">// 是否使用图标图片透明颜色</span></div><div class="line">POINT pointIconTrans;   <span class="comment">// 透明像素点位置</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> nIconLeft;          <span class="comment">// 图标距控件客户区左端距离</span></div><div class="line"><span class="keyword">int</span> nIconDx;            <span class="comment">// 图标距文本距离</span></div><div class="line"></div><div class="line">BOOL bIconDisableEffect;            <span class="comment">// 是否使用disable 状态特效</span></div><div class="line">HDC hIconDC;                        <span class="comment">// ICON Alpha 混合DC</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> nIconDisableAlpha;    <span class="comment">// ICON Alpha 混合值</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>类数据结构：</li>
</ul>
<p>只有BEXS_DRAW风格需要用到类成员。BEXS_DRAW风格正常状态的背景由2种颜色渐变形成，从中间由一种颜色（我称为基色）纵向向顶部和底部渐变到另外一种（我称为渐变色），呈对称形状。设计2个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RGB rgbRenderNormalBase;    <span class="comment">// 基色颜色</span></div><div class="line">RGB rgbRenderNormalShade;   <span class="comment">// 渐变颜色</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>这里用RGB变量保存，因为这里需要进行颜色渐变运算，直接用像素值保存容易产生颜色与设置有误差的情况。BEXS_DRAW风格的BEXUI_FOCUS状态在控件上加上一圈虚线表示；BEXUI_DISABLE状态背景换成另外一种颜色表示；控件具有边框。设计如下变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gal_pixel pixelFocus;       <span class="comment">// BEXS_FOCUS状态虚线颜色</span></div><div class="line">gal_pixel pixelDisableBk;   <span class="comment">// BEXUI_DISABLE状态背景颜色</span></div><div class="line">gal_pixel pixelBorder;      <span class="comment">// 边框颜色</span></div><div class="line"></div></pre></td></tr></table></figure>

<h3 id="2：接口">2：接口</h3>
<p>首先就是控件注册和卸载的接口，这个在之前的教程里已经详细说过了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL RegisterButtonExControl (<span class="keyword">void</span>);</div><div class="line">BOOL UnregisterButtonExControl (<span class="keyword">void</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<h4 id="实例接口：">实例接口：</h4>
<p>实例接口就是消息，这个也在前面的教程说过了的。首先先确定本控件自定义消息的范围。因为MiniGUI留给用户的自定义消息范围是：0x0800 ~ 0xEFFF。一般的应用程序都会有自己的消息，所以作为提供给外部程序使用的控件应尽量避免自定义消息定义冲突，所以这里我设计从自定消息的最大范围从后向前定义（应用程序一般都是从前向后定义的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_BEXMBASE    0xEFFF</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_BEXMXX      MSG_BEXMBASE – 1</span></div><div class="line">… …</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>1: 设置控件通用数据。<br>我把状态图片（pbmpButton[4]、bTrans、pointTrans）、文本颜色（pixelTextNormal、pixelTextDisable）、点击特效（bClickEffect、nClickEffect）这些变量归结到一个接口来设置，叫通用数据设置。wParam传入设置PBEXDATA，lParam传入需要设置的变量（这个32bit的变量每一个位可以代表一个设置变量的开关）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_IMAGE           0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_TEXTCOLOR       0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_CLICKEFFECT     0x00000004L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_COM_ALL             ((BEX_COM_IMAGE)| (BEX_COM_TEXTCOLOR) | (BEX_COM_CLICKEFFECT))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_SETCOMDATA         MSG_BEXMBASE – 1</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>2: 获取控件通用数据。<br>和设置相对应：wParam传入获取PBEXDATA，lParam传入需要获取的变量：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_GETCOMDATA     MSG_BEXMBASE - 2</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>3: 设置控件图标数据。<br>我把图标图片（pbmpIcon），图标位置，图标无效状态特效这些变量归结到一个接口来设置，叫做图标数据设置。wParam和lParam与通用数据的相似：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_IMAGE          0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_POSTION        0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_DISABLEEFFECT  0x00000004L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_ICON_ALL            ((BEX_ICON_IMAGE) | (BEX_ICON_POSTION) | (BEX_ICON_DISABLEEFFECT))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_SETICON            MSG_BEXMBASE – 3</span></div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>4: 获取控件图标数据。<br>和设置对应：wParam传入获取PBEXDATA，lParam传入需要获取的数据：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXM_GETICON  MSG_BEXMBASE – 4</span></div><div class="line"></div></pre></td></tr></table></figure>

<h4 id="类接口：">类接口：</h4>
<p>类接口就是函数了。我这里设计的和上面实例的相似。 </p>
<ul>
<li>1: 设置类数据。<br>PBEXCDATA传入的是设置的变量指针，DWORD传入32bit的设置变量类型：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_CDATA_RENDER    0x00000001L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_CDATA_DEFAULT   0x00000002L</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEX_CDATA_ALL       ((BEX_CDATA_RENDER))</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> BexSetCData (<span class="keyword">const</span> PBEXCDATA pSetCData, DWORD dwMask);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里我把目前所有的类变量都统一到一个开关里设置了（测我的测试使用来看，这是比较方便的）；BEX_CDATA_DEFAULT是把所有的类变量设置成默认值。</p>
<ul>
<li>2: 获取类数据。<br>这个和设置对应，PBEXCDATA传入获取的变量指针，DWORD传入32bit的获取变量类型：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> BexGetCData (<span class="keyword">const</span> PBEXCDATA pSetCData, DWORD dwMask);</div><div class="line"></div></pre></td></tr></table></figure>

<h4 id="通知码：">通知码：</h4>
<p>据我的理解，一般的消息是针对控件自己的，通知码是针对别的控件的（一般是父控件）。</p>
<ul>
<li>1: 点击通知码。<br>在控件处于BEXUI_CLICK状态下在客户区弹起鼠标左键或是在控件BEXUI_CLICK状态弹起enter、space按键发送，表示控件被按下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BEXN_CLICKED    0</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>目前就暂时设置这一个通知码，感觉作为Button来说就这个通知码用得最多，就先设计这一个了。</p>
<p>这里以一个Button功能的扩展控件说明如何完全自己写MiniGUI的控件。本次教程先介绍ButtonEx的设计，下次将介绍ButtonEx的具体实现。从1月14号起的头，拖到30号才写完，怎能用茶几、杯具来形容 -_-|| 。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="http://download.csdn.net/detail/mingming_killer/4045894" target="_blank" rel="external">下载地址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B2/</loc>
    <lastmod>2015-01-19T12:34:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程2</title>
        <pubTime>2015-01-19T12:34:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<h2 id="控件功能确认">控件功能确认</h2>
<p>咋接着上次的教程继续。这次我们依托一个例子来说明如何使用MiniGUI中的第一种方法（也就是子类化已经创建的控件实例）。假设我们的例子是：某个学校的某个年级的某些班在某个时间搞了某次考试。考试过后经老师研究决定把考试成绩按班为单位分成3个分数段：差、中等、好。现在咱们就要用MiniGUI来整一个统计图来直观的显示这个3个分数段的学生比例。但是有几个班就有几个统计图啊。你可能说，我可以只画一个图然后切换数据显示不就行啦。哎呀，那么大的窗口你就忍心只放一个图么，再说了你偏要这么弄，那咋的教程也进没办法进行下去了。所以我决定在界面上放上2个统计图（其实放多少个都可以，反正代码只有写一次 ^_^）。然后再弄1个按钮在切换不同的班级数据显示。最终的效果如下图：</p>
<p> <img src="http://7u2hy4.com1.z0.glb.clouddn.com/minigui/custom-control2/1.jpeg" alt=""></p>
<h2 id="控件设计">控件设计</h2>
<p>OK，首先让我们确定下要“继承”哪一个MiniGUI的控件。哎，其实这问题太明显了。我们要的是一个统计直方图，基本上控件都是自己画出来的了，MiniGUI原来控件的一些特性基本上用不到，那当然是选择继承CTRL_STATIC啦，这个控件本身没多少自己数据（占用资源少），而且如果你不设置任何信息在上面的话，就是白花花的一块画布啊，赶紧画吧。</p>
<p>第二次OK，让我们设计下我们这个控件的数据结构：我们需要保存3个分数段的学生人数（弄个int的3元素的数组啦）；班级的名字（弄个32个字符的char数组啦）；控件附加数据（DWORD类型，这个为什么要要，在后面的注意事项里再说）。所以我们的控件的数据结构就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _statgdata_st</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> nData[<span class="number">3</span>];</div><div class="line">    <span class="keyword">char</span> strName[<span class="number">32</span>];</div><div class="line">        </div><div class="line">    DWORD dwUserAddData;</div><div class="line">} STATGDATA;</div><div class="line"><span class="keyword">typedef</span> STATGDATA* PSTATGDATA;</div><div class="line"></div></pre></td></tr></table></figure>

<p>第三次OK，然后我们再来设计下我控件对外的接口。MiniGUI 采用消息机制，那和外部打交道的当然就是消息啦。注意我这里说设计的消息是指控件自定义的消息，不是MiniGUI 原有的消息。</p>
<ol>
<li>初始化。观众又要说了不是有MSG_CREATE消息么，为什么还要自己再弄一个。嘿嘿，这个在同样在后面的注意事项再说。我把它整成STATGM_INIT；不要任何参数；主要负责初始化控件数据变量。</li>
<li>设置控件数据。这个就不多什么了，没这个你还怎么操作控件？我把它整成STATGM_SETDATA；WPARAM 传入字符串指针来设置strName；LPARAM传入int数组首地址来设置nData。</li>
<li>设置控件附加数据。这个说了后面再说的。我把它整成STATGM_SETADDDATA；WPARAM传入DWORD的附加数据。</li>
<li>获取控件附加数据。有了前面的设置附加数据能没这个么。我把它整成STATGM_GETADDDATA；WPARAM传入获取的DWORD指针。为啥不用SendMessage的返回值，那个是int的，DWORD在MiniGUI的定义为unsigned long 其实还是和int的有区别的。</li>
</ol>
<p>对了，应该还有一个STATGM_GETDATA的来获取当前控件的数据值的，但是我一想反正是弄了小例子而已，大家有兴趣的自己去改我的源代码啦。所以我们的消息就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_BASE         MSG_USER + 3000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_INIT         STATGM_BASE + 1</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_SETDATA      STATGM_BASE + 2</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_SETADDDATA   STATGM_BASE + 3</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> STATGM_GETADDDATA   STATGM_BASE + 4</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>第四次OK，控件数据结构和消息都设计好了，可以开工写了。其实C语言，MiniGUI的API的调用大家都会，我这里就是主要说一下使用这样方式自定义控件的注意事项，也算为把之前挖的坑给填了 ^_^ 。</p>
<h2 id="需要注意的问题">需要注意的问题</h2>
<h3 id="1：如何继承父类（我们这里是CTRL_STATIC）">1：如何继承父类（我们这里是CTRL_STATIC）</h3>
<p>飞漫的编程指南里，写的是用一个全局的WNDPROC 变量来保存SetWindowCallbackProc() 的返回值来获取原来控件的过程处理函数指针。然后在新的过程处理函数消息处理过后再利用这个全局变量来跳转到父类控件的过程处理函数去执行。我个人不怎么喜欢这样方式。我的方法是用如下这段代码来获得父类控件的过程处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">WNDCLASS wcStatic;</div><div class="line"></div><div class="line">wcStatic.spClassName =  CTRL_STATIC;</div><div class="line">wcStatic.opMask = <span class="number">0x00FF</span>;</div><div class="line"></div><div class="line">GetWindowClassInfo (&wcStatic);</div><div class="line">wpOldStatic = wcStatic.WinProc;</div><div class="line"></div></pre></td></tr></table></figure>

<p>其中wpOldStatic是自定义控件源文件的文件变量。我定义一个接口函数把这段代码封装起来，然后在子类化控件实例前调用。注意这个一定要获取正确不然得不到正确的继承效果的，一般来整个项目的初始化过程里调用。然后我再解释下那个opMask为啥要设置成0x00FF。这个是飞漫的API编程手册里没写清楚的地方之一（至少我看的2.0.4的没写）。这个DWORD的掩码告诉下面的GetWindowClassInfo() 函数你想要获取的控件类的信息。然后这个函数会把控件类的相关信息填入你传入的WNDCLASS指针里。不过要注意你传入的WNDCLASS的spClassName字段你要填好，不然这个函数不知道你要获取的是哪个控件类的信息。opMask掩码含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_STYLE       0x0001  <span class="comment">// 获取风格信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_HCURSOR     0x0002  <span class="comment">// 获取鼠标信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_BKCOLOR     0x0004  <span class="comment">// 获取背景颜色信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_WINPROC     0x0008  <span class="comment">// 获取过程处理函数信息</span></span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> COP_ADDDATA     0x0010  <span class="comment">// 获取附加数据信息</span></span></div><div class="line"></div></pre></td></tr></table></figure>

<p>我们要的就是 COP_WINPROC(0x0008)这个啦，不过为什么设置为0x00FF咧。哎，这个就代表我以后的信息全部获取，当然也就包括控件的过程处理函数啦。</p>
<h3 id="2：如何子类化控件实例">2：如何子类化控件实例</h3>
<p>飞漫的编程手册里介绍的是用 SetWindowCallbackProc? () 来替换掉要子类化的控件实例的过程处理函数。没错就是用这个函数来替换，不过需要注意一个问题。你控件需要初始化吧。大家说：响应MSG_CREATE消息不就得啦。嘿嘿，这就不行了吧。大家仔细想想看，MSG_CREATE消息是什么时候发送的？是在控件创建好之后就发送了。那你是什么时候替换掉它的过程处理函数的？你别告诉我可以再控件实例创建好之前替换。你替换时候的控件句柄哪来的，不创建好后你能GetDlgItem到控件句柄？所以如果这个时候你把初始化控件变量的代码写到了MSG_CREATE里的话，你就着道了。你的控件数据是不会被初始化的，这个对于指针来说，意味着什么会C、C++的人不用我说了吧。所以我才在上面说要自己整一个初始化的消息让外部在替换的时候告诉控件：要初始化啦。 这样我就把实例化封装成一个接口函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InstanceStatGCtrl (HWND hCtrl)</div><div class="line">{</div><div class="line">    SetWindowCallbackProc (hCtrl, StatGraphProc);</div><div class="line">    SendMessage (hCtrl, STATGM_INIT, <span class="number">0L</span>, <span class="number">0L</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>每次子类化控件实例，把该控件实例的句柄传入这个函数就可以啦。</p>
<h3 id="3：控件数据如何实现每个实例保存一份">3：控件数据如何实现每个实例保存一份</h3>
<p>C++里有类和对象的概念，每个类的对象都拥有自己的数据（叫成员变量，或者叫实例变量），也有所有对象公用的数据（叫类数据，在定义类的数据时加上static即可）。可是C语言是没有真正的类的数据的，只有结构体。MiniGUI的每个控件都有2个附件数据，都是DWORD类似的其实就是unsigned long，在一般的linux上是32bit的。用于保存控件的私有数据（其实就是可以理解为每个控件实例自己的数据）。又有人问了，这只是一个32bit的数据，怎么保存各种各样的数据啊？嘿嘿，C语言忘了指针了么。如果你拿这个32bit的空间来保持数值确实不能干什么事，但是如果你是拿来保持地址呢。这个地址指向了你希望保持数据的首地址，那这就把这个问题给解决了。</p>
<p>我把控件的数据类型定义成一个结构体，然后在初始化话的时候给它申请内存空间，然后把地址（也就是这个结构体的变量的指针）保存到附加数据里。然后在后面的消息处理中，通过获取控件的附加数据（获取后强制转化为控件结构体指针），就能够操控每个控件实例的数据了。别了在控件销毁时释放内存哦。</p>
<p>但是这里还要特别强调一点。MiniGUI每个控件有2个附加数据。这不是随便用其中的一个的。其中dwAdditionalData2（附加数据2）是被MiniGUI原有的控件用掉了的，用来保存它们的控件私有数据去啦。所以像这种“继承”至MiniGUI原有控件的绝对不能使用dwAdditionalData2，不然控件就很容易出乱子，甚至程序崩溃，因为MiniGUI原来的控件也是使用指针的方式来保持的，你把它原来的弄掉了，然后它原来的代码又用这个指针干原来的事情，想想看多危险的情况啊。这个在飞漫的编程指南里有提到，但是仅仅是在44页的一个不起眼的地方用了一个小字体一笔带过而已 -_-|| 。</p>
<p>所以，我现在一个例子的这种情况应该使用dwAdditionalData1（附加数据1）来保存我们自定义控件的数据。不过这个附近数据还有一个用途就是应用程序的开发人员来保持一些特定应用程序的一些数据的。但是这里被我们用掉了，咋办咧。嘿嘿，这个也好办，还记得我设计的时候说设计了一个设置控件附加数据的消息么，MiniGUI 有SetWindowAdditianlData() 的API了，我为什么还要设计这个接口咧。这就是原因啦，本来设计保留给应用程序的dwAdditionalDtat1别我的控件占用掉了，我们控件的开发原则就是尽量方便外部应用程序的使用，不能让人家不能使用原有的功能啊。所以我在自定义控件的结构体里增加了一个DWORD类型的数据，然后提供结构给外部来设置和获取。不过这里一定要告诉使用控件的人，让他使用你提供的消息来设置和获取控件附加数据，而不是直接使用SetWindowAdditionalData 和GetWindowAdditionalData 。</p>
<p>这里再啰嗦一点：外部的应用程序不管什么情况下，都不要轻易的使用SetWindowAdditionalData2和GetWindowAdditionalData2。这个之前说过了，是保存MiniGUI 原有控件数据的指针，不是开放给外部应用程序使用的。</p>
<p>其他的一些通常的MiniGUI GUI编程的一些就不多说，看我的源代码相信大家都会。这次介绍子类化已有控件实例的方法。下次我将结合自己写的一些通用自定义控件介绍子类化控件类和完全自己从头开始写自定义控件类（我管某一种方式叫完全自己从头开始写，至于准不准确大家自己看着办了，话说我还没开始介绍咧 -_-||）的方法。</p>
<p>本人比较懒散些，所以更新慢是必然的，请大家多多包涵。飞漫的MiniGUI的3.0版本都出来了，据说和1.6/2.0 区别很多，本人这些全是在2.0的基本上研究的，哎，不知道过时了没 -_-|| 。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
<h2 id="代码下载">代码下载</h2>
<p><a href="http://download.csdn.net/detail/mingming_killer/4045894" target="_blank" rel="external">下载地址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/MiniGUI%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%99%E7%A8%8B1/</loc>
    <lastmod>2015-01-19T12:25:16.000Z</lastmod>
    <data>
        <display>
        <title>MiniGUI 自定义控件教程1</title>
        <pubTime>2015-01-19T12:25:16.000Z</pubTime>
        
        <tag>minigui </tag>
         
         <content><![CDATA[<h2 id="前言：">前言：</h2>
<p>MiniGUI 采用的机制是与win32十分类似的消息机制，基本上与win32的sdk一致。win32上经典的Framework MFC 采用的是C++，面向对象的方法，自定控件可以直接使用继承的方式，十分方便。MiniGUI 使用的是c语音，重所周知这是一个面向过程的语言。但是其实它也可以使用类似c++的面向对象的思想（详细的可以看一本叫做 《Object-Oriented Programming with ANSI-C》的书，具体的就不在这里研究了）。MiniGUI 本身自带的控件就是用c语言来模仿一些面向对象思想来实现的。</p>
<p> 飞漫的编程指南上也提到了自定控件的方法。但是与其它的章节比起来篇幅太小了 -_-||。网上这方面的资料更是少得可怜，在csdn和pudn上我可以随便搜到MFC、VB、Dephi等自定义控件的例子，但是MiniGUI基本上就没看到。想当初自己研究，很费劲，走了不少弯路。现在总结了一些心得，希望开发定义控件的弟兄们少走些弯路。</p>
<h2 id="自定控件的方法">自定控件的方法</h2>
<p>MiniGUI 原有的控件用一个叫做 WNDCLASS 的来表示。从名字就可以看出了，飞漫把这玩意当类来对待了。不过c++（面向对象的语言相对来说本人对c++比较熟悉，就拿这个举例子了）里的自定义控件可都是子类化某个原有的控件类，然后写好类之后，实例化得到控件对象就可以使用了。</p>
<p>飞漫的编程指南里说到了3种方法：</p>
<ol>
<li>对已经建立的控件实例进行子类化，子类化的结果只会影响这一个控件实例。</li>
<li>是对某个控件类进行子类化，将影响其后创建的所有该控件类的控件实例。 </li>
<li>是在某个控件类的基础上新注册一个子类化的控件类，不会影响原有控件类。在 Windows 中，这种技术又称为超类化。</li>
</ol>
<p>恕本人水平及理解能力有限，我目前只理解和使用了第1和第3种方法，第2种我愣是没明白怎么回事。要是哪位兄弟理解了的，望留言或发email告诉我。 那现在我就说说我理解了的这2种方法吧。</p>
<h3 id="对已建立的控件进（实例）行子类化">对已建立的控件进（实例）行子类化</h3>
<p>MiniGUI 的控件就是一类特殊的子窗口，所以它们也有自己的过程处理函数 typedef int (* WNDPROC) (HWND, int, WPARAM, LPARAM) 。这种方式的实现其实就是替换掉已经创建了的控件原来的过程出来函数。这个函数其实是每个控件结构体变量里一个函数指针所指向的。通过函数指针指向不同的处理函数就能实现控件的不同功能已经不同的属性。再配合上每个控件的实例数据（后面再说这个东东），是不是有点像面向对象的感觉了呢 ^_^。</p>
<p>这种方法只会对你替换了过程处理函数的控件实例才生效。个人感觉比较适用的情况是：一个工程里，有好几个界面用到了同一个控件或者一个界面用到了好几个控件；但是这些控件都是和本工程关系比较紧密的，其他工程基本上用不到的。例如：一个项目里需要画N个直方图，这些直方图只是数据不一样而已，绘图方法基本一致；但是别的工程基本上用不到这个东西。其实这个用一个函数来实现也可以，让其传入绘图dc和相应的区域坐标就可以了。不过我感觉用函数这种方法没有封装成控件来得方便。</p>
<ol>
<li>函数使用的绘图相关的变量是和父窗口相关的，用起来不怎么方便。</li>
<li>提供给工程里别的模块使用话，在MiniGUI这种gui编程中，封装成控件，使用消息机制更符合MiniGUI的编程方式。</li>
</ol>
<p>哎~~总之大家自己可以感受封装成控件的好处的，我表达能力有限，好像没怎么说清楚。不过这样弄有点点代价。就是MiniGUI的控件都有自己的数据结构变量，会稍微占有一些额外的资源，不过都能跑GUI的设备了，这些应该问题不大啦。</p>
<h3 id="对控件类进行子类化">对控件类进行子类化</h3>
<p>这种方法与上一种相比，应该算是更接近C++的自定义控件的方法。上一种是针对原有控件实例的，而这种是针对控件类了。是改动整了类，正如飞漫编程指南上写的，这种方法能影响到每一个创建的控件实例。 这种方法要是向MiniGUI 注册自己的类，然后自己设计控件数据（不是指GUI系统的调用的控件窗口数据（这些例如客户区、私有DC、托管窗口之类的），而是指保存控件某些行为的数据（例如ctrl_button里的BUTTONDATA这一些的数据））和过程处理函数。</p>
<p>这种方法我个人认为比较适用用于像扩展按钮（Button）、编辑框（Edit）、进度条（ProgressBar）之类的通用性比较强的控件。例如你觉得MiniGUI原来的Button不怎么好看，就可以自己弄一个，然后你写的所有工程都可以用你写的好看的Button来装饰了。</p>
<p>这里先介绍些理论的东西，之后再结合实际来讲解具体的方法。</p>
<p>参考资料：飞漫MiniGUI编程指南2.0.4</p>
]]></content>
         
         
           
             
              <breadCrumb title="MiniGUI" url="http://www.light3moon.com/categories/MiniGUI/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20float%20%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</loc>
    <lastmod>2015-01-19T12:22:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) float 类型在内存中的表示</title>
        <pubTime>2015-01-19T12:22:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<h2 id="标准">标准</h2>
<p>先说一下计算机中二进制的算法：</p>
<h3 id="整数">整数</h3>
<p>整数的二进制算法大家应该很熟悉，就是不断的除以2取余数，然后将余数倒序排列。比如求9的二进制： </p>
<pre>
9/2=4 余 1 
4/2=2 余 0 
2/2=1 余 0 
1/2=0 余 1
</pre> 

<p>一直计算到商为0为止，然后将得到的余数由下到上排列，就得到了9的二进制：1001。 从上面的算法我们可以看到，用整数除以2，最终都能够到0。因此，整数是可以用二进制来精确表示的。</p>
<h3 id="小数">小数</h3>
<p>小数的二进制算法和整数的大致相反，就是不断的拿小数部分乘以2取积的整数部分，然后正序排列。比如求0.9的二进制：</p>
<pre> 
0.9*2=1.8 取 1 
0.8*2=1.6 取 1 
0.6*2=1.2 取 1 
0.2*2=0.4 取 0 
0.4*2=0.8 取 0 
0.8*2=1.6 取 1 
… … 
</pre>

<p>如此循环下去。因此我么得到的二进制小数也是无限循环的：0.11100110011… 从小数的二进制算法中我们可以知道，如果想让这种算法停止，只有在小数部分是0.5的时候才可以，但是很不幸，这类的小数很少。所以大部分小数是很难用二进制来精确表示的。</p>
<p>OK，有了上面的知识，我们进入正题：看看float类型在内存中是如何表示的。float类型又称为单精度浮点类型，在 <a href="http://en.wikipedia.org/wiki/IEEE_754-2008" title="IEEE 754-2008" target="_blank" rel="external">IEEE 754-2008</a> 中是这样定义它的结构的：</p>
<pre>
S    EEEEEEEE  FFFFFFFFFFFFFFFFFFFFFFF
31   30        23 22 21 ... ...      0
</pre>

<p>float类型总共4个字节——32位：</p>
<ul>
<li><p><strong>符号位</strong><br>其中最左边的为符号位，0为正，1为负。</p>
</li>
<li><p><strong>指数</strong><br>接下来的E是指数，一共8位，也用二进制来表示。</p>
</li>
<li><p><strong>尾数</strong><br>最后的F是小数部分，尾数正是由这23位的小数部分+1位组成的。（这个稍后解释）。</p>
</li>
</ul>
<p>这里我们需要多说一下指数。虽然指数也是用8位二进制来表示的，但是IEEE在定义它的时候做了些手脚，使用了偏移来计算指数。IEEE规定，在float类型中，用来计算指数的偏移量为 <strong>127</strong> 。也就是说，如果你的指数实际是0，那么在内存中存的就是 <strong>0+127=127</strong> 的二进制。稍后我们来看这个到底如何使用。</p>
<h2 id="实例">实例</h2>
<p>好了，看了这么多，我们该演示一下计算机如何将一个十进制的实数转换为二进制的。就拿6.9这个数字来举例吧。-_-||!</p>
<p>首先，我们按照上面说的方法，分别将整数和小数转换成对应的二进制。这样 6.9 的二进制表示就是 110.1110011001100…（整数的部分按整数转化为二进制，小数部分按小数部分转化）。这里就看出来 了，6.9 转换成二进制，小数部分是无限循环的，这在现在的计算机系统上是无法精确表示的。这是计算机在计算浮点数的时候常常不精确的原因之一。</p>
<p>其次，将小数点左移（或右移）到第一个有效数字之后。说的通俗些，就是把小数点移到第一个1之后。这样的话，对于上面的 110.1110011001100… 我们就需要把小数点左移2位，得到 1.101110011001100… 。</p>
<p>接下来的事情就有意思了。首先我们把得到的 1.101110011001100.. 这个数，从小数点后第一位开始，数出23个来，填充到上面float内存 结构的尾数部分（就是那一堆F的地方），我们这里数出来的就是 10111001100110011001100。这里又要发生一次不精确了，小数点后超出 23位的部分都将被舍弃，太惨了。</p>
<p>不过，这里有一个可能让大家觉得特别坑爹的事情，就是小数点前面的1也不要了。仔细看看上面的内存结构，确实没有地方存放这个1。原因是这样的：IEEE觉得，既然我们大家都约定把小数点移动到第一个有效数字之后，那也就默认小数点前面一定有且只有一个1，所以把这个1存起来也浪费，干脆就不要了，以后大家都这么默契的来就好。这也是为什么我上面说尾数是 <strong>23位+1位</strong> 的原因。</p>
<p>填充完尾数，该填充指数了。这个指数就是刚才我们把小数点移动的位数，左移为正，右移为负，再按照上面所说的偏移量算法，我们填充的指数应该是 2+127=129 。转换成8位二进制就是 10000001。</p>
<p>最后，根据这个数的正负来填充符号位。我们这里是正数，所以填0。这样6.9的在内存中的存储结果就出来了：</p>
<pre>
0  10000001  10111001100110011001100
</pre>

<p>总结一下，实数转二进制float类型的方法：</p>
<ol>
<li>分别将实数的整数和小数转换为二进制</li>
<li>左移或者右移小数点到第一个有效数字之后</li>
<li>从小数点后第一位开始数出23位填充到尾数部分 </li>
<li>把小数点移动的位数，左移为正，右移为负，加上偏移量127，将所得的和转换为二进制填充到指数部分</li>
<li>根据实数的正负来填充符号位，0为正，1为负</li>
</ol>
<p>如果需要把float的二进制转换回十进制的实数，只要将上面的步骤倒着来一边就行了。</p>
<h2 id="需要注意的东西">需要注意的东西</h2>
<h3 id="23位尾数填充的问题">23位尾数填充的问题</h3>
<p>虽然在IEEE754标准中我没有找到相应的描述，但是在实际处理的时候，截取23位尾数需要对第24位进行零舍一入的操作，至少在Java虚拟机中是这么做的。有兴趣的可以试试0.7f-0.6f。</p>
<h3 id="运算时向右对阶操作的舍入问题">运算时向右对阶操作的舍入问题</h3>
<p>这个也是在实际操作时遇到的问题。到目前为止我还无法确定向右对阶操作是否也进行了零舍一入的操作。有兴趣的可以试试9.6f-6.9f。</p>
<h3 id="指数全零问题">指数全零问题</h3>
<p>全部为零的指数说明当前所表示的是一个特殊的float数字。全零的float类型分为两种情况：</p>
<ul>
<li><p><strong>尾数全零</strong><br>此时代表当前float数为0。根据符号位，分为+0和-0。这两个在JVM上相等的。这里需要解释一下。因为IEEE的默认1的问题，所以float类型没有办法表示0，因此只能在已有的规定上做一些强制性的规则来表示0，也就有了上面的这个全零的说法。 </p>
</li>
<li><p><strong>尾数不全为零</strong><br>此时说明当前的float数是一个非规格化的数。</p>
</li>
</ul>
<h3 id="指数全一问题">指数全一问题</h3>
<p>指数全部为一也说明这个float数是一个不寻常的数字。它也分为两种情况：</p>
<ul>
<li><p><strong>尾数全零</strong><br>此时根据符号位的不同，分为正无穷（+infinity）和负无穷（-infinity）。注意，这两个东西在JVM中是不相等的。</p>
</li>
<li><p><strong>尾数不全为零</strong><br>此时表示此float数纯粹不是一个数（NaN，Not a Number）。这个NaN也分QNaN（Quiet NaN）和SNaN（Signalling NaN）。至于这两个NaN有什么区别，下面这段话倒是说明了，但是我没有这方面的知识，所以不敢妄加翻译，只好把原文放在这里：</p>
</li>
</ul>
<p>A QNaN is a NaN with the most significant fraction bit set. QNaN’s propagate freely through most arithmetic operations. These values pop out of an operation when the result is not mathematically defined.<br>An SNaN is a NaN with the most significant fraction bit clear. It is used to signal an exception when used in operations. SNaN’s can be handy to assign to uninitialized variables to trap premature usage.<br>Semantically, QNaN’s denote indeterminate operations, while SNaN’s denote invalid operations.</p>
<p>最后一句话说的明白，QNaN就是一个不确定操作的结果，而SNaN纯粹就是一个非法的操作结果。</p>
<p>OK，废话了这么多，我觉得对float类型也大致有个了解了。float明白了以后，double类型也就好说了，基本和上面一样，只是指数和尾数的位数不一样而已。</p>
<p><a href="http://blog.csdn.net/nethibernate/article/details/6120382" title="原始出处" target="_blank" rel="external">原始出处</a></p>
<h2 id="我的话">我的话</h2>
<p>这个作者写的很好，很好的说明了 float 在内存中是怎么存放的。从这里可以看得出，为什么 float 运算比 int 要慢很多（多了太多的运算）。所以以前嵌入式 Soc 不给力的时候嵌入式的 app 一般不使用 float。现在我能理解以前 MiniGUI 用定点数代替 float 的做法了：</p>
<p>就是把一个 int 类型拆成2部分：例如 32bit 的，高 16bit 当作整数部分，低 16bit 当作小数部分来表示和运算。这样的话，因为整数和小数的位数都是固定的，所以叫定点数。这样表示 float 的方法比正统的 float 要快很多，虽然精度比 float 差，但是在一些不太要紧的场合很实用。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/Endianness/</loc>
    <lastmod>2015-01-19T12:18:16.000Z</lastmod>
    <data>
        <display>
        <title>Endianness</title>
        <pubTime>2015-01-19T12:18:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>大、小端这个东西，每隔一段时间我就会忘记，发现维基上有2张图太形象了，记不得的时候看下这2张图就能想起来了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/basics/Endianness/1.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/basics/Endianness/2.png" alt=""></p>
<p>然后总结下，有个简单的记得方法：如果是大端存储的话，那么就是大的数值（专有名词叫 The most significant byte (MSB），俗称高位，就是好说个、十、百、千中的千）是存放在存储的低位的（就是最开始地方）。所以大端存储格式直接按顺序从存储中读出来的位数就是对的。</p>
<p>小端就正好反过来， MSB 是存在存储的高位的（就是后面），所以小端存储的话，从存储中读出来，要把位数反过来。</p>
<p>最后贴个 wiki 地址： <a href="http://en.wikipedia.org/wiki/Endianness" title="Endianness" target="_blank" rel="external">Endianness</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</loc>
    <lastmod>2015-01-19T02:38:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) 内存对齐</title>
        <pubTime>2015-01-19T02:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<h2 id="为什么要内存对齐">为什么要内存对齐</h2>
<p>简单的说内存对齐能够提高 cpu 读取数据的速度，减少 cpu 访问数据的出错性（有些 cpu 必须内存对齐，否则指针访问会出错）。</p>
<p>对于所有直接操作内存的程序员来说,数据对齐都是很重要的问题.数据对齐对你的程序的表现甚至能否正常运行都会产生影响.就像本文章阐述的一样,理解了对齐的本质还能够解释一些处理器的”奇怪的”行为.</p>
<h3 id="内存存取粒度">内存存取粒度</h3>
<p>程序员通常倾向于认为内存就像一个字节数组.在C及其衍生语言中,char * 用来指代”一块内存”,甚至在JAVA中也有byte[]类型来指代物理内存.</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/1.jpeg" alt=""></p>
<p>然而,你的处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存.我们将上述这些存取单位称为内存存取粒度.</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/2.jpeg" alt=""></p>
<p>高层(语言)程序员认为的内存形态和处理器对内存的实际处理方式之间的差异产生了许多有趣的问题.如果你不理解内存对齐,你编写的程序将有可能产生下面的问题,按严重程度递增:</p>
<ol>
<li>程序运行速度变慢</li>
<li>应用程序产生死锁</li>
<li>操作系统崩溃</li>
<li>你的程序会毫无征兆的出错,产生错误的结果</li>
</ol>
<h3 id="内存对齐基础">内存对齐基础</h3>
<p>为了说明内存对齐背后的原理,我们考察一个任务,并观察内存存取粒度是如何对该任务产生影响的.这个任务很简单:先从地址0读取4个字节到寄存器,然后从地址1读取4个字节到寄存器.</p>
<p>首先考察内存存取粒度为1byte的情况:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/3.jpeg" alt=""></p>
<p>这迎合了那些天真的程序员的观点:从地址0和地址1读取4字节数据都需要相同的4次操作.现在再看看存取粒度为双字节的处理器(像最初的68000处理器)的情况:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/4.jpeg" alt=""></p>
<p>从地址0读取数据,双字节存取粒度的处理器读内存的次数是单字节存取粒度处理器的一半.因为每次内存存取都会产生一个固定的开销,最小化内存存取次数将提升程序的性能.</p>
<p>但从地址1读取数据时由于地址1没有和处理器的内存存取边界对齐,处理器就会做一些额外的工作.地址1这样的地址被称作非对齐地址.由于地址1是非对齐的,双字节存取粒度的处理器必须再读一次内存才能获取想要的4个字节,这减缓了操作的速度.</p>
<p>最后我们再看一下存取粒度为4字节的处理器(像68030,PowerPC® 601)的情况:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/5.jpeg" alt=""></p>
<p>在对齐的内存地址上,四字节存取粒度处理器可以一次性的将4个字节全部读出;而在非对齐的内存地址上,读取次数将加倍.既然你理解了内存对齐背后的原理,那么你就可以探索该领域相关的一些问题了.</p>
<h3 id="懒惰的处理器">懒惰的处理器</h3>
<p>处理器对非对齐内存的存取有一些技巧.考虑上面的四字节存取粒度处理器从地址1读取4字节的情况,你肯定想到了下面的解决方法:</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/memory-align/6.jpeg" alt=""></p>
<p>处理器先从非对齐地址读取第一个4字节块,剔除不想要的字节,然后读取下一个4字节块,同样剔除不要的数据,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
<p>有些处理器并不情愿为你做这些工作.最初的68000处理器的存取粒度是双字节,没有应对非对齐内存地址的电路系统.当遇到非对齐内存地址的存取时,它将抛出一个异常.最初的Mac OS并没有妥善处理这个异常,它会直接要求用户重启机器.悲剧.</p>
<p>随后的680x0系列,像68020,放宽了这个的限制,支持了非对齐内存地址存取的相关操作.这解释了为什么一些在68020上正常运行的旧软件会在68000上崩溃.这也解释了为什么当时一些老Mac编程人员会将指针初始化成奇数地址.在最初的Mac机器上如果指针在使用前没有被重新赋值成有效地址,Mac会立即跳到调试器.通常他们通过检查调用堆栈会找到问题所在.</p>
<p>所有的处理器都使用有限的晶体管来完成工作.支持非对齐内存地址的存取操作会消减”晶体管预算”,这些晶体管原本可以用来提升其他模块的速度或者增加新的功能.以速度的名义牺牲非对齐内存存取功能的一个例子就是MIPS.为了提升速度,MIPS几乎废除了所有的琐碎功能.</p>
<p>PowerPC各取所长.目前所有的PowPC都硬件支持非对齐的32位整型的存取.虽然牺牲掉了一部分性能,但这些损失在逐渐减少.另一方面,现今的PowPC处理器缺少对非对齐的64-bit浮点型数据的存取的硬件支持.当被要求从非对齐内存读取浮点数时,PowerPC会抛出异常并让操作系统来处理内存对齐这样的杂事.软件解决内存对齐要比硬件慢得多.</p>
<h2 id="内存对齐的例子">内存对齐的例子</h2>
<p>在实际的编程中（以 C 语言为例），编译器都会为你自动对齐的。</p>
<p>在结构中，编译器为结构的每个成员按<strong>其自身的自然对界（alignment）条件分配空间</strong>。各个成员按照它们被声明的顺序在内存中顺序存储，<strong>第一个成员的地址和整个结构的地址相同</strong>。</p>
<p>例如，下面的结构各成员空间分配情况(假设对齐方式大于2字节,即#pragma pack(n), n = 2,4,8…下文将讨论#pragmapack())：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> test </div><div class="line">{</div><div class="line">     <span class="keyword">char</span> x1;</div><div class="line">     <span class="keyword">short</span> x2;</div><div class="line">     <span class="keyword">float</span> x3;</div><div class="line">     <span class="keyword">char</span> x4;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，即偏移地址是2的倍数。因此，编译器在x2和x1之间填充了一个空字节，将x2放在了偏移地址为2的位置。结构的第三个成员x3和第四个成员x4恰好落在其自然对界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，<strong>是该结构所有成员中要求的最大对界单元</strong>，因而test结构的自然对界条件为4字节，<strong>整个结构体的大小是最大对界单元大小的整数倍(结构体内部有结构体时也遵循这个规则，下文将提到)</strong>，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。</p>
<h3 id="#pragma_pack()">#pragma pack()</h3>
<p>该预处理指令用来改变对齐参数。在缺省情况下，C编译器为每一个变量或数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对齐参数：</p>
<pre config="brush:bash;toolbar:false;">
使用伪指令#pragma pack (n)，C编译器将按照n字节对齐。
使用伪指令#pragma pack ()，取消自定义字节对齐方式。
</pre>

<p>也可以写成：</p>
<pre config="brush:bash;toolbar:false;">
#pragma pack(push,n)
#pragma pack(pop)
</pre>

<p><code>#pragma pack (n)</code>表示每个成员的对齐单元不大于n（n为2的整数次幂）。这里规定的是上界，只影响对齐单元大于n的成员，对于对齐字节不大于n的成员没有影响。其实从字面意思，pack是“包裹，打包”的意思，#pragma pack(n)规定n个字节是一个“包裹”，个人认为实在不理解的话可以认为处理器一次性可以从内存中读/写n个字节，这样好理解。对于大小小于n的成员，当然是按照自己的对齐条件对齐，因为不论怎么放都可以一次性取出。对于对齐条件大于n个字节的成员，成员按照自身的对齐条件对齐和按照n字节对齐需要相同的读取次数，但按照n字节对齐节省空间，何乐而不为呢。</p>
<h3 id="结构体内成员如何找出自己的位置">结构体内成员如何找出自己的位置</h3>
<p>看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> pack(8)</span></div><div class="line"><span class="keyword">struct</span> s1</div><div class="line">{</div><div class="line">    <span class="keyword">short</span> a;</div><div class="line">    <span class="keyword">long</span> b;</div><div class="line">};</div><div class="line"><span class="keyword">struct</span> s2</div><div class="line">{</div><div class="line">    <span class="keyword">short</span> c;</div><div class="line">    s1 d;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e;</div><div class="line">};</div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> pack()</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>成员对齐有一个重要的条件：每个成员分别对齐。即每个成员按自己的方式对齐.</p>
<p>也就是说上面虽然指定了按8字节对齐，但并不是所有的成员都是以8字节对齐。其对齐的规则是，每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是8字节)中较小的一个对齐。并且结构的长度必须为所用过的所有对齐参数的整数倍(只要是最大的对齐参数的整数倍即可)，不够就补空字节(视编译器而定)。</p>
<p>S1中，成员a是2字节默认按2字节对齐，指定对齐参数为8，这两个值中取2，a按2字节对齐；成员b是4个字节，默认是按4字节对齐，这时就按4字节对齐，a后补2个字节后存放b，所以sizeof(S1)应该为8。8是4的倍数，满足上述的第3条规则。</p>
<p>S2中，c和S1中的a一样，按2字节对齐，而d是个结构，它是8个字节，它按什么对齐呢?对于结构来说，它的默认对齐方式就是该结构定义(声明)时它的所有成员使用的对齐参数中最大的一个，S1的是4，小于指定的8。所以成员d就是按4字节对齐，c后补2个字节，后面是8个字节的结构体d。成员e是8个字节，它是默认按8字节对齐，和指定的一样，所以它对到8字节的边界上，这时，已经使用了12个字节了，所以d后又补上4个字节,从第16个字节开始放置成员e。这时，长度为24，已经可以被最大对齐参数8(成员e按8字节对齐)整除。这样，一共使用了24个字节。</p>
<p>如果上面那段代码，如果去掉 #pragma pack 的话，应该是这样的： （未完待续）</p>
<p>原始出处：<br><a href="http://blog.csdn.net/lgouc/article/details/8235471" title="为什么要内存对齐" target="_blank" rel="external">为什么要内存对齐</a><br><a href="http://blog.csdn.net/lgouc/article/details/8235616" title="关于内存对齐" target="_blank" rel="external">关于内存对齐</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/reinterpret_cast%E3%80%81static_cast%20%E5%92%8C%20dynamic_cast%20%E7%9A%84%E5%8C%BA%E5%88%AB/</loc>
    <lastmod>2015-01-19T02:38:16.000Z</lastmod>
    <data>
        <display>
        <title>reinterpret_cast、static_cast 和 dynamic_cast 的区别</title>
        <pubTime>2015-01-19T02:38:16.000Z</pubTime>
        
        <tag>basics </tag>
         
         <content><![CDATA[<p>reinterpret_cast 可以转换任意一个32bit整数，包括所有的指针和整数。可以把任何整数转成指针，也可以把任何指针转成整数，以及把指针转化为任意类型的指针，威力最为强大！但不能将非32bit的实例转成指针。总之，只要是32bit的东东，怎么转都行！</p>
<p>static_cast 和 dynamic_cast 可以执行指针到指针的转换，或实例本身到实例本身的转换，但不能在实例和指针之间转换。static_cast 只能提供编译时的类型安全，而 dynamic_cast 可以提供运行时类型安全。举个例子：</p>
<pre> 
class a;
class b:a;
class c 
</pre>

<p>上面三个类a是基类，b继承a，c和ab没有关系。有一个函数 void function(a&amp; a); 现在有一个对象是b的实例b，一个c的实例c。function(static_cast<a&>(b)) 可以通过而 function(static<a&>(c)) 不能通过编译，因为在编译的时候编译器已经知道c和a的类型不符，因此 static_cast 可以保证安全。 </a&></a&></p>
<p>下面我们骗一下编译器，先把c转成类型a </p>
<pre>
b& ref_b = reinterpret_cast<b&>c;
</b&></pre>

<p>然后 function(static_cast<a&>(ref_b)) 就通过了！因为从编译器的角度来看，在编译时并不能知道ref_b实际上是c！ 而 function(dynamic_cast<a&>(ref_b)) 编译时也能过，但在运行时就失败了，因为 dynamic_cast 在运行时检查了 ref_b 的实际类型，这样怎么也骗不过去了。</a&></a&></p>
<p>在应用多态编程时，当我们无法确定传过来的对象的实际类型时使用 dynamic_cast，如果能保证对象的实际类型，用 static_cast 就可以了。至于 reinterpret_cast，我很喜欢，很象c语言那样的暴力转换。</p>
<p>总结一下：</p>
<p><strong>dynamic_cast</strong>: 动态类型转换，一般用在父类和子类指针或应用的互相转化。<br><strong>static_cast</strong>: 静态类型转换，一般是普通数据类型(如: int m=static_cast<int>(3.14))<br><strong>reinterpret_cast</strong>: 重新解释类型转换，很像c的一般类型转换操作<br><strong>const_cast</strong>: 常量类型转换，是把cosnt或volatile属性去掉 </int></p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20unlocked_ioctl%20%E5%92%8C%E5%A0%B5%E5%A1%9E%EF%BC%88waitqueue%EF%BC%89%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</loc>
    <lastmod>2015-01-19T02:31:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</title>
        <pubTime>2015-01-19T02:31:16.000Z</pubTime>
        
        <tag>basics </tag>
         
        <tag>linux </tag>
         
         <content><![CDATA[<p>学习了驱动程序的设计，感觉在学习驱动的同时学习linux内核，也是很不错的过程哦，做了几个实验，该做一些总结，只有不停的作总结才能印象深刻。</p>
<p>我的平台是虚拟机，fedora14，内核版本为2.6.38.1.其中较之前的版本存在较大的差别，具体的实现已经在上一次总结中给出了。今天主要总结的是ioctl和堵塞读写函数的实现。</p>
<h2 id="一、ioctl函数的实现">一、ioctl函数的实现</h2>
<p>首先说明在2.6.36以后ioctl函数已经不再存在了，而是用<code>unlocked_ioctl</code>和<code>compat_ioctl</code>两个函数实现以前版本的ioctl函数。同时在参数方面也发生了一定程度的改变，去除了原来ioctl中的struct inode参数，同时改变了返回值。</p>
<p>但是驱动设计过程中存在的问题变化并不是很大，同样在应用程序设计中我们还是采用ioctl实现访问，而并不是<code>unlocked_ioctl</code>函数，因此我们还可以称之为ioctl函数的实现。ioctl函数的实现主要是用来实现具体的硬件控制，采用相应的命令控制硬件的具体操作，这样就能使得硬件的操作不再是单调的读写操作。使得硬件的使用更加的方便。ioctl函数实现主要包括两个部分，首先是命令的定义，然后才是ioctl函数的实现，命令的定义是采用一定的规则。</p>
<p>ioctl的命令主要用于应用程序通过该命令操作具体的硬件设备，实现具体的操作，在驱动中主要是对命令进行解析，通过switch-case语句实现不同命令的控制，进而实现不同的硬件操作。</p>
<p>ioctl函数的命令定义方法：</p>
<pre>
int (*unlocked_ioctl)(struct file*filp,unsigned int cmd,unsigned long arg)
</pre>

<p>虽然其中没有指针的参数，但是通常采用arg传递指针参数。cmd是一个命令。<strong>每一个命令由一个整形数据构成（32bits），将一个命令分成四部分，每一部分实现具体的配置，设备类型（幻数）8bits，方向2bits，序号8bits，数据大小13/14bits</strong>。命令的实现实质上就是通过简单的移位操作，将各个部分组合起来而已。</p>
<p>一个命令的分布的大概情况如下：</p>
<pre config="brush:bash;toolbar:false;">
|---方向位(31-30)|----数据长度(29-16)----------------|---------设备类型（15-8）------|----------序号（7-0）----------|
|----------------------------------------------------------------------------------------------------------------------------------------|
</pre>

<p>其中方向位主要是表示对设备的操作，比如读设备，写设备等操作以及读写设备等都具有一定的方向，2个bits只有4种方向。数据长度表示每一次操作（读、写）数据的大小，一般而已每一个命令对应的数据大小都是一个固定的值，不会经常改变，14bits说明可以选择的数据长度最大为16k。</p>
<p>设备类型类似于主设备号（由于8bits，刚好组成一个字节，因此经常采用字符作为幻数，表示某一类设备的命令），用来区别不同的命令类型，也就是特定的设备类型对应特定的设备。序号主要是这一类命令中的具体某一个，类似于次设备号（256个命令），也就是一个设备支持的命令多达256个。</p>
<p>同时在内核中也存在具体的宏用来定义命令以及解析命令。但是大部分的宏都只是定义具体的方向，其他的都需要设计者定义。</p>
<p>主要的宏如下：</p>
<pre config="brush:bash;toolbar:false;">

#include<linux ioctl.h="">

_IO(type,nr)                表示定义一个没有方向的命令，
_IOR(type,nr,size)          表示定义一个类型为type，序号为nr，数据大小为size的读命令
_IOW(type,nr,size)          表示定义一个类型为type，序号为nr，数据大小为size的写命令
_IOWR(type,nr,size)         表示定义一个类型为type，序号为nr，数据大小为size的写读命令

</linux></pre>

<p>通常的type可采用某一个字母或者数字作为设备命令类型。是实际运用中通常采用如下的方法定义一个具体的命令:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//头文件</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;linux/ioctl.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/*定义一系列的命令*/</span></div><div class="line"><span class="comment">/*幻数，主要用于表示类型*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAGIC_NUM 'k'</span></div><div class="line"><span class="comment">/*打印命令*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_PRINTF _IO(MAGIC_NUM,1)</span></div><div class="line"><span class="comment">/*从设备读一个int数据*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_READ _IOR(MAGIC_NUM,2,int)</span></div><div class="line"><span class="comment">/*往设备写一个int数据*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_WRITE _IOW(MAGIC_NUM,3,int)</span></div><div class="line"></div><div class="line"><span class="comment">/*最大的序列号*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEM_MAX_CMD 3</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>还有对命令进行解析的宏，用来确定具体命令的四个部分（方向，大小，类型，序号）具体如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*确定命令的方向*/</span></div><div class="line">_IOC_DIR(nr)                    </div><div class="line"><span class="comment">/*确定命令的类型*/</span></div><div class="line">_IOC_TYPE(nr)                     </div><div class="line"><span class="comment">/*确定命令的序号*/</span></div><div class="line">_IOC_NR(nr)                           </div><div class="line"><span class="comment">/*确定命令的大小*/</span></div><div class="line">_IOC_SIZE(nr)</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的几个宏可以用来命令，实现命令正确性的检查。</p>
<p>ioctl的实现过程主要包括如下的过程：</p>
<ol>
<li>命令的检测</li>
<li>指针参数的检测</li>
<li>命令的控制switch-case语句</li>
</ol>
<p>1、命令的检测主要包括类型的检查，数据大小，序号的检测，通过结合上面的命令解析宏可以快速的确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*检查类型，幻数是否正确*/</span></div><div class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd)!=MAGIC_NUM)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"><span class="comment">/*检测命令序号是否大于允许的最大序号*/</span></div><div class="line"><span class="keyword">if</span>(_IOC_NR(cmd)&gt; MEM_MAX_CMD)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"></div></pre></td></tr></table></figure>

<p>2、主要是指针参数的检测。指针参数主要是因为内核空间和用户空间的差异性导致的，因此需要来自用户空间指针的有效性。使用<code>copy_from_user</code>,<code>copy_to_user</code>,<code>get_user</code>,<code>put_user</code>之类的函数时，由于函数会实现指针参量的检测，因此可以省略，但是采用<code>__get_user()</code>,<code>__put_user()</code>之类的函数时一定要进行检测。具体的检测方法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span>(_IOC_DIR(cmd) & _IOC_READ)</div><div class="line">        err = !access_ok(VERIFY_WRITE,(<span class="keyword">void</span> *)args,_IOC_SIZE(cmd));</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_IOC_DIR(cmd) & _IOC_WRITE)</div><div class="line">        err = !access_ok(VERIFY_READ,(<span class="keyword">void</span> *)args,_IOC_SIZE(cmd));</div><div class="line"><span class="keyword">if</span>(err)<span class="comment">/*返回错误*/</span></div><div class="line">        <span class="keyword">return</span> -EFAULT;</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>当方向是读时，说明是从设备读数据到用户空间，因此要检测用户空间的指针是否可写，采用<code>VERIFY_WRITE</code>，而当方向是写时，说明是往设备中写数据，因此需要检测用户空间中的指针的可读性<code>VERIFY_READ</code>。检查通常采用<code>access_ok()</code>实现检测，第一个参数为读写，第二个为检测的指针，第三个为数据的大小</strong>。</p>
<p>3、命名的控制：命令的控制主要是采用switch和case相结合实现的，这于window编程中的检测各种消息的实现方式是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*根据命令执行相应的操作*/</span></div><div class="line">        <span class="keyword">switch</span>(cmd)</div><div class="line">        {</div><div class="line">                <span class="keyword">case</span> MEMDEV_PRINTF:</div><div class="line">                        printk(<span class="string">"&lt;--------CMD MEMDEV_PRINTF Done------------&gt;\n\n"</span>);</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MEMDEV_READ:</div><div class="line">                        ioarg = &mem_devp-&gt;data;</div><div class="line">                        ...</div><div class="line">                        ret = __put_user(ioarg,(<span class="keyword">int</span> *)args);</div><div class="line">                        ioarg = <span class="number">0</span>;</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MEMDEV_WRITE:</div><div class="line">                        ...</div><div class="line">                        ret = __get_user(ioarg,(<span class="keyword">int</span> *)args);</div><div class="line">                        printk(<span class="string">"&lt;--------CMD MEMDEV_WRITE Done ioarg = %d---------&gt;\n\n"</span>,ioarg); </div><div class="line">                        ioarg = <span class="number">0</span>;</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                        ret = -EINVAL;</div><div class="line">                        printk(<span class="string">"&lt;-------INVAL CMD---------&gt;\n\n"</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这只是基本的框架结构，实际中根据具体的情况进行修改。这样就实现了基本的命令控制。<br>文件操作支持的集合如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*添加该模块的基本文件操作支持*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations mem_fops =</div><div class="line">{</div><div class="line">        <span class="comment">/*结尾不是分号，注意其中的差别*/</span></div><div class="line">        .owner = THIS_MODULE,</div><div class="line">        .llseek = mem_llseek,</div><div class="line">        .read = mem_read,</div><div class="line">        .write = mem_write,</div><div class="line">        .open = mem_open,</div><div class="line">        .release = mem_release,</div><div class="line">        <span class="comment">/*添加新的操作支持*/</span></div><div class="line">        .unlocked_ioctl = mem_ioctl,</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>需要注意不是ioctl,而是unlocked_ioctl。</p>
<h2 id="二、设备的堵塞读写方式实现，通常采用等待队列。">二、设备的堵塞读写方式实现，通常采用等待队列。</h2>
<p>设备的堵塞读写方式，默认情况下的读写操作都是堵塞型的，具体的就是如果需要读数据，当设备中没有数据可读的时候应该等待设备中有设备再读，当往设备中写数据时，如果上一次的数据还没有被读完成，则不应该写入数据，就会导致进程的堵塞，等待数据可读写。但是在应用程序中也可以采用非堵塞型的方式进行读写。只要在打开文件的时候添加一个<code>O_NONBLOCK</code>,这样在不能读写的时候就会直接返回，而不会等待。</p>
<p>因此我们在实际设计驱动设备的同时需要考虑读写操作的堵塞方式。堵塞方式的设计主要是通过等待队列实现，通常是将等待队列（实质就是一个链表）的头作为设备数据结构的一部分。在设备初始化过程中初始化等待队列的头。最后在设备读写操作的实现添加相应的等待队列节点，并进行相应的控制。</p>
<p>等待队列的操作基本如下：</p>
<p>1、等待队列的头定义并初始化的过程如下：</p>
<p>方法一：</p>
<pre>
struct wait_queue_head_t mywaitqueue;
init_waitqueue_head(&mywaitqueue);
</pre>
方法二：
<pre>
DECLARE_WAIT_QUEUE_HEAD(mywaitqueue);
</pre>
以上的两种都能实现定义和初始化等待队列头。

2、创建、移除一个等待队列的节点，并添加、移除相应的队列。
定义一个等待队列的节点:`DECLARE_WAITQUEUE(wait,tsk)`
其中tsk表示一个进程，可以采用current当前的进程。
添加到定义好的等待队列头中。
<pre>
add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
即：add_wait_queue(&mywaitqueue,&wait);
</pre>

<p>移除等待节点</p>
<pre>
remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
即：remove_wait_queue(&mywaitqueue,&wait);
</pre>

<p>3、等待事件<br><code>wait_event(queue,condition)</code>;当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下不能被信号打断。<br><code>wait_event_interruptible(queue,condition)</code>;当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下能被信号打断。</p>
<p>4、唤醒等待队列<br><code>wait_up(wait_queue_head_t *q)</code>,唤醒该等待队列头对应的所有等待。<br><code>wait_up_interruptible(wait_queue_head_t *q)</code>唤醒处于<code>TASK_INTERRUPTIBLE</code>的等待进程。</p>
<p>应该成对的使用。即<code>wait_event</code>于<code>wait_up</code>,而<code>wait_event_interruptible</code>与<code>wait_up_interruptible</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">wait_event和wait_event_interruptible的实现都是采用宏的方式，都是一个重新调度的过程，如下所示：</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> wait_event_interruptible(wq, condition)                \</span></div><div class="line">({                                    \</div><div class="line">    <span class="keyword">int</span> __ret = <span class="number">0</span>;                            \</div><div class="line">    <span class="keyword">if</span> (!(condition))                        \</div><div class="line">        __wait_event_interruptible(wq, condition, __ret);    \</div><div class="line">    __ret;                                \</div><div class="line">})</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __wait_event_interruptible(wq, condition, ret)            \</span></div><div class="line"><span class="keyword">do</span> {                                    \</div><div class="line">     <span class="comment">/*此处存在一个声明等待队列的语句，因此不需要再重新定义一个等待队列节点*/</span></div><div class="line">    DEFINE_WAIT(__wait);                        \</div><div class="line">                                    \</div><div class="line">    <span class="keyword">for</span> (;;) {                            \</div><div class="line">        <span class="comment">/*此处就相当于add_wait_queue()操作，具体参看代码如下所示*/</span></div><div class="line">        prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);    \</div><div class="line">        <span class="keyword">if</span> (condition)                        \</div><div class="line">            <span class="keyword">break</span>;                        \</div><div class="line">        <span class="keyword">if</span> (!signal_pending(current)) {                \</div><div class="line">            <span class="comment">/*此处是调度，丢失CPU，因此需要wake_up函数唤醒当前的进程</span></div><div class="line"><span class="comment">		根据定义可知，如果条件不满足，进程就失去CPU,能够跳出for循环的出口只有</span></div><div class="line"><span class="comment">                1、当条件满足时2、当signal_pending（current）=1时。</span></div><div class="line"><span class="comment">                1、就是满足条件，也就是说wake_up函数只是退出了schedule函数，</span></div><div class="line"><span class="comment">                而真正退出函数还需要满足条件	</span></div><div class="line"><span class="comment">                2、说明进程可以被信号唤醒。也就是信号可能导致没有满足条件时就唤醒当前的进程。 </span></div><div class="line"><span class="comment">               这也是后面的代码采用while判断的原因.防止被信号唤醒。   </span></div><div class="line"><span class="comment">	   */</span></div><div class="line">            schedule();                    \</div><div class="line">            <span class="keyword">continue</span>;                    \</div><div class="line">        }                            \</div><div class="line">        ret = -ERESTARTSYS;                    \</div><div class="line">        <span class="keyword">break</span>;                            \</div><div class="line">    }                                \</div><div class="line">    finish_wait(&wq, &__wait);                    \</div><div class="line">} <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFINE_WAIT_FUNC(name, function)				\</span></div><div class="line">	wait_queue_t name = {						\</div><div class="line">		.<span class="keyword">private</span>	= current,				\</div><div class="line">		.func		= function,				\</div><div class="line">		.task_list	= LIST_HEAD_INIT((name).task_list),	\</div><div class="line">	}</div><div class="line"></div><div class="line"><span class="keyword">void</span> prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, <span class="keyword">int</span> state)</div><div class="line">{</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	wait-&gt;flags &= ~WQ_FLAG_EXCLUSIVE;</div><div class="line">	spin_lock_irqsave(&q-&gt;lock, flags);</div><div class="line">	<span class="keyword">if</span> (list_empty(&wait-&gt;task_list))</div><div class="line">               <span class="comment">/*添加节点到等待队列*/</span></div><div class="line">		__add_wait_queue(q, wait);</div><div class="line">	set_current_state(state);</div><div class="line">	spin_unlock_irqrestore(&q-&gt;lock, flags);</div><div class="line">}</div><div class="line">唤醒的操作也是类似的。</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> wake_up_interruptible(x)	__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></div><div class="line"> </div><div class="line">  <span class="keyword">void</span> __wake_up(wait_queue_head_t *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</div><div class="line">{</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	spin_lock_irqsave(&q-&gt;lock, flags);</div><div class="line">	__wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);</div><div class="line">	spin_unlock_irqrestore(&q-&gt;lock, flags);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(wait_queue_head_t *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</div><div class="line">{</div><div class="line">	wait_queue_t *curr, *next;</div><div class="line"></div><div class="line">	list_for_each_entry_safe(curr, next, &q-&gt;task_list, task_list) {</div><div class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &&</div><div class="line">				(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>等待队列通常用在驱动程序设计中的堵塞读写操作，并不需要手动的添加节点到队列中，直接调用即可实现，具体的实现方法如下：</p>
<p>1、在设备结构体中添加等待队列头，由于读写都需要堵塞，所以添加两个队列头，分别用来堵塞写操作，写操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;linux/wait.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> mem_dev</div><div class="line">{</div><div class="line">        <span class="keyword">char</span> *data;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line">        <span class="comment">/*添加一个并行机制*/</span></div><div class="line">        spinlock_t lock;</div><div class="line"></div><div class="line">        <span class="comment">/*添加一个等待队列t头*/</span></div><div class="line">        wait_queue_head_t rdqueue;</div><div class="line">        wait_queue_head_t wrqueue;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>2、然后在模块初始化中初始化队列头:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*初始化函数*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> memdev_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">       ....</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MEMDEV_NR_DEVS; i)</div><div class="line">        {</div><div class="line">                mem_devp[i].size = MEMDEV_SIZE;</div><div class="line">                <span class="comment">/*对设备的数据空间分配空间*/</span></div><div class="line">                mem_devp[i].data = kmalloc(MEMDEV_SIZE,GFP_KERNEL);</div><div class="line">                <span class="comment">/*问题，没有进行错误的控制*/</span></div><div class="line">                <span class="built_in">memset</span>(mem_devp[i].data,<span class="number">0</span>,MEMDEV_SIZE);</div><div class="line"></div><div class="line">                <span class="comment">/*初始化定义的互信息量*/</span></div><div class="line">                <span class="comment">//初始化定义的自旋锁ua</span></div><div class="line">                spin_lock_init(&(mem_devp[i].lock));</div><div class="line">                <span class="comment">/*初始化两个等待队列头,需要注意必须用括号包含起来，使得优先级正确*/</span></div><div class="line">                init_waitqueue_head(&(mem_devp[i].rdqueue));</div><div class="line">                init_waitqueue_head(&(mem_devp[i].wrqueue));</div><div class="line">        }</div><div class="line">      ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>3、确定一个具体的条件，比如数据有无，具体的条件根据实际的情况设计。</strong></p>
<pre>
/*等待条件*/
static bool havedata = false;
</pre>

<p>4、在需要堵塞的读函数，写函数中分别实现堵塞，首先定义等待队列的节点，并添加到队列中去，然后等待事件的唤醒进程。但是由于读写操作的两个等待队列都是基于条件havedata的，所以在读完成以后需要唤醒写，写完成以后需要唤醒读操作，同时更新条件havedata，最后还要移除添加的等待队列节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*read函数的实现*/</span></div><div class="line"><span class="keyword">static</span> ssize_t mem_read(<span class="keyword">struct</span> file *filp,<span class="keyword">char</span> __user *buf, size_t size,loff_t *ppos)</div><div class="line">{</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> mem_dev *dev = filp-&gt;private_data;</div><div class="line"></div><div class="line">        <span class="comment">/*参数的检查，首先判断文件位置*/</span></div><div class="line">        <span class="keyword">if</span>(p &gt;= MEMDEV_SIZE)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">/*改正文件大小*/</span></div><div class="line">        <span class="keyword">if</span>(count &gt; MEMDEV_SIZE - p)</div><div class="line">                count = MEMDEV_SIZE - p;</div><div class="line">         <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*添加一个等待队列节点到当前进程中*/</span></div><div class="line">        DECLARE_WAITQUEUE(wait_r,current);</div><div class="line"></div><div class="line">        <span class="comment">/*将节点添加到等待队列中*/</span></div><div class="line">        add_wait_queue(&dev-&gt;rdqueue,&wait_r);</div><div class="line"></div><div class="line">        <span class="comment">/*添加等待队列，本来采用if即可，但是由于信号等可能导致等待队列的唤醒，因此采用循环，确保不会出现误判*/</span></div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!havedata)</div><div class="line">        {</div><div class="line">                <span class="comment">/*判断用户是否设置为非堵塞模式读,告诉用户再读*/</span></div><div class="line">                <span class="keyword">if</span>(filp-&gt;f_flags & O_NONBLOCK)</div><div class="line">                        <span class="keyword">return</span> -EAGAIN;</div><div class="line"></div><div class="line">                <span class="comment">/*依据条件havedata判断队列的状态，防止进程被信号唤醒*/</span></div><div class="line">                wait_event_interruptible(dev-&gt;rdqueue,havedata);</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_lock(&dev-&gt;lock);</div><div class="line">        <span class="comment">/*从内核读数据到用户空间，实质就通过private_data访问设备*/</span></div><div class="line">        <span class="keyword">if</span>(copy_to_user(buf,(<span class="keyword">void</span> *)(dev-&gt;data p),count))</div><div class="line">        {</div><div class="line">                <span class="comment">/*出错误*/</span></div><div class="line">                ret = -EFAULT;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">                <span class="comment">/*移动当前文件光标的位置*/</span></div><div class="line"></div><div class="line">                *ppos = count;</div><div class="line">                ret = count;</div><div class="line"></div><div class="line">                printk(KERN_INFO <span class="string">"read %d bytes(s) from %d\n"</span>,count,p);</div><div class="line">        }</div><div class="line">      </div><div class="line">        spin_unlock(&dev-&gt;lock);</div><div class="line">	 <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*将等待队列节点从读等待队列中移除*/</span></div><div class="line">        remove_wait_queue(&dev-&gt;rdqueue,&wait_r);</div><div class="line">	<span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">        <span class="comment">/*更新条件havedate*/</span></div><div class="line">        havedata = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">/*唤醒写等待队列*/</span></div><div class="line">        wake_up_interruptible(&dev-&gt;wrqueue);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*write函数的实现*/</span></div><div class="line"><span class="keyword">static</span> ssize_t mem_write(<span class="keyword">struct</span> file *filp,<span class="keyword">const</span> <span class="keyword">char</span> __user *buf,size_t size,loff_t *ppos)</div><div class="line">{</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*获得设备结构体的指针*/</span></div><div class="line">        <span class="keyword">struct</span> mem_dev *dev = filp-&gt;private_data;</div><div class="line"></div><div class="line">        <span class="comment">/*检查参数的长度*/</span></div><div class="line">        <span class="keyword">if</span>(p &gt;= MEMDEV_SIZE)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(count &gt; MEMDEV_SIZE - p)</div><div class="line">                count = MEMDEV_SIZE - p;</div><div class="line">	  <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*定义并初始化一个等待队列节点，添加到当前进程中*/</span></div><div class="line">        DECLARE_WAITQUEUE(wait_w,current);</div><div class="line">        <span class="comment">/*将等待队列节点添加到等待队列中*/</span></div><div class="line">        add_wait_queue(&dev-&gt;wrqueue,&wait_w);</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="comment">/*添加写堵塞判断*/</span></div><div class="line">        <span class="comment">/*为何采用循环是为了防止信号等其他原因导致唤醒*/</span></div><div class="line">        <span class="keyword">while</span>(havedata)</div><div class="line">        {</div><div class="line">                <span class="comment">/*如果是以非堵塞方式*/</span></div><div class="line">                <span class="keyword">if</span>(filp-&gt;f_flags & O_NONBLOCK)</div><div class="line">                        <span class="keyword">return</span> -EAGAIN;</div><div class="line">        <span class="comment">/*分析源码发现，wait_event_interruptible 中存在DECLARE_WAITQUEUE和add_wait_queue的操作，因此不需要手动添加等待队列节点*/</span></div><div class="line">                wait_event_interruptible(&dev-&gt;wrqueue,(!havedata));</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_lock(&dev-&gt;lock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(copy_from_user(dev-&gt;data p,buf,count))</div><div class="line">                ret = -EFAULT;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">                <span class="comment">/*改变文件位置*/</span></div><div class="line">                *ppos = count;</div><div class="line">                ret = count;</div><div class="line">                printk(KERN_INFO <span class="string">"writted %d bytes(s) from %d\n"</span>,count,p);</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_unlock(&dev-&gt;lock);</div><div class="line">	</div><div class="line">	<span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*将该等待节点移除*/</span></div><div class="line">        remove_wait_queue(&dev-&gt;wrqueue,&wait_w);</div><div class="line">	<span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">        <span class="comment">/*更新条件*/</span></div><div class="line">        havedata = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">/*唤醒读等待队列*/</span></div><div class="line">        wake_up_interruptible(&dev-&gt;rdqueue);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>5、应用程序采用两个不同的进程分别进行读、写，然后检测顺序是否可以调换，检查等待是否正常。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Basics Knowledge" url="http://www.light3moon.com/categories/Basics-Knowledge/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20%E5%AE%89%E8%A3%85%20winusb/</loc>
    <lastmod>2015-01-19T02:25:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 安装 winusb</title>
        <pubTime>2015-01-19T02:25:16.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<p>今天 win8 突然蓝屏启动不了，说什么 boot File:\BCD 损坏了，我擦，搞什么飞机。只好切换到 ubuntu 下想办法制作个 win8.1 的启动盘修复一下。</p>
<p>度娘了一下，发现 ubuntu 下有个叫 winusb 的软件可以制作 win 的启动盘，但是 14.04 没有对应的源（或者话说被屏蔽掉了）。然后 google 了一个老外的办法，手动安装：</p>
<p>64 bit 的：</p>
<pre config="brush:bash;toolbar:false;">
wget https://launchpad.net/~colingille/+archive/freshlight/+files/winusb_1.0.11+saucy1_amd64.deb
</pre>

<p>32 bit 的：</p>
<pre config="brush:bash;toolbar:false;">
wget https://launchpad.net/~colingille/+archive/freshlight/+files/winusb_1.0.11+saucy1_i386.deb
</pre>

<p>然后：</p>
<pre config="brush:bash;toolbar:false;">
sudo dpkg -i winusb_1.0.11+saucy1*
</pre>

<p>然后好像会出错的，然后再修复下依赖关系：</p>
<pre config="brush:bash;toolbar:false;">
sudo apt-get -f install
</pre>

<p>最后修复依赖关系那会让你装一堆东西，装就行，中间好像让你装 GRUB，然后让你选安装的地方，按 esc 退出去，然后选 yes 不安装 GRUB，这个东西别乱选，不然把 ubuntu 的引导都搞坏了就麻烦了（我的 window 已经歇菜了）。</p>
<p>然后命令行 winusbgui 就可以启动带 gui 的 winusb 了，用起来挺简单的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/winusb/1.png" alt=""></p>
<p>最后说一句，NND，电脑上多装一个系统还是保险点，无缘无故给老子启动文件损坏，操，操~~ &gt;_&lt;</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%5B%E8%BD%AC%5D%20gimp%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%8B%BE%E8%89%B2%E5%99%A8%E6%8B%BE%E5%8F%96%E7%9A%84%E9%A2%9C%E8%89%B2%E7%9A%84alpha%E5%80%BC/</loc>
    <lastmod>2015-01-19T02:18:16.000Z</lastmod>
    <data>
        <display>
        <title>(转) gimp中如何查看拾色器拾取的颜色的alpha值</title>
        <pubTime>2015-01-19T02:18:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>其实非常简单，按住shift然后点击颜色拾取，就会弹出一个小窗口告诉你所拾取的颜色的包括alpha的各种信息。还可以查看hsv信息或者cmyk信息</p>
<p>这个开源的图像处理工具很强大，在 linux 上可以替代 PhotoShop。不过由于功能太多，简单的处理反而不太方便，平常使用可以用在线的一个图像工具也挺好用的：</p>
<p><a href="http://apps.pixlr.com/editor/" title="在线PS工具" target="_blank" rel="external">在线PS工具</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ctags%20tag%20%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-19T02:16:16.000Z</lastmod>
    <data>
        <display>
        <title>ctags tag 文件错误问题</title>
        <pubTime>2015-01-19T02:16:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>有些时候用 ctags 打出来的 tag，在 vim 里跳转用的时候，有些会报什么 tag 文件格式错误，然后跳转无效的问题。我遇到好几次了，公司的电脑，自己的电脑。今天突发奇想，打开 tag 文件看了一下，发现文件开头有这么一段：</p>
<pre config="brush:bash;toolbar:false;">
                                int  hash_idx,
                                int  iteration_count,  
                      unsigned char *out,
                      unsigned long  password_len, 
                      unsigned long *outlen)
                const unsigned char *salt, 
!_TAG_FILE_FORMAT   2   /extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED   1   /0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR    Darren Hiebert  /dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME  Exuberant Ctags //
!_TAG_PROGRAM_URL   http://ctags.sourceforge.net    /official site/
!_TAG_PROGRAM_VERSION   5.9~svn20110310 //
"   external/chromium_org/third_party/WebKit/PerformanceTests/SunSpider/tests/sunspider-0.9.1/string-tagcloud.js    /^            '\\r': '\\\\r',$/;"   p
"   external/chromium_org/third_party/WebKit/PerformanceTests/SunSpider/tests/sunspider-0.9/string-tagcloud.js  /^            '\\r': '\\\\r',$/;"   p
"   external/chromium_org/third_party/WebKit/PerformanceTests/SunSpider/tests/sunspider-1.0/string-tagcloud.js  /^            '\\r': '\\\\r',$/;"   p
#1  external/dropbear/libtomcrypt/crypt.tex /^  {                   % THESE headers.$/;"    s
#::B    external/chromium_org/third_party/JSON/JSON-2.59/blib/lib/JSON/backportPP/Compat5005.pm /^    sub B::SVp_IOK () { 0x01000000; }$/;" s
#::B    external/chromium_org/third_party/JSON/JSON-2.59/blib/lib/JSON/backportPP/Compat5005.pm /^    sub B::SVp_NOK () { 0x02000000; }$/;" s
#::B    external/chromium_org/third_party/JSON/JSON-2.59/blib/lib/JSON/backportPP/Compat5005.pm /^    sub B::SVp_POK () { 0x04000000; }$/;" s
</pre>

<p>那几段打 ！ 应该是注释（我不会 ctags 的语法，自己猜的），然后下面应该是真实的记录函数、变量位置的数据了。那么前面那几段感觉就怪怪，于是我尝试把那几段删掉，果然 vim 里面的跳转就能用了。</p>
<p>有些时候就要多猜，呵呵。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20virtual%20box%20%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</loc>
    <lastmod>2015-01-19T02:14:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu virtual box 问题小结</title>
        <pubTime>2015-01-19T02:14:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="usb">usb</h2>
<p>要在虚拟机中使用 usb 设置（烧录接口）： </p>
<ul>
<li><p>需要先安装 Extension Pack（注意版本要和 virtual box 的版本对应）。最好去虚拟机里把 guset addiations 也装了。</p>
</li>
<li><p>查看下 /etc/group ，看看自己的用户有没有在 vboxusers 这个组下面，如果没在的话，把自己的用户加到这个用户组下面： usermod -a -G group1 user1</p>
</li>
<li><p>在 Settings —&gt; Usb —&gt; Enable USB Controller (USB 2.0) 都勾上。</p>
</li>
</ul>
<p>然后在虚拟机的 Usb devices 下面就可以勾选要使用的 usb 设置了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%20Patch%20%E8%A1%A5%E4%B8%81/</loc>
    <lastmod>2015-01-19T02:12:16.000Z</lastmod>
    <data>
        <display>
        <title>如何生成 Patch 补丁</title>
        <pubTime>2015-01-19T02:12:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>一般有 2 种方式：</p>
<h2 id="2个文件夹生成_patch">2个文件夹生成 patch</h2>
<p>在2个文件夹之前生成 patch 使用 diff -Nur a b 命令（a、b 2个文件夹）。注意，这样生成 patch 的时候，要把一些不需要的临时文件清理掉（例如 tag、编译的中间文件等），这样才能保证 patch 是干净的。可以重定向到 xx.patch 文件，这样 patch 就生成好了。</p>
<h2 id="git_仓库不同版本生成_patch">git 仓库不同版本生成 patch</h2>
<p>在 git 仓库的不同版本间生成 patch 使用 git diff commita commitb 命令。commit 是每个 git 版本的那一串很长的数字。不过注意这个只能比较已经提交了的。例如说，这个命令如果什么都参数都不加的话，就是比较当前 git 版本和现在 git 仓库代码的区别。不过如果你当前新加入了一些文件，是 diff 不出来的，需要提交以后才能 diff 。这个也是可以通过重定向到 xx.patch 文件的。</p>
<h2 id="git_commit_修改了二进制文件">git commit 修改了二进制文件</h2>
<p>上面那个 git diff 生成的 patch 是普通的文本 patch，用 vi 就可以看到 patch 的内容。但是这种方式不适用于修改了二进制文件的提交（例如修改了图片）。这种文本 patch 无法包含二进制文件的修改的。所以这个时候就使用：</p>
<pre>
git diff --binary commita commitb > xx.patch 
</pre>

<p>来生成二进制形式的 patch。这种 patch 要使用 git apply patch 来打。打之前可以使用 git apply —check patch 来检测 patch 是否有错误。有些时候打 patch 会出现一些空白符号的警告错误，不用理会就行。</p>
<p>有些时候 git diff a b 生成的 patch 会有点不对（你不加 binary 去看 patch 能看出来，patch 多改了一些东西）。如果只是单个 commit 的 patch 可以使用:</p>
<pre>
git show --binary commit > xx.patch
</pre>

<p>来生成 patch，这样就对了（其实只要能打出 diff 的命令都可以生成 patch）。</p>
<h2 id="总结">总结</h2>
<p>以上 2 种方式打出来的 patch 都是 p1 的，还有这个 px 的问题，需要在打 patch 的时候注意。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%9D%99%E6%80%81%E5%BA%93%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</loc>
    <lastmod>2015-01-19T02:07:16.000Z</lastmod>
    <data>
        <display>
        <title>交叉编译静态库常见问题</title>
        <pubTime>2015-01-19T02:07:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>交叉编译静态库，会遇到一些比较郁闷的问题，现在总结一下。</p>
<h2 id="编译库">编译库</h2>
<p>编译静态库的时候，一般不要指定 LDFLAGS 中的 -lxx 去链接某个库（可以设置 -Lxx 链接库的路径）。因为好像指定的话，它老会去链接某些依赖库的 .so（假设之前你这些库都是编成 .a 的）。</p>
<h2 id="编译应用程序">编译应用程序</h2>
<p>编译应用程序的时候，需要以下几个问题：</p>
<ul>
<li><p>这个时候一般需要指定 LDFLAGS 中的 -lxx （这个结合上面说的，可以在编译脚本里定义几个命令：编译库时候 unset xx ，编译应用程序时 export xx）。</p>
</li>
<li><p>注意 -lxx 链接库时的先后顺序。有些时候会出现某些依赖库找不到另外一些依赖库中定义的符号的问题，这个时候就是 -lxx 的顺序不对。动态库是无所谓顺序的，但是静态库一般来说所依赖的库还放到后面去链接。</p>
</li>
<li><p>有些时候就算按照上面的设置了，编应用程序的时候它还是会去链接依赖库的 .so 文件。这个时候可以把依赖库的 .la （所有的，一个不能留）文件移开（但是注意要是重新编译依赖库的时候需要把这些 .la 文件还远回去）。</p>
</li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20%E5%BC%80%E5%90%AF%20ftp%20%E6%9C%8D%E5%8A%A1/</loc>
    <lastmod>2015-01-19T02:03:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 开启 ftp 服务</title>
        <pubTime>2015-01-19T02:03:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="安装vsftpd">安装vsftpd</h2>
<p>直接从源里面安装：</p>
<pre>
sudo apt-get install vsftpd
</pre>

<p>安装完毕后或许会自动生成一个帐户”ftp”，/home下也会增加一个文件夹。<br>如果没有生成这个用户的话可以手动来，生成了就不用了：</p>
<pre>
sudo useradd -m ftp
sudo passwd ftp
</pre>

<p>有”ftp”帐户后还要更改权限：</p>
<pre>
sudo chmod 777 /home/ftp
</pre>

<p>在这个目录下我建立一个文件夹专门保存需要共享的内容</p>
<h2 id="配置文件">配置文件</h2>
<p>通过sudo gedit /etc/vsftpd.conf修改。配置文件比较简单，如下：</p>
<pre config="brush:bash;toolbar:false;">
#独立模式启动
listen=YES

#同时允许4客户端连入，每个IP最多5个进程
max_clients=200
max_per_ip=4

#不允许匿名用户访问，允许本地（系统）用户登录
anonymous_enable=NO
local_enable=YES
write_enable=NO

#是否采用端口20进行数据传输
connect_from_port_20=YES

#生成日志
xferlog_enable=YES

#指定登录转向目录
local_root=/home/ftp/ftp
</pre>

<p>这样，在同局域网的电脑上，用我的IP地址，用帐号”ftp”和对应密码就可以登录了，密码是第一步里面passwd那句指定的。就这样就结束了，请大家拍砖！！对了，更改配置后不要忘了重启ftp服务：</p>
<pre>
sudo /etc/init.d/vsftpd restart
</pre>

<p>此外还有开启关闭服务的命令：</p>
<pre>
sudo /etc/init.d/vsftpd start
sudo /etc/init.d/vsftpd stop
</pre>

]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20libtool%20%E9%94%99%E8%AF%AF/</loc>
    <lastmod>2015-01-19T02:01:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu libtool 错误</title>
        <pubTime>2015-01-19T02:01:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>使用Ubuntu 8.04以上版本的同事在编译咱们的产品的时候可能会遇到类似如下错误：</p>
<pre config="brush:bash;toolbar:false;">
../libtool: line 841: X--tag=CC: command not found
../libtool: line 874: libtool: ignoring unknown tag : command not found
../libtool: line 841: X--mode=link: command not found
../libtool: line 1008: *** Warning: inferring the mode of operation is deprecated.: command not found
../libtool: line 1009: *** Future versions of Libtool will require --mode=MODE be specified.: command not found
../libtool: line 2253: X-g: command not found
../libtool: line 2253: X-Wall: command not found
../libtool: line 2253: X-I/home/cos/target/pc-ths/include: No such file or directory
../libtool: line 2253: X-I/home/cos/build/pc-ths/include: No such file or directory
../libtool: line 2253: X-Wall: command not found
../libtool: line 2253: X-Wstrict-prototypes: command not found
../libtool: line 2253: X-pipe: command not found
../libtool: line 1967: X-L/home/cos/target/pc-ths/lib: No such file or directory
../libtool: line 1967: X-L/home/cos/build/pc-ths/lib: No such file or directory
../libtool: line 2216: X-Wl,-rpath-link=/home/cos/build/pc-ths/lib: No such file or directory
</pre>

<p>我们知道有一种解决方法是在运行autogen.sh和configure后，修改configure生成的libtool文件，将其中的ECHO修改为echo，然后make;make install即可。</p>
<p>在网上找到另外一种方法， 就是用autoreconf代替autogen.sh，方法如下:</p>
<pre>
autoreconf -i
configure
make
make install
</pre>

<p><a href="http://www.gossamer-threads.com/lists/clamav/devel/41623" target="_blank" rel="external">参考网址</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20%E5%AE%89%E8%A3%85%20jdk/</loc>
    <lastmod>2015-01-19T01:59:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 安装 jdk</title>
        <pubTime>2015-01-19T01:59:16.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>install </tag>
         
         <content><![CDATA[<h2 id="10-10">10.10</h2>
<ul>
<li>在 /etc/apt/sources.list 里新建一个源文件：</li>
</ul>
<pre>
deb  http://archive.canonical.com/ubuntu maverick partner
</pre>

<ul>
<li><p>然后 apt-get update —&gt; apt-get install sun-java6-jdk 。</p>
</li>
<li><p>值得注意的是，默认ubuntu10.10已经安装了open-JDK 可以使用java -version命令查看，当前默认使用的JDK是哪个类型的。如果直接卸载了openJDK软件包，再使用java -version命令，系统还是使用的open-JDK，这时需要修改ubuntu默认使用JDK的配置，配置默认Java使用哪个</p>
</li>
</ul>
<pre>
sudo update-alternatives –-config java
</pre>

<p>选择“2”，再查看系统使用java的版本。注意：wordpress不好的地方就是在写代码时，经常会修改代码里的内容，上面在sudo update-alternatives –config java这句，config前面是两个“-”,wordpress会显示为一个长“-”。</p>
<h2 id="13-04">13.04</h2>
<p>更新下 13.04 安装 sun jdk 的方法：</p>
<ul>
<li><p>如果安装了 open jdk 的，要先把 open jdk 卸掉： apt-get purge openjdk*</p>
</li>
<li><p>添加 sun java 源： add-apt-repository ppa:webupd8team/java （如果有问题可以先安装： apt-get install software-properties-common ），然后更新源列表： apt-get update</p>
</li>
<li><p>然后就可以安装 jdk 了： apt-get install oracle-java7-installer（这里装的是7，也可以安装6或是8 oracle-java6-installer, oralce-java8-installer）</p>
</li>
<li><p>如果要卸载之前安装的 sun jdk，用 apt-get purge oracle-java<em> 就行了，不要用 apt-get purge java</em> ，这样能删掉很多别的东西的。</p>
</li>
</ul>
<h2 id="13-10">13.10</h2>
<p>ubuntu 13.10 之后软件源里面就没 oracle-java6-installer 了，但是如果是编译 android 的话，必须要 jdk6 才行。所以只能去 oracle 官网去下载： <a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html#jdk-6u45-oth-JPR" target="_blank" rel="external">oracle jdk6</a>。 我选的是 *.rpm.bin 下载的（下载还必须要注册 oracle 的帐号才能下，恶心）。然后就是手动安装了。</p>
<ul>
<li><p>先是 chmod+x <em>.rpm.bin ，给这个玩意加上执行权限，然后执行一下，会解压出很多 </em>.rpm 包出来，可能这个东西会自动安装的吧，但是在我到机子上报错了，所以我只好手动安装这票 rpm 包了。</p>
</li>
<li><p>先要装 alien (apt-get install alien)，然后用 alien 把这些 rpm 包转化为 deb 包： alien —scripts —keep-version -d *.rpm 。耐心等一下，就会转化好 deb 包。</p>
</li>
<li><p>安装转化好到 deb 包： dpkg -i *.deb 。就终于装好 oracle-jdk-6 了。</p>
</li>
</ul>
<h2 id="14-04">14.04</h2>
<p>android 5.0 以后就必须要 jdk7 才能编译通过了，然后好像其实 open-jdk 也能用了，所以如果一开始什么都没转的话用 apt-get install 装 open-jdk 比较好，啥路径都不要自己设置。但是如果以前就已经装了 sun jdk6 的话就有点的麻烦，话说我搞了半天也没发现要怎么删掉这个东西，其实要删掉很简单，which java 一下就能知道 jdk 的路径，直接过去删掉就没了，但是 /etc/alternatives/ 下面那个链接还在，后来实在不行，就直接把 /etc/alternatives/ 下那些 java* 的软件链接删掉了。然后去上面 oracle jdk 的下载页面把 jdk 下来，然后转化为 deb 包装一下。不过 14.04 上 jdk7 的 deb 包装好后，不会自己设置路径了。</p>
<p>唉，蛋疼。jdk7 装在 /usr/java 下面，有一个 jdk1.7.0_75 ，此外这个目录下还有一个 default 的软链接文件夹。看到这里就知道要怎么搞了吧。在 .bashrc 中增加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> JAVA_HOME=/usr/java/default/</div><div class="line"><span class="keyword">export</span> CLASSPATH=<span class="variable">$CLASSPATH</span>:<span class="variable">$JAVA_HOME</span>/lib </div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>:<span class="variable">$JAVA_HOME</span>/bin</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后命令行下 java 就能用了。不用还有一件蛋疼的事，eclipse 还不认这个，本来我还想怎么设一下，让 eclipse 认的，后面发现 eclipse 报的错是这样的：</p>
<pre>
A Java Runtime Environment (JRE) or Java Development Kit (JDK)
must be available in order to run Eclipse. No Java virtual machine
was found after searching the following locations:
/home/mingming/eclipse/jre/bin/java
java in your current PATH
</pre>

<p>这就好办了么，去 eclipse 目录下（上面那个 /home/mingming/eclipse 就是我 eclipse 的目录），创建一个 jre 的软件链接指向 /user/java/default 就行了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20minicom%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-19T01:57:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu minicom 使用问题总结</title>
        <pubTime>2015-01-19T01:57:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="键盘无法输入">键盘无法输入</h2>
<p>一般来说 每秒位数/奇偶校验/位数 设置成 xxxx 8N1 就可以了的，但是有些时候还是不能输入命令。这个时候可以尝试把 硬件流控制（Hardware Flow Control），软件流控制（Software Flow Control） 关掉（设置成 off），就可以输入了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/ubuntu%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</loc>
    <lastmod>2015-01-19T01:54:16.000Z</lastmod>
    <data>
        <display>
        <title>ubuntu 使用问题总结</title>
        <pubTime>2015-01-19T01:54:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<h2 id="激活_root_账号">激活 root 账号</h2>
<p>默认 root 账号是不能切换和登陆的，只能用 sudo 来了临时获取一个命令的 root 执行权限。有些时候为了方便可以激活 root</p>
<p>账号。 sudo passwd root ，设置一个密码就可以了。</p>
<h2 id="中文输入安装之后无法调出">中文输入安装之后无法调出</h2>
<p>安装了 ibus 无法调出，一般是 ibus demon 没启动，然后输入法也没设置为中文。ibus-setup 可以调出输入法设置，然后把</p>
<p>中文输入法设置好。不过要想个办法让 ibus demon 自动启动（没启动的，ibus-setup 守护进程就启动了）。可以装一个 im-swtich 然后设置默认输入法为 ibus</p>
<h2 id="自动挂载_ntfs_分区">自动挂载 ntfs 分区</h2>
<p>一般来说安装了双系统（window、ubuntu），window 的 ntfs 分区，ubuntu 会默认挂载。可读写，但是无法使用 git 和 repo，因为挂载的权限不太对。同理，移动硬盘的如果也是使用 ntfs 分区的话，也会有这个问题（拿移动硬盘存 android mirror 就会遇到这些问题了）。这个时候可以安装 ntfs-config 这个软件来，然后 sudo 运行，勾选 mount 成可读、写的，然后 auto-config 一下就行了。</p>
<p>然后在 /etc/fstab 会记录 mount 的路径。可以自己编辑的，把自己的 window 分区挂载到自己指定的目录（这个目录要自己提前 mkdir 建好，不然无法挂载的），同理移动硬盘的分区可以自己指定路径的，像下面这样（这样 mount 路径固定，写某些脚本会方便点，不然时不时变一下 mount 路径，烦得很）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/fstab: static file system information.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></div><div class="line"></div><div class="line"><span class="comment">#Entry for /dev/sdc7 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">0</span>cc75462-fe83-<span class="number">4928</span>-bdd9-<span class="number">514750</span>e91f7f   /   ext4    <span class="variable">errors=</span>remount-ro   <span class="number">0</span>   <span class="number">1</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_gpt3 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">5</span>f0a43bf-<span class="number">72</span>d5-<span class="number">45</span>f1-<span class="number">9</span>c66-c5a355ca454a   /boot   ext4    defaults    <span class="number">0</span>   <span class="number">2</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_gpt1 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">6483</span>-<span class="number">74</span>C9  /boot/efi   vfat    defaults    <span class="number">0</span>   <span class="number">1</span></div><div class="line"><span class="comment">#Entry for /dev/sdc8 :</span></div><div class="line"><span class="variable">UUID=</span>b2317adb-c3a3-<span class="number">4608</span>-af58-<span class="number">78</span>b9d8a836dd   /home   ext4    defaults    <span class="number">0</span>   <span class="number">2</span></div><div class="line"><span class="comment">#Entry for /dev/sdc6 :</span></div><div class="line"><span class="comment">#UUID=F084F63784F60040  /media/BIOS_RVY ntfs-3g defaults,locale=en_US.UTF-8 0   0</span></div><div class="line"><span class="comment">#Entry for /dev/sdc2 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">5046</span>ED5746ED3DFA   /media/local/collect    ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/sdc4 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">64</span>C626E5C626B768   /media/local/game   ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_data2 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">32</span>D67187D6714BDB   /media/local/ssd    ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/mapper/isw_ebgeghbdjj_ssd_gpt4 :</span></div><div class="line"><span class="comment">#UUID=E6C0F9E8C0F9BF3D  /media/local/win    ntfs-3g defaults,locale=en_US.UTF-8 0   0</span></div><div class="line"><span class="comment">#Entry for /dev/sdc3 :</span></div><div class="line"><span class="variable">UUID=</span>BAC60DBFC60D7D3F   /media/local/work   ntfs-<span class="number">3</span>g defaults,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span> <span class="number">0</span>   <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#Entry for /dev/sdd3 :</span></div><div class="line"><span class="variable">UUID=</span>E214EC8C14EC64CF   /media/removable/media  ntfs-<span class="number">3</span>g defaults,nosuid,nodev,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span>    <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/sdd2 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">27</span>E4DC5E2CC9645D   /media/removable/other  ntfs-<span class="number">3</span>g defaults,nosuid,nodev,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span>    <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="comment">#Entry for /dev/sdd1 :</span></div><div class="line"><span class="variable">UUID=</span><span class="number">66118</span>DF048E7A1EE   /media/removable/work   ntfs-<span class="number">3</span>g defaults,nosuid,nodev,<span class="variable">locale=</span>en_US.UTF-<span class="number">8</span>    <span class="number">0</span>   <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#Entry for /dev/sdc5 :</span></div><div class="line"><span class="variable">UUID=</span>d1143252-<span class="number">352</span>a-<span class="number">4</span>c36-<span class="number">8560</span>-d35c8661089a   none    swap    sw  <span class="number">0</span>   <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#UUID=F084F63784F60040  /media/BIOS_RVY ntfs-3g defaults,locale=en_US.UTF-8 0   0</span></div></pre></td></tr></table></figure>

<p>然后注意下 UUID 不要去动 ntfs-config 自动生成的（UUID 是每一个硬盘分区的识别号），当然如果生成有错误，可以用下面2个命令查看：</p>
<pre>
blkid -s UUID

ls -l /dev/disk/by-uuid
</pre>

<p>然后有些时候 window 的 ntfs 分区会挂载失败，然后出来下面的错误：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/ubuntu-memos/unable-mount.png" alt="" title="挂载错误"></p>
<p>这个时候可以用 sudo ntfsfix -d xx（xx 就是图中报错的那个 device： /dev/sdc3，这个用上面那个2个命令也可以看得到的）。一般来说输出修复成功就可以挂载了。如果还是实在不行，网上有人话说是因为 win8 的快速启动导致 ntfs 分区没有被 window 完全卸载导致的。实在不行，尝试把 win8 的快速启动关掉吧。</p>
<h2 id="vpn_无法连接">vpn 无法连接</h2>
<p>ubuntu 一安装好就可以直接新建 PPTP 方式的 vpn 的（点右上角的网络连接的 vpn 配置那里）。除了记得设置 Advanced 那里按下面的设置：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/ubuntu-memos/vpn-config-adv.png" alt=""></p>
<p>把 IP、用户名和密码设置好后，一般就能连上了。不过有些时候有点蛋疼，怎么也连不上，刚开始以为是什么 vpn PPTP 的什么软件没装，搞了半天还是没用。后面无意发现设置 General 那里有一个 <strong>允许所有用户连接</strong> 的选项（默认一般是勾上的），不知道什么时候没勾上，勾上后就可以连了。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/ubuntu-memos/vpn-all-users.png" alt=""></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/%E4%BD%BF%E7%94%A8%20pkg-config/</loc>
    <lastmod>2015-01-19T01:51:16.000Z</lastmod>
    <data>
        <display>
        <title>使用 pkg-config</title>
        <pubTime>2015-01-19T01:51:16.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>shell </tag>
         
         <content><![CDATA[<p>有的使用了共享库的程序，在编译和连接时都很顺利，但是在运行时却发生了找不到共享库的问题，其原因就是库的搜索路径没有设置，或者设置不正确。一般来说，如果库的头文件不在 /usr/include 目录中，那么在编译的时候需要用 -I 参数指定其路径。由于同一个库在不同系统上可能位于不同的目录下，用户安装库的时候也可以将库安装在不同的目录下，所以即使使用同一个库，由于库的路径的 不同，造成了用 -I 参数指定的头文件的路径也可能不同，其结果就是造成了编译命令界面的不统一。如果使用 -L 参数，也会造成连接界面的不统一。编译和连接界面不统一会为库的使用带来麻烦。</p>
<p>为了解决编译和连接界面不统一的问题，人们找到了一些解决办法。其基本思想就是：事先把库的位置信息等保存起来，需要的时候再通过特定的工具将其中 有用的信息提取出来供编译和连接使用。这样，就可以做到编译和连接界面的一致性。</p>
<h2 id="pkg-config">pkg-config</h2>
<p>其中，目前最为常用的库信息提取工具就是下面介绍的 pkg-config。pkg-config 是通过库提供的一个 .pc 文件获得库的各种必要信息的，包括版本信息、编译和连接需要的参数等。这些信息可以通过 pkg-config 提供的参数单独提取出来直接供编译器和连接器使用。</p>
<p>在默认情况下，每个支持 pkg-config 的库对应的 .pc 文件在安装后都位于安装目录中的 lib/pkgconfig 目录下。例如，我们在上面已经将 gstreamer 安装在 /usr/lib/gstreamer 目录下了，那么这个 gstreamer 库对应的 .pc 文件是 /usr/lib/pkgconfig 目录下一个叫 gtreamer-0.10.pc 的文件。</p>
<pre config="brush:bash;toolbar:false;">

prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include/gstreamer-0.10
toolsdir=${exec_prefix}/bin
pluginsdir=${exec_prefix}/lib/gstreamer-0.10
gstcontrol_libs=-lgstcontrol-0.10

Name: GStreamer
Description: Streaming media framework
Requires: glib-2.0, gobject-2.0, gmodule-no-export-2.0, gthread-2.0, libxml-2.0
Version: 0.10.18
Libs: -L${libdir} -lgstreamer-0.10
Cflags: -I${includedir}

</pre>

<p>大概可以看得出是怎么回事了。</p>
<h2 id="使用方法">使用方法</h2>
<p>使用 pkg-config 的 —cflags 参数可以给出在编译时所需要的选项，而 —libs 参数可以给出链接时的选项。例如，假设一个 sample.c 的程序用到了 gstreamer 库，就可以这样编译：</p>
<pre config="brush:bash;toolbar:false;">

//先这样编译（注意是键盘上数字键1旁边的`，不是单引号'）：
$ gcc -c `pkg-config --cflags gstreamer-0.10` sample.c

//然后这样链接：
$ gcc sample.o -o sample `pkg-config --libs gstreamer-0.10`

//或者上面两步也可以合并为以下一步：
$ gcc sample.c -o sample `pkg-config --cflags --libs gstreamer-0.10`

</pre>

<p>可以看到：由于使用了 pkg-config 工具来获得库的选项，所以不论库安装在什么目录下，都可以使用相同的编译和连接命令，带来了编译和连接界面的统一。使用 pkg-config 工具提取库的编译和连接参数有两个基本的前提：库本身在安装的时候必须提供一个相应的 .pc 文件。不这样做的库说明不支持 pkg-config 工具的使用。</p>
<p>pkg-config 必须知道要到哪里去寻找此 .pc 文件。一般来所某些库会指定一个环境变量来寻找 .pc 文件，例如gstreamer就是哟你 PKG_CONFIG_PATH 来寻找的。可以用 export PKG_CONFIG_PATH=XX 设置 .pc 文件的路径。</p>
<h2 id="我的makefile">我的makefile</h2>
<p>这样一来我之前用的makefile模板就可以改成这样啦：</p>
<pre config="brush:bash;toolbar:false;">
#This Makefile is created by mingming-killer

SRCS := $(wildcard *.c)
DEPS := $(SRCS:.c=.d)
OBJS := $(SRCS:.c=.o)

APP = app


CC = gcc
LDFLAGS = `pkg-config --libs gstreamer-0.10` -L$(LIB_PATH) $(LIBS)
CFLAGS = `pkg-config --cflags gstreamer-0.10` -I$(INCLUDE_PATH)
LIBS = -lpthread -lminigui_ths -lm -ljpeg -lpng
LIB_PATH = /usr/local/lib
INCLUDE_PATH = /usr/local/include


# if "make clean" do not create the depend file
ifneq ($(MAKECMDGOALS), clean)

%d: %c
    $(CC) -MM $< > $@

endif



$(APP): $(OBJS)
    $(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)


-include $(DEPS)




.PHONY: clean 
clean:
    -rm -f debug $(APP) $(wildcard *.o ./tmp/*.d *.d *~)
    @echo "it is cleaning."
</pre>

<p>autoconf、automake的工具暂时还不会用，又不像mg-sample那样可以替换里面的文件来直接使用，而且又只是小程序，所以还是用个makefile来搞定吧 ^_^ 。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/19/BBK%20%E5%B7%A5%E4%BD%9C%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-18T16:01:16.000Z</lastmod>
    <data>
        <display>
        <title>BBK 工作编译脚本分析</title>
        <pubTime>2015-01-18T16:01:16.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>shell </tag>
         
         <content><![CDATA[<p>在 bbk 搞 apk 开发，通常一个人要用 N 个仓库，但是又不让 repo ，所以就搞了这个东西，还是借鉴了以前的在搞 MiniGUI 的脚本。</p>
<p>之前我们大家一起摸索出一套在服务器上统一编译 apk 的方法。服务器上的编译是由一个脚本来执行的，这样能够省很多事情。我们本机，如果相关的仓库不多的话，可以手动编译，但是如果相关的仓库很多的话，手动就很麻烦了。这几天抽了点时间，参看了下服务上的编译脚本，自己整理出一套适用于本机的编译脚本。拿出来和大家分享一下，不对的地方欢迎指正。</p>
<h2 id="功能">功能</h2>
<p>首先先确定下想要什么功能。我想要的功能是：</p>
<ol>
<li>一个命令，能帮我把我想要的仓库全都 clone 下来。</li>
<li>一个命令，能帮我把我想要的仓库全部更新。</li>
<li>一个命令，能帮我把我想要的仓库全部切换到指定的版本。</li>
<li>一个命令，能帮我把我的模块全部编译出来。</li>
</ol>
<h2 id="工作环境配置文件（-inc）">工作环境配置文件（.inc）</h2>
<p>根据上面的几个需求，开始打造我们的脚本。首先我们设定一个编译环境：不同的编译环境，环境变量不同，不同的编译环境，彼此不影响。这样的话，对于多个项目就很方便。例如说：有一个项目叫 H8，另外一个叫 H9 。可以先在 H8 中工作，后来因为需要，要切换到 H9 。打造不同的环境能够方便在多个项目中自由的切换。这样的话，就设计一个工作环境配置，然后用一个命令去读取这个配置，并且按照这个配置设置环境。我把配置文件放到在 home 目录的 /bin/inc 下面（注意这里是 linux 下的环境，不是 window 的，window 下可以用 cygwin 来模拟 linux 的环境）。这里还有一个约定，要把 home 目录下的 bin 文件夹设到环境变量里面去，这样这个下面的脚本可以在任何路径下被访问到（我的脚本放在这个目录下）。这个可以在 .bashrc 中设置一下：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/1.png" alt=""></p>
<p>先来看看环境配置文件的信息：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/2.png" alt=""></p>
<p>我定义了下面几个可以配置的环境变量：</p>
<ul>
<li><p><strong>BUILD_PATH:</strong><br>工作环境目录。这个是这个配置对应的工作环境的目录，这里假设这个工作环境叫 test（对应配置文件为 test.inc）。这个目录是我本机 cygwin 的目录。</p>
</li>
<li><p><strong>CONFIG_PATH:</strong><br>工作环境配置目录。这个目录下放置一些工作环境的配置文件（后面会介绍有哪些配置）。这里设置的是在 <code>BUILD_PATH</code> 下面的 config 文件夹。</p>
</li>
<li><p><strong>TARGET_REPO_PREFIX：</strong><br>目标仓库前缀。就是我们的仓库地址（以及每个人的账号）。从仓库 URL 可以看得出，仓库的前缀是一样的，只有后面的路径不一样而已。</p>
</li>
<li><p><strong>ANDROID_CMD：</strong><br>android sdk 命令设置。这个是为了兼顾 linux 和 window 而设置的变量。linux 下，直接使用 android 就可以调用，window 下是 android.bat 。</p>
</li>
<li><p><strong>ERROR_OUTPUT:</strong><br>错误信息输出文件。用来保存错误信息，方便查看。这里配置的是 CONFIG_PATH 下面的 error 文件。</p>
</li>
<li><p><strong>MESSAGE_OUTPUT：</strong><br>信息输出文件。（这个暂时没用到）</p>
</li>
<li><p><strong>TARGET_REPOS：</strong><br>目录仓库配置文件。就是自己模块的以及自己模块相关（依赖）的仓库列表文件。脚本会去读这个列表文件。这里配置的是 <code>CONFIG_PATH</code> 下面的 target_repos 文件。</p>
</li>
<li><p><strong>BUILD_REPOS:</strong><br>编译仓库配置文件。由于一些仓库有多级目录，所以这个和 <code>TARGET_REPOS</code> 有点不一样。这里配置的是 <code>CONFIG_PATH</code> 下面的 <code>build_repos</code> 文件。</p>
</li>
<li><p><strong><code>BUILD_LIB_REPOS</code>:</strong><br>编译 LIB 配置文件。有些时候不想编译全部的模块，只要编一个就行了，但是需要先把 jar 先编出来，这个是只编译自己依赖的 jar 仓库的。这里配置的是 <code>CONFIG_PATH</code> 下面的 <code>build_lib_repos</code> 文件。</p>
</li>
<li><p><strong><code>COPY_LIBS_PATH</code>:</strong><br>某些 jar 仓库编译比较麻烦，所以服务器上会帮我们编译好，这个时候我们可以偷懒，直接去用服务上编出来的 libout （像 contentview、词典的 jar）。这个路径下放置已经编译好的 jar ，脚本编译的时候会去把这个路径下的 jar、so copy 到 libout 下，当做已经编译好了的。不过要注意一点，切换版本的时候，注意这个下面的库要和你切换的版本对应。也就是说切换版本的时候，记得更换这目录下的 jar 。当然如果你不偷懒，所有的仓库都自己编译，就不需要注意这一点了。这里配置的是 <code>CONFIG_PATH</code> 下面的 <code>copy_libs</code> 文件夹。</p>
</li>
</ul>
<p>上面这段配置文件作用很明显了，导出几个变量到当前 shell 环境中，然后打印一下这些值，最后自动进入设置好的当前环境工作目录。</p>
<h2 id="工作环境切换脚本（sw）">工作环境切换脚本（sw）</h2>
<p>切换工作环境脚本放到 /bin 下面：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/3.png" alt=""></p>
<p>前面说了，在 .bashrc 中把 home 目录下的 \bin 加入到环境变量中，这样 \bin 下面的 sw （switch）脚本就能被找到。这个脚本接收一个参数，使用方式如下：</p>
<pre>
$ sw test
</pre>

<p>后面那个参数就是你要切换的工作环境的名字。例如说这里的 test （假设这里的工作环境叫 test，你也可以叫 H8、H9 之类的）。上面脚本第一段是判断下参数是否合法（不为空，只有一个参数）。</p>
<p>如果不合法的话，就打印一段提示，告诉使用者用法。如果合法的话，就会进入到 home 目录下的 /bin/inc 下（前面说，我把工作环境配置文件放到这个目录下，如果你要添加新的工作环境，在这个目录加新的配置文件就可以了）。配置文件以 .inc 为后缀（模板在前面说过了）。然后就在 /bin/inc 下查找匹配输入参数的配置文件。例如我上面输入的是 sw test，那么就会去查找 test.inc ，如果没找到就提示没找到。如果找到了的话：</p>
<ol>
<li>导入（读取）配置文件的内容（source $INCFILE 就是干这件事的）。这里会把配置文件里面定义的环境变量都导出到当前 shell 环境中。</li>
<li>改变当前 shell bash 的显示，把切换的环境变量的名字作为 bash 的显示，这样就能清楚的知道自己是在哪个工作环境下面了。并且重新开启一个 bash。上张效果图： ^_^</li>
</ol>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/4.png" alt=""></p>
<p>当你想退出当前工作环境的时候，输入 exit 就可以，或者可以直接 sw xx 切换到另外一个工作环境。</p>
<h2 id="仓库配置文件">仓库配置文件</h2>
<p>这个就是上面的 .inc 文件中指定的那3个仓库列表文件。服务器上的是上次郭跃华收集的依赖关系然后用一个小程序生成出来的。我们本机自己的仓库没那么多，而且也没那么复杂，所以这里我就采用了比较原始的办法，自己手动写。</p>
<p>自己把自己的模块以及依赖关系整理出来（你自己肯定知道，自己都不知道的面壁去），然后按照依赖关系（编译顺序）写成一个列表（其实 TARGET_REPOS 不需要按照这个顺序写的）。拿我负责的3个模块来看看吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/5.png" alt=""><br><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/6.png" alt=""></p>
<p>上边的是我配置的 TARGET_REPOS ，下边的是 BUILD_REPOS。可以看到其实差别就只是在于那些有多级目录的仓库而已。这里写的有3个模块：闹钟、听力测试和中学视频课堂，上面的是依赖库。最后上的那部分是 jar 依赖库，中的是 project 依赖库。其实这里并不是完整的依赖关系，省掉了 contentview.jar 和 dict.jar 的仓库及其依赖仓库。前面也说了，某些 jar 比较难编译（其实就是依赖的东西多），可以偷懒直接用服务器编出来的。这里就直接使用了服务器编译出来的 contentview.jar 和 dict.jar（还带了几个 so）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/7.png" alt=""></p>
<p>不过前面也说了，偷懒的话要注意，切换版本的时候，这几个 jar 和 so 要记得自己换成对应版本的。如果不偷懒，全都自己编的话，就不用担心版本问题了，脚本会帮你统一切换的。各有利弊，大家自己衡量吧。</p>
<h2 id="命令脚本（bbk_mk）">命令脚本（bbk_mk）</h2>
<p>这个脚本是主要部分了，和前面的 sw 一样，放到 home 目录的 /bin 下面（bbk makefile ?? 其实这个名字我也是随便取的，大家可以改成自己喜欢的）。先来看看脚本的入口：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/8.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/9.png" alt=""></p>
<ol>
<li><strong>co(clone)：</strong> clone 配置文件列表中所有的仓库。</li>
<li><strong>de(delete)：</strong> 删除配置文件列表中所有的仓库（删除哦，使用前要慎重考虑下）。</li>
<li><strong>up(update)：</strong> 更新配置文件列表中所有的仓库。</li>
<li><strong>rc(recover)：</strong> 恢复配置文件列表中所有的仓库。</li>
<li><strong>sw(switch)：</strong> 将配置文件列表中所有的仓库切换要指定版本。</li>
<li><strong>lo(local)：</strong> 本地化配置文件列表中所有的仓库（其实就是执行 android update project，但是这个命令本质上是生成一些本地的环境变量，所以我给它取名为本地化）。</li>
<li><strong>cl(clean)：</strong> 清除所有仓库的编译结果（包括 libout、apk 以及每个仓库中的 libs、bin、gen、obj 文件夹）</li>
<li><strong>bu(build)：</strong> 编译配置文件列表中所有的仓库（编译之前你要确定你已经调用过 lo 命令了）。</li>
<li><strong>lb(lib)：</strong> 编译 lib 库配置文件列表中所有的仓库（这个和上面的区别仅仅是只编译 \lib 下面的仓库而已，其实是由你指定的那个配置文件决定的）。</li>
</ol>
<p>这个脚本的用法是这样的：</p>
<pre>
$ bbk_mk command params
</pre>

<p>例如说要 clone 所有的仓库就敲 bbk_mk co，要切换到某一个分支就敲 bbk_mk sw branch ，要编译所有的仓库就敲 bbk_mk bu 。</p>
<p>上面这8条命令的功能就囊括了我最开始想要要的功能。下面就来看看是怎么实现些功能的吧。</p>
<p>这个脚本确实挺简单的，跑的就只是右边那个 if eles 语句而已。那个语句也是先判断下传入的参数是否合法（必须要有1个以上的参数，并且这个参数不为空）。不合法的话，给出提示（func_tip）。合法的话，就根据不同的命令（第一个参数），执行不同的功能。其实大家看到了，这里所有的功能都是调用一个函数来完成的，从这个函数的命令大概可以猜得到这个函数是干什么的。func_do_trav_repos 这个函数就是遍历所有的仓库列表，然后做某一件事情。</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/10.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/11.png" alt=""></p>
<p>上面就是 func_do_trav_repo 的实现。左边开始的一段可以看做是预处理， lo(local), cl(clean), bu(build) 这3个命令用的仓库配置文件是 BUILD_REPOS， lb(lib)用的是 BUILD_LIB_REPOS，其它的命令用的是 <code>TARGET_REPOS</code>。根据前面说明就知道为什么要这样。然后 cl(clean) 命令要执行一个 <code>func_clean_output</code> 函数，这个函数就是去删除 libout, apk 目录，比较简单我就不贴出来了。bu(build) 和 lb(lib) 命令要执行一个 func_copy_libs 函数，这个函数就是去 copy 那个方便偷懒的从服务器上弄下来的 jar、so 到 libout 下面的，也是比较简单，我也不贴了。后面就是删除上一次的错误输出文件。</p>
<p>然后后面这句 cat $target_file | while read path ，前面一半就是去读取指定配置文件（linux 的 cat 命令），后面一半是把前面一半读出来的每一行做为 while 循环的输入。循环体里面为了在配置文件中支持空行和注释（以”#”开头），用了一个 case 做判断。当读到有效数据的时候就把当前的累加计数、命令、仓库路径，原始路径，命令参数传给 func_do_tarv_repos_impl（原始路径在执行命令开始的时候使用 $PWD 保存的）。这个函数又根据不同的命令做不同的事情。</p>
<p>func_clone_impl： co 命令的实现：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/12.png" alt=""></p>
<p>首先判断下当前工作命令下 lib, libproject, project 这3个目录存在存在，不存在的话就创建。这里是为了和服务器的目录结构保持一致。服务器是用 repo 的，所有不需要手动做，我们本地悲剧点，就只能手动了 -_-|| 。然后下面那段判断也是为了和服务器的目录结构保持一致，判断传递过来的仓库路径是以什么开头的。看看前面定义的仓库配置文件，就会发现有很明显的规律，/lib/xx 的是放在 lib 目录下的，/libproject/xx 的是放在 libproject 目录下的， /project/xx 是放在 project 目录下的。这里使用了 linux 下的一个命令 expr 进行简单的正则表达式匹配。expr match string 返回值代表匹配个数，而匹配表达式最前面的 ^ 表示匹配最开始的部分。这么解释这里就很容易理解了，例如： if [ $(expr match $path “^/lib/“) = 5 ] 就 $path 这个路径，最开头的5个字符是 /lib/ 那么这样就可以判断这个仓库是在 lib 目录下的。根据上面判断出不同的目录，进入到想要的目录，然后在这里执行 git clone 命令。至于完整的仓库路径就是：前缀（就是前面配置里写的，每个人的都不一样，用户名不同） + 路径（也是配置文件里读的）。这里注意一点，要想让脚本顺便的执行 clone 命令，如果你的 private key（私钥）是带密码的，是需要输密码的，可以使用 ssh 代理来帮你输密码（eval <code>ssh-agent</code>, ssh-add），不然的话，每一个仓库敲一次密码就和手动 clone 没啥区别了。当然如果你的 private key 没密码，就不用管。执行完一次 clone 命令后，重新回到原来的目录下面。</p>
<p>这样 clone 下面的仓库目录结构就和服务器上的是一样的。上张效果图： ^_^</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/13.png" alt=""></p>
<p>func_update_impl： up 命令的实现：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/14.png" alt=""></p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/linux/BBK-make/15.png" alt=""></p>
<p>这个其实很简单，就是 git pull 命令。只不过加了个错误检测而已。错误检测的做法是：</p>
<ol>
<li>先将错误输出流（linux 有12个文件描述符，系统使用的是 0、1、2，分别代表标准输入、输出和错误，自己可以使用的是 3~9）重定向到我们指定的错误文件中（ERROR_OUTPUT）。具体做法是：先拿 4 号文件符临时保存错误输出，然后把错误输出重定向到错误文件中，然后再把原来保存错误输出的 4 号文件重新定向到错误输出（就是恢复一下原来的错误输出）。</li>
<li>func_check_error 在错误文件中使用 grep 命令查找是否有 Error、error、fatal、BUILD FAILED 这些关键字，如果有的话就认为有错误的，返回 1，如果没错误就返回 0。</li>
<li>根据 func_check_error 的返回值来判断，如果有错误就退出脚本执行，并且打印出错误信息，没错误就继续执行。</li>
</ol>
<p>后面那几个 func_switch_impl、func_local_impl、func_build_impl 都是和这个差不多的，大家自己去看下具体的脚本文件就知道了。我自己感觉用起来还是不错的，大家要就觉得好用可以拿去用。</p>
<p>要是觉得有什么可以改进的地方欢迎提出来。</p>
<p>额，最后说一句：这个是基于 linux 下的 bash shell 脚本，在 linux 下可以使用（废话），window 下 cygwin 也可以使用（相应的软件包要齐全，git、ssh、grep、expr 要装好）。</p>
<p>来个附件： 附件里带的有上面写的脚本，还有例子中的配置文件，大家可以拿去玩一下。</p>
<p><a href="http://pan.baidu.com/s/1eQy2S1c" target="_blank" rel="external">本机编译脚本分享</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/18/Linux%20Shell%20%E8%BF%9B%E9%98%B6%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-18T15:44:16.000Z</lastmod>
    <data>
        <display>
        <title>Linux Shell 进阶环境脚本分析</title>
        <pubTime>2015-01-18T15:44:16.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>shell </tag>
         
         <content><![CDATA[<p>之前编译环境脚本是用候哥的，简单方便。不过有个缺点就是如果要特别指定一些配置的话，不太方便，需要每次都自己去设置。最近从其志那弄了个高级点的，据说源头是万哥那个的 -_-|| 。来看下吧。</p>
<h2 id="用法">用法</h2>
<p>在分析脚本之前先说说用法吧，很简单：</p>
<pre>
/* 切换编译环境 */
sw xx

/* autogen */
cfg
make
make install

/* cmake */
cm
make
make install
</pre>

<p>然后终端显示会相应的变成 xx 。这就表示已经设置成 xx 的编译环境了。</p>
<h2 id="sw-sh">sw.sh</h2>
<pre config="brush:bash;toolbar:false;">
#! /bin/bash

#check weather exe
if [ "$1" = "" -o $# -ne 1 ]; then
echo "Usage: $0 <target_name>"
echo "  target_name: build target name"
exit 1
else
cd /home/mingming/bin/inc

INCFILE="$1.inc"

#check file
INCFILE=`find . -iname $INCFILE`
if [ "$INCFILE" = "" ]; then
echo "Can't find the path: $INCFILE."
exit 1
fi
echo "Found match path: $INCFILE"
echo "Setting $1 env ..."
echo 

export TARGET_NAME=$1

#set env
export PS1="\[\033[01;35m\]$1\[\033[01;34m\] \w \$\[\033[00m\] "
source $INCFILE
fi

#/bin/bash
</target_name></pre>

<p>这个脚本很短，也比较容易理解。它会把输入的第一个参数（就是 sw xx 的 xx），作为这个编译环境的名字。然后去 /home/mingming/bin/inc 下去找对应的环境配置文件： xx.inc 。这个路径可以自己指定。如果找不到就报错。找到后就把这个名字 export 一下，后面的配置文件会用到的。然后把终端显示相应的改成编译环境的名字。最后读入配置文件的信息。</p>
<h2 id="inc">inc</h2>
<p>我的配置文件放在 /home/mingming/bin/inc 下，一般新建一个编译环境，就只要新写一个配置文件就可以了。现在来看看一个比较简单的 MiniGUI PC 上的线程版的配置文件吧：</p>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

#cfg
export minigui_configure_flags="\
--with-ttfsupport=ft2 \
--enable-ttfcache \
--enable-jpgsupport \
--enable-pngsupport \
--disable-dlcustomial \
--disable-splash \
--disable-screensaver"

export cmake_minigui_configure_flags="\
-Dwith_osname:STRING=linux \
-Dimage_pngsupport:BOOL=ON \
-Dimage_jpegsupport:BOOL=ON \
-Dwith_fontttfsupport:STRING=ft2 \
-Dfont_ttfenablecache:BOOL=ON \
-Dlicense_splash:BOOL=OFF \
-Dlicense_screensaver:BOOL=OFF \
-Dial_dlcustom:BOOL=OFF"

export mdolphin_configure_flags="\
--enable-focusring_tv"


export minigui_src="${ss}/minigui/rel-3-0"
export mgplus_src="${ss}/mgplus/rel-3-0"
export mgeff_src="${ss}/mgeff/rel-0-8"
export gvfb_src="${ss}/gvfb/trunk"


#env
export PREFIX="${tt}/${TARGET_NAME}"
export pp=$PREFIX
export BUILDPATH="${bb}/${TARGET_NAME}"

export MG_RES_PATH=$ss/res-trunk
export MG_CFG_PATH=$PREFIX/etc
export MG_CFG_FILE=$PREFIX/etc/MiniGUI.cfg
export libs_base="-L$PREFIX/lib -L/usr/local/lib -Wl,-rpath-link=$PREFIX/lib"
export extra_libs="-lpthread -lfreetype -lpng -ljpeg"
export CFLAGS="-g -Wall -I$PREFIX/include -I/usr/local/include"
export CPPFLAGS=$CFLAGS
export CXXFLAGS=$CFLAGS
export LDFLAGS="${libs_base}"
export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
export PATH=$extra_path:$PREFIX/bin:/home/mingming/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
export LD_LIBRARY_PATH="${tt}/${TARGET_NAME}/lib":$LD_LIBRARY_PATH

export CC=gcc
export AR=ar
export RANLIB=ranlib
export HOST=


cd $BUILDPATH
</pre>

<p>这个文件其实很一目了然了。开始的那个几个 flags 是相应设置 MiniGUI configure, MiniGUI cmake 的。如果有别的库需要编译的话，可以多加。后面就是设置安装路径（PREFIX）、CFLAGS、CXXFLAGS、LDFLAGS 等。这里注意下后面几个编译变量：</p>
<ul>
<li>PKG_CONFIG_PATH：这个是设置 pkgconfig 的文件路径，编译一些库必须要指定这个才能正确编译。</li>
<li>PATH：这个是指定一些库的配置脚本的，例如 freetype-config 等，有些库如果要链接另外一个库的话，必须要有这些配置脚本才能正确编译。注意会优先找放在前面的</li>
<li>LD_LIBRARY_PATH：这个是设置链接时候的路径。也是优先找放在前面的。不设置这个的话，很容易老去链接 /usr/lib 或是 /usr/local/lib 下的，交叉编译特别有用。</li>
</ul>
<h2 id="cfg">cfg</h2>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

#. common_flags.inc

echo $PWD |grep minigui > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$minigui_configure_flags $common_minigui_configure_flags"
fi

echo $PWD |grep mgplus > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mgplus_configure_flags $common_mgplus_configure_flags"
fi

echo $PWD |grep mgeff > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mgeff_configure_flags $common_mgeff_configure_flags"
fi

echo $PWD |grep mgutils > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mgutils_configure_flags $common_mgutils_configure_flags"
fi

echo $PWD |grep mgncs > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$ncs_configure_flags $common_mgncs_configure_flags"
fi

echo $PWD |grep mginit > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mginit_configure_flags $common_mginit_configure_flags"
fi

echo $PWD |grep core > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mdolphin_configure_flags $common_mdolphin_core_configure_flags"
fi

echo $PWD |grep mdtv > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$mdtv_configure_flags $common_mdtv_configure_flags"
fi

echo $PWD |grep curl > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$curl_configure_flags $common_curl_configure_flags"
fi

echo $PWD |grep xml2 > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$xml2_configure_flags $common_libxml_configure_flags"
fi

echo $PWD |grep xslt > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$xslt_configure_flags $common_libxslt_configure_flags"
fi

echo $PWD |grep dfb > /dev/null
if [ $? -eq 0 ]; then
FLAGS="$dfb_configure_flags $common_dfb_core_configure_flags"
fi

if [ ! -e configure ]; then
echo autogen.sh
./autogen.sh
fi

cmd="./configure $FLAGS --prefix=$PREFIX $common_configure_flags $*"

echo $cmd
$cmd
</pre>

<p>这个配合前面的 inc 文件也很简单了。它就是把之前 inc 文件里 export 的那些配置变量用到不同的库的 configure 上（如果没有 configure 的话，会先执行 autogen.sh）。不过这里可以看到局限性：就是这个脚本是根据当前的文件名判断应该使用哪个配置变量的。例如你的当前编译目录是： /home/mingming/build/pc-ths/minigui 的话，它就会使用 minigui<em>configure_flags 。所以编译库的文件夹名字不能随便乱取，要和这个脚本的对应。如果要新加的库的话，在这个脚本和加上那几句就可以，还有 inc 文件里也要加上相应的配置变量（不过如果你需要特别的配置的话，可以不加）。这个是简单的，复杂的可以参看附件里交叉编译 ST7167 的 ^</em>^。</p>
<h2 id="cm">cm</h2>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

#. common_flags.inc

echo $PWD |grep cmake_minigui > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$minigui_src"
FLAGS="$cmake_minigui_configure_flags $common_cmake_minigui_configure_flags"
fi

echo $PWD |grep cmake_mgplus > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgplus_src"
FLAGS="$cmake_mgplus_configure_flags $common_cmake_mgplus_configure_flags"
fi

echo $PWD |grep cmake_mgeff > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgeff_src"
FLAGS="$cmake_mgeff_configure_flags $common_cmake_mgeff_configure_flags"
fi

echo $PWD |grep cmake_mgutils > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgutils_src"
FLAGS="$cmake_mgutils_configure_flags $common_cmake_mgutils_configure_flags"
fi

echo $PWD |grep cmake_mgncs > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$mgncs_src"
FLAGS="$cmake_mgncs_configure_flags $common_cmake_mgncs_configure_flags"
fi

echo $PWD |grep cmake_gvfb > /dev/null
if [ $? -eq 0 ]; then
SOURCE="$gvfb_src"
FLAGS="$cmake_gvfb_configure_flags $common_cmake_gvfb_configure_flags"
fi


cmd="cmake $SOURCE -DCMAKE_INSTALL_PREFIX=$PREFIX $FLAGS $common_cmake_configure_flags $*"

echo $cmd
$cmd
</pre>

<p>这个是和 cfg 类似的，只不过是 cmake 的而已。也就是说如果你的库同时支持 autogen 和 cmake，你 inc 文件里就要写2份配置。</p>
<h2 id="注意事项">注意事项</h2>
<p>原来我的 sw.sh 是 sw 的，然后是放在 ～/bin/ 下的，不过后来发现这样，终端显示的名字改变不了。好像是改变后马上又变会 ~/.bashrc 里设置的默认的了。晕～～后来把 sw 改成 sw.sh ，然后放到 ~/build/ 下才算可以正常修改终端的显示名字。真是奇怪，估计和 .bashrc 里哪个冲突了吧，不过我暂时还发现是哪个。</p>
<h2 id="附件">附件</h2>
<p><a href="http://pan.baidu.com/s/1hq6BqWO" target="_blank" rel="external">set.zip</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Linux%20shell%20%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</loc>
    <lastmod>2015-01-13T12:50:16.000Z</lastmod>
    <data>
        <display>
        <title>Linux shell 环境脚本分析</title>
        <pubTime>2015-01-13T12:50:16.000Z</pubTime>
        
        <tag>linux </tag>
         
        <tag>shell </tag>
         
         <content><![CDATA[<p>侯哥之前帮我在编译服务器上弄了个工作环境，vim啊，调试不同的minigui版本都挺好用的。不过总想弄明白这些脚本是咋回事。在不停的提问、百度、google之下，稍微明白了点；赶紧记下来吧，免得又忘记了。</p>
<h2 id="bashrc">bashrc</h2>
<p>目前的工作环境的目录安排是这样的（以下目录分别是在/home/xx/下）：</p>
<ul>
<li>source：源代码存放目录.</li>
<li>build：编译产生的中间文件目录.</li>
<li>target：minigui的库路径.</li>
</ul>
<p>每个不同的minigui版本在source下存放不同的源代码（例如rel－3－0）；在build下用mkdir建立相应的目录（build/rel-3-0），然后build/rel-3-0下有可以建立minigui目录（用于编译此版本的minigui），mg－sample（编译此版本的实例程序）；在target也建立相应的目录（target/rel-3-0）。以上目录建立完成后就可以用命令：</p>
<pre>
envbuild rel－3－0
</pre>

<p>来自动切换到rel－3－0版本的编译环境。此时会自动进入到build/rel－3－0目下。然后可以用lndir命令把source下rel－3－0的源代码链接过来，这样就能保证源代码目录的“干净”（编译都在build下）。把源码链接过来后，就可以用acfg命令配置生成makefile文件；然后用mi命令就编译，把编译好的库安装到相应的target/rel-3-0目录下。之后在build可以把mg－sample的链接过来，然后配置自动生成makefile文件，编译、运行实例程序了（这个时候会链接正确的minigui库哦）。</p>
<p>以上这些功能是怎样通过脚本来实现的呢，那从.bashrc看起吧。</p>
<pre config="brush:bash;toolbar:false;">
ss=/home/mingming/source
bb=/home/mingming/build
tt=/home/mingming/target
ftp=/home/ftp/pub
alias make='make -j5'
alias mc='make clean'
alias mi='make -j5 install'
alias mci='make clean; make -j5 install'
alias cfg='./configure --prefix=${TARGET_CFG}'
alias acfg='./autogen.sh;./configure --prefix=${TARGET_CFG}'
alias acmci='./autogen.sh;./configure --prefix=${TARGET_CFG}; mci'
#alias envbuild=". ${bb}/env.rc $*; cd ${bb}/${TARGET}"
#alias envsource="$ss/cd.sh $*"
alias buildtarget3="${ss}/build-target-3.sh $*"
alias envbuild=". ${bb}/env.sh $*"
alias envtarget=". ${tt}/set-env.sh $*"
alias cpexe="${bb}/cpexe1.sh $*"
export ss bb tt ftp
</pre>

<p>.bashrc这个脚本其实它的很具体的一些的东西我还是不太清楚，但是我目前知道的一点就是它是bash shell的环境配置文件（ubuntu上默认的shell是bash）。在它里面设置的一些环境信息会在用户登录的时候读入到shell中。我们先来看看上面这段.bashrc里的内容。ss、bb、tt分别就是上面我说的建立的source、build、target目录。后面的几个alias就能知道前面的acfg、mi的真正面目啦（alias这个命令看网上的说法应该是定义一个命令的别名，可以说是相当于简写？）。后面就定义了envbuild和envtarget命令啦。这里可以看到envbuild和envtarget还分别用到了build/env.sh和target/set-env.sh，这个2个脚本我们后面再看。这里可以看到这2个命令最后还有一个 $<em> 的符号。我虽然没确切的明白这个符号什么意思，但是我猜应该是传递envbuild xx这个命令后接的所有参数的意思（例如envbuild rel－3－0，那 $</em> 应该就只有一个参数：rel－3－0）。我可是根据后面的脚本这样猜的咧，应该是对的吧。</p>
<h2 id="env-sh">env.sh</h2>
<pre config="brush:bash;toolbar:false;">
#!/bin/sh

if test $# -eq 0; then
echo "target is not specify!"
echo "configure failed!"
exit 1
fi

export TARGET_NAME=$1
export TARGET=$1
TT=$tt
BB=$bb
TARGET_HOME=$TT
DEBUG=$2

if test -z $DEBUG; then
DEBUG="-O2 -Wall"

else
shift
a=""
for i in $@; do
a="$a $i"
echo $a
done
DEBUG=$a
fi

CFLAGS="-I${TARGET_HOME}/${TARGET_NAME}/include $DEBUG" 
CPPFLAGS="-I${TARGET_HOME}/${TARGET_NAME}/include $DEBUG" 
LDFLAGS="-L${TARGET_HOME}/${TARGET_NAME}/lib" 

export CFLAGS CPPFLAGS LDFLAGS
</pre>

<p>env.sh脚本刚开始是一个测试命令。test这个命令，会检测后面的表达式，若条件成立，则由$?返回0值，否则返回非0值（一般是1）；然后if由$?的返回值决定执行流程，若$?为0则执行then后面的语句。这里就可以看得到出这个检测命令的意思就是如果evnbuild后面什么参数（就是你的环境目录啦）都没给的话（$# -eq 0）就会提示错误信息，然后退出。</p>
<p>然后是又定义了几个变量，其中有用到 $1、$2 的值的。这2个我网上查到的信息是第1个和第2个参数的值。这个是env.sh的参数哦，可是我们好像没有显示的给env.sh什么参数啊；但是结合前面envbuild的定义就可以看得出了：env.sh $<em> 。所以我前面猜这个 $</em> 是后面所有参数的意思，这里看来应该是这样了。这里把TARGET_NAME＝$1（我们假设之前的envbuild命令后面接的是rel－3－0），TARGET_HOME＝$TT（TT=$tt）然后后面的：</p>
<pre>
LDFLAGS="-L${TARGET_HOME}/${TARGET_NAME}/lib" 
CFLAGS="-I${TARGET_HOME}/${TARGET_NAME}/include $DEBUG"
</pre>

<p>就可以知道为什么编译mg－sample能够链接到正确的库路径了。这里解析得到的就是：/home/mingming/target/rel-3-0/lib；正好就是之前minigui库的安装路径。如果换成rel-3-0-arena的版本的话，也能正确的找到minigui的库路径。</p>
<p>这里还有个 if test -z $DEBUG 的测试命令。DEBUG＝$2，这个我猜应该是envbuild后接了minigui的版本名字，后面再接一些特定的调试开关命令用的。因为$1是minigui的版本名字。这样就很好理解了，如果你什么调试开关都不写的话（这样test -z $DEBUG就成立），就用默认调试开关DEBUG＝”-O2 -Wall”；否则就将你输入的调试开关赋给DEBUG。然后可以看到CFLAGS最后将DEBUG给拼接上去了。</p>
<pre config="brush:bash;toolbar:false;">
#change TARGET for copy file.
TARGET_CFG=$TT/$TARGET_NAME
export TARGET_CFG
export TARGET_HOME

export PS1="\[\033[01;31m\]$TARGET_NAME\[\033[01;34m\] \w \$\[\033[00m\] "
#echo "Target is $1..."
export PATH=$TARGET_CFG/bin:$PATH

target=$TARGET_NAME
export TARGET_NAME=$target

if test -d $BB/$target; then
cd $BB/$target
if test  -f self.sh; then
. ./self.sh
fi
fi

if test -d $TT/$target; then
envtarget $TARGET_NAME
cd $TT/$target
if test  -f self.sh; then
. ./self.sh
fi
fi
cd $BB/$target



#./configure --prefix=${TARGET_CFG}
</pre>

<p>这里的PS1是根据当前的mingiui版本名字（也就是envbuild命令后面给的名字）改变shell的提示符。具体的代码含义可以去 其志 的个人wiki地盘去看 ^_^。PATH变量也增加了当前minigui库安装路径的bin目录。这里说下 export PATH=$TARGET_CFG/bin:$PATH 这样的用法，就是相当于在当前变量的基础上增加某些表达式，在设置某些查找库、二进制文件的路径上很有用。</p>
<p>接下来的 test -d $BB/$target 这个测试，应该是当/home/mingming/build/rel-3-0目录存在（假设是envbuild rel-3-0），并且该目录下有self.sh这个脚本文件，就去执行这个self.sh的脚本。这个应该估计是针对某些特殊minigui版本配置用的脚本，目前我还没用这个。</p>
<p>然后是 test -d $TT/$target 这个测试。这个测试是当/home/mingming/target/rel-3-0目录存在（同之前的假设），就会执行 envtarget $TARGET_NAME 这个命令。最后我们可以再看一下set-env.sh这个脚本了。（环环相扣啊）</p>
<h2 id="set-env-sh">set-env.sh</h2>
<pre config="brush:bash;toolbar:false;">
#/bin/bash
if test $# -eq 0; then
echo "error:Target is not specic."
exit 0
fi

TT=$tt
SS=$ss
TT_DIR=$TT/$1

export MG_CFG_PATH=$TT_DIR/etc
export MG_RES_PATH=$SS/res-trunk/
export LD_LIBRARY_PATH=$TT_DIR/lib:$LD_LIBRAY_PATH
export PATH=$TT_DIR/bin:$PATH
export BOOTCLASSPATH=$TT_DIR/usr/local/share/jamvm/classes.zip:$TT_DIR/usr/share/classpath/glibj.zip:$TT_DIR/usr/local/share/mgjni/mgjni.zip
export CLASSPATH=.:$TT_DIR/usr/share/jamvm/classes.zip:$TT_DIR/usr/share/classpath/glibj.zip

echo "Target is $1..."
export PS1="\[\033[01;31m\]$1\[\033[01;34m\] \w \$\[\033[00m\] "

cd $TT_DIR
if test  -f ./self.sh; then
source self.sh
fi

cd $TT_DIR/bin
</pre>

<p>哈哈，到这里就可以可以看到所有的minigui的一些环境信息都设置好了：</p>
<ul>
<li>MG_CFG_PATH：Minigui.cfg配置文件的路径</li>
<li>MG_RES_PATH：minigui资源文件的路径</li>
<li>LD_LIBRARY_PATH：minigui的链接库路径</li>
</ul>
<p>有一些java运行时的，暂时没用到；其它的是和前面重复定义了的 -_-||。最后执行完set-env.sh（应该说是执行完envtarget命令）后，env.sh最后会 cd $BB/$target 进入到相应的环境build目录下。</p>
<p>现在我大致上知道我现在用的这些脚本在后面干了些什么事了。不过上次听万大师的介绍，他用的脚本更强了，可以根据环境的不同配置不同的mingiui的configure。不过这个好像更麻烦，以后有空再研究下了。</p>
<h2 id="改进">改进</h2>
<p>有些项目用默认的 MiniGUI configure 不行了，所以就要手动改 configure 配置。这里可以在 .bashrc 里加2个映射命令：</p>
<pre>
alias cb='cd ${bb}/${TARGET_NAME};./build.sh;cd ${bb}/${TARGET_NAME}/minigui'
alias acb='./autogen.sh;cd ${bb}/${TARGET_NAME};./build.sh;cd ${bb}/${TARGET_NAME}/minigui'
</pre>

<p>然后在 /build/ 目录下放一个 build.sh 的 configure 脚本，MiniGUI 的编译源代码要放到 /build/minigui/ 下（一般我都是这么做的）。要用指定配置选项的时候就用 cb, acb 命令，要用默认配置选项的时候就用 cfg, acfg 命令。手法很简陋，但是自己用着还是蛮顺手的。</p>
<h2 id="附件">附件</h2>
<p><a href="http://pan.baidu.com/s/1hq6BqWO" target="_blank" rel="external">set.zip</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Gitweb/</loc>
    <lastmod>2015-01-13T12:48:16.000Z</lastmod>
    <data>
        <display>
        <title>Gitweb</title>
        <pubTime>2015-01-13T12:48:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>Git web 是一个可以在 web 上查看 git 仓库的程序。例如可以在 web 上查看所有的 git 分支， git 的 commit、diff 等。</p>
<p>参考资料： <a href="http://www.cnblogs.com/wanghongmei/archive/2011/06/22/2087391.html" target="_blank" rel="external">ubuntu 上安装 gitweb</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Repo%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-13T12:37:16.000Z</lastmod>
    <data>
        <display>
        <title>Repo 命令备忘</title>
        <pubTime>2015-01-13T12:37:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>repo 其实本身就是一个 git 仓库，只不过这个仓库记录了别的 git 仓库的地址，版本号信息而已。这个 git 仓库在项目的根目录的 .repo/mainfests 下面。其实就是一个 xml 文件，然后里面记录了各个项目的版本号而已，repo 自身是一个脚本。</p>
<h2 id="download_repo">download repo</h2>
<p> 下载 repo 的地址: <a href="http://android.git.kernel.org/repo" target="_blank" rel="external">http://android.git.kernel.org/repo</a> ，可以用 wget <a href="http://android.git.kernel.org/repo" target="_blank" rel="external">http://android.git.kernel.org/repo</a> 或者 curl <a href="http://android.git.kernel.org/repo&gt;~/bin/repo" target="_blank" rel="external">http://android.git.kernel.org/repo&gt;~/bin/repo</a>  来下载 repo , Repo脚本授权：chmod a+x ~/bin/repo</p>
<h2 id="repo_ini">repo ini</h2>
<p>repo init -u URL ,  在当前目录安装 repository ，会在当前目录创建一个目录 “.repo”  -u 参数指定一个URL，从这个URL 中取得repository 的 manifest 文件。</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git
</pre>

<p>可以用 -m 参数来选择 repository 中的某一个特定的 manifest 文件，如果不具体指定，那么表示为默认的 namifest 文件(default.xml)    repoinit -u git://android.git.kernel.org/platform/manifest.git -m dalvik-plus.xml 可以用 -b 参数来指定某个manifest 分支。</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git -b release-1.0
</pre>

<p>可以用命令: repo help init 来获取 repo init 的其他用法。</p>
<h2 id="查看_repo_可用的版本信息">查看 repo 可用的版本信息</h2>
<p>先 repo init 把 repo 仓库安装下来，然后 cd ./repo/manifests 下，然后 git branch -a 就可以看到了。</p>
<p>repo branch 也可以看到当前 repo 用的分支。</p>
<h2 id="repo_sync_[project-list]">repo sync [project-list]</h2>
<p>下载最新本地工作文件，更新成功，这本地文件和repository 中的代码是一样的。可以指定需要更新的project ，如果不指定任何参数，会同步整个所有的项目。如果是第一次运行 repo sync ，则这个命令相当于 git clone ，会把 repository 中的所有内容都拷贝到本地。如果不是第一次运行 repo sync ，则相当于 git remote update ;  git rebaseorigin/branch .  repo sync 会更新 .repo 下面的文件。如果在merge 的过程中出现冲突，这需要手动运行  git  rebase —continue</p>
<h2 id="repo_update[_project-list_]">repo update[ project-list ]</h2>
<p>上传修改的代码，如果你本地的代码有所修改，那么在运行 repo sync 的时候，会提示你上传修改的代码，所有修改的代码分支会上传到 Gerrit (基于web 的代码review 系统), Gerrit 受到上传的代码，会转换为一个个变更，从而可以让人们来review 修改的代码。</p>
<h2 id="repo_diff_[_project-list_]">repo diff [ project-list ]</h2>
<p>显示提交的代码和当前工作目录代码之间的差异。</p>
<h2 id="repo_download_target_revision">repo download  target revision</h2>
<p>下载特定的修改版本到本地，例如:  repo downloadpltform/frameworks/base 1241 下载修改版本为 1241 的代码</p>
<h2 id="repo_start_newbranchname">repo start newbranchname</h2>
<p>创建新的branch分支。 “.” 代表当前工作的branch 分支。</p>
<h2 id="repo_prune_[project_list]">repo prune [project list]</h2>
<p>删除已经merge 的 project</p>
<h2 id="repo_forall_[_project-lists]_-c_command">repo forall [ project-lists] -c command</h2>
<p>对每一个 project 运行 command 命令。例如你要用 repo 创建一个新的分支（其实就是让每个项目创建一个分支）： </p>
<pre>
# repo 本地创建一个 xx 分支
repo forall -c git branch xx
# repo 创建远程分支（把本地分支 push 到服务器上去）
# origin 是默认的远程路径名字
repo forall -c git push origin xx:xx
</pre>

<h2 id="repo_status">repo status</h2>
<p>显示 project 的状态</p>
<h2 id="签名错误">签名错误</h2>
<p>有些时候 repo 的时候会出现</p>
<pre>
gpg: 于 2013年10月02日 星期三 00时44分27秒 CST 创建的签名，使用 RSA，钥匙号 692B382C
gpg: 无法检查签名：找不到公钥
</pre>

<p>这样的错误。这是因为前后 key 不一样导致的，把 home 目录下的 .repoconfig 删掉，让 repo 自动导入一次 key 就可以了。</p>
<h2 id="创建新的远程分支">创建新的远程分支</h2>
<p>首先要创建对应的 git 的各个仓库的分支，可以参加前面 repo forall 命令的使用。然后去 .repo/mainfests 这个仓库下创建自己的 repo 分支。然后可以自己创建分支所用的 xml 文件，提交到刚刚新创建的 repo 分支就可以了。然后就可以用下面的命令 down 新分支代码了：</p>
<pre>
repo init -u git://android.git.kernel.org/platform/manifest.git -b my-branch -m my-branch.xml
repo sync
</pre>

<h2 id="创建远程仓库">创建远程仓库</h2>
<ol>
<li><p>先本地库的创建，在一个本地一个目录把要创建仓库的目录创建好：</p>
<pre>
# 在本地仓库目录，创建裸仓库
git init
# 把本地仓库先提交到一个分支，一般开始是 master
git add
git commit
</pre>
</li>
<li><p>提交远程服务器<br>命令： git remote add <name> <url><br>如:<br><pre><br>git remote add origin gitrepo:android/android4.1/platform/external/abc.git<br></pre><br>origin 是远程仓库的别名（路径），然后后面的 url 一定要是远程服务器的 url 。弄好后可以用 git remote -v 或是 git config -l 查看。如果一开始远程别名弄错了，可以用 git remote rename old new 来重命名。如果 url 错了，可以用 git remote set-url origin xx 来重新指定远程服务器 url 。确保正确后，用 git push origin master:master 把本地仓库提交远程服务器。</url></name></p>
</li>
<li><p>在 repo 中添加新的仓库<br>进入 .repo/manifests 这个 repo 仓库，编辑 default.xml (视自己项目使用的 xml 不用，编辑不同的 xml 文件)。照着原有的模版添加刚刚新创建的仓库就好。例如： <code>&lt;project path=&quot;external/abc&quot; name=&quot;platform/external/abc&quot; /&gt;</code>。然后把修改提交到自己项目的 repo 仓库分支就 OK 了，例如: git push origin default:default。</p>
</li>
</ol>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Rsa%20%E9%AA%8C%E8%AF%81%E7%AE%80%E4%BB%8B/</loc>
    <lastmod>2015-01-13T12:33:16.000Z</lastmod>
    <data>
        <display>
        <title>Rsa 验证简介</title>
        <pubTime>2015-01-13T12:33:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p> 如果不是用密码来进行验证的话，那么就可以使用 rsa 数据签名来进行验证。签名分为公钥和私钥2个。公钥是可以公开出来的，密钥是自己个人持有的。一般来使用 RSA 验证的话，是自己生成一对公钥/私钥。然后把公钥放置到服务器上，自己持有公钥和私钥，然后就可以通过公钥来验证了。下面上使用简介：</p>
<p>假设客户端的用户 charlee 要以 guest 用户登录到服务器上。首先在客户端执行下面的命令:</p>
<pre>
// ssh-keygen: 
// -t 指定公钥类型，默认的是 rsa 的
// -c 是生成的公钥注释，如果不指定的话就是自己机子的终端显示的那个东西
// 其它的一些选项可以自己去查帮助文档
</pre>

<pre>
[charlee@client:~]$ ssh-keygen -t rsa -c "your_email@youremail.com"
Generating public/private rsa1 key pair.
Enter file in which to save the key (/home/charlee/.ssh/id_rsa): 回车 （这个是让你指定输出文件，直接敲回车就是括号里那个默认的路径、文件）
Enterpassphrase (empty for no passphrase):  回车 （这个是让你输入你公钥的密码，直接敲回车就不设定密码）
Enter same passphrase again:   回车
Your identification has been sabed in /home/charlee/.ssh/id_rsa
Your public key has been saved in /home/charlee/.ssh/id_rsa.pub
</pre>

<p>生成的文件保存在主目录的 .ssh 目录下，id_rsa 为客户端密钥，id_rsa.pub 为客户端公钥。之后，通过 U 盘等方式将公钥 id_rsa.pub 复制到服务器上，并执行下列命令。</p>
<p>[guest@server:~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</p>
<p>其实还可以执行 ssh-copy-id mingming@192.168.0.8 把公钥弄到服务器上。其中 id_rsa.pub 是客户端的用户 charlee 的公钥。这样在客户端即可通过以下的命令连接服务器。到此基本可以配对两台机的公钥了。</p>
<p>[charlee@client:~]$ ssh -l guest server</p>
<p>若不想每次登录服务器时都输入密码，可以先执行下列命令：</p>
<pre>
// 如果提示 ssh not find agent 之类的，可以输入 eval `ssh-agent` 启动 ssh agent
[charlee@client:~]$ ssh-add
Enter passphrase for /home/charlee/.ssh/id_rsa: 输入密码
Identity added: /home/charlee/.ssh/id_rsa (/home/charlee/.ssh/id_rsa)
</pre>

<p>以后登录服务器就不需要输入密码了。</p>
<p>如果出现： Permissions 0464 for ‘.ssh/id_rsa’ are too open. 之类的错误，把私钥文件（id_rsa）权限改为 600 就可以了。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/13/Git%20%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-13T12:13:16.000Z</lastmod>
    <data>
        <display>
        <title>Git 使用备忘</title>
        <pubTime>2015-01-13T12:13:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>简单的 git 使用教程。</p>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>git clone</li>
</ul>
<p>从服务拷贝代码副本到本地（类似 svn checkout）</p>
<ul>
<li>git add</li>
</ul>
<p>添加本机文件到服务器</p>
<ul>
<li>查看git仓库路径</li>
</ul>
<p>这个好像没直接的命令可以查看，可以去 git 代码的根目录下的 .git/config 里去看。</p>
<ul>
<li>git checkout</li>
</ul>
<p>切换分支。一般在切换分支前需要 git pull 更新到最新。这个命令，还有另外一个用处，当你想恢复一个文件时候，可以使用 git checkout xx （你还可以先把这个文件先删掉）。</p>
<ul>
<li><p>git branch</p>
<ul>
<li>git branch name ：创建新的分支（name）。</li>
<li>git branch -a ：查看所有的分支信息。</li>
<li>git branch -d name ：删除本地分支 name。</li>
<li>git push origin :name ：删除远程分支 name。</li>
</ul>
</li>
<li><p>git diff</p>
</li>
</ul>
<p>和 svn diff 类似的东西。</p>
<ul>
<li>git merge-base branch-A branch-B</li>
</ul>
<p>找到2个分支最近一次的公共 commit 。</p>
<ul>
<li>git merge branch-A</li>
</ul>
<p>把 branch-A 合并到当前分支。</p>
<ul>
<li>git init</li>
</ul>
<p>创建仓库。如果是在远程的服务器上，一般要用 git init —bare 来创建仓库。 创建仓库的话需要配置一下仓库访问权限，否则别人无法提交代码到你创建的仓库。</p>
<p>1: 修改 config ： 加上 sharedrepositiory = 1 这个属性。</p>
<pre config="brush:bash;toolbar:false;">
[core]
    repositoryformatversion = 0
    filemode = true
    bare = true
    sharedrepository = 1
[receive]
    enyNonFastforwards = true
</pre>

<p>2: 把 object 和 refs 目录（当然你改全部的也行）权限改成其它的人（同一组或者指定组的人）可以有写的权限（chmod 777 就可以）。</p>
<ul>
<li>git log</li>
</ul>
<p>git log 查看 log， git log -p xx 可以单独查看这个文件的修改记录。</p>
<ul>
<li>git tag</li>
</ul>
<p>打标签，查看标签。</p>
<ul>
<li>git show</li>
</ul>
<p>显示一个 commit 的详细信息，还可以显示一个 tag 的详细信息。</p>
<h2 id="初始化配置">初始化配置</h2>
<h3 id="1-">1.</h3>
<p>下面的命令将修改/home/[username]/.gitconfig文件，也就是说下面的配置只对每一个ssh的用户可见，所以每个人都需要做。</p>
<ul>
<li><p>提交代码的log里面会显示提交者的信息</p>
<pre>
[user]
  git config --global user.name [username]
  git config --global user.email [email]
</pre>
</li>
<li><p>在git命令中开启颜色显示</p>
<pre>
[color]
  git config --global color.ui true
</pre>

</li>
</ul>
<p>如果不太确定 .gitconfig 的位置的，可以用 git config  —global 命令来配置，git 会自动保存配置文件的。</p>
<h3 id="2-">2.</h3>
<p>下面的命令将修改/etc/gitconfig文件，这是全局配置，所以admin来做一次就可以了。</p>
<pre config="brush:bash;toolbar:false;">
// 配置一些git的常用命令alias
sudo git config --system alias.st status     // git st
sudo git config --system alias.ci commit     // git commit
sudo git config --system alias.co checkout   // git co
sudo git config --system alias.br  branch    // git branch
</pre>

<h3 id="3-">3.</h3>
<p>也可以进入工作根目录，运行git config -e，这样就只会修改工作区的.git/config文件，但是暂时还用不着. git config文件的override顺序是3&gt;1&gt;2.</p>
<h2 id="代码提交流程里">代码提交流程里</h2>
<ul>
<li><p>先确定下本地的修改： git status</p>
</li>
<li><p>看下diff: git diff</p>
</li>
<li><p>提交修改代码：git add xx</p>
</li>
<li><p>确认提交修改：git commit -m”xx” （-m 是注释信息，偷懒的话可以使用 git commit -am”xx”，可以把上面那一步也省了，不过好像不太好）</p>
</li>
<li><p>然后合并别人的代码：git pull （如果有冲突的话，需要解决冲突；有时候无法找到默认的分子，可以用 git pull origin xx 更新指定的分支，这个 origin 是仓库的名字，可以通过 git branch -a 看到，一般是 /remote/xx/branch，xx 就是，默认是 origin）</p>
</li>
<li><p>最后提交本地修改代码： git push (如果也是找不到默认分支的话，可以使用 git push origin xx(分支名)，如果不想每次都这么写，可以在第一次提交的时候使用 -u 参数，以后会默认提交到上次提交的分支 )</p>
</li>
<li><p>可以查看下提交记录： git log</p>
</li>
</ul>
<h2 id="忽略规则配置">忽略规则配置</h2>
<p>在仓库代码目录下可以新建一个叫 .gitignore 的文件来配置提交代码时忽略的文件类型：</p>
<pre>
*.class
*.apk
*.ap_
*.swp
tags
bin/
gen/
doc/
local.properties
proguard/
build.xml
</pre>

<h2 id="创建远程分支">创建远程分支</h2>
<p>要创建一个新的远程分支，首先要创建一个本地分支（git branch xx），例如 git branch test。然后再把这个本地分支 push 到服务器上去：</p>
<pre>
# ：号左边的是本地的分支，右边的是远程分支
# 当然你可以把本地分支 push 到服务器用不同的名字，但是我觉得还是一样的比较好
git push origin test:test
</pre>

<p>然后如果要删掉某个远程分支的话，这么弄就行了：</p>
<pre>
# 把本地的留空就是删除了
git push origin :test
</pre>

<h2 id="删除误添加的文件">删除误添加的文件</h2>
<p>如果在 git all —all 不小心添加了不想提交的文件（在 git status 中可以可得到添加的文件）。可以使用 git rm —cached xx 删掉误添加的文件。当然这个是还没 commit 的时候，可以这样简单的就删除掉，如果已经 commit 了，就不是这么简单的弄了。所以每次提交的时候都要 status 检查下本次提交的内容。</p>
<h2 id="撤销_add_的文件">撤销 add 的文件</h2>
<p>使用 git reset xx ，撤销 add 的问题，特别适用于使用 add —all 但是发现多添加了文件。注意这个是 add 但是还没 commit 的时候。</p>
<h1 id="撤销_commit">撤销 commit</h1>
<p>如果只是本地 commit 还没 push 到服务器，可以使用 git reset —hard xx（回到某个提交，xx 可以是 commit 的 id）。如果 push 到服务器的，要稍微麻烦点。但是最后每次提交前确定一下，这种操作还是少一点比较好。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/11/GDB%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-10T16:25:16.000Z</lastmod>
    <data>
        <display>
        <title>GDB 命令备忘</title>
        <pubTime>2015-01-10T16:25:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>一些常用的 gdb 使用命令备忘。help 可以查看命令，help xx 可以查看具体命令的所有参数。</p>
<h2 id="编译带调试符号的程序">编译带调试符号的程序</h2>
<p>要想用 gdb 调试，编译的时候要带上 debug 符号，就是用 gcc 编译的时候带上 -g 参数编译（bu要带 -o 开启优化模式，这个会把所有的调试符号优化掉）。</p>
<h2 id="file">file</h2>
<p>file app，装载要调试的应用程序。</p>
<h2 id="list_（l）">list （l）</h2>
<p>list fun，可查看对应函数 fun 的代码。可以接很多参数，例如行号等。函数名是可以使用 tab 键补全的。</p>
<h2 id="breakpoint_(b)">breakpoint (b)</h2>
<p>break fun，在函数 fun 出设置断点。也是可以接很多参数的，例如说行号等。</p>
<ul>
<li><p>b fun if condition，设置条件断点，只有当 condition 为 true 时才中断。</p>
</li>
<li><p>i breakpoint（b），显示当前设置的断点。</p>
</li>
<li><p>delete breakpoint 1，删除1号断点，编号可以使用 i b 查看，如果不加参数，则会删除所有断点。</p>
</li>
<li><p>disable breakpoint 1，禁止1号断点。</p>
</li>
<li><p>enable breakpoint 1，开启1号断点。</p>
</li>
</ul>
<h2 id="watch">watch</h2>
<p>watch condition (watch i&gt;99)，监视变量的变化达到条件时停止程序执行。注意：监视点的设定不依赖于断点的位置，但是与变量的作用域有关。也就是说，要设置监视点必须在程序运行时才可设置。</p>
<p>还有一个作用是，硬件写断点。这种断点和普通的 break 有点不同，需要每次挂载 gdb 后，先利用普通的 break 让程序停下来，然后查看出你要查看变量的地址（用p）。然后再用 watch 命令设置。然后每次程序重新运行都要重新设置，因此每次变量地址的都不一样。</p>
<h2 id="控制命令">控制命令</h2>
<ul>
<li><p>run (r): 运行程序。</p>
</li>
<li><p>next (n): 下一步，跳过函数。</p>
</li>
<li><p>setp (s): 下一步，进入函数。</p>
</li>
<li><p>continue (c): 继续执行。</p>
</li>
</ul>
<h2 id="info_(i)">info (i)</h2>
<p>显示某些内容。</p>
<ul>
<li><p>i breakpoints(b)，显示当前断点。</p>
</li>
<li><p>i variables，显示所有全局变量和静态变量。</p>
</li>
<li><p>i functions，显示所有函数名字。</p>
</li>
<li><p>i local，显示当前函数中的变量。</p>
</li>
<li><p>i file，显示调试文件的信息。</p>
</li>
<li><p>i prog，显示调试程序的执行状态</p>
</li>
</ul>
<h2 id="print_(p)">print (p)</h2>
<p>p var，显示变量 var 的值，或者 p exp，可以显示该表达式的值。这样可以查看几乎任何变量的值。只要你确定改变量是什么类型的指针，可以直接转化为该类型就行了，例如 p *(PDC)hdc 就可以查看这个结构的值了。还可以通过添加参数来设置输出格式：</p>
<pre>
/x 按十六进制格式显示变量
/d 按十进制格式显示变量
/u 按十六进制格式显示无符号整型
/o 按八进制格式显示变量
/t 按二进制格式显示变量
/a 按十六进制格式显示变量
/c 按字符格式显示变量
/f 按浮点数格式显示变量
</pre>

<p>其实它还有一个功能就是执行函数。调试 MiniGUI 的时候，最典型的用法用法就是可以将你想查看的一些 memdc 中的图像信息输出到屏幕上进行检查。方法是调用 BitBlt ，注意这种情况一些宏定义的变量无法直接使用，而是要填入真正的数值，这些可以从代码里面去差。例如先把屏幕一块地方填充成红色，然后再把 memdc 中的内容输入到屏幕的这个地方：</p>
<pre config="brush:bash;toolbar:false;">
// SetBrushColor(hdc, color) 的宏定义是 SetDCAttr(hdc, DC_ATTR_BRUSH_COLOR, color)
// DC_ATTR_BRUSH_COLOR 值就是2
// HDC_SCREEN 的值就是0
// 如果自己知道 rgb 对应的 pixel 值的话，也可以不用 RGB2Pixel
p SetDCAttr(0, 2, RGB2Pixel(0, 255, 0, 0))

p FillBox(0, 400, 0, 360, 480)

p BitBlt(memdc, 0, 0, 0, 0, 0, 400, 0, 0)
</pre>

<h2 id="x">x</h2>
<p>x /nfu <addr>，查看addr地址处的内存信息。n是显示多少字节，后面的显示的格式，和 p 命令是一样的。</addr></p>
<h2 id="thread">thread</h2>
<p>用法：thread xx。切换当前活动线程。用于调试多线程程序。xx 为线程号，用 info thread（th）查看，每个线程的第一个数字就是线程号。 </p>
<h2 id="backtrace_(bt)">backtrace (bt)</h2>
<p>backtrace [-n] [n] 显示程序中的当前位置和表示如何到达当前位置的栈跟踪。<br>-n：表示只打印栈底上n层的栈信息<br> n：表示只打印栈顶上n层的栈信息<br>不加参数，表示打印所有栈信息。</p>
<h2 id="call">call</h2>
<p>call func_name，调用和执行一个函数。例如 call print(“abcd\n”)。</p>
<h2 id="查看_coredump_文件">查看 coredump 文件</h2>
<p>首先要让程序在崩溃的时候产生 coredump 文件。输入 ulimit -c unlimited 命令（注意这个只对一个终端有效）。然后在程序崩溃的时候，就会产生 core.xx 的文件。使用 gdb app core.xx 命令查看（app 就是产生 core.xx 的程序）。然后就和普通的 gdb 用法一样了，用 bt 查看崩溃时的堆栈信息啊，但是就是不能执行而已。</p>
<h2 id="disassemble">disassemble</h2>
<p>对当前的执行到的代码反汇编。</p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/11/VI%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-10T16:12:16.000Z</lastmod>
    <data>
        <display>
        <title>VI 命令备忘</title>
        <pubTime>2015-01-10T16:12:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>我的一些常用的 vi 使用命令备忘。</p>
<h2 id="新建">新建</h2>
<ul>
<li>在 shell 直接 vi file 就能创建以 file 命名的文件。</li>
<li>:e file，在里面内存打开（创建）file 文件。（其中 ： 表示是命令模式）</li>
</ul>
<h2 id="保存">保存</h2>
<ul>
<li>:s，保存当前文件。</li>
<li>:q!，退出，不保存。</li>
<li>:q，退出当前窗口。:qa，退出所有窗口。 </li>
<li>:c，关闭当前窗口。</li>
</ul>
<h2 id="复制、粘贴">复制、粘贴</h2>
<ul>
<li>c， 复制。</li>
<li>p， 粘贴。</li>
</ul>
<h2 id="移动">移动</h2>
<ul>
<li>i， 上。</li>
<li>k， 下。</li>
<li>j， 左。</li>
<li>l， 右。</li>
<li>gg， 回到文件最第一行。</li>
<li>GG， 回到文件最后一行。</li>
<li>nG， 跳转到第n行。</li>
<li>ctrl+i(k,j,l)， 在窗口之间移动。</li>
</ul>
<h2 id="跳转">跳转</h2>
<ul>
<li>ctrl+o， 能回到跳转前的位置。</li>
<li>ctrl+i， 就是o的反操作。</li>
</ul>
<h2 id="撤销">撤销</h2>
<ul>
<li>u， 撤销。</li>
<li>ctrl+r， 恢复（就是反撤销）。</li>
</ul>
<h2 id="搜索">搜索</h2>
<ul>
<li>/ xx， 向后搜索 xx。支持正则表达式。</li>
<li>？ xx， 向前搜索 xx。</li>
<li>n， 下一个。</li>
<li>N， 上一个。</li>
</ul>
<h2 id="替换">替换</h2>
<p>:s，用法为 “:[range]s/target/replace/g” 。其中 range 可以是全文（%），target 是你要替换的字符串，replace 是你要换成的东西（/是分隔符），后面的 g 参数，表示替换一行中所有出现的字符串。例如：你要全文替换 hello 为 hello_world</p>
<pre>
:%s/hello/hello_world/g
</pre> 

<p>典型的用法就是在 linux 下打开某些 window 下编辑的代码，会在每行结尾有一个 ^M 的符号，可以使用替换命令替换掉： %s/^M//g （注意这里输入的 ^M 要按住 ctrl + v 和 ctrl + M 输入）。</p>
<h2 id="大小写转化">大小写转化</h2>
<p>gu(gU)，u是变小写，U是变大写，后面可以接范围命令，例如 guw 就是把当前一个单词变成小写。</p>
<h2 id="v">v</h2>
<p>视图模式，可以使用任何移动命令进行选择，选择后可以使用复制、粘贴、对齐等操作。</p>
<h2 id="标记">标记</h2>
<ul>
<li><p>:ma A-Z(a-z)，在当前位置做标记。可以设置 A 到 Z 个标记。</p>
</li>
<li><p>:marks，显示当前做的标记。</p>
</li>
<li><p>` A-Z，跳转到某个标记处。</p>
</li>
</ul>
<h2 id="q">q</h2>
<p>录制命令。qx：其中 x 是录制宏的编号，应该可以从 a ~ z 吧。按 qx 后就进入了录制模式，vi 会有 rercdring 的提示，录制完成后，再次按 q 推出。之后用 @x 来播放，x 就是宏的编号。@x 前面可以加范围的命令，例如 10@x ，表示10行进行这个命令。</p>
<h2 id="代码展开">代码展开</h2>
<p>代码展开命令。有些代码默认是折叠的，使用 zo 命令可以全部展开。</p>
<ul>
<li>zo 展开当前</li>
<li>zO 展开所有</li>
<li>zr 展开所有</li>
</ul>
<h2 id="==">==</h2>
<p>连续按2次 “=” 号键，就会自动对该行代码进行缩进对齐。并且前面可以加行数前缀。</p>
<h2 id="分屏编辑">分屏编辑</h2>
<ul>
<li>split： 上下分屏</li>
<li>vsplit： 左右分屏</li>
</ul>
<h2 id=":nohl">:nohl</h2>
<p>这是vi里的一个命令来的，就是去掉一些搜索结果时候的高亮显示。有时候高亮太多时，用这个比较好。</p>
<h2 id="16进制编辑">16进制编辑</h2>
<p>需要借助 linux 下的命令行工具 xxd（一般系统都自带了的）： xxd text &gt; text-hex，然后再用 vi 打开就行了，最好不好在 vi 中用使用调用外部命令的方式（:!xxd）直接改变当前的文本，容易出现转化错误。在外面转化出另外一个临时文件比较好。</p>
<h2 id="外部命令">外部命令</h2>
<p>在命令模式下，前面加 ！ 号，然后后面就可以执行外部 shell 命令。例如 :！pwd 就是显示当前路径。</p>
<h2 id="插件使用">插件使用</h2>
<p>插件、插件配置以及 vi 配置在附件里。</p>
<ul>
<li><p>可以看附件里的 vi 配置设置的快捷键参数，例如 F2、F3 这些。</p>
</li>
<li><p>wm（这个是 vi 配置里的快捷键），开启文件管理插件，类似 IDE 的那种。</p>
</li>
<li><p>superTab</p>
<ul>
<li>tab 键进行标签切换。</li>
<li>:b 1，切换到1号标签，标签号在 tab 上有显示。</li>
<li>在标签上按 d 键可以关闭这个标签。</li>
</ul>
</li>
<li><p>如果窗口大小乱了，可以使用窗口管理命令：</p>
<ul>
<li>ctrl + w + “+”， 放大该窗口。（注意是先按 ctrl，再按 w，再按 +号）</li>
<li>ctrl + w + “-“， 缩小该窗口。</li>
</ul>
</li>
</ul>
<h2 id="附件">附件</h2>
<p><a href="http://pan.baidu.com/s/1c0F6QTq" target="_blank" rel="external">vi 配置以及插件配置文件</a></p>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/10/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/</loc>
    <lastmod>2015-01-10T15:55:16.000Z</lastmod>
    <data>
        <display>
        <title>Linux 命令备忘</title>
        <pubTime>2015-01-10T15:55:16.000Z</pubTime>
        
        <tag>linux </tag>
         
         <content><![CDATA[<p>百度、google都能搜得到，但是很杂。这里记录下我记不清的，但是又比较常用的一些linux命令用法。</p>
<h2 id="mount">mount</h2>
<p>挂载设备命令，一般挂载存储设备就用这个了（硬盘、U盘等）。</p>
<pre>
mount [-t vfstype] [-o options] device dir
</pre>

<p>其中：</p>
<ul>
<li><p>-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：</p>
<ul>
<li>光盘或光盘镜像：iso9660</li>
<li>DOS fat16文件系统：msdos</li>
<li>Windows 9x fat32文件系统：vfat （一般U盘的是这种文件系统）</li>
<li>Windows NT ntfs文件系统：ntfs</li>
<li>Mount Windows文件网络共享：smbfs</li>
<li>UNIX(LINUX) 文件网络共享：nfs</li>
</ul>
</li>
<li><p>-o options 主要用来描述设备或档案的挂接方式。常用的参数有：</p>
<ul>
<li>loop：用来把一个文件当成硬盘分区挂接上系统</li>
<li>ro：采用只读方式挂接设备</li>
<li>rw：采用读写方式挂接设备</li>
<li>iocharset：指定访问文件系统所用字符集</li>
</ul>
</li>
<li><p>device 要挂接(mount)的设备。</p>
</li>
<li><p>dir设备在系统上的挂接点(mount point)。</p>
</li>
</ul>
<p>具体的可以去看 man mount 。在挂载 samba 的时候如果说啥 mount 格式错误，一般是没有装 smbfs ， apt-get install 装一个就好。<br>查看电脑上的文件系统：fdisk -l 或 more /proc/partitions （一般要有root权限）。一般的用法是：</p>
<pre config="brush:bash;toolbar:false;">
// /mnt/windows 必须存在
// 用完了卸载用 sudo umount /mnt/windows
sudo mount -t ntfs /dev/sda1 /mnt/windows 

// 挂载 samba 网络设备（以 192.168.0.8 为例）
sudo mount -t smbfs -o username=****,password="****" 192.168.0.8:/xx /mnt/samba
</pre>

<p>要想在一开机就让linux自己挂载某个硬盘分区可以这样：编辑/etc/fstab，加入以下一行：</p>
<pre>
/dev/sda1 /mnt/windows ntfs defaults 0 0
</pre>

<p>卸载命令是：umount </p>
<h2 id="find">find</h2>
<p>查找文件命令。常用的形式： find path -type f -name filename -depth 。</p>
<ul>
<li>path: 路径，一般当前路径可以用 “.” 表示。</li>
<li>-type：查找的文件类型，f 表示普通文件。其他的可以看 man find。</li>
<li>-name：查找文件的名字，可以用正则表达式（不过我基本上只会用*而已）。</li>
<li>-depth：表示递归查找（查找子目录），好像可以设置深度的，具体的看 man 吧。</li>
</ul>
<h2 id="grep">grep</h2>
<p>查找文件内容命令。常用的形式： grep -Irn findstrings filenames。</p>
<ul>
<li>I：表示忽略小写。</li>
<li>r: 表示查找子目录。</li>
<li>n：表示显示行号。</li>
<li>v：这个表示方向查找，就是显示不包含查找内容的文件。例如 grep -Irn xx . | grep -v svn 就可以不去查找可恶的svn目录下的的东西。</li>
<li>l：表示只显示文件名字，例如 grep -lr xx . 搜索结果就只显示文件名。</li>
<li>findstrings：要查找的字符串，同样支持正则表达式。字符串可以加“”这样遇到要查找一些特殊字符不要加转意字符()，否则一些字符是命令的需要加转意字符。例如 grep -Irn “path\list” .</li>
<li>filenames：要查找的文件。</li>
</ul>
<h2 id="sed">sed</h2>
<p>流编辑器，功能十分强大，但是我目前就会用它的一点点功能而已，简单的说它能将输入文件一行一行的做处理。这样它和 grep , find 配合起来做替换的话，就十分方便了。常用形式：sed ‘s/old/new/g’ -i files 。</p>
<ul>
<li>‘s’：这个是替换命令，和vim的替换命令差不多。</li>
<li>-i：将输出写入原文件，也就是修改原文件的内容；如果不加的话就会输出到标准输出（一般是终端）。</li>
<li>files：输入的文件，可以是多个。</li>
</ul>
<p>这里与 grep 配合一个就可以在一个工程项目里做全局的替换了：（在工程的根目录弄） </p>
<pre>
# grep -r old * | sed 's/old/new/g' -i
</pre>

<h2 id="apt-get_install">apt-get install</h2>
<p>从网上下载并安装软件包。用法很简单，一般就是 sudo apt-get install xx ，但是一般会记不住包的名字。可以使用 aptitude search 关键字 （apt-cache search xx）来搜索。软件源可以修改 /etc/apt/source.list （不过一般用图形界面比较方便点），然后使用 sudo apt-get update 来更新。还有 apt-get install xx 的下载包的缓存地址在 /var/cache/apt/archives 里，这里其实可以备份起来，下次重装系统的时候就不用再重新下载了。</p>
<p>aptitude dist-upgrade xx 可以单独更新某个包。</p>
<h2 id="chmod_和_chown">chmod 和 chown</h2>
<p>chmod 是修改文件权限的，例如添加所属组的读写权限、添加其它用户的读写权限等。chown 是修改文件的拥有者，拥有者对该文件拥有所有权限。</p>
<h2 id="mkswap,_swapon">mkswap, swapon</h2>
<p>用来创建和挂载swap分区（linux下的虚拟内存），一般在板子上开发时，可以拿U盘做swap分区（事先要格式化成swap分区格式的）。一般用法是： mkswap /dev/sda 创建swap分区（假设/dev/sda是你的U盘），然后 swapon /dev/sda 挂载上就可以了。然后可以用 free 查看结果。</p>
<h2 id="删除不需要的内核">删除不需要的内核</h2>
<ul>
<li>dpkg —get-selections | grep linux ：可以查看自己安装了多少内核。用 uname -a 可以看到自己目前用的是哪个内核。</li>
<li>然后用 apt-get remove xxxx 就可以把自己不要的内核删掉（删掉后会自动把 grub 中对应的启动项目也删掉）。</li>
<li>不过某些时候 grub 会检测到一些没有办法启动的启动项目，这个时候可以修改 grub 的菜单文件把无用的项目去掉：<ul>
<li>grub1（ubuntu 9.10 之前）：/boot/grub/menu.lst</li>
<li>grub2（ubuntu 10.04 之后）：  /boot/grub/grub.cfg</li>
</ul>
</li>
</ul>
<h2 id="patch">patch</h2>
<p>linux打补丁命令。由 vim diff 等工具生成的 .patch 文件可由该命令对源代码打补丁。一般形式为： patch -p0 &lt; xx.patch 。p0 代表是源代码目标的第几层（文件夹深度），0就代表是根目录。一般是把 .patch 文件复制到源代码包的根目录，然后用上面的形式进行打补丁。更多的用 man patch 自己看吧。</p>
<h2 id="ftp">ftp</h2>
<p>用 ftp 上传东西的时候，如果发的不是文本文件，在上传之前要使用 binary 命令，转化为二进制传输模式，否则上传后的文件可能无法正常使用。</p>
<h2 id="解压_rpm_包">解压 rpm 包</h2>
<p>rpm 包可以使用 rpm -i 直接安装，也可以使用 rpm2cpio xxx.rpm | cpio -div 进行解压。</p>
<h2 id="修改用户权限">修改用户权限</h2>
<ul>
<li><p>useradd<br>添加一个新用户，一般新建立一个用户就会相应的建立这个用户同名的用户组。如果要新建立用户组的话，可以用 groupadd 。</p>
</li>
<li><p>usermod<br>修改指定用户的信息。可以修改这个用户的用户目录（home目录）、shell 环境（bash 还是 sh）、所属于的用户组等。其中修改说属的用户组就可以赋予和删除用户相应的用户组的权限。使用 </p>
</li>
</ul>
<pre>
usermod -a -G group1 user1
</pre>

<p>就可以将 user1 添加到 group1 组中。具体的用法可以看 man。其中</p>
<pre>
// 可以看到有哪些组, 组里有哪些用户
cat /ect/groups

// 可以看到用户的一些信息
cat /ect/passwd
</pre>

<ul>
<li><p>chgrp<br>chgrp -R file 可以改变这个文件的所属于组。</p>
</li>
<li><p>权限说明<br>一般我们最常用的也就是 777 755 644 这三种 Linux主机文件目录权限原理：</p>
</li>
</ul>
<pre config="brush:bash;toolbar:false;">
444 r--r--r--
600 rw-------
644 rw-r--r--
666 rw-rw-rw-
700 rwx------
744 rwxr--r--
755 rwxr-xr-x
777 rwxrwxrwx
</pre>

<p>三位数字代表9位的权限，分成3部分，第一部分3位表示所有者的权限，第二部分3位表示同组用户权限，第三部分3位表示其他用户权限，r代表读取权限等于4，w代表写入权限等于2，x代表执行权限等于1</p>
<p>比如777，第一位7等于4+2+1，所以就是rwx，所有者有读取、写入、执行的权限，第二位7也是4+2+1，rwx，同组用户具有读取、写入、执行权限，第三位7，代表其他用户有读取、写入、执行的权限。<br>比如744，第一位7等于4+2+1，rwx，所有者具有读取、写入、执行权限，第二位4等于4+0+0，r—，同组用户只有读取权限、第三位4，也是r—，其他用户只有读取权限。</p>
<h2 id="修改用户密码">修改用户密码</h2>
<p>passwd user 可以修改指定用户的登陆密码，当然如果修改别的用户要有 root 权限。</p>
<h2 id="监视某个端口">监视某个端口</h2>
<pre>
# 这里是监视网络流量
watch -n 1 "/sbin/ifconfig eth0 | grep bytes"
</pre>

<h2 id="查看磁盘空间">查看磁盘空间</h2>
<p>虽然有 fdisk 可用，但是 df -h 效果更好。</p>
<h2 id="wget">wget</h2>
<p>这个东西下 http 的挺好用的。一般用法比较简单，直接 wget url 就行了。</p>
<h2 id="压缩">压缩</h2>
<p>可以用 tar，也可以用 zip：</p>
<pre>
// gz 格式的
tar -xzvf xx.tar.gz      // 解压
tar -zvf xx.tar          // 解压
tar -czvf xx.tar.gz xx   // 压缩

// bz2 格式的
bzip2 xx.tar.bz2  // 解压 

// 递归（文件夹）中的打包为 xx.zip，其中 -0 表示不压缩，仅仅是存储
// 不加 -0 则表示用默认压缩
zip -r -0 xx.zip xx 

// 将 xx 这个文件加入到 xx.zip 中，其中能保持 xx 的文件树结构
zip -g xx.zip xx
</pre>

<h2 id="dpkg">dpkg</h2>
<ul>
<li>安装 deb 包： dpkg -i package-file.deb</li>
<li>卸载 deb 包： dpkg -r package-name</li>
<li>包名可以通过 dpkg —info package-file.deb 查看</li>
</ul>
<h2 id="xargs">xargs</h2>
<p>可以显示指定让上一个命令的输出作为下一个命令的输入参数。例如： </p>
<pre>
# 先搜索以 buildin 结尾的文件，然后再删掉。
find . -iname *.buildin | xargs rm 
</pre>

<h2 id="which,_ldd">which, ldd</h2>
<ul>
<li>which: 显示到某个程序（命令）的所在路径，这个检查要用某些版本的程序的时候（例如说编译器）很有用。</li>
<li>ldd: 显示某个程序链接的 so 的路径，同样对于查看某些库的版本很有用。</li>
</ul>
<h2 id="who,_uname">who, uname</h2>
<ul>
<li>who: 查看当前登录的用户</li>
<li>uname: 查看当前系统的一些信息（例如架构，内核等），可以加 -a 显示全部</li>
</ul>
]]></content>
         
         
           
             
              <breadCrumb title="Linux" url="http://www.light3moon.com/categories/Linux/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/2015/01/10/Test/</loc>
    <lastmod>2015-01-10T03:07:16.000Z</lastmod>
    <data>
        <display>
        <title>Test</title>
        <pubTime>2015-01-10T03:07:16.000Z</pubTime>
        
         <content><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="my_test">my test</h3>
<p>An activity is a single, focused thing that the user can do. <strong>Almost all activities interact with the user</strong>, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with windowIsFloating set) or embedded inside of another activity (using ActivityGroup). There are <font color="#ff0000">two methods</font> almost all subclasses of Activity will implement:</p>
<ul>
<li>onCreate(Bundle) is where you initialize your activity. Most importantly, here you will usually call setContentView(int) with a layout resource defining your UI, and using findViewById(int) to retrieve the widgets in that UI that you need to interact with programmatically.</li>
<li>onPause() is where you deal with the user leaving your activity. Most importantly, any changes made by the user should at this point be committed (usually to the ContentProvider holding the data). </li>
</ul>
<p>To be of use with Context.startActivity(), all activity classes must have a corresponding <code>&lt;activity&gt;</code> declaration in their package’s AndroidManifest.xml.The Activity class is an important part of an application’s overall lifecycle, and the way activities are launched and put together is a fundamental part of the platform’s application model. For a detailed perspective on the structure of an Android application and how activities behave, please read the Application Fundamentals and Tasks and Back Stack developer guides.</p>
<p><strong>垂直同步</strong>又称场同步（Vertical Hold），从CRT显示器的显示原理来看，单个象素组成了水平扫描线，水平扫描线在垂直方向的堆积形成了完整的画面。显示器的刷新率受显卡DAC控制，显卡DAC完成一帧的扫描后就会产生一个垂直同步信号。我们平时所说的打开垂直同步指的是将该信号送入显卡3D图形处理部分，从而让显卡在生成3D图形时受垂直同步信号的制约。主要区别在于那些高速运行的游戏，比如实况，FPS游戏，打开后能防止游戏画面高速移动时画面撕裂现象，当然打开后如果你的游戏画面FPS数能达到或超过你显示器的刷新率，这时你的游戏画面FPS数被限制为你显示器的刷新率。你会觉得原来移动时的游戏画面是如此舒服，如果达不到会出现不同程度的跳帧现象，FPS与刷新率差距越大跳帧越严重。关闭后除高速运动的游戏外其他游戏基本看不出<font color="#ff0000">画面撕裂现象</font>。</p>
<p>This code hightlight:</p>
<p><strong>cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayHardware/HWComposer.h"</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Effects/Daltonizer.h"</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> android {</div><div class="line"></div><div class="line"><span class="comment">// ---------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Client;</div><div class="line"><span class="keyword">class</span> DisplayEventConnection;</div><div class="line"><span class="keyword">class</span> EventThread;</div><div class="line"><span class="keyword">class</span> IGraphicBufferAlloc;</div><div class="line"><span class="keyword">class</span> Layer;</div><div class="line"><span class="keyword">class</span> LayerDim;</div><div class="line"><span class="keyword">class</span> Surface;</div><div class="line"><span class="keyword">class</span> RenderEngine;</div><div class="line"><span class="keyword">class</span> EventControlThread;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> {</div><div class="line">    eTransactionNeeded        = <span class="number">0x01</span>,</div><div class="line">    eTraversalNeeded          = <span class="number">0x02</span>,</div><div class="line">    eDisplayTransactionNeeded = <span class="number">0x04</span>,</div><div class="line">    eTransactionMask          = <span class="number">0x07</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">enum</span></div><div class="line">{</div><div class="line">    <span class="comment">/* NOTE: These enums are unknown to Android.</span></div><div class="line"><span class="comment">     * Android only checks against HWC_FRAMEBUFFER.</span></div><div class="line"><span class="comment">     * This layer is to be drawn into the framebuffer by hwc blitter */</span></div><div class="line">    <span class="comment">//HWC_TOWIN0 = 0x10,</span></div><div class="line">    <span class="comment">//HWC_TOWIN1,</span></div><div class="line">    HWC_BLITTER = <span class="number">100</span>,</div><div class="line">    HWC_DIM,</div><div class="line">    HWC_CLEAR_HOLE</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> SurfaceFlinger : <span class="keyword">public</span> BnSurfaceComposer,</div><div class="line">                       <span class="keyword">private</span> IBinder::DeathRecipient,</div><div class="line">                       <span class="keyword">private</span> HWComposer::EventHandler</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="keyword">const</span>* getServiceName() ANDROID_API {</div><div class="line">        <span class="keyword">return</span> <span class="string">"SurfaceFlinger"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    SurfaceFlinger() ANDROID_API;</div><div class="line"></div><div class="line">    <span class="comment">// must be called before clients can connect</span></div><div class="line">    <span class="keyword">void</span> init() ANDROID_API;</div><div class="line"></div><div class="line">    Daltonizer mDaltonizer;</div><div class="line">    <span class="keyword">bool</span> mDaltonize;</div><div class="line">    <span class="keyword">int</span> mDebugFPS;</div><div class="line">    </div><div class="line">    <span class="comment">// add by rk for workwround some display issue. </span></div><div class="line">    <span class="keyword">int</span> mSkipFlag;</div><div class="line">    <span class="keyword">int</span> mDelayFlag;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">SurfaceFlinger::SurfaceFlinger()</div><div class="line">    :   BnSurfaceComposer(),</div><div class="line">        mTransactionFlags(<span class="number">0</span>),</div><div class="line">        mTransactionPending(<span class="keyword">false</span>),</div><div class="line">        mAnimTransactionPending(<span class="keyword">false</span>),</div><div class="line">        mLayersRemoved(<span class="keyword">false</span>),</div><div class="line">        mRepaintEverything(<span class="number">0</span>),</div><div class="line">        mRenderEngine(NULL),</div><div class="line">        mBootTime(systemTime()),</div><div class="line">        mVisibleRegionsDirty(<span class="keyword">false</span>),</div><div class="line">        mHwWorkListDirty(<span class="keyword">false</span>),</div><div class="line">        mAnimCompositionPending(<span class="keyword">false</span>),</div><div class="line">        mDebugRegion(<span class="number">0</span>),</div><div class="line">        mDebugDDMS(<span class="number">0</span>),</div><div class="line">        mDebugDisableHWC(<span class="number">0</span>),</div><div class="line">        mDebugDisableTransformHint(<span class="number">0</span>),</div><div class="line">        mDebugInSwapBuffers(<span class="number">0</span>),</div><div class="line">        mLastSwapBufferTime(<span class="number">0</span>),</div><div class="line">        mDebugInTransaction(<span class="number">0</span>),</div><div class="line">        mLastTransactionTime(<span class="number">0</span>),</div><div class="line">        mBootFinished(<span class="keyword">false</span>),</div><div class="line">        mPrimaryHWVsyncEnabled(<span class="keyword">false</span>),</div><div class="line">        mHWVsyncAvailable(<span class="keyword">false</span>),</div><div class="line">        mDaltonize(<span class="keyword">false</span>),</div><div class="line">        mHardwareOrientation(<span class="number">0</span>),</div><div class="line">        mUseLcdcComposer(<span class="number">0</span>),</div><div class="line">        mSkipFlag(<span class="number">0</span>),</div><div class="line">        mDelayFlag(<span class="number">0</span>)</div><div class="line">{</div><div class="line">    ALOGI(<span class="string">"SurfaceFlinger is starting"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// debugging stuff...</span></div><div class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</div><div class="line"></div><div class="line">    property_get(<span class="string">"ro.bq.gpu_to_cpu_unsupported"</span>, value, <span class="string">"0"</span>);</div><div class="line">    mGpuToCpuSupported = !atoi(value);</div><div class="line"></div><div class="line">    property_get(<span class="string">"debug.sf.showupdates"</span>, value, <span class="string">"0"</span>);</div><div class="line">    mDebugRegion = atoi(value);</div><div class="line"></div><div class="line">    property_get(<span class="string">"debug.sf.ddms"</span>, value, <span class="string">"0"</span>);</div><div class="line">    mDebugDDMS = atoi(value);</div><div class="line">    <span class="keyword">if</span> (mDebugDDMS) {</div><div class="line">        <span class="keyword">if</span> (!startDdmConnection()) {</div><div class="line">            <span class="comment">// start failed, and DDMS debugging not enabled</span></div><div class="line">            mDebugDDMS = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    property_get(<span class="string">"debug.sf.fps"</span>, value, <span class="string">"0"</span>);</div><div class="line">    mDebugFPS = atoi(value);</div><div class="line"></div><div class="line">    ALOGI_IF(mDebugRegion, <span class="string">"showupdates enabled"</span>);</div><div class="line">    ALOGI_IF(mDebugDDMS, <span class="string">"DDMS debugging enabled"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// hardware rotation</span></div><div class="line">    property_get(<span class="string">"ro.sf.hwrotation"</span>, value, <span class="string">"0"</span>);</div><div class="line">    mHardwareOrientation = atoi(value) / <span class="number">90</span>;</div><div class="line">    property_get(<span class="string">"ro.sf.lcdc_composer"</span>, value, <span class="string">"0"</span>);</div><div class="line">    mUseLcdcComposer = atoi(value);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * List of all active broadcasts that are to be executed one at a time.</span></div><div class="line"><span class="comment"> * The object at the top of the list is the currently activity broadcasts;</span></div><div class="line"><span class="comment"> * those after it are waiting for the top to finish.  As with parallel</span></div><div class="line"><span class="comment"> * broadcasts, separate background- and foreground-priority queues are</span></div><div class="line"><span class="comment"> * maintained.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> SurfaceFlinger::destroyDisplay(<span class="keyword">const</span> sp&lt;IBinder&gt;& display) {</div><div class="line">    Mutex::Autolock _l(mStateLock);</div><div class="line"></div><div class="line">    ssize_t idx = mCurrentState.displays.indexOfKey(display);</div><div class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) {</div><div class="line">        ALOGW(<span class="string">"destroyDisplay: invalid display token"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DisplayDeviceState& info(mCurrentState.displays.valueAt(idx));</div><div class="line">    <span class="keyword">if</span> (!info.isVirtualDisplay()) {</div><div class="line">        ALOGE(<span class="string">"destroyDisplay called for non-virtual display"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    mCurrentState.displays.removeItemsAt(idx);</div><div class="line">    setTransactionFlags(eDisplayTransactionNeeded);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright (C) 2006-2008 The Android Open Source Project</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></div><div class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></div><div class="line"><span class="comment"> * You may obtain a copy of the License at</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></div><div class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment"> * limitations under the License.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_DATA_DIR = <span class="string">"/data/user/"</span>; </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ActivityManager"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG_MU = <span class="string">"ActivityManagerServiceMU"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> localLOGV = DEBUG;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_SWITCH = localLOGV || <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Control over CPU and battery monitoring.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BATTERY_STATS_TIME = <span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>;      <span class="comment">// write battery stats every 30 minutes.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> MONITOR_CPU_USAGE = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONITOR_CPU_MIN_TIME = <span class="number">5</span>*<span class="number">1000</span>;        <span class="comment">// don't sample cpu less than every 5 seconds.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONITOR_CPU_MAX_TIME = <span class="number">0x0fffffff</span>;    <span class="comment">// wait possibly forever for next cpu sample.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> MONITOR_THREAD_CPU_USAGE = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * java mulit-line comment should use on *</span></div><div class="line"><span class="comment">     * otherwise can't render correct.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Description of a request to start a new activity, which has been held</span></div><div class="line"><span class="javadoc">     * due to app switches being disabled.</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">static</span> class PendingActivityLaunch {</div><div class="line">        ActivityRecord r;</div><div class="line">        ActivityRecord sourceRecord;</div><div class="line">        <span class="keyword">int</span> startFlags;</div><div class="line">    }</div><div class="line"></div><div class="line">    BroadcastQueue broadcastQueueForIntent(Intent intent) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() & Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (DEBUG_BACKGROUND_BROADCAST) {</div><div class="line">            Slog.i(TAG, <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></div><div class="line">                    + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>)</div><div class="line">                    + <span class="string">" queue"</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>bash show as code file list:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java 层 Context 相关接口</span></div><div class="line">frameworks/base/core/java/android/app/ContextImpl.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line">frameworks/base/core/java/android/app/ActivityThread.java</div><div class="line">frameworks/base/core/java/android/content/ServiceConnection</div><div class="line"></div><div class="line"><span class="comment"># java 层 Service 相关接口</span></div><div class="line">frameworks/base/core/java/android/app/IActivityManager.java</div><div class="line">frameworks/base/core/java/android/app/ActivityManager.java</div><div class="line">frameworks/base/core/java/android/app/ActivityManagerNative.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActiveServices.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ServiceRecord.java</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>xml:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></div><div class="line"><span class="comment">&lt;!-- Copyright (C) 2006 The Android Open Source Project</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     Licensed under the Apache License, Version 2.0 (the "License");</span></div><div class="line"><span class="comment">     you may not use this file except in compliance with the License.</span></div><div class="line"><span class="comment">     You may obtain a copy of the License at</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">          http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">     Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment">     distributed under the License is distributed on an "AS IS" BASIS,</span></div><div class="line"><span class="comment">     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment">     See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment">     limitations under the License.</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Layout for a Preference in a PreferenceActivity. The</span></div><div class="line"><span class="comment">     Preference is able to place a specific widget for its particular</span></div><div class="line"><span class="comment">     type in the "widget_frame" layout. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span> </span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:minHeight</span>=<span class="value">"?android:attr/listPreferredItemHeight"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:gravity</span>=<span class="value">"center_vertical"</span></span></div><div class="line"><span class="tag">    <span class="attribute">android:paddingRight</span>=<span class="value">"?android:attr/scrollbarSize"</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="title">RelativeLayout</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"15dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginRight</span>=<span class="value">"6dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"6dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_marginBottom</span>=<span class="value">"6dip"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_weight</span>=<span class="value">"1"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:id</span>=<span class="value">"@+android:id/title"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:singleLine</span>=<span class="value">"true"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:textAppearance</span>=<span class="value">"?android:attr/textAppearanceLarge"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:ellipsize</span>=<span class="value">"marquee"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:fadingEdge</span>=<span class="value">"horizontal"</span> /&gt;</span></div><div class="line">            </div><div class="line">        // 就是在这里改啦，加一个 textColor 属性</div><div class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:id</span>=<span class="value">"@+android:id/summary"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_below</span>=<span class="value">"@android:id/title"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:layout_alignLeft</span>=<span class="value">"@android:id/title"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:textAppearance</span>=<span class="value">"?android:attr/textAppearanceSmall"</span></span></div><div class="line"><span class="tag">            <span class="attribute">android:textColor</span>=<span class="value">"#FFFF0000"</span> </span></div><div class="line"><span class="tag">            <span class="attribute">android:maxLines</span>=<span class="value">"4"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- Preference should place its actual preference widget here. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">android:id</span>=<span class="value">"@+android:id/widget_frame"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:gravity</span>=<span class="value">"center_vertical"</span></span></div><div class="line"><span class="tag">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>markdown origin table:</strong> (en, the origin table format is render well)</p>
<table>
<thead>
<tr>
<th style="text-align:left">API(left)</th>
<th style="text-align:center">存储(center)</th>
<th style="text-align:center">区域</th>
<th style="text-align:right">特性(right)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GetMemDC</td>
<td style="text-align:center">on-screen</td>
<td style="text-align:center">指定大小</td>
<td style="text-align:right">我就是要写长一点一点一点点，哈哈</td>
</tr>
<tr>
<td style="text-align:left">CreateSubMemDC</td>
<td style="text-align:center">off-screen</td>
<td style="text-align:center">指定大小</td>
<td style="text-align:right">短一点</td>
</tr>
</tbody>
</table>
<p><strong>html table:</strong> (en, the parser render bug … …)</p>
<hr>
<table border="1"><br><tr><br>  <th align="center">API</th><br>  <th align="center">存储位置</th><br>  <th align="center">区域</th><br>  <th align="center">特性</th><br></tr><br><tr><br>  <td align="left">CreateMemDC</td><br>  <td align="center">off-screen</td><br>  <td align="center">指定大小</td><br>  <td align="center">我就是要写长一点一点一点点，哈哈</td><br></tr><br><tr><br>  <td align="left">CreateSubMemDC</td><br>  <td align="center">off-screen</td><br>  <td align="center">指定大小</td><br>  <td align="center">短一点</td><br></tr><br></table>

<hr>
<p>manually fix it:</p>
<table border="1"><tr><th align="center">API</th><th align="center">存储位置</th><th align="center">区域</th><th align="center">特性</th></tr><tr>  <td align="left">CreateMemDC</td><td align="center">off-screen</td><td align="center">指定大小</td><td align="center">我就是要写长一点一点一点点，哈哈</td><br></tr><tr><td align="left">CreateSubMemDC</td><td align="center">off-screen</td><td align="center">指定大小</td><td align="center">短一点</td></tr></table>

<p>My test end</p>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div><div class="line"></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div><div class="line"></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line"></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.light3moon.com/1986/12/20/%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/</loc>
    <lastmod>1986-12-19T23:30:16.000Z</lastmod>
    <data>
        <display>
        <title>文章索引</title>
        <pubTime>1986-12-19T16:00:16.000Z</pubTime>
        
         <content><![CDATA[<h2 id="Linux">Linux</h2>
<p><a href="http://light3moon.com/2015/01/10/Linux 命令备忘" title="Linux 命令备忘" target="_blank" rel="external">Linux 命令备忘</a><br><a href="http://light3moon.com/2015/01/11/VI 命令备忘" title="VI 命令备忘" target="_blank" rel="external">VI 命令备忘</a><br><a href="http://light3moon.com/2015/01/11/GDB 命令备忘" title="GDB 命令备忘" target="_blank" rel="external">GDB 命令备忘</a><br><a href="http://light3moon.com/2015/01/13/Git 使用备忘" title="Git 使用备忘" target="_blank" rel="external">Git 使用备忘</a><br><a href="http://light3moon.com/2015/01/13/Rsa 验证简介" title="Rsa 验证简介" target="_blank" rel="external">Rsa 验证简介</a><br><a href="http://light3moon.com/2015/01/13/Repo 命令备忘" title="Repo 命令备忘" target="_blank" rel="external">Repo 命令备忘</a><br><a href="http://light3moon.com/2015/01/13/Gitweb" title="Gitweb" target="_blank" rel="external">Gitweb</a><br><a href="http://light3moon.com/2015/01/19/交叉编译静态库常见问题" title="交叉编译静态库常见问题" target="_blank" rel="external">交叉编译静态库常见问题</a><br><a href="http://light3moon.com/2015/01/19/如何生成 Patch 补丁" title="如何生成 Patch 补丁" target="_blank" rel="external">如何生成 Patch 补丁</a><br><a href="http://light3moon.com/2015/01/19/使用 pkg-config" title="使用 pkg-config" target="_blank" rel="external">使用 pkg-config</a><br><a href="http://light3moon.com/2015/01/13/Linux shell 环境脚本分析" title="Linux shell 环境脚本分析" target="_blank" rel="external">Linux shell 环境脚本分析</a><br><a href="http://light3moon.com/2015/01/18/Linux Shell 进阶环境脚本分析" title="Linux Shell 进阶环境脚本分析" target="_blank" rel="external">Linux Shell 进阶环境脚本分析</a><br><a href="http://light3moon.com/2015/01/19/BBK 工作编译脚本分析" title="BBK 工作编译脚本分析" target="_blank" rel="external">BBK 工作编译脚本分析</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 使用问题总结" title="ubuntu 使用问题总结" target="_blank" rel="external">ubuntu 使用问题总结</a><br><a href="http://light3moon.com/2015/01/19/ubuntu minicom 使用问题总结" title="ubuntu minicom 使用问题总结" target="_blank" rel="external">ubuntu minicom 使用问题总结</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 安装 jdk" title="ubuntu 安装 jdk" target="_blank" rel="external">ubuntu 安装 jdk</a><br><a href="http://light3moon.com/2015/01/19/ubuntu libtool 错误" title="ubuntu libtool 错误" target="_blank" rel="external">ubuntu libtool 错误</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 开启 ftp 服务" title="ubuntu 开启 ftp 服务" target="_blank" rel="external">ubuntu 开启 ftp 服务</a><br><a href="http://light3moon.com/2015/01/19/ubuntu virtual box 问题小结" title="ubuntu virtual box 问题小结" target="_blank" rel="external">ubuntu virtual box 问题小结</a><br><a href="http://light3moon.com/2015/01/19/ubuntu 安装 winusb" title="ubuntu 安装 winusb" target="_blank" rel="external">ubuntu 安装 winusb</a><br><a href="http://light3moon.com/2015/01/19/ctags tag 文件错误问题" title="ctags tag 文件错误问题" target="_blank" rel="external">ctags tag 文件错误问题</a><br><a href="http://light3moon.com/2015/01/19/[转] gimp中如何查看拾色器拾取的颜色的alpha值" title="[转] gimp中如何查看拾色器拾取的颜色的alpha值" target="_blank" rel="external">[转] gimp中如何查看拾色器拾取的颜色的alpha值</a> </p>
<h2 id="Basics_Knowledge">Basics Knowledge</h2>
<p><a href="http://light3moon.com/2015/01/19/[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" title="[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" target="_blank" rel="external">[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</a><br><a href="http://light3moon.com/2015/01/19/reinterpret_cast、static_cast 和 dynamic_cast 的区别" title="reinterpret_cast、static_cast 和 dynamic_cast 的区别" target="_blank" rel="external">reinterpret_cast、static_cast 和 dynamic_cast 的区别</a><br><a href="http://light3moon.com/2015/01/31/[转] Java 的模版和 C++ 模版的区别" title="[转] Java 的模版和 C++ 模版的区别" target="_blank" rel="external">[转] Java 的模版和 C++ 模版的区别</a><br><a href="http://light3moon.com/2015/01/19/[转] 内存对齐" title="[转] 内存对齐" target="_blank" rel="external">[转] 内存对齐</a><br><a href="http://light3moon.com/2015/01/19/Endianness" title="Endianness" target="_blank" rel="external">Endianness</a><br><a href="http://light3moon.com/2015/01/19/[转] float 类型在内存中的表示" title="[转] float 类型在内存中的表示" target="_blank" rel="external">[转] float 类型在内存中的表示</a><br><a href="http://light3moon.com/2015/01/31/[转] unicode 编码表" title="[转] unicode 编码表" target="_blank" rel="external">[转] unicode 编码表</a><br><a href="http://light3moon.com/2015/01/31/[转] 字符编码笔记" title="[转] 字符编码笔记" target="_blank" rel="external">[转] 字符编码笔记</a><br><a href="http://light3moon.com/2015/01/31/[转] 那些 cache 和 buffer —— 上" title="[转] 那些 cache 和 buffer —— 上" target="_blank" rel="external">[转] 那些 cache 和 buffer —— 上</a><br><a href="http://light3moon.com/2015/01/31/[转] 那些 cache 和 buffer —— 下" title="[转] 那些 cache 和 buffer —— 下" target="_blank" rel="external">[转] 那些 cache 和 buffer —— 下</a><br><a href="http://light3moon.com/2015/01/31/[转] 什么是 VSync" title="[转] 什么是 VSync" target="_blank" rel="external">[转] 什么是 VSync</a> </p>
<h2 id="MiniGUI">MiniGUI</h2>
<p><a href="http://light3moon.com/2015/01/19/MiniGUI 自定义控件教程1" title="MiniGUI 自定义控件教程1" target="_blank" rel="external">MiniGUI 自定义控件教程1</a><br><a href="http://light3moon.com/2015/01/19/MiniGUI 自定义控件教程2" title="MiniGUI 自定义控件教程2" target="_blank" rel="external">MiniGUI 自定义控件教程2</a><br><a href="http://light3moon.com/2015/01/19/MiniGUI 自定义控件教程3" title="MiniGUI 自定义控件教程3" target="_blank" rel="external">MiniGUI 自定义控件教程3</a><br><a href="http://light3moon.com/2015/01/20/MiniGUI 自定义控件教程4" title="MiniGUI 自定义控件教程4" target="_blank" rel="external">MiniGUI 自定义控件教程4</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 自定义控件教程5" title="MiniGUI 自定义控件教程5" target="_blank" rel="external">MiniGUI 自定义控件教程5</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 自定义控件教程6" title="MiniGUI 自定义控件教程6" target="_blank" rel="external">MiniGUI 自定义控件教程6</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 自定义控件教程7" title="MiniGUI 自定义控件教程7" target="_blank" rel="external">MiniGUI 自定义控件教程7</a> </p>
<p><a href="http://light3moon.com/2015/01/21/MiniGUI 消息机制源码分析" title="MiniGUI 消息机制源码分析" target="_blank" rel="external">MiniGUI 消息机制源码分析</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI 源码分析笔记" title="MiniGUI 源码分析笔记" target="_blank" rel="external">MiniGUI 源码分析笔记</a><br><a href="http://light3moon.com/2015/01/21/MiniGUI DC 分析" title="MiniGUI DC 分析" target="_blank" rel="external">MiniGUI DC 分析</a> </p>
<p><a href="http://light3moon.com/2015/01/21/STi7167 GAL 开发笔记" title="STi7167 GAL 开发笔记" target="_blank" rel="external">STi7167 GAL 开发笔记</a><br><a href="http://light3moon.com/2015/01/21/联芯透明窗体支持方案" title="联芯透明窗体支持方案" target="_blank" rel="external">联芯透明窗体支持方案</a> </p>
<h2 id="Android_Development">Android Development</h2>
<p><a href="http://light3moon.com/2015/01/25/Java 备忘" title="Java 备忘" target="_blank" rel="external">Java 备忘</a><br><a href="http://light3moon.com/2015/01/25/Java 反射的参数问题" title="Java 反射的参数问题" target="_blank" rel="external">Java 反射的参数问题</a><br><a href="http://light3moon.com/2015/01/25/Android 命令备忘" title="Android 命令备忘" target="_blank" rel="external">Android 命令备忘</a><br><a href="http://light3moon.com/2015/01/25/[转] Android 开发环境搭建全程演示[jdk+eclipse+android sdk]" title="[转] Android 开发环境搭建全程演示（jdk+eclipse+android sdk）" target="_blank" rel="external">[转] Android 开发环境搭建全程演示（jdk+eclipse+android sdk）</a><br><a href="http://light3moon.com/2015/01/25/Android 模拟器使用心得" title="Android 模拟器使用心得" target="_blank" rel="external">Android 模拟器使用心得</a><br><a href="http://light3moon.com/2015/01/25/Android 应用程序开发小问题总结" title="Android 应用程序开发小问题总结" target="_blank" rel="external">Android 应用程序开发小问题总结</a><br><a href="http://light3moon.com/2015/01/25/Android sdk 本地文档加载慢的解决办法&quot;" title="Android sdk 本地文档加载慢的解决办法" target="_blank" rel="external">Android sdk 本地文档加载慢的解决办法</a><br><a href="http://light3moon.com/2015/01/25/ndroid 程序签名问题" title="Android 程序签名问题" target="_blank" rel="external">Android 程序签名问题</a><br><a href="http://light3moon.com/2015/01/25/Linux 下 adb usb 连接 usb 设备问题总结" title="Linux 下 adb usb 连接 usb 设备问题总结" target="_blank" rel="external">Linux 下 adb usb 连接 usb 设备问题总结</a><br><a href="http://light3moon.com/2015/01/25/64位 ubuntu adb No such file or directory 解决办法" title="64位 ubuntu adb No such file or directory 解决办法" target="_blank" rel="external">64位 ubuntu adb No such file or directory 解决办法</a><br><a href="http://light3moon.com/2015/01/25/Android sdk content loader 0 的解决方法" title="Android sdk content loader 0 的解决方法" target="_blank" rel="external">Android sdk content loader 0 的解决方法</a><br><a href="http://light3moon.com/2015/01/25/[转] linux 下 ndk-build 出现 Invalid attribute name package 错误" title="[转] linux 下 ndk-build 出现 Invalid attribute name package 错误" target="_blank" rel="external">[转] linux 下 ndk-build 出现 Invalid attribute name package 错误</a><br><a href="http://light3moon.com/2015/01/25/Android中 Error generating final archive Debug Certificate expired on xx 的错误" title="Android中 Error generating final archive Debug Certificate expired on xx 的错误" target="_blank" rel="external">Android中 Error generating final archive Debug Certificate expired on xx 的错误</a><br><a href="http://light3moon.com/2015/01/25/反编译 Android apk" title="反编译 Android apk" target="_blank" rel="external">反编译 Android apk</a><br><a href="http://light3moon.com/2015/01/25/Android Gesture 使用简介" title="Android Gesture 使用简介" target="_blank" rel="external">Android Gesture 使用简介</a><br><a href="http://light3moon.com/2015/01/25/Android 布局笔记" title="Android 布局笔记" target="_blank" rel="external">Android 布局笔记</a><br><a href="http://light3moon.com/2015/01/25/Android Create Bitmap Out Of Memory" title="Android Create Bitmap Out Of Memory" target="_blank" rel="external">Android Create Bitmap Out Of Memory</a><br><a href="http://light3moon.com/2015/01/25/Android OpenGLES 学习笔记" title="Android OpenGLES 学习笔记" target="_blank" rel="external">Android OpenGLES 学习笔记</a><br><a href="http://light3moon.com/2015/01/25/Android 4.0 访问 WebService 出现 android.os.NetworkOnMainThreadException 异常" title="Android 4.0 访问 WebService 出现 android.os.NetworkOnMainThreadException 异常" target="_blank" rel="external">Android 4.0 访问 WebService 出现 android.os.NetworkOnMainThreadException 异常</a><br><a href="http://light3moon.com/2015/01/25/Android 自定义 Preference" title="Android 自定义 Preference" target="_blank" rel="external">Android 自定义 Preference</a><br><a href="http://light3moon.com/2015/01/25/Android 资源文件夹命名规则" title="Android 资源文件夹命名规则" target="_blank" rel="external">Android 资源文件夹命名规则</a><br><a href="http://light3moon.com/2015/01/25/Android 设置广播标志启动还没启动程序" title="Android 设置广播标志启动还没启动程序" target="_blank" rel="external">Android 设置广播标志启动还没启动程序</a><br><a href="http://light3moon.com/2015/01/26/[转] Android 让应用手动管理应用的数据目录" title="[转] Android 让应用手动管理应用的数据目录" target="_blank" rel="external">[转] Android 让应用手动管理应用的数据目录</a><br><a href="http://light3moon.com/2015/01/26/Android 优秀开源网络框架" title="Android 优秀开源网络框架" target="_blank" rel="external">Android 优秀开源网络框架</a><br><a href="http://light3moon.com/2015/01/26/apk 捕获全局异常" title="apk 捕获全局异常" target="_blank" rel="external">apk 捕获全局异常</a><br><a href="http://light3moon.com/2015/01/26/dmtracedump 的用法" title="dmtracedump 的用法" target="_blank" rel="external">dmtracedump 的用法</a><br><a href="http://light3moon.com/2015/01/26/Android 打印函数调用堆栈调试" title="Android 打印函数调用堆栈调试" target="_blank" rel="external">Android 打印函数调用堆栈调试</a><br><a href="http://light3moon.com/2015/01/26/hierarchyviewer 无法使用问题" title="hierarchyviewer 无法使用问题" target="_blank" rel="external">hierarchyviewer 无法使用问题</a> </p>
<p><a href="http://light3moon.com/2015/01/26/Android 坑爹大全 —— SeekBar" title="Android 坑爹大全 —— SeekBar" target="_blank" rel="external">Android 坑爹大全 —— SeekBar</a><br><a href="http://light3moon.com/2015/01/26/Android 坑爹大全 —— Paint mask filter 无效" title="Android 坑爹大全 —— Paint mask filter 无效" target="_blank" rel="external">Android 坑爹大全 —— Paint mask filter 无效</a> </p>
<h2 id="Android_Framework">Android Framework</h2>
<p><a href="http://light3moon.com/2015/01/27/Android x86 在 X window system 上的调研" title="Android x86 在 X window system 上的调研" target="_blank" rel="external">Android x86 在 X window system 上的调研</a><br><a href="http://light3moon.com/2015/01/27/Android Root Recovery 学习笔记" title="Android Root Recovery 学习笔记" target="_blank" rel="external">Android Root Recovery 学习笔记</a><br><a href="http://light3moon.com/2015/01/27/Android MiniGUI Recovery 笔记" title="Android MiniGUI Recovery 笔记" target="_blank" rel="external">Android MiniGUI Recovery 笔记</a> </p>
<p><a href="http://light3moon.com/2015/03/06/下载 Android 源码问题总结" title="下载 Android 源码问题总结" target="_blank" rel="external">下载 Android 源码问题总结</a><br><a href="http://light3moon.com/2015/01/27/编译 Android 源码问题总结" title="编译 Android 源码问题总结" target="_blank" rel="external">编译 Android 源码问题总结</a><br><a href="http://light3moon.com/2015/01/27/[转] 如何取得Android源代码" title="[转] 如何取得Android源代码" target="_blank" rel="external">[转] 如何取得Android源代码</a><br><a href="http://light3moon.com/2015/01/27/开启 Android SDK 所有的 API 的方法" title="开启 Android SDK 所有的 API 的方法" target="_blank" rel="external">开启 Android SDK 所有的 API 的方法</a><br><a href="http://light3moon.com/2015/01/27/在源码中修改 Android 系统配置" title="在源码中修改 Android 系统配置" target="_blank" rel="external">在源码中修改 Android 系统配置</a><br><a href="http://light3moon.com/2015/01/27/[转] Android locales 本地化" title="[转] Android locales 本地化" target="_blank" rel="external">[转] Android locales 本地化</a><br><a href="http://light3moon.com/2015/01/27/[转] Android系统移植与调试之——build.prop文件详细赏析" title="[转] Android系统移植与调试之——build.prop文件详细赏析" target="_blank" rel="external">[转] Android系统移植与调试之——build.prop文件详细赏析</a> </p>
<p><a href="http://light3moon.com/2015/01/27/Android 按键映射分析" title="Android 按键映射分析" target="_blank" rel="external">Android 按键映射分析</a><br><a href="http://light3moon.com/2015/01/28/forceStopPackage 的副作用" title="forceStopPackage 的副作用" target="_blank" rel="external">forceStopPackage 的副作用</a><br><a href="http://light3moon.com/2015/01/28/vold share 操作清理正在使用磁盘的进程分析" title="vold share 操作清理正在使用磁盘的进程分析" target="_blank" rel="external">vold share 操作清理正在使用磁盘的进程分析</a><br><a href="http://light3moon.com/2015/01/28/Android 开机启动画面分析" title="Android 开机启动画面分析" target="_blank" rel="external">Android 开机启动画面分析</a><br><a href="http://light3moon.com/2015/01/28/Android Surface flinger 颜色格式分析" title="Android Surface flinger 颜色格式分析" target="_blank" rel="external">Android Surface flinger 颜色格式分析</a><br><a href="http://light3moon.com/2015/01/28/Android Provision 的影响和作用" title="Android Provision 的影响和作用" target="_blank" rel="external">Android Provision 的影响和作用</a><br><a href="http://light3moon.com/2015/01/28/Android 智能指针备忘" title="Android 智能指针备忘" target="_blank" rel="external">Android 智能指针备忘</a> </p>
<p><a href="http://light3moon.com/2015/01/28/Android Binder 分析——原理" title="Android Binder 分析——原理" target="_blank" rel="external">Android Binder 分析——原理</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——通信模型" title="Android Binder 分析——通信模型" target="_blank" rel="external">Android Binder 分析——通信模型</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——数据传递者[Parcel]" title="Android Binder 分析——数据传递者（Parcel）" target="_blank" rel="external">Android Binder 分析——数据传递者（Parcel）</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——匿名共享内存[Ashmem]" title="Android Binder 分析——匿名共享内存（Ashmem）" target="_blank" rel="external">Android Binder 分析——匿名共享内存（Ashmem）</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——内存管理" title="Android Binder 分析——内存管理" target="_blank" rel="external">Android Binder 分析——内存管理</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——系统服务 Binder 对象的传递" title="Android Binder 分析——系统服务 Binder 对象的传递" target="_blank" rel="external">Android Binder 分析——系统服务 Binder 对象的传递</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递" title="Android Binder 分析——普通服务 Binder 对象的传递" target="_blank" rel="external">Android Binder 分析——普通服务 Binder 对象的传递</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——多线程支持" title="Android Binder 分析——多线程支持" target="_blank" rel="external">Android Binder 分析——多线程支持</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——懒人的工具[AIDL]" title="Android Binder 分析——懒人的工具（AIDL）" target="_blank" rel="external">Android Binder 分析——懒人的工具（AIDL）</a><br><a href="http://light3moon.com/2015/01/28/Android Binder 分析——死亡通知[DeathRecipient]" title="Android Binder 分析——死亡通知（DeathRecipient）" target="_blank" rel="external">Android Binder 分析——死亡通知（DeathRecipient）</a> </p>
<p><a href="http://light3moon.com/2015/01/22/Android Broadcast 分析——注册" title="Android Broadcast 分析——注册" target="_blank" rel="external">Android Broadcast 分析——注册</a><br><a href="http://light3moon.com/2015/01/22/Android Broadcast 分析——发送、处理" title="Android Broadcast 分析——发送、处理" target="_blank" rel="external">Android Broadcast 分析——发送、处理</a><br><a href="http://light3moon.com/2015/01/22/Android Broadcast 分析——超时或异常" title="Android Broadcast 分析——超时或异常" target="_blank" rel="external">Android Broadcast 分析——超时或异常</a> </p>
<p><a href="http://light3moon.com/2015/02/06/Android SystemUI 分析——最近任务列表" title="Android SystemUI 分析——最近任务列表" target="_blank" rel="external">Android SystemUI 分析——最近任务列表</a><br><a href="http://light3moon.com/2015/02/06/Android SystemUI 分析——通知" title="Android SystemUI 分析——通知" target="_blank" rel="external">Android SystemUI 分析——通知</a><br><a href="http://light3moon.com/2015/03/04/Android SystemUI 分析——状态栏图标" title="Android SystemUI 分析——状态栏图标" target="_blank" rel="external">Android SystemUI 分析——状态栏图标</a> </p>
<p><a href="http://light3moon.com/2015/01/30/Android 一些有意思的命令小工具 —— dumpsys" title="Android 一些有意思的命令小工具 —— dumpsys" target="_blank" rel="external">Android 一些有意思的命令小工具 —— dumpsys</a><br><a href="http://light3moon.com/2015/01/30/Android 一些有意思的命令小工具 —— service" title="Android 一些有意思的命令小工具 —— service" target="_blank" rel="external">Android 一些有意思的命令小工具 —— service</a> </p>
<p><a href="http://light3moon.com/2015/01/30/工作小笔记——扩展字库乱码排查" title="工作小笔记——扩展字库乱码排查" target="_blank" rel="external">工作小笔记——扩展字库乱码排查</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——Android 多用户切换无法启动应用的问题" title="工作小笔记——Android 多用户切换无法启动应用的问题" target="_blank" rel="external">工作小笔记——Android 多用户切换无法启动应用的问题</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——Android 多用户下的要注意的问题" title="工作小笔记——Android 多用户下的要注意的问题" target="_blank" rel="external">工作小笔记——Android 多用户下的要注意的问题</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——Android 动态切换系统字体" title="工作小笔记——Android 动态切换系统字体" target="_blank" rel="external">工作小笔记——Android 动态切换系统字体</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——利用反射需要注意的问题" title="工作小笔记——利用反射需要注意的问题" target="_blank" rel="external">工作小笔记——利用反射需要注意的问题</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——Android 自带的应用统计服务[UsageStatsService]" title="工作小笔记——Android 自带的应用统计服务（UsageStatsService）" target="_blank" rel="external">工作小笔记——Android 自带的应用统计服务（UsageStatsService）</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——拦截应用内置广告.检测篇" title="工作小笔记——拦截应用内置广告.检测篇" target="_blank" rel="external">工作小笔记——拦截应用内置广告.检测篇</a><br><a href="http://light3moon.com/2015/01/31/工作小笔记——拦截应用内置广告.拦截篇" title="工作小笔记——拦截应用内置广告.拦截篇" target="_blank" rel="external">工作小笔记——拦截应用内置广告.拦截篇</a></p>
<p><a href="http://light3moon.com/2015/01/31/Google android source code build 问题总结" title="Google android source code build 问题总结" target="_blank" rel="external">Google android source code build 问题总结</a><br><a href="http://light3moon.com/2015/01/31/[转] Nexus7 2rd unlock fastboot" title="[转] Nexus7 2rd unlock fastboot" target="_blank" rel="external">[转] Nexus7 2rd unlock fastboot</a><br><a href="http://light3moon.com/2015/01/31/删除遗忘的 vpn 存储凭据" title="删除遗忘的 vpn 存储凭据" target="_blank" rel="external">删除遗忘的 vpn 存储凭据</a></p>
<h2 id="Window">Window</h2>
<p><a href="http://light3moon.com/2015/01/31/cygwin 使用备忘" title="cygwin 使用备忘" target="_blank" rel="external">cygwin 使用备忘</a><br><a href="http://light3moon.com/2015/01/31/window 在 cygwin 中使用 repo ssh" title="window 在 cygwin 中使用 repo ssh" target="_blank" rel="external">window 在 cygwin 中使用 repo ssh</a><br><a href="http://light3moon.com/2015/01/31/cygwin screen Directory tmp uscreens S-UserName must have mode 700" title="cygwin screen Directory tmp uscreens S-UserName must have mode 700" target="_blank" rel="external">cygwin screen Directory tmp uscreens S-UserName must have mode 700</a><br><a href="http://light3moon.com/2015/01/31/cygwin screen Caption line issue" title="cygwin screen Caption line issue" target="_blank" rel="external">cygwin screen Caption line issue</a> </p>
<p><a href="http://light3moon.com/2015/01/31/EFI 安装系统" title="EFI 安装系统" target="_blank" rel="external">EFI 安装系统</a><br><a href="http://light3moon.com/2015/01/31/提取 OEM window key" title="提取 OEM window key" target="_blank" rel="external">提取 OEM window key</a><br><a href="http://light3moon.com/2015/01/31/window 下的 linux 开发工具" title="window 下的 linux 开发工具" target="_blank" rel="external">window 下的 linux 开发工具</a><br><a href="http://light3moon.com/2015/01/31/window 开启自带 ftp" title="window 开启自带 ftp" target="_blank" rel="external">window 开启自带 ftp</a> </p>
<p><a href="http://light3moon.com/2015/01/31/win8.1 自带程序入口" title="win8.1 自带程序入口" target="_blank" rel="external">win8.1 自带程序入口</a><br><a href="http://light3moon.com/2015/01/31/win8.1 蓝牙使用备忘" title="win8.1 蓝牙使用备忘" target="_blank" rel="external">win8.1 蓝牙使用备忘</a><br><a href="http://light3moon.com/2015/01/31/win8.1 微软输入法备忘" title="win8.1 微软输入法备忘" target="_blank" rel="external">win8.1 微软输入法备忘</a> </p>
<h2 id="Other">Other</h2>
<p><a href="http://light3moon.com/2015/01/31/OES_draw_texture 详解" title="OES_draw_texture 详解" target="_blank" rel="external">OES_draw_texture 详解</a><br><a href="http://light3moon.com/2015/01/31/GL 中的纹理坐标" title="GL 中的纹理坐标" target="_blank" rel="external">GL 中的纹理坐标</a> </p>
<p><a href="http://light3moon.com/2015/01/31/Python 使用总结" title="Python 使用总结" target="_blank" rel="external">Python 使用总结</a><br><a href="http://light3moon.com/2015/01/31/Eclipse 插件小结" title="Eclipse 插件小结" target="_blank" rel="external">Eclipse 插件小结</a><br><a href="http://light3moon.com/2015/01/31/[转] eclipse 代码补齐、注释小窗口崩溃解决方法" title="[转] eclipse 代码补齐、注释小窗口崩溃解决方法" target="_blank" rel="external">[转] eclipse 代码补齐、注释小窗口崩溃解决方法</a><br><a href="http://light3moon.com/2015/01/31/[转] Dia 无法输入中文" title="[转] Dia 无法输入中文" target="_blank" rel="external">[转] Dia 无法输入中文</a><br><a href="http://light3moon.com/2015/01/31/[转] 如何在 github 上删除一个仓库" title="[转] 如何在 github 上删除一个仓库" target="_blank" rel="external">[转] 如何在 github 上删除一个仓库</a> </p>
<p><a href="http://light3moon.com/2015/01/10/Test" title="Test" target="_blank" rel="external">Test</a> </p>
]]></content>
         
         
           
        </display>
    </data>
    </url>

</urlset>
