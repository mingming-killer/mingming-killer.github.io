
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——内存管理 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="android 为了高效的 IPC 通信做了很多工作，内存管理就属于其中之一。传统的 IPC 传递数据，至少需要2次拷贝，一次为进程1到内核，一次为内核到进程2，但是得益 android binder 的内存管理，数据拷贝只有1次，就从这里速度比传统的要快1倍。这里慢慢分析。还是先说下相关代码的位置">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">〜(￣△￣〜) 三月学长的根据地 (〜￣△￣)〜</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——内存管理/" title="Android Binder 分析——内存管理" itemprop="url">Android Binder 分析——内存管理</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T13:14:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2016-03-31T02:27:16.000Z" itemprop="dateModified">2016 3月 31</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#只复制一次的实现"><span class="toc-number">3.</span> <span class="toc-text">只复制一次的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际运用"><span class="toc-number">4.</span> <span class="toc-text">实际运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">5.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>android 为了高效的 IPC 通信做了很多工作，内存管理就属于其中之一。传统的 IPC 传递数据，至少需要2次拷贝，一次为进程1到内核，一次为内核到进程2，但是得益 android binder 的内存管理，数据拷贝只有1次，就从这里速度比传统的要快1倍。这里慢慢分析。还是先说下相关代码的位置（其实还有很多 linux 编程的相关基础知识）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># native binder 头文件</span></div><div class="line">frameworks/native/include/binder</div><div class="line"><span class="comment"># native binder 实现</span></div><div class="line">frameworks/native/libs/binder</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="基础知识">基础知识</h2>
<p>首先得说下一些相关的基础知识。这里很多我都是找网上现成的，因为这方面的基础知识我几乎为0 -_-||。先说下，为什么 linux 要使用虚拟地址映射物理地址，内存为什么要分页：<br><a href="http://blog.chinaunix.net/uid-26611383-id-3761754.html" title="Linux中的内存管理" target="_blank" rel="external">Linux中的内存管理</a></p>
<p>然后还有这篇有介绍 linux 用户空间和内核空间的：<br><a href="http://blog.csdn.net/f22jay/article/details/7925531" title="Linux用户空间与内核空间" target="_blank" rel="external">Linux用户空间与内核空间</a></p>
<p>然后 linux 中的内存是分页的，也就是说要按照页大小对齐。这个在后面内存分配那里能够体现出来，这里先提前说一下。</p>
<h2 id="原理">原理</h2>
<p>前面几篇也说过了，IPC 中最基本的问题在于进程间使用的虚拟地址空间是相互独立的，不能直接访问，所以要相互访问，就要借助 kernel ，就是要让数据用用户空间进入到内核空间，然后再去到另一个进程的用户空间。传统的 IPC 是这样的，其实 binder 也是这样的，不过它把内核空间的地址和用户空间的虚拟地址映射到了同一段物理地址上，所以就只需要把数据从原始用户空间复制到内核空间，把目标进程用户空间和内核空间映射到同一段物理地址，这样第一次复制到内核空间，其实目标的用户空间上也有这段数据了。这就是 binder 比传统 IPC 高效的一个原因。</p>
<p>这么抽象的文字，不太好理解吧，下面从代码慢慢看吧：</p>
<h2 id="只复制一次的实现">只复制一次的实现</h2>
<p>首先 ProcessState 初始化的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ProcessState::ProcessState()</div><div class="line">    : mDriverFD(open_driver())</div><div class="line">    , mVMStart(MAP_FAILED)</div><div class="line">    , mManagesContexts(<span class="keyword">false</span>)</div><div class="line">    , mBinderContextCheckFunc(NULL)</div><div class="line">    , mBinderContextUserData(NULL)</div><div class="line">    , mThreadPoolStarted(<span class="keyword">false</span>)</div><div class="line">    , mThreadPoolSeq(<span class="number">1</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) {</div><div class="line">        <span class="comment">// XXX Ideally, there should be a specific define for whether we</span></div><div class="line">        <span class="comment">// have mmap (or whether we could possibly have the kernel module</span></div><div class="line">        <span class="comment">// availabla).</span></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> !defined(HAVE_WIN32_IPC)</span></div><div class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></div><div class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>); </div><div class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) {</div><div class="line">            <span class="comment">// *sigh*</span></div><div class="line">            ALOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</div><div class="line">            close(mDriverFD);</div><div class="line">            mDriverFD = -<span class="number">1</span>; </div><div class="line">        }   </div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">        mDriverFD = -<span class="number">1</span>; </div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    } </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个 <code>open_driver()</code> 是打开 /dev/binder 这个设备节点。额，这里多扯下这个设备节点相关的知识。这个是 android 为 binder 驱动创建的虚拟设备节点。什么叫虚拟的咧，像触摸屏、传感器这些设备节点是有真实的物理设备的，但是 binder 确没有，只是为 IPC 创建的驱动而已，所以是虚拟的。android 上 linux 不支持动态创建设备节点，所有的设备节点都是通过 system/core/init 这个 init 程序创建的。这个东西有个配置文件，可以配置要创建哪里设备节点，默认的在 system/core/rootdir/ueventd.rc 这个文件中：</p>
<pre config="brush:bash;toolbar:false;">
/dev/null                 0666   root       root
/dev/zero                 0666   root       root
/dev/full                 0666   root       root
/dev/ptmx                 0666   root       root
/dev/tty                  0666   root       root
/dev/random               0666   root       root
/dev/urandom              0666   root       root
/dev/ashmem               0666   root       root
/dev/binder               0666   root       root
</pre>

<p>可以在 devices 下面 ueventd.xx.rc 加上自己机器板子上相关的设备节点。</p>
<p>好，回到打开 /dev/binder 那，这里有个 mmap ，前面有一篇说到这里看注释这是映射给 binder 驱动接受数据用的 buffer，但是你搜索完整个 binder 模块（frameworks/native/lib/binder）发现没一个地方使用 mVMStart 这个返回的映射地址空间。注意一下 mmap 设置的标志： <code>PROT_READ</code> 。这个标志说明映射的这段内存是只读的，当然在这个模块没使用（其实读也没用到）。</p>
<p>其实映射的这段内存是内核的 binder 驱动在使用，同时也在管理，而且这里也是前面提到的 IPC 中只复制一次的实现的地方。</p>
<p>我们去 binder 驱动中看下， mmap 经过系统调用，最后会调用 binder 驱动的 binder_mmap：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_mmap(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret; </div><div class="line">    <span class="keyword">struct</span> vm_struct *area;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line"></div><div class="line">    <span class="comment">// 限制下映射内存的大小，最大不超过 4M</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags & FORBIDDEN_MMAP_FLAGS) {</div><div class="line">        ret = -EPERM;</div><div class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</div><div class="line">        <span class="keyword">goto</span> err_bad_arg;</div><div class="line">    }</div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) & ~VM_MAYWRITE;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) {</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 在内核中申请一段内存空间，和用户空间的 malloc 差不多吧，我对内核方面的 api 了解基本为 0 -_-||</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    <span class="keyword">if</span> (area == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"get_vm_area"</span>;</div><div class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</div><div class="line">    }</div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CONFIG_CPU_CACHE_VIPT</span></div><div class="line">    <span class="keyword">if</span> (cache_is_vipt_aliasing()) {</div><div class="line">        <span class="keyword">while</span> (CACHE_COLOUR((vma-&gt;vm_start ^ (uint32_t)proc-&gt;buffer))) {</div><div class="line">            printk(KERN_INFO <span class="string">"binder_mmap: %d %lx-%lx maps %p bad alignment\n"</span>, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);</div><div class="line">            vma-&gt;vm_start += PAGE_SIZE;</div><div class="line">        }    </div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    <span class="comment">// 申请好内存页面结构所占用的内存</span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc-&gt;pages == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc page array"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</div><div class="line">    }</div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">    vma-&gt;vm_ops = &binder_vm_ops;</div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line"></div><div class="line">    <span class="comment">// 映射一个内存页（把内核空间和用户空间同时映射到同一物理地址）</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    }</div><div class="line">    <span class="comment">// 把分配好内存插入到对应的表中（空闲内存表）</span></div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    INIT_LIST_HEAD(&proc-&gt;buffers);</div><div class="line">    list_add(&buffer-&gt;entry, &proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(current);</div><div class="line">    proc-&gt;vma = vma;</div><div class="line"></div><div class="line">    printk(KERN_INFO <span class="string">"binder_mmap: %d %lx-%lx maps %p\n"</span>,</div><div class="line">         proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">err_alloc_small_buf_failed:</div><div class="line">    kfree(proc-&gt;pages);</div><div class="line">    proc-&gt;pages = NULL;</div><div class="line">err_alloc_pages_failed:</div><div class="line">    vfree(proc-&gt;buffer);</div><div class="line">    proc-&gt;buffer = NULL;</div><div class="line">err_get_vm_area_failed:</div><div class="line">err_already_mapped:</div><div class="line">err_bad_arg:</div><div class="line">    printk(KERN_ERR <span class="string">"binder_mmap: %d %lx-%lx %s failed %d\n"</span>,</div><div class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>额，从这开始要涉及到内核的一些相关知识，我其实对这些一窍不通，这里推荐去看下这里：<br><a href="http://blog.csdn.net/xiaojsj111/article/details/31422175" title="binder驱动-------之内存映射篇" target="_blank" rel="external">binder驱动———-之内存映射篇</a></p>
<p>其实我能弄明白 binder 的内存管理，很大程序上得感觉这篇博文的博，他已经说得挺清楚了的，但是还是自己再整一次记得比较深。</p>
<p>对应程序 map 内存的情况，可以通过 cat /proc/pid/maps 查看，普通走 android binder 封装的程序（就是 ProcessState 那）映射的内存大小是 1M 左右：</p>
<pre config="brush:bash;toolbar:false;">
#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))
</pre>

<p>唯独特殊的 servicemanager （它是直接通过 ioctl 来使用 binder 的）映射的内存比较小（frameworks/base/cmds/servicemanager/service_manager.c）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_state *bs;</div><div class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) {</div><div class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    svcmgr_handle = svcmgr;</div><div class="line">    binder_loop(bs, svcmgr_handler);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这片内存是接收 IPC 中客户发送过来的数据的，所以之前网上有人说使用 bundle 在 activity 之间传递数据不能太大，如果超过 1M 就会出现错误。现在明白了吧，bundle 最后是通过 binder 来传递数据的，底层接收数据的 buffer 一共才 1M（其实比1M小点，还减了8k去咧），超过 1M 肯定就失败啦。那 servicemanager 为什么才开 128k 的空间呢，去看看 servicemanager 的接口就知道了，它一共才3个接口：addService、getSerivce、checkSerivce，参数都没几个，所以 128k 肯定够了。上张图来看看吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/1.png" alt=""></p>
<p>servermanager /dev/binder map 的内存区域是： 40185000 - 401a5000（16进制的） 正好是 128*1024。那个 k7service 是我写的一个测试的 native 小程序（Bn端的），它 /dev/binder map 的内存区域是： 4020e000 - 4030c000，也正好是 1M - 4k。</p>
<p>vma 这个变量是 mmap 调用后，系统传过来的，包含了内核分配给这次 mmap 映射的内存地址的一些信息，其中就有比较重要的起始和结束地址： <code>vma-&gt;vm_start</code> 和 <code>vma-&gt;vm_end</code>。然后我们慢慢往下看，后面通过传递过来的地址计算出要映射的内存大小（这里注意下，vma 里面地址是用户空间的地址），然后使用 <code>get_vm_area</code> 这个调用向内核申请一片内存空间。这个申请的是内核空间的内存，感觉有点像上层的 malloc，我对这个也不是很了解，只能先这么认为了。再注意一点这里只是向内核申请了一片内存空间而已，还是真正的分配物理地址（建立虚拟地址到物理地址的映射关系）。</p>
<p>申请成功后，会返回一个 <code>vm_struct</code> 的结构，里面有描述这片内存区域的信息，这里把内核这片区域的起始地址 addr 保存在了 <code>proc-&gt;buffer</code> 这个变量里面。然后后面那个 <code>proc-&gt;user_buffer_offset</code> 这个变量的计算很关键：</p>
<pre config="brush:bash;toolbar:false;">
proc->user_buffer_offset = vma->vm_start - (uintptr_t)proc->buffer;
</pre>

<p>拿用户空间的地址去减内核空间的地址，得到这2个地址的偏移量（这个名字取得也很直接： <code>user_buffer_offset</code>）。前面给的一篇参考文章里说到，32位的 linux（目前的 android 还都是32位的）总共可用内存空间 4G，0G～3G 为用户空间（也就是应用程序使用的空间），3G～4G 为内核空间，用户空间无法访问内核空间，但是内核空间可以访问用户空间。所以这里申请到内核空间的地址，然后拿 mmap 传递过来的用户空间的地址去减得到偏移。但是这里有个奇怪的地方我不太理解的，这里是拿低地址 - 高地址，得到的应该是负数，但是地址是无符号的，所以得到的是 0xffffffff 减去的数值，然后后面拿这个值加上用户空间地址还能正确的得到内核空间地址，反正我是醉了。在 binder 里加了点打印，上个图来点真相（是我写的那个 k7service 的小程序）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/2.png" alt=""></p>
<p>1198 是 k7service 的 pid，然后分配的用户空间范围是： 4020e000 - 4030c000（和前面 cat 看到的一样），然后分配的内核空间起始地址是： e2f00000，确实是从 3G（0xc0000000）开始的。</p>
<p>后面 <code>proc-&gt;buffer_size</code> 就是用 mmap 传过来的地址一减就能得到映射内存的大小。后面 <code>binder_update_page_range</code> 这个函数是同时映射用户空间和内核空间，调用这个才是真正的分配物理地址，这个后面再说。</p>
<p>proc-&gt;pages 是一个指向指针的指针，struct page 是内核的代表内存页的数据结构。前面也说了 linux 带 MMU 的内存管理都是分页的（现在跑 android 的芯片基本都带 MMU）。这里是拿内核一页的大小（经过打印我手上的板子上 <code>PAGE_SIZE</code> 是 4096，也就是 4k，一般都是这大小吧），算出 mmap 映射的内存一共可以分为几页，然后事先先把保存内核页的数据结构的数组分配好。</p>
<p>然后后面那句： <code>buffer = proc-&gt;buffer;</code>。<code>proc-&gt;buffer</code> 是这片内存内核空间的首地址，这个 buffer 是一个叫 <code>binder_buffer</code> 的结构体，用来表示 binder 分配内存的块的一个块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_buffer {</div><div class="line">    <span class="keyword">struct</span> list_head entry; <span class="comment">/* free and allocated entries by addesss */</span></div><div class="line">    <span class="keyword">struct</span> rb_node rb_node; <span class="comment">/* free entry by size or allocated entry */</span></div><div class="line">                <span class="comment">/* by address */</span>               </div><div class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_node *target_node;</div><div class="line">    size_t data_size;</div><div class="line">    size_t offsets_size;</div><div class="line">    uint8_t data[<span class="number">0</span>];</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面的变量都先不说，注意看最后那个叫 data[0] 的变量。这个 data 其实表示的是地址来的。这个是怎么回事咧，其实 binder mmap 这一片内存中，是分成一块块的（<code>binder_buffer</code>），内存中的排列是这样的：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/3.png" alt=""></p>
<p>每一块数据前面跟着一个 <code>binder_buffer</code>，然后紧着下一个，一个跟一个保存在 <code>proc-&gt;buffers</code> 这个链表里。然后再看看刚刚说的那句：<code>buffer = proc-&gt;buffer;</code> 。这句话相当于是说：</p>
<ol>
<li>分配内核第一块 <code>binder_buffer</code>。</li>
<li>同时， <code>proc-&gt;buffer</code> 这个首地址就是第一个块 <code>binder_buffer</code>，并且 <code>binder_buffer</code> 的 data 就是这块 <code>binder_buffer</code> 指向的数据地址。所以这个 data 必须要放在这个结构体的最后（kernel 的链表实现则是利用结构体的首变量（地址），在这种淫荡的技能上，c 秒杀 java）。</li>
</ol>
<p>这种简洁、高效的办法，kernel 的代码中有不少，可以好好运用一下。</p>
<p>然后后面是把刚刚分配好的这块 <code>binder_buffer</code> 分别插入到 proc 的 buffers 链表和 <code>free_buffers</code> 红黑树中。这里稍微看下 <code>binder_proc</code> 中几个相关的成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc {</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root free_buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;</div><div class="line">    size_t free_async_space;</div><div class="line"></div><div class="line">    ... ...</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>



<p>这几个变量分别代表：</p>
<ul>
<li>buffers： 这个链表保存了所有已经分配的 <code>binder_buffer</code> 内存块。</li>
<li><code>free_buffers</code>: 这个红黑树保持了还未使用的 <code>binder_buffer</code> 内存块，就是已经分配了，但是没还创建物理内存映射的，说是分配倒不如说创建的好理解点，就是说 <code>binder_buffer</code> 这个结构体已经创建，然后在那片内存中占了个空位，要申请内存，可以不用重新创建对象，不用重新再那片内存重新分配。使用红黑树提高查找速度，按 <code>binder_buffer</code> 的 size 排列（后面的查找算法，会发现使用红黑树的好处）。</li>
<li><code>allocated_buffers</code>：这里保存的是已经建立好物理内存映射的 <code>binder_buffer</code> 内存块，也是说正在使用中的 <code>binder_buffer</code>。也是一颗红黑树。</li>
</ul>
<p>所以理论上，<code>proc-&gt;buffers</code> 里有所有的 <code>binder_buffer</code>，然后 <code>proc-&gt;buffers</code> 的里的是 <code>proc-&gt;free_buffers</code> 和 <code>allocated_buffers</code> 之和。</p>
<p>一般用法是刚开始新分配一个 <code>binder_buffer</code> 插入到 <code>proc-&gt;buffers</code> 里，同时也插入 <code>proc-&gt;free_buffers</code> 里。<code>binder_mmap</code> 就是一开是分配了一个 <code>binder_buffer</code>。然后后面数据来了，要申请使用 <code>binder_buffer</code> 会先在 <code>proc-&gt;free_buffers</code> 里查找大小最接近要求的 <code>binder_buffer</code> 块，然后调用 <code>binder_update_page_range</code> 将这块 <code>binder_buffer</code> 的用户空间地址和内核地址映射到物理地址（真正的分配内存），然后把这块 <code>binder_buffer</code> 从 <code>proc-&gt;free_buffers</code> 中删掉，再插入到 <code>allocated_buffers</code> 中。然后重复。当然里面还有不少细节，还有内存管理相关的，这些后面再说。</p>
<p>这里 <code>binder_mmap</code> 差不多看完了，那回去看看那个 <code>binder_update_page_range</code>，这个是将用户地址和内核地址映射到同一物理地址上，来看看是怎么做到的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_update_page_range(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> allocate,</div><div class="line">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</div><div class="line">                    <span class="keyword">struct</span> vm_area_struct *vma)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> *page_addr;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</div><div class="line">    <span class="keyword">struct</span> vm_struct tmp_area;</div><div class="line">    <span class="keyword">struct</span> page **page;</div><div class="line">    <span class="keyword">struct</span> mm_struct *mm;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (end &lt;= start)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma)</div><div class="line">        mm = NULL;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        mm = get_task_mm(proc-&gt;tsk);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mm) {</div><div class="line">        down_write(&mm-&gt;mmap_sem);</div><div class="line">        vma = proc-&gt;vma;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 第二个参数为 0 则是解除内存映射（释放内存）</span></div><div class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> free_range;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma == NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed to "</span></div><div class="line">               <span class="string">"map pages in userspace, no vma\n"</span>, proc-&gt;pid);</div><div class="line">        <span class="keyword">goto</span> err_no_vma;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 循环分配内存页面</span></div><div class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) {</div><div class="line">        <span class="keyword">int</span> ret;</div><div class="line">        <span class="keyword">struct</span> page **page_array_ptr;</div><div class="line">        <span class="comment">// 根据地址计算出所处的内存页面数组的索引</span></div><div class="line">        page = &proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</div><div class="line"></div><div class="line">        BUG_ON(*page);</div><div class="line">        <span class="comment">// 向内核申请内存页面</span></div><div class="line">        *page = alloc_page(GFP_KERNEL | __GFP_ZERO);</div><div class="line">        <span class="keyword">if</span> (*page == NULL) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed "</span></div><div class="line">                   <span class="string">"for page at %p\n"</span>, proc-&gt;pid, page_addr);</div><div class="line">            <span class="keyword">goto</span> err_alloc_page_failed;</div><div class="line">        }</div><div class="line">        <span class="comment">// 设置要映射的内核地址</span></div><div class="line">        tmp_area.addr = page_addr;</div><div class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>; </div><div class="line">        page_array_ptr = page;</div><div class="line">        <span class="comment">// 将设置好的内存页做物理内存映射（这里是内核的）</span></div><div class="line">        ret = map_vm_area(&tmp_area, PAGE_KERNEL, &page_array_ptr);</div><div class="line">        <span class="keyword">if</span> (ret) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed "</span></div><div class="line">                   <span class="string">"to map page at %p in kernel\n"</span>,</div><div class="line">                   proc-&gt;pid, page_addr);</div><div class="line">            <span class="keyword">goto</span> err_map_kernel_failed;</div><div class="line">        }</div><div class="line">        <span class="comment">// 根据前面保存的地址偏移，计算出内核地址对应的用户地址</span></div><div class="line">        user_page_addr =</div><div class="line">            (uintptr_t)page_addr + proc-&gt;user_buffer_offset;</div><div class="line">        <span class="comment">// 这里是做用户地址到物理内存的映射</span></div><div class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">if</span> (ret) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf failed "</span></div><div class="line">                   <span class="string">"to map page at %lx in userspace\n"</span>,</div><div class="line">                   proc-&gt;pid, user_page_addr);</div><div class="line">            <span class="keyword">goto</span> err_vm_insert_page_failed;</div><div class="line">        }</div><div class="line">        <span class="comment">/* vm_insert_page does not seem to increment the refcount */</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (mm) {</div><div class="line">        up_write(&mm-&gt;mmap_sem);</div><div class="line">        mmput(mm);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">free_range:</div><div class="line">    <span class="comment">// 这里是释放映射的</span></div><div class="line">    <span class="keyword">for</span> (page_addr = end - PAGE_SIZE; page_addr &gt;= start;</div><div class="line">         page_addr -= PAGE_SIZE) {</div><div class="line">        page = &proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</div><div class="line">        <span class="keyword">if</span> (vma)</div><div class="line">            zap_page_range(vma, (uintptr_t)page_addr +</div><div class="line">                proc-&gt;user_buffer_offset, PAGE_SIZE, NULL);</div><div class="line">err_vm_insert_page_failed:</div><div class="line">        unmap_kernel_range((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr, PAGE_SIZE);</div><div class="line">err_map_kernel_failed:</div><div class="line">        __free_page(*page);</div><div class="line">        *page = NULL;</div><div class="line">err_alloc_page_failed:</div><div class="line">        ;</div><div class="line">    }</div><div class="line">err_no_vma:</div><div class="line">    <span class="keyword">if</span> (mm) {</div><div class="line">        up_write(&mm-&gt;mmap_sem);</div><div class="line">        mmput(mm);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> -ENOMEM;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>一开始有个 end &lt;= start 的判断，后面会发现，当 end == start 的时候是表示这段内存已经映射过了。然后是那第二参数，为 0 的时候表示释放映射，我们先看映射的情况。下面是一个循环，前面说了 linux 内存是分页的，所以就要一页一页的映射，这里就是从映射起始地址到结束看需要映射几页。然后循环开始通过地址算出当前地址所在的页在之前创建的页数组中的位置，proc-&gt;pages 前面 mmap 那里提前创建好了。然后是 <code>alloc_page</code> 申请内核页面，以后有时间补补相关知识，现在暂时理解为 malloc 差不多就行了。后面设置这个页面的地址，然后大小的时候不知道为什么多加了 <code>PAGE_SIZE</code> 大小，看注释是说防止页面越界？？ <code>map_vm_area</code> 把刚刚设置的内核页面做物理内存映射，到这里才算真正分配内存。</p>
<p>这里 <code>proc-&gt;user_buffer_offset</code> 这个前面保存的内核到用户地址的偏移终于派上用场了。通过这个偏移可以算得出内核空间地址对应的用户空间地址。然后 <code>vm_insert_page</code> 把这段用户空间地址也做一次物理内存映射。这样内核空间地址和用户空间的地址就映射到同一块物理内存上了。这里由于缺少相关的知识我还是不怎么理解，这几个内核的 api 调用是咋回事，但是简单来说：如果你在 binder 驱动对内核这段地址的内存写入数据，对应用户空间的那段内存也会有同样的数据。这样就省去了一次 <code>copy_to_user</code> 的从内核空间到用户空间的数据 copy。</p>
<p>最后来张图吧，这样比较简单明了：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-memory/4.png" alt=""></p>
<h2 id="实际运用">实际运用</h2>
<p>前面说了那么多，来点例子看看是怎么运用只 copy 一次的。假设有个 proc A 发起了一次 IPC 调用，那么根据前面的讲解会通过 IPCThreadState.transact 发送到 binder 的 <code>binder_thread_write</code> 写请求，然后是跑到了 <code>binder_thread_transaction</code> 中。我们这里来看看前面 <code>binder_transaction</code> 中忽略的一些细节。在 <code>binder_transaction</code> 有这么一句：</p>
<pre config="brush:bash;toolbar:false;">
    t->buffer = binder_alloc_buf(target_proc, tr->data_size,
        tr->offsets_size, !reply && (t->flags & TF_ONE_WAY));
</pre>

<p>这里跑到了 <code>binder_alloc_buf</code> 里面，这个函数后面在内存管理那里再分析，这里向跳过，反正记住调用这个会给你返回一块符合你指定大小的 <code>buffer_size</code>（当然得有足够的内存空间）。然后这里注意一点，传递的一个参数是 <strong><code>target_proc</code></strong>，这个是从目标进程分配的 buffer，也就是 proc B。这个很关键，后面就能知道数据是怎么传递的了。然后接着看后面的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">    binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">        <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">    return_error = BR_FAILED_REPLY;</div><div class="line">    <span class="keyword">goto</span> err_copy_data_failed;     </div><div class="line">}</div><div class="line"><span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">    binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">        <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">    return_error = BR_FAILED_REPLY;</div><div class="line">    <span class="keyword">goto</span> err_copy_data_failed;     </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 <code>buffer-&gt;data</code> 的淫荡前面分析过了，这个就是这块 buffer 的存放数据的首地址。唉，这里其实调用了2次 <code>copy_from_user</code> 一次 copy parcel 的 data 数据，一次 copy parcel 里 <code>flat_binder_object</code> 的偏移地址的数据（-_-||）。其实我们就将就认为只有一次 copy 吧。这里就把 proc A 从用户空间传递过来的数据（parcel 打包）copy 到内核空间了。而且这个内核空间的内存是 proc B 提供的，而且这个块内核空间还和 proc B 的用户空间共同映射到了同一块物理内存上。</p>
<p>但是别激动先，我们把整个流程看完。根据前面的分析 <code>binder_transaction</code> 后面把从 proc B 获取了 <code>binder_buffer</code> 的 <code>binder_transaction</code> 这个数据结构插入到 proc B 的 work 队列中并且唤醒阻塞等待数据的 proc B 的 <code>binder_thread_read</code>。我们来看看 <code>binder_thread_read</code> 中前面忽略的一些比较重要的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tr.data_size = t-&gt;buffer-&gt;data_size;</div><div class="line">tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</div><div class="line">tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</div><div class="line">            proc-&gt;user_buffer_offset;      </div><div class="line">tr.data.ptr.offsets = tr.data.ptr.buffer +</div><div class="line">            ALIGN(t-&gt;buffer-&gt;data_size,    </div><div class="line">                <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));               </div><div class="line"></div><div class="line"><span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">    <span class="keyword">return</span> -EFAULT;   </div><div class="line">ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line"><span class="keyword">if</span> (copy_to_user(ptr, &tr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">    <span class="keyword">return</span> -EFAULT;   </div><div class="line">ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line"></div></pre></td></tr></table></figure>

<p>t 就是从前面 proc A <code>binder_transaction</code> 插到 proc B 的 work 队列里的，然后从它这里获取 <code>data_size</code>, <code>offsets_size</code> 之类，这些都是前面设置好的。然后观点的地方来了：</p>
<pre config="brush:bash;toolbar:false;">
        tr.data.ptr.buffer = (void *)t->buffer->data +
                    proc->user_buffer_offset; 
</pre>

<p>tr 是 <code>binder_transaction_data</code> 这个数据结构，是在用户层和 binder 驱动传递数据的数据结构。直接取 <code>buffer-&gt;data + user_buffer_offset</code> 这个地址。根据前面的分析 <code>buffer-&gt;data</code> 是前面 proc A 塞数据的内核地址，<code>user_buffer_offset</code> 是用内核地址到用户空间地址的偏移，一加就得到了同一物理地址的用户空间地址。这里其实就差不多相当于数据从 proc A 传递到 proc B 了。这里就相当于传递 IPC 内核到用户空间的那一次 copy，但是这里只是计算了一个地址偏移而已。</p>
<p>然后看看后面， <code>put_user</code> 是把 binder 命令（cmd）返回给用户空间。还有后面有一个 <code>copy_to_user</code> 但是这个不是 copy 数据的，而是 copy <code>binder_transaction_data</code> 这个数据结构，只不过这个数据结构里有传递数据的地址，所以这个不算在 binder 数据传递的复制次数中。也就是说就算传递比较大的数据，这次复制只是复制一个数据结构的大小。根据前面的分析，<code>binder_thread_read</code> 返回，<code>binder_ioctl</code> 就返回了，然后就到用户空间的 IPCThreadState 的 talkWithDriver，然后 proc B（从假设的例子看是 Bn 端）就该执行 executeCommand 的 <code>BR_TRANSACTION</code> 命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">binder_transaction_data tr;</div><div class="line">result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">ALOG_ASSERT(result == NO_ERROR,</div><div class="line">    <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line"><span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">Parcel buffer;</div><div class="line">buffer.ipcSetDataReference(</div><div class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">    tr.data_size,</div><div class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">    tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>看 <code>binder_transaction_data</code> 从 mIn 中读出来了吧，这个是前面 <code>binder_thread_read copy_to_user</code> 传递到用户空间的。然后这个里面的 tr.data.ptr.buffer 就是 proc A 传递的 IPC 函数调用参数数据啦。</p>
<h2 id="内存管理">内存管理</h2>
<p>前面把数据传递的基本流程走完了，最后看看内存管理。每一个 binder 通信的进程都 mmap 了一片内存（目前来看是 1M），然后在这片内存上按照请求分块（<code>binder_buffer</code>）。那一般就涉及到，如何分块，如果查找合适大小的 <code>binder_buffer</code> 块，以及使用完成后，碎片合并的问题。现在就来看看。</p>
<p>前面说了，一开始 binder 会映射一页的内存（一般是 4k），然后插入到 <code>proc-&gt;free_buffers</code> 中去。然后要需要使用的时候先从 <code>free_buffers</code> 里找大小最接近的，我们看看是怎么查找的，就是前面说的那个 <code>binder_alloc_buf</code> 函数啦：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_buffer *binder_alloc_buf(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          size_t data_size,              </div><div class="line">                          size_t offsets_size, <span class="keyword">int</span> is_async)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;free_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    size_t buffer_size;</div><div class="line">    <span class="keyword">struct</span> rb_node *best_fit = NULL;</div><div class="line">    <span class="keyword">void</span> *has_page_addr;</div><div class="line">    <span class="keyword">void</span> *end_page_addr;</div><div class="line">    size_t size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proc-&gt;vma == NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf, no vma\n"</span>,</div><div class="line">               proc-&gt;pid);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 计算总共需要 buffer 的大小，字节对齐</span></div><div class="line">    size = ALIGN(data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</div><div class="line">        ALIGN(offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &lt; data_size || size &lt; offsets_size) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d: got transaction with invalid "</span></div><div class="line">            <span class="string">"size %zd-%zd\n"</span>, proc-&gt;pid, data_size, offsets_size);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (is_async &&</div><div class="line">        proc-&gt;free_async_space &lt; size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer)) {</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                 <span class="string">"binder: %d: binder_alloc_buf size %zd"</span></div><div class="line">                 <span class="string">"failed, no async space left\n"</span>, proc-&gt;pid, size);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 在 free_buffers 红黑树查找大小合并的 buffer 块</span></div><div class="line">    <span class="keyword">while</span> (n) {</div><div class="line">        buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</div><div class="line">        buffer_size = binder_buffer_size(proc, buffer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (size &lt; buffer_size) {      </div><div class="line">            best_fit = n;</div><div class="line">            n = n-&gt;rb_left;   </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; buffer_size) </div><div class="line">            n = n-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            best_fit = n;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (best_fit == NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: %d: binder_alloc_buf size %zd failed, "</span></div><div class="line">               <span class="string">"no address space\n"</span>, proc-&gt;pid, size);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (n == NULL) {</div><div class="line">        buffer = rb_entry(best_fit, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        buffer_size = binder_buffer_size(proc, buffer);</div><div class="line">    }</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: binder_alloc_buf size %zd got buff"</span></div><div class="line">             <span class="string">"er %p size %zd\n"</span>, proc-&gt;pid, size, buffer, buffer_size);</div><div class="line"></div><div class="line">    <span class="comment">// 这个好像是用来地址是不是越界的吧</span></div><div class="line">    has_page_addr =</div><div class="line">        (<span class="keyword">void</span> *)(((uintptr_t)buffer-&gt;data + buffer_size) & PAGE_MASK);</div><div class="line">    <span class="comment">// n == NULL 表示没有大小精确的块，需要拆分</span></div><div class="line">    <span class="keyword">if</span> (n == NULL) {</div><div class="line">        <span class="keyword">if</span> (size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer) + <span class="number">4</span> &gt;= buffer_size)</div><div class="line">            buffer_size = size; <span class="comment">/* no room for other buffers */</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            buffer_size = size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</div><div class="line">    }</div><div class="line">    <span class="comment">// 计算所需要映射的内存的结束地址，注意页对齐</span></div><div class="line">    end_page_addr =</div><div class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + buffer_size);</div><div class="line">    <span class="keyword">if</span> (end_page_addr &gt; has_page_addr)</div><div class="line">        end_page_addr = has_page_addr;</div><div class="line">    <span class="comment">// 做物理内存映射</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>,</div><div class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr, NULL))</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line"></div><div class="line">    <span class="comment">// 从 free_buffers 中把刚刚分配的 buffer 块删掉</span></div><div class="line">    rb_erase(best_fit, &proc-&gt;free_buffers);</div><div class="line">    <span class="comment">// 标志这块 buffer 正在使用</span></div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 把这块 buffer 插入到 allocated_buffers 中</span></div><div class="line">    binder_insert_allocated_buffer(proc, buffer);</div><div class="line">    <span class="comment">// 如果要分配的 buffer_size 和原来 buffer 块不一样就要拆分</span></div><div class="line">    <span class="keyword">if</span> (buffer_size != size) {</div><div class="line">        <span class="keyword">struct</span> binder_buffer *new_buffer = (<span class="keyword">void</span> *)buffer-&gt;data + size;</div><div class="line">        <span class="comment">// 新块插入到 proc-&gt;buffers 中</span></div><div class="line">        list_add(&new_buffer-&gt;entry, &buffer-&gt;entry);</div><div class="line">        new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 新块插入到 free_buffers</span></div><div class="line">        binder_insert_free_buffer(proc, new_buffer);</div><div class="line">    }</div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: binder_alloc_buf size %zd got "</span></div><div class="line">             <span class="string">"%p\n"</span>, proc-&gt;pid, size, buffer);</div><div class="line">    buffer-&gt;data_size = data_size;</div><div class="line">    buffer-&gt;offsets_size = offsets_size;</div><div class="line">    buffer-&gt;async_transaction = is_async;</div><div class="line">    <span class="keyword">if</span> (is_async) {</div><div class="line">        proc-&gt;free_async_space -= size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</div><div class="line">                 <span class="string">"binder: %d: binder_alloc_buf size %zd "</span></div><div class="line">                 <span class="string">"async free %zd\n"</span>, proc-&gt;pid, size,</div><div class="line">                 proc-&gt;free_async_space);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> buffer;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>先说说这个函数的参数，第一个前面说了是目标进程的。后面2个 size 分别是 proc A 使用 parcel 打包的 data size 和 <code>flat_binder_object</code> 偏移数据的 size（见前一篇分析）（最后那个异步释放先不管）。这2个 size 加起来就是总共需要空间。然后后面那个 while 循环，是在从 free_buffers 的根开始查找大小合适的 buffer。<code>free_buffers</code> 红黑树按照大小排列，左子树一定比当前节点小，右子树一定比当前节点大。然后我们看下 <code>binder_buffer_size</code> 这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> size_t binder_buffer_size(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                 <span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (list_is_last(&buffer-&gt;entry, &proc-&gt;buffers))</div><div class="line">        <span class="keyword">return</span> proc-&gt;buffer + proc-&gt;buffer_size - (<span class="keyword">void</span> *)buffer-&gt;data;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> (size_t)list_entry(buffer-&gt;entry.next,</div><div class="line">            <span class="keyword">struct</span> binder_buffer, entry) - (size_t)buffer-&gt;data;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数是获取指定 <code>binder_buffer</code> 的大小，从实现可以看得出：</p>
<ol>
<li>如果这块 buffer 是最后那块，那么返回的后面剩下整块内存空间的大小。</li>
<li>如果这块 buffer 在中间，那么大小就是后面那块地址 - 当前这块地址。</li>
</ol>
<p>结合这2点可以看出这些 <code>binder_buffer</code> 在那 1M 的内存块中是连续排列的（这也为后面合并碎片块提供了便利性）。</p>
<p>从上面就能知道，如果这 1M 当中还有大于要求 size 的大小，就一定能找得到，就算分配的 buffer 没有这么大，如果找到最后那块，就是整个剩余空间的大小了。当然如果整个剩余空间都不够那就没办法了。所以上层应用写一些跨进程的功能的时候不要直接使用 binder 传递大于 1M 的数据（上面是 Bundle、Parcel 之类的），应该使用共享内存来传递（见前面一篇的分析）。</p>
<p>继续往下走，<code>best_fit == NULL</code> 表示没有足够的空间了（找不到比要求 size 大或者等于的 buffer 块）。然后能往后走说明 <code>best_fit</code> 这块至少是不小于要求 size 大小的。 n == NULL 这个判断就是说没找一块 buffer 大小正好是要求的 size 大小（实际上大小正好相等的情况是很少的），那么就意味要从这一块中分出 size 大小的出去另外做一块 buffer。所以后面重新计算了下 <code>buffer_size</code> 的大小，要加上 <code>binder_buffer</code> 结构体的大小，前面分析了，一块 buffer 前面是 <code>binder_buffer</code> 信息。</p>
<p>然后后面调用 <code>binder_update_page_range</code> 去映射物理内存。注意下，前面分析的，因为 linux 的内存是按页分的，所以映射的时候也要按页去映射，那就要按页对齐，一般一页是 4k，但是很多参数其实就几个、十几个字节。所以这里起始地址和结束地址一对齐很多情况都是相等的。所以前面那个 <code>binder_update_page_range</code> 有个判断是 end &gt;= start 就返回，这里如果 end == start 就表示这段内存已经映射过了（在同一页中）。</p>
<p>再后面就是把要用的那快 buffer 从 <code>free_buffers</code> 中删掉，然后把 free 标志改成正在使用的，插入到 <code>allocated_buffers</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_insert_allocated_buffer(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                       <span class="keyword">struct</span> binder_buffer *new_buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;allocated_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line"></div><div class="line">    BUG_ON(new_buffer-&gt;<span class="built_in">free</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        buffer = rb_entry(parent, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(buffer-&gt;<span class="built_in">free</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 按地址排列</span></div><div class="line">        <span class="keyword">if</span> (new_buffer &lt; buffer)</div><div class="line">            p = &parent-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_buffer &gt; buffer)</div><div class="line">            p = &parent-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            BUG();</div><div class="line">    }</div><div class="line">    rb_link_node(&new_buffer-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&new_buffer-&gt;rb_node, &proc-&gt;allocated_buffers);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>可以看到 <code>allocated_buffers</code> 是按地址排列的。然后后面那个判断 <code>buffer_size != size</code>，如果前面找不到大小一样的 buffer 块，然后重新计算了 <code>buffer_size</code>， 那么如果这块 buffer 的大小比原来 size 大（这里肯定是大的，如果小的话就表示内存不够了）就要原来那块一分为二，前面拿 size 大小去用，后面剩下的作为空闲块。所以新弄了一个 <code>binder_buffer</code> 出来，然后把插入到 <code>free_buffers</code> 和 <code>proc-&gt;buffers</code> 里去了。那个 <code>proc-&gt;buffers</code> 是个链表，这里 <code>list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</code> 这种写法就是插入到这个链表的最后。然后来看插入到 <code>free_buffers</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_insert_free_buffer(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                      <span class="keyword">struct</span> binder_buffer *new_buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;free_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    size_t buffer_size;</div><div class="line">    size_t new_buffer_size;</div><div class="line"></div><div class="line">    BUG_ON(!new_buffer-&gt;<span class="built_in">free</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 计算新 buffer 的大小</span></div><div class="line">    new_buffer_size = binder_buffer_size(proc, new_buffer);</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: add free buffer, size %zd, "</span></div><div class="line">             <span class="string">"at %p\n"</span>, proc-&gt;pid, new_buffer_size, new_buffer);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        buffer = rb_entry(parent, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</div><div class="line"></div><div class="line">        buffer_size = binder_buffer_size(proc, buffer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (new_buffer_size &lt; buffer_size)</div><div class="line">            p = &parent-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p = &parent-&gt;rb_right;</div><div class="line">    }</div><div class="line">    rb_link_node(&new_buffer-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&new_buffer-&gt;rb_node, &proc-&gt;free_buffers);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数主要注意 <code>new_buffer_size = binder_buffer_size(proc, new_buffer);</code> 。从这里可以看得出，这些空闲的 buffer 是不保存本块的大小的，都是要用的时候现场计算的。然后这里证实了 <code>free_buffers</code> 是按大小排列的了。</p>
<p>然后我们来看看使用完之后释放这些 buffer 块的情况。前一篇 parcel 那里说到 Parcel 里有一个叫 mOwner 的函数指针，如果设置了的话，会在 parcel 的析够函数里调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Parcel::~Parcel()</div><div class="line">{</div><div class="line">    freeDataNoInit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::freeDataNoInit()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">        <span class="comment">//ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());</span></div><div class="line">        mOwner(<span class="keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        releaseObjects();</div><div class="line">        <span class="keyword">if</span> (mData) <span class="built_in">free</span>(mData);</div><div class="line">        <span class="keyword">if</span> (mObjects) <span class="built_in">free</span>(mObjects);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在 parcel 中设置 mOwner 的地方是 ipcSetDataReference 这个方法。然后在 IPCThreadState 有2个地方会调用 ipcSetDataReference 设置一个叫 freeBuffer 的函数：</p>
<p>一个是在 waitForResponse 中的 BR_REPLY 的命令那里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BR_REPLY:</div><div class="line">    {</div><div class="line">        binder_transaction_data tr;    </div><div class="line">        err = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">        ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (reply) {</div><div class="line">            <span class="keyword">if</span> ((tr.flags & TF_STATUS_CODE) == <span class="number">0</span>) {</div><div class="line">                reply-&gt;ipcSetDataReference(    </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer), </div><div class="line">                    tr.data_size,                  </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets), </div><div class="line">                    tr.offsets_size/<span class="keyword">sizeof</span>(size_t),</div><div class="line">                    freeBuffer, <span class="keyword">this</span>);             </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                err = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> status_t*&gt;(tr.data.ptr.buffer);</div><div class="line">                freeBuffer(NULL,               </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer), </div><div class="line">                    tr.data_size,                  </div><div class="line">                    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets), </div><div class="line">                    tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">            }  </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            freeBuffer(NULL,               </div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer), </div><div class="line">                tr.data_size,                  </div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets), </div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">goto</span> finish;</div><div class="line"></div></pre></td></tr></table></figure>

<p>一个是在 executeCommand 的 BR_TRANSACTION 的命令那：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        {</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ALOG_ASSERT(result == NO_ERROR,</div><div class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) {</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                <span class="keyword">const</span> status_t error = b-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">const</span> status_t error = the_context_object-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后回到通信篇那里去看看我之前画的那张图，注意设置 freeBuffer 全都是 BR 命令，一个是 executeCommand， 这个是 Bn 端那里。在 <code>BR_TRANSACTION</code> 命令里定义了一个本地变量 Parcel buffer，并且给这个 parcel 设置了 feeBuffer。然后作为参数传递给后面执行 Bn 端的 transaction 实现远程调用。然后这个 executeCommand 执行完后，就会执行 Parcel 的析够函数从而触发 freeBuffer 的调用。freeBuffer 的实现我们后面再说，里面是让 binder 去释放之前申请的 buffer 块。然后前面说了 proc A 发起 IPC，binder 里面是用 proc B（也就是 Bn 端）来的内存来申请 buffer 的。所以这里在 proc B 设置释放 buffer 的函数是合理的。</p>
<p>然后第二个 waitForResponse 也是差不多的。前面那个是在 Bn 端释放，是 Bp —&gt; Bn 发送请求，target 是 Bn，这里呢是从 Bn 返回结果到 Bp，就是 Bn —&gt; Bp， target 就是 Bp 了（proc A）。waitForResponse 的参数 Parcel reply 是从 Bp 的 IPCThreadState 的 transact 传递过来的，这个就是上层发起 IPC 那个接口函数传递过来的，也是一个本地变量，transact 调用完成后就会调用 Parcel 的析够函数触发释放函数。这里是从 Bn 返回到 Bp，申请的内存就是 Bp 端的，所以在 Bp 释放也是对的。</p>
<p>通过上面先得搞清楚，内存从哪个进程来的，在哪个进程释放。基本上在谁那拿的，就由谁来释放。搞清楚后，现在可以看看 freeBuffer 的实现了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::freeBuffer(Parcel* parcel, <span class="keyword">const</span> uint8_t* data, size_t dataSize,</div><div class="line">                                <span class="keyword">const</span> size_t* objects, size_t objectsSize,</div><div class="line">                                <span class="keyword">void</span>* cookie)                  </div><div class="line">{</div><div class="line">    <span class="comment">//ALOGI("Freeing parcel %p", &parcel);</span></div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        alog &lt;&lt; <span class="string">"Writing BC_FREE_BUFFER for "</span> &lt;&lt; data &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    ALOG_ASSERT(data != NULL, <span class="string">"Called with NULL data"</span>);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) parcel-&gt;closeFileDescriptors();</div><div class="line">    IPCThreadState* state = self();</div><div class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</div><div class="line">    state-&gt;mOut.writeInt32((int32_t)data);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个通过 mOut 对 binder 写了一个 <code>BC_FREE_BUFFER</code> 的命令，然后把保存的 buffer 块的用户空间的地址也写了进去。这些内存都是由 kernel 的 binder 驱动管理的，所以只能由 binder 驱动来释放，用户空间无法释放的。这样的话这个进程下次和 binder 进行通信的时候，就会由 <code>BINDER_WRITE_READ</code> ioctl 把这条命令写到 binder 驱动中去。binder 驱动就会执行 <code>BC_FREE_BUFFER</code> 释放使用完的 <code>binder_buffer</code> 内存块。还记得前面说 parcel 打包 binder 命令（或是解析）可以打包多条命令的么，这里就体现出来了。释放命令是随真正的业务命令一起打包发送过去的。</p>
<p>然后我们可以回到 binder 驱动里，看看 <code>BC_FREE_BUFFER</code> 的处理，这个在 <code>binder_thread_write</code> 里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BC_FREE_BUFFER: {</div><div class="line">    <span class="keyword">void</span> __user *data_ptr;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;  </div><div class="line"></div><div class="line">    <span class="comment">// 获取用户传递过来 buffer 的地址</span></div><div class="line">    <span class="keyword">if</span> (get_user(data_ptr, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;</div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"></div><div class="line">    <span class="comment">// 通过地址查找 buffer 块</span></div><div class="line">    buffer = binder_buffer_lookup(proc, data_ptr);</div><div class="line">    <span class="keyword">if</span> (buffer == NULL) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">            <span class="string">"BC_FREE_BUFFER u%p no match\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, data_ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!buffer-&gt;allow_user_free) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">            <span class="string">"BC_FREE_BUFFER u%p matched "</span>  </div><div class="line">            <span class="string">"unreturned buffer\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, data_ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    binder_debug(BINDER_DEBUG_FREE_BUFFER,</div><div class="line">             <span class="string">"binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction\n"</span>,</div><div class="line">             proc-&gt;pid, thread-&gt;pid, data_ptr, buffer-&gt;debug_id,</div><div class="line">             buffer-&gt;transaction ? <span class="string">"active"</span> : <span class="string">"finished"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer-&gt;transaction) {</div><div class="line">        buffer-&gt;transaction-&gt;buffer = NULL;</div><div class="line">        buffer-&gt;transaction = NULL;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (buffer-&gt;async_transaction && buffer-&gt;target_node) {</div><div class="line">        BUG_ON(!buffer-&gt;target_node-&gt;has_async_transaction);</div><div class="line">        <span class="keyword">if</span> (list_empty(&buffer-&gt;target_node-&gt;async_todo))</div><div class="line">            buffer-&gt;target_node-&gt;has_async_transaction = <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &thread-&gt;todo);</div><div class="line">    }</div><div class="line">    <span class="comment">// 释放资源</span></div><div class="line">    binder_transaction_buffer_release(proc, buffer, NULL);</div><div class="line">    binder_free_buf(proc, buffer); </div><div class="line">    <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>通过 <code>get_user</code> 得到从用户空间传递过来要释放的 buffer 的地址。然后调用 <code>binder_buffer_lookup</code> 查找 buffer 块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_buffer *binder_buffer_lookup(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          <span class="keyword">void</span> __user *user_ptr)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;allocated_buffers.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *kern_ptr;</div><div class="line">                </div><div class="line">    <span class="comment">// 通过偏移由用户空间地址计算出内核空间地址</span></div><div class="line">    kern_ptr = user_ptr - proc-&gt;user_buffer_offset</div><div class="line">        - offsetof(<span class="keyword">struct</span> binder_buffer, data);</div><div class="line">                </div><div class="line">    <span class="comment">// 在已经映射的 buffer 红黑树中查找</span></div><div class="line">    <span class="keyword">while</span> (n) { </div><div class="line">        buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</div><div class="line">        BUG_ON(buffer-&gt;<span class="built_in">free</span>);</div><div class="line">                    </div><div class="line">        <span class="keyword">if</span> (kern_ptr &lt; buffer)</div><div class="line">            n = n-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kern_ptr &gt; buffer)</div><div class="line">            n = n-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>user_buffer_offset</code> 的作用又来了，这里是通过用户空间地址计算出对应的内核空间地址。前面说了 <code>allocated_buffers</code> 是按地址排列的，所以通过地址查找。</p>
<p>然后后面先看看 <code>binder_transaction_buffer_release</code> 的释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction_buffer_release(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          <span class="keyword">struct</span> binder_buffer *buffer,  </div><div class="line">                          size_t *failed_at)             </div><div class="line">{</div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">int</span> debug_id = buffer-&gt;debug_id;</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">             <span class="string">"binder: %d buffer release %d, size %zd-%zd, failed at %p\n"</span>,</div><div class="line">             proc-&gt;pid, buffer-&gt;debug_id,   </div><div class="line">             buffer-&gt;data_size, buffer-&gt;offsets_size, failed_at);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer-&gt;target_node)</div><div class="line">        binder_dec_node(buffer-&gt;target_node, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    offp = (size_t *)(buffer-&gt;data + ALIGN(buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    <span class="keyword">if</span> (failed_at)</div><div class="line">        off_end = failed_at;  </div><div class="line">    <span class="keyword">else</span></div><div class="line">        off_end = (<span class="keyword">void</span> *)offp + buffer-&gt;offsets_size; </div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line">        <span class="keyword">struct</span> flat_binder_object *fp; </div><div class="line">        <span class="keyword">if</span> (*offp &gt; buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: transaction release %d bad"</span></div><div class="line">                    <span class="string">"offset %zd, size %zd\n"</span>, debug_id,</div><div class="line">                    *offp, buffer-&gt;data_size);     </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) {</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: {</div><div class="line">            <span class="keyword">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;binder);</div><div class="line">            <span class="keyword">if</span> (node == NULL) {            </div><div class="line">                printk(KERN_ERR <span class="string">"binder: transaction release %d"</span></div><div class="line">                       <span class="string">" bad node %p\n"</span>, debug_id, fp-&gt;binder);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        node %d u%p\n"</span>,       </div><div class="line">                     node-&gt;debug_id, node-&gt;ptr);    </div><div class="line">            binder_dec_node(node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                printk(KERN_ERR <span class="string">"binder: transaction release %d"</span></div><div class="line">                       <span class="string">" bad handle %ld\n"</span>, debug_id,</div><div class="line">                       fp-&gt;handle);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        ref %d desc %d (node %d)\n"</span>,</div><div class="line">                     ref-&gt;debug_id, ref-&gt;desc, ref-&gt;node-&gt;debug_id);</div><div class="line">            binder_dec_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD:</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        fd %ld\n"</span>, fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (failed_at)</div><div class="line">                task_close_fd(proc, fp-&gt;handle);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: transaction release %d bad "</span></div><div class="line">                   <span class="string">"object type %lx\n"</span>, debug_id, fp-&gt;type);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 buffer 后面保存了 parcel <code>flat_binder_object</code> 的偏移数据，这里是去取这个偏移，然后通过这些偏移取到打包在 parcel 里面的 <code>flat_binder_object</code> 数据，然后去根据不同的类型去减少引用之类的（前面使用的时候会增加相应的引用）。我是比较讨厌这些啥引用计算的，这里就随便过过就行了。</p>
<p>然后看后面的 <code>binder_free_buf</code>， 这个和 <code>binder_alloc_buf</code> 真对应啊：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_free_buf(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                <span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    size_t size, buffer_size;</div><div class="line"></div><div class="line">    <span class="comment">// 获取这块 buffer 的大小</span></div><div class="line">    buffer_size = binder_buffer_size(proc, buffer);</div><div class="line"></div><div class="line">    <span class="comment">// 计算 buffer 的 size 大小，注意字节对齐</span></div><div class="line">    size = ALIGN(buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</div><div class="line">        ALIGN(buffer-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">             <span class="string">"binder: %d: binder_free_buf %p size %zd buffer"</span></div><div class="line">             <span class="string">"_size %zd\n"</span>, proc-&gt;pid, buffer, size, buffer_size);</div><div class="line"></div><div class="line">    BUG_ON(buffer-&gt;<span class="built_in">free</span>);</div><div class="line">    BUG_ON(size &gt; buffer_size);</div><div class="line">    BUG_ON(buffer-&gt;transaction != NULL);</div><div class="line">    BUG_ON((<span class="keyword">void</span> *)buffer &lt; proc-&gt;buffer);</div><div class="line">    BUG_ON((<span class="keyword">void</span> *)buffer &gt; proc-&gt;buffer + proc-&gt;buffer_size);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer-&gt;async_transaction) {</div><div class="line">        proc-&gt;free_async_space += size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</div><div class="line"></div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</div><div class="line">                 <span class="string">"binder: %d: binder_free_buf size %zd "</span></div><div class="line">                 <span class="string">"async free %zd\n"</span>, proc-&gt;pid, size,</div><div class="line">                 proc-&gt;free_async_space);       </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 释放物理映射</span></div><div class="line">    binder_update_page_range(proc, <span class="number">0</span>,</div><div class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data),</div><div class="line">        (<span class="keyword">void</span> *)(((uintptr_t)buffer-&gt;data + buffer_size) & PAGE_MASK),</div><div class="line">        NULL);</div><div class="line">    <span class="comment">// 从 allocated_buffers 删除这块 buffer</span></div><div class="line">    rb_erase(&buffer-&gt;rb_node, &proc-&gt;allocated_buffers);</div><div class="line">    <span class="comment">// 设置空闲标志位</span></div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 向后查看有没有可以合并的空闲块</span></div><div class="line">    <span class="keyword">if</span> (!list_is_last(&buffer-&gt;entry, &proc-&gt;buffers)) {</div><div class="line">        <span class="keyword">struct</span> binder_buffer *next = list_entry(buffer-&gt;entry.next, </div><div class="line">                        <span class="keyword">struct</span> binder_buffer, entry);  </div><div class="line">        <span class="keyword">if</span> (next-&gt;<span class="built_in">free</span>) {</div><div class="line">            rb_erase(&next-&gt;rb_node, &proc-&gt;free_buffers);</div><div class="line">            binder_delete_free_buffer(proc, next);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 向前查看下有没有可以合并的空闲块</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffers.next != &buffer-&gt;entry) {</div><div class="line">        <span class="keyword">struct</span> binder_buffer *prev = list_entry(buffer-&gt;entry.prev,</div><div class="line">                        <span class="keyword">struct</span> binder_buffer, entry);</div><div class="line">        <span class="keyword">if</span> (prev-&gt;<span class="built_in">free</span>) {</div><div class="line">            binder_delete_free_buffer(proc, buffer);</div><div class="line">            rb_erase(&prev-&gt;rb_node, &proc-&gt;free_buffers);</div><div class="line">            buffer = prev;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 把合并好的块插入到 free_buffers 中，以供下次使用</span></div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里调用 <code>binder_update_page_range</code> 是第二个参数是传递 0 了，就表示是要释放物理内存映射，这个前面已经分析过了。然后从 <code>allocated_buffers</code> 中删掉这块 buffer，把 free 标志也设置一下。重点在后面：</p>
<p>判断这块是不是最后一块 buffer，这里其实就是向后查看后面那块 buffer 是不是也是 free 的（前面说 <code>proc-&gt;buffers</code> 是一个链表）。如果是的话，表示可以把这2块合并成一个更大的 buffer 块。这里插一句内存管理方面的常识，空闲的 buffer 块越大，下次申请成功概率就越大，所以要保证空闲 buffer 块尽量的大。如果 buffer 都是零零星星很小、数量很多的小块，那么下次申请很可能会失败，但是总体空间的大小却是够的，也就是我们常说的内存碎片。要尽可能的避免内存碎片，所以才需要有内存合并的处理。</p>
<p>那看看怎么合并的。要合并的话，先把后面那块从 <code>free_buffers</code> 中删掉，然后调用 <code>binder_delete_buffer</code> 去删除：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_delete_free_buffer(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                      <span class="keyword">struct</span> binder_buffer *buffer)  </div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_buffer *prev, *next = NULL;</div><div class="line">    <span class="comment">// 这2个标志，表示要释放的 buffer 是否于其他的 buffer 共用一个内存页</span></div><div class="line">    <span class="keyword">int</span> free_page_end = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> free_page_start = <span class="number">1</span>;</div><div class="line"></div><div class="line">    BUG_ON(proc-&gt;buffers.next == &buffer-&gt;entry);</div><div class="line">    prev = list_entry(buffer-&gt;entry.prev, <span class="keyword">struct</span> binder_buffer, entry);</div><div class="line">    <span class="comment">// 要释放这块 buffer，前面那个块必须是 free 的</span></div><div class="line">    BUG_ON(!prev-&gt;<span class="built_in">free</span>);</div><div class="line">    <span class="comment">// 查看这块 buffer 是否与前面一块 buffer 共用一个内存页</span></div><div class="line">    <span class="keyword">if</span> (buffer_end_page(prev) == buffer_start_page(buffer)) {</div><div class="line">        free_page_start = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">if</span> (buffer_end_page(prev) == buffer_end_page(buffer))</div><div class="line">            free_page_end = <span class="number">0</span>;</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                 <span class="string">"binder: %d: merge free, buffer %p "</span></div><div class="line">                 <span class="string">"share page with %p\n"</span>, proc-&gt;pid, buffer, prev);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 查看这块 buffer 是否于后面一块 buffer 共用一个内存页</span></div><div class="line">    <span class="keyword">if</span> (!list_is_last(&buffer-&gt;entry, &proc-&gt;buffers)) {</div><div class="line">        next = list_entry(buffer-&gt;entry.next, </div><div class="line">                  <span class="keyword">struct</span> binder_buffer, entry);  </div><div class="line">        <span class="keyword">if</span> (buffer_start_page(next) == buffer_end_page(buffer)) {</div><div class="line">            free_page_end = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (buffer_start_page(next) == </div><div class="line">                buffer_start_page(buffer))     </div><div class="line">                free_page_start = <span class="number">0</span>;           </div><div class="line">            <span class="comment">// PS 这个打印写错了吧，不是 prev 而是 next 吧 -_-||</span></div><div class="line">            binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                     <span class="string">"binder: %d: merge free, buffer"</span></div><div class="line">                     <span class="string">" %p share page with %p\n"</span>, proc-&gt;pid,</div><div class="line">                     buffer, prev);                 </div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 从 proc-&gt;buffers 删除这块 buffer</span></div><div class="line">    list_del(&buffer-&gt;entry); </div><div class="line">    <span class="comment">// 如果这块 buffer 不与前面和后面的 buffer 共用一个内存页的话，</span></div><div class="line">    <span class="comment">// 那就释放掉这块 buffer 所在的内存页的映射</span></div><div class="line">    <span class="keyword">if</span> (free_page_start || free_page_end) {</div><div class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</div><div class="line">                 <span class="string">"binder: %d: merge free, buffer %p do "</span></div><div class="line">                 <span class="string">"not share page%s%s with with %p or %p\n"</span>,</div><div class="line">                 proc-&gt;pid, buffer, free_page_start ? <span class="string">""</span> : <span class="string">" end"</span>, </div><div class="line">                 free_page_end ? <span class="string">""</span> : <span class="string">" start"</span>, prev, next);</div><div class="line">        binder_update_page_range(proc, <span class="number">0</span>, free_page_start ?</div><div class="line">            buffer_start_page(buffer) : buffer_end_page(buffer),</div><div class="line">            (free_page_end ? buffer_end_page(buffer) :</div><div class="line">            buffer_start_page(buffer)) + PAGE_SIZE, NULL);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到那个 <code>BUG_ON(!prev-&gt;free)</code> 感觉这个函数就是内存合并专用的，要调用这个释放 buffer 块，还必须前面那个块是 free 的，合并的时候就是这样（仔细看下前面，向前合并的时候，删除的是自己，所以前面那个也是 free 的）。然后后面的的判断是检测要释放的这块 buffer 所在的页面是不是别的 buffer 也在用。因为前面说了好几次了，一般一页是 4k， IPC 的参数经常只有几个、十几个字节而已，所以经常会一个页里面有好块 buffer。所以就向前（前一块）和向后（后一块）检测下自己的邻居是否和自己共用一个内存页：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *buffer_start_page(<span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)((uintptr_t)buffer & PAGE_MASK);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *buffer_end_page(<span class="keyword">struct</span> binder_buffer *buffer)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)(((uintptr_t)(buffer + <span class="number">1</span>) - <span class="number">1</span>) & PAGE_MASK);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>检测方法和前面差不多就是拿地址进行页面内存对齐。看对齐后的地址是不是落在一起。然后设置2个标志。在最后判断，只要前后有一块 buffer 和自己共用一页就不释放这片地址的物理内存映射。否则就调用 <code>binder_update_page_range</code> 去把自己映射的这片物理内存释放掉。以前在大学里面听老师说内存对齐的问题是最麻烦的，后来敲了几年代码没啥感觉，现在深深感受到恶意啦，页面对齐、字节对齐 -_-||。</p>
<p>回到 <code>binder_free_buf</code>，向后合并是删掉后面那块（next），向前合并是删掉自己（buffer），拿 prev 重新当作自己。最后 <code>binder_insert_free_buffer</code> 把合并之后的 buffer 重新插入到 <code>proc-&gt;free_buffers</code> 中供下次申请的时候使用。</p>
<p>这个做法其实我和以前弄 MiniGUI 的一个 GAL 中的显存管理很类似，简单但是有效，可以来这里对比一下（那里还有图说明）： <a href="http://light3moon.com/2015/01/21/STi7167 GAL 开发笔记/#显存管理" title="STi7167 GAL 显存管理" target="_blank" rel="external">STi7167 GAL 显存管理</a> </p>
<h2 id="总结">总结</h2>
<p>感觉 binder 下了不少功夫进行效率的优化：</p>
<ol>
<li>通过将内核地址和用户地址映射到同一个物理地址以减少数据传递中 copy 的次数。</li>
<li>自己进行内存管理、快速查找（红黑树）、合并碎片。</li>
<li>线程池支持，提供高服务端并发的响应能力（后面再分析）。</li>
<li>以及等等 … … </li>
</ol>
<p>另外 binder 还提供调用者和目的地的 pid 验证，对 IPC 的安全性也有提高。并且对上层提供友好的封装接口以及偷懒的代码自动生成工具（aidl），易用上也比传递 IPC 好。现在稍微能理解点 android 为什么要自己搞一套 IPC 的机制了。据说标准的 linux kernel 3.xx 好像加入 binder 了。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——内存管理/" data-title="Android Binder 分析——内存管理 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——匿名共享内存[Ashmem]/" title="Android Binder 分析——匿名共享内存（Ashmem）">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——匿名共享内存（Ashmem）</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——系统服务 Binder 对象的传递/"  title="Android Binder 分析——系统服务 Binder 对象的传递">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——系统服务 Binder 对象的传递
</span>
</a>
</div>

</nav>


	
<section class="comment">
	<div class="ds-thread" data-thread-key="Android Binder 分析——内存管理" data-title="Android Binder 分析——内存管理" 
      data-author-key="mingming" data-limit=10
      data-url="light3moon.com/2015/01/28/Android Binder 分析——内存管理/">
    </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#只复制一次的实现"><span class="toc-number">3.</span> <span class="toc-text">只复制一次的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际运用"><span class="toc-number">4.</span> <span class="toc-text">实际运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">5.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>35</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>47</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Server/" title="Server">Server<sup>1</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/android/" title="android">android<sup>82</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">哥的后勤处 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-qqzone"></i> <a href="http://user.qzone.qq.com/544630305" target="_blank">QQ 空间</a></li>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">战斗力</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="commentlist">
  <p class="asidetitle">最近冒泡的小伙伴 ╰(●&#39;◡&#39;●)╮</p>
    <ul>
      <ul class="ds-recent-comments" 
        data-num-items="6" 
        data-show-avatars="1" 
        data-show-title="1"   
        data-show-time="1" 
        data-show-admin="1" 
        data-excerpt-length="30">
      </ul>
      <!-- duoshou js begin load, one page only load once -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"mingming"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- duoshou js load end -->
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	
		<a href="http://user.qzone.qq.com/544630305" target="_blank" title="qqzone"></a>
		         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2016 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"mingming"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
