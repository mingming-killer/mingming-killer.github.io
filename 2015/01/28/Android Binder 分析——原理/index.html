
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——原理 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="分析之前说一下原理。为要 android 要搞这么复杂的一个东西。那是因为 android 是个多进程的系统，进程间的数据交换、相互调用（某几个程序配合完成某些业务）就涉及跨进程通信。2个进程不能直接访问数据的原因：

每个进程的地址空间的独立的，所以进程A中某个数据的地址在进程B中不确定是什么东西">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">〜(￣△￣〜) 三月学长的根据地 (〜￣△￣)〜</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——原理/" title="Android Binder 分析——原理" itemprop="url">Android Binder 分析——原理</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T12:17:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2016-03-31T02:31:16.000Z" itemprop="dateModified">2016 3月 31</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用"><span class="toc-number">2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架设计——native"><span class="toc-number">3.</span> <span class="toc-text">框架设计——native</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架设计——java"><span class="toc-number">4.</span> <span class="toc-text">框架设计——java</span></a></li></ol>
		</div>
		
		<p>分析之前说一下原理。为要 android 要搞这么复杂的一个东西。那是因为 android 是个多进程的系统，进程间的数据交换、相互调用（某几个程序配合完成某些业务）就涉及跨进程通信。2个进程不能直接访问数据的原因：</p>
<ol>
<li>每个进程的地址空间的独立的，所以进程A中某个数据的地址在进程B中不确定是什么东西。</li>
<li>安全性，如果能随便访问其它进程空间的数据，那么是非常危险的事情（想想看你再用支付宝输支付密码的时候，其它随便一个程序就能轻轻松松读取你输入的密码是多么恐怖）。</li>
</ol>
<p>所以 android 就整一套进程通信框架——binder</p>
<h2 id="原理">原理</h2>
<p>首先 binder 在最底层有 kernel 的驱动支持。/dev/binder 是 binder 的设备文件。然后 android 通过这个驱动在 native 层整了一套 C/S 架构的框架出来，最后在 java 对应也封装了一层（可以理解为 native 的马甲）。这些东西后面再慢慢分析。</p>
<h2 id="应用">应用</h2>
<p>基于 binder android 弄了很多 manager services，不过我觉得倒是因为需要存在这些 maanger services 才需要 binder 进程间通信。这里说说为什么需要这些 manager services（我后面把这些称为：那一票 services）。因为设备的上的有些硬件（例如相机、传感器）一般一次只能一个访问，有些需要把一些数据混合在一起输出（SurfaceFlinger、AudioFlinger），这就需要一些管理，但是应用是不同的程序，它们并不知道其它人的情况，所以就需要一个 manager，而且这个 manager 是要能接受不同进程的。这就引出了 android binder 的最经典的场景—— android 那一票 services。</p>
<p>同时由于有这一票 services 的 存在，那么又要有人来管它们，所以就有一个东西叫： ServiceManager 。这个东西本身也是基于 binder 通信的。</p>
<h2 id="框架设计——native">框架设计——native</h2>
<p>binder 主要的实现在 native 层。先来张图，整体对框架有个概括（图中我省略了 binder 进程 death 之后的通知机制，这个可以后面单独分析，这里只是画出了刚开始比较关键的通信的那部分）：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-base/1.png" alt=""></p>
<p>这里先啰嗦下 binder native 层的代码位置（这个是个模块，相关的都里面，没几个文件，自己找吧）： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 头文件：</span></div><div class="line">frameworks/native/include/binder</div><div class="line"><span class="comment"># 实现：</span></div><div class="line">frameworks/native/libs/binder</div><div class="line"></div></pre></td></tr></table></figure>

<p>图中分为2个部分：一个是实现部分（BBinder、Bpinder 那部分），一个是接口部分（IInterface 那部分）。先来看下实体部分：</p>
<p>前面说了 binder 是 C/S 架构的，那当然得有 server 和 client。BBinder 代表 server，Bpinder 代表 client，然后在这个基础上抽象出 IBinder 这个基类。IBinder 中比较重要的抽象方法有4个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Check if this IBinder implements the interface named by</span></div><div class="line"><span class="comment"> * @a descriptor.  If it does, the base pointer to it is returned,</span></div><div class="line"><span class="comment"> * which you can safely static_cast&lt;&gt; to the concrete C++ interface.</span></div><div class="line"><span class="comment"> */</span> </div><div class="line"><span class="keyword">virtual</span> sp&lt;IInterface&gt;  queryLocalInterface(<span class="keyword">const</span> String16& descriptor);</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> status_t        transact(   uint32_t code,</div><div class="line">                                    <span class="keyword">const</span> Parcel& data,</div><div class="line">                                    Parcel* reply,</div><div class="line">                                    uint32_t flags = <span class="number">0</span>) = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> BBinder*        localBinder();</div><div class="line"><span class="keyword">virtual</span> BpBinder*       remoteBinder();</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后在基类有默认实现的是3个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sp&lt;IInterface&gt;  IBinder::queryLocalInterface(<span class="keyword">const</span> String16& descriptor)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line">BBinder* IBinder::localBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line">BpBinder* IBinder::remoteBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>基类的实现还真全是马甲，但是这样也有个好出，就是之类可以只覆盖自己感兴趣的方法就可以了（否则子类就必须全部实现，不然编译会报错的）。</p>
<p>先来看看 localBinder 和 remoteBinder 这2个，这2个看定义就十分明显了，一个是返回 BBinder 的指针（服务器的），一个是返回 BpBinder 的指针（客户端的），而且在 BBinder 和 BpBinder 分别只实现了一个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># 简单干脆，都直接返回自己</span></div><div class="line">BBinder* BBinder::localBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div><div class="line">BpBinder* BpBinder::remoteBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 queryLocalInterface 这个，这个返回的是 IInterface 的指针（sp android 搞的啥智能指针，可以参看我前面一篇相关的备忘，挺烦的）。BBinder 和 BpBinder 都没有实现，这个放到后面暴露的接口去实现了（后面再说）。</p>
<p>最后来看下： transact，这个看名字，和参数就知道这个就是通信用的方法。这个在基类中也没实现，但是在 BBinder 和 BpBinder 有实现，并且不一样（当然得不一样，服务器能和客户端一样么）。BBinder 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">status_t BBinder::transact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    data.setDataPosition(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    status_t err = NO_ERROR;</div><div class="line">    <span class="keyword">switch</span> (code) {</div><div class="line">        <span class="keyword">case</span> PING_TRANSACTION:</div><div class="line">            reply-&gt;writeInt32(pingBinder());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = onTransact(code, data, reply, flags);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (reply != NULL) {</div><div class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> err; </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个 <code>PING_TRANSACTION</code> 估计是测试用的，先不理它，它主要就是调用了 onTransact 这个回调。这个回调是在 BBinder 中定义的，是个虚函数，主要留给它的子类来实现。可以想象得到服务器端在等待客户端的请求，当有请求来的时候，就会出发 onTransact 然后由具体的服务（子类）来实现这个回调，处理不同的逻辑。 </p>
<p>而在 BpBinder 中是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">status_t BpBinder::transact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></div><div class="line">    <span class="keyword">if</span> (mAlive) {</div><div class="line">        status_t status = IPCThreadState::self()-&gt;transact(</div><div class="line">            mHandle, code, data, reply, flags);</div><div class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    }</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> DEAD_OBJECT;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>又是马甲，这个IPCThreadState 是线程剧本变量，就是一个线程存一个，不同线程不一样，binder 的 C/S 架构采用了多线程来处理请求，这个也是后面再分析，先来看看实现再说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::transact(int32_t handle,</div><div class="line">                                  uint32_t code, <span class="keyword">const</span> Parcel& data,</div><div class="line">                                  Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    status_t err = data.errorCheck();</div><div class="line"></div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line"></div><div class="line">    IF_LOG_TRANSACTIONS() {</div><div class="line">        TextOutput::Bundle _b(alog);</div><div class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span> </div><div class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</div><div class="line">            (flags & TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</div><div class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        <span class="keyword">return</span> (mLastError = err);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((flags & TF_ONE_WAY) == <span class="number">0</span>) { </div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (reply) {</div><div class="line">            err = waitForResponse(reply);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Parcel fakeReply;</div><div class="line">            err = waitForResponse(&fakeReply);</div><div class="line">        }    </div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        IF_LOG_TRANSACTIONS() {</div><div class="line">            TextOutput::Bundle _b(alog);</div><div class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</div><div class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        err = waitForResponse(NULL, NULL);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数中关键点是 writeTransactionData 和  waitForResponse，这2个函数分别是对 binder 驱动写请求（数据已经通过 Parcel 打包好，这个也是后面再分析），然后等待 binder 驱动的返回的数据结果（服务器那端写的）。驱动相关的也是后面再说，先在继续往下走。这里可以看得出客户端是将请求写入驱动，发送给服务器，然后等待服务器返回的结果。</p>
<p>然后就是接口了，接口基类是 IInterface，这个基类很简单，就定义2个有用的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> IInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">            IInterface();</div><div class="line">            sp&lt;IBinder&gt;         asBinder();</div><div class="line">            sp&lt;<span class="keyword">const</span> IBinder&gt;   asBinder() <span class="keyword">const</span>;</div><div class="line">            </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span>                     ~IInterface();</div><div class="line">    <span class="keyword">virtual</span> IBinder*            onAsBinder() = <span class="number">0</span>;</div><div class="line">};</div><div class="line"></div><div class="line">sp&lt;IBinder&gt; IInterface::asBinder()</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> ? onAsBinder() : NULL;</div><div class="line">}</div><div class="line"></div><div class="line">sp&lt;<span class="keyword">const</span> IBinder&gt; IInterface::asBinder() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> ? <span class="keyword">const_cast</span>&lt;IInterface*&gt;(<span class="keyword">this</span>)-&gt;onAsBinder() : NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实它留给子类的就 onAsBinder 这个回调，用来获取 IBinder 的指针。IInterface 的子类是 BnInterface<interface> 和 BpInterface<interface> 分别对应 BBinder（服务器） 和 BpBinder（客户端）的接口。在这之前得先看看 INTERFACE 这个东西，android 在这里弄了一个模版类，BnXx 和 BpXx 都是。</interface></interface></p>
<p>在 IInterface.h 中有这2个宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ----------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                          \</div><div class="line">    <span class="keyword">static</span> android::sp&lt;I<span class="preprocessor">##INTERFACE&gt; asInterface(                       \</span></div><div class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;& obj);                  \</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::String16& getInterfaceDescriptor() <span class="keyword">const</span>;    \</div><div class="line">    I<span class="preprocessor">##INTERFACE();                                                     \</span></div><div class="line">    <span class="keyword">virtual</span> ~I<span class="preprocessor">##INTERFACE();                                            \</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></div><div class="line">    <span class="keyword">const</span> android::String16 I<span class="preprocessor">##INTERFACE::descriptor(NAME);             \</span></div><div class="line">    <span class="keyword">const</span> android::String16&                                            \</div><div class="line">            I<span class="preprocessor">##INTERFACE::getInterfaceDescriptor() const {              \</span></div><div class="line">        <span class="keyword">return</span> I<span class="preprocessor">##INTERFACE::descriptor;                                \</span></div><div class="line">    }                                                                   \</div><div class="line">    android::sp&lt;I<span class="preprocessor">##INTERFACE&gt; I##INTERFACE::asInterface(                \</span></div><div class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;& obj)                   \</div><div class="line">    {                                                                   \</div><div class="line">        android::sp&lt;I<span class="preprocessor">##INTERFACE&gt; intr;                                 \</span></div><div class="line">        <span class="keyword">if</span> (obj != NULL) {                                              \</div><div class="line">            intr = <span class="keyword">static_cast</span>&lt;I<span class="preprocessor">##INTERFACE*&gt;(                          \</span></div><div class="line">                obj-&gt;queryLocalInterface(                               \</div><div class="line">                        I<span class="preprocessor">##INTERFACE::descriptor).get());               \</span></div><div class="line">            <span class="keyword">if</span> (intr == NULL) {                                         \</div><div class="line">                intr = <span class="keyword">new</span> Bp<span class="preprocessor">##INTERFACE(obj);                          \</span></div><div class="line">            }                                                           \</div><div class="line">        }                                                               \</div><div class="line">        <span class="keyword">return</span> intr;                                                    \</div><div class="line">    }                                                                   \</div><div class="line">    I<span class="preprocessor">##INTERFACE::I##INTERFACE() { }                                    \</span></div><div class="line">    I<span class="preprocessor">##INTERFACE::~I##INTERFACE() { }                                   \</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> CHECK_INTERFACE(interface, data, reply)                         \</span></div><div class="line">    <span class="keyword">if</span> (!data.checkInterface(<span class="keyword">this</span>)) { <span class="keyword">return</span> PERMISSION_DENIED; }       \</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ----------------------------------------------------------------------</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>如果在 .h 中的 class 定义中调用 <code>DECLARE_META_INTERFACE(&quot;Xx&quot;)</code> 在 .cpp 中的实现中调用 <code>IMPLEMENT_META_INTERFACE(&quot;Xx&quot;, &quot;Xx&quot;)</code> 那么就想当于声明和实现了：</p>
<ol>
<li>默认构造函数</li>
<li>析构函数</li>
<li>定义了并以 Xx 初始化 String16 descriptor 这个变量</li>
<li>asInterface： 返回 IXx 的指针</li>
<li>getInterfaceDescriptor： 返回 descriptor 字符串</li>
</ol>
<p>实际上不是如果，后面的具体的 native 的 service 的接口就是这么写的（后面会有具体的实例分析）。</p>
<p>接下来就看真正的接口基类： BnInterface<xx>:</xx></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">class</span> BnInterface : <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16& _descriptor);</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> String16&     getInterfaceDescriptor() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> IBinder*            onAsBinder();</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>哎呦咧，C++ 的多重继承，分别继续了 BBinder（binder 的服务器） 和 INTERFACE 这个其实就是上面的 IInterface，在具体的 services 中会通过 IInterface 中的那2个宏弄一个 IXx 出来，然后 BnInterface 这里的 INTERFACE 就是 IXx（这个后面到了实例分析，就会很清楚了）。这里实现上面 BBinder 那没实现的几个接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> sp&lt;IInterface&gt; BnInterface&lt;INTERFACE&gt;::queryLocalInterface(</div><div class="line">        <span class="keyword">const</span> String16& _descriptor)   </div><div class="line">{</div><div class="line">    <span class="comment">// 对比下是不是自己的标示，是的话直接返回自己</span></div><div class="line">    <span class="keyword">if</span> (_descriptor == INTERFACE::descriptor) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> String16& BnInterface&lt;INTERFACE&gt;::getInterfaceDescriptor() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="comment">// 这 ... 有必要重写一下么？？</span></div><div class="line">    <span class="keyword">return</span> INTERFACE::getInterfaceDescriptor();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line">IBinder* BnInterface&lt;INTERFACE&gt;::onAsBinder()</div><div class="line">{</div><div class="line">    <span class="comment">// 这里抛弃 BBinder 的 localBinder 了，直接返回自己了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>queryLocalInterface 这个是只有 BBinder 才有的（对比 IBinder 的接口），然后根据在这个函数的实现：对比 descriptor 是不是自己定义的（通过 <code>DECLARE_META_INTERFACE</code> 这个宏定义的），然后是否返回自己，可以猜得到：1、这个函数是用来判断请求是不是处于本进程内，如果是的话，应该就不需要跨进程调用，直接可以调用本进程的方法。这样对于上层应用来说，暴露的是 IBinder 接口，上层应用不需要关心调用是本地的还是远程的。2：descriptor 这个是用来区别 binder 的服务器的，binder 通过这个来判断请求是不是发给自己的，如果 descriptor 不匹配，则拒绝处理。（这些猜测后面再慢慢说）</p>
<p>然后是 BpInterface 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">class</span> BpInterface : <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;& remote);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> IBinder*            onAsBinder();</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>比 Bn 相比，没了判断是不是本地的接口了，客户端当然不需要有啦。然后应该是继续 BpBinder 的，变成了 BpRefBase ，看到这个名字我又想到了 android 那蛋疼的智能指针和引用计数，我真的很烦这个东西，就不能好好的自己管好内存么？？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BpRefBase : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">                            BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;& o); </div><div class="line">    <span class="keyword">virtual</span>                 ~BpRefBase();</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>            onFirstRef();</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>            onLastStrongRef(<span class="keyword">const</span> <span class="keyword">void</span>* id);</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span>            onIncStrongAttempted(uint32_t flags, <span class="keyword">const</span> <span class="keyword">void</span>* id);</div><div class="line"></div><div class="line">    <span class="comment">// 最重要的一个函数，返回 mRemote IBinder 指针</span></div><div class="line">    <span class="keyword">inline</span>  IBinder*        remote()                { <span class="keyword">return</span> mRemote; }</div><div class="line">    <span class="keyword">inline</span>  IBinder*        remote() <span class="keyword">const</span>          { <span class="keyword">return</span> mRemote; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">                            BpRefBase(<span class="keyword">const</span> BpRefBase& o); </div><div class="line">    BpRefBase&              <span class="keyword">operator</span>=(<span class="keyword">const</span> BpRefBase& o); </div><div class="line"></div><div class="line">    IBinder* <span class="keyword">const</span>          mRemote;</div><div class="line">    RefBase::weakref_type*  mRefs;</div><div class="line">    <span class="keyword">volatile</span> int32_t        mState;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面这个东西，其它的不看，就看一个函数 remote() 返回 mRemote 这个 IBinder 指针。然后来看下 BpInterface 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> BpInterface&lt;INTERFACE&gt;::BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;& remote)</div><div class="line">    : BpRefBase(remote)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="keyword">inline</span> IBinder* BpInterface&lt;INTERFACE&gt;::onAsBinder()</div><div class="line">{</div><div class="line">    <span class="comment">// 调用 BpRefBase 的 remote() 返回 BpBinder 的远程 binder 指针</span></div><div class="line">    <span class="keyword">return</span> remote();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>BpInterface 的 sp<ibinder> 参数的构造函数，把 sp<ibinder> 传给 BpRefBase 了，这个 IBinder 其实就是 BpBinder （通过后面的分析可以看得出的）。结合上面 Bn 的 onAsBinder 是返回 this 自己（BBinder），Bp 的是返回 BpBinder 。</ibinder></ibinder></p>
<p>再下面，就是具体业务相关的了，IXx 继承自 IInterface，主要是使用 IInterface 提供的那个 <code>DECLARE_META_INTERFACE(Xx)</code> 这个宏声明一些接口（上面有分析的），Xx 就是接口的名字了，例如 ServerManager、SurfaceComposer 之类的（这个后面会有具体的实例分析的）。然后这个 IXx 还得定义这个 service 对外（客户端）提供的接口，例如 CaptureScreen 之类的，这个就和具体的 service 相关了。 </p>
<p>BnXx 继承 BnInterface（同时继承 IXx），使用 IInterface 提供的 <code>IMPLEMENT_META_INTERFACE(Xx, Xx)</code> 来实现上面说的那些接口。注意这里的 Xx 要和 <code>DECLARE_META_INTERFACE</code> 那里的一样，例如都叫 SurfaceComposer， 然后后面那个是标示（descriptor），例如 “android.ui.ISurfaceComposer”（用包名来标示一般不会重复）。</p>
<p>然后剩下的主要是实现 onTransact 就是响应客户端的请求。其实通过后面的分析 BnXx 中也并不是真正实现请求的地方，这个只是一个中转站而已，真正的实现在 service 模块里面，一个一个业务函数实现的，这里的 onTransact 只是区分客户端发过来的请求命令，然后去调用 service 里面的函数，实现这些的文件都叫 I<br>Xx.h, IXx.cpp 看上去也不像实现的样子。然后真正的 service 就要继承 BnXx 去实现 onTransact。但是你也发现了，onTransact 已经在 BnXx 里实现了，所以你在 services 看到的 onTransact 都是马甲（有些做了一些拦截，例如权限检测，没权限的请求直接拦截下来），基本上都是调用： super.onTransact 的 -_-|| 。</p>
<p>BpXx 继承 BpInterface。 BpInterface 并没强制要求 BpXx 实现啥东西，但是作用客户端（Java 层那一堆 XxManager 给其它 apk 调用的），暴露给第三方引用使用的，必须要实现服务器提供的方法对应的接口：例如说 service 那边有一个方法是： captureScreen 用来实现截屏用的，那么客户端也必须有响应的方法： captureScreen，然后客户端调用 remote()（IBinder） 的 transact 发送请求到服务器。当然其实函数名字也可以不一一对应，你只要在服务器 onTransact 里调用正确就行了。但是后面你会发现如果这些东西一一对应的话，代码是很机械的，后面 android 就搞了个代码自动生成的工具出来（aidl）。</p>
<p>这里 native 层的框架就说完了。接下来看下 java 层的。</p>
<h2 id="框架设计——java">框架设计——java</h2>
<p>照例来先张图先：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-base/2.png" alt=""></p>
<p>图中我把相关的 jni 里面类也画了出来，这样就能更加明显的看到 java 层和 native 层的对应关系。</p>
<p>代码位置也先说下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java：</span></div><div class="line">frameworks/base/core/java/android/os/Binder.java</div><div class="line">frameworks/base/core/java/android/os/Parcel.java</div><div class="line">frameworks/base/core/java/com/android/internal/os/BinderInternal.java</div><div class="line"></div><div class="line"><span class="comment"># jni：</span></div><div class="line">frameworks/base/core/jni/android_util_Binder.h</div><div class="line">frameworks/base/core/jni/android_util_Binder.cpp</div><div class="line">frameworks/base/core/jni/android_os_Parcel.h</div><div class="line">frameworks/base/core/jni/android_os_Parcel.cpp</div><div class="line"></div></pre></td></tr></table></figure>

<p>从图可得到，java 层的架构和 native 的很像。也是分为2个部分：实现部分和接口部分（几乎连名字都和 native 的一样）。</p>
<p>实现部分的话，也是一个 IBinder 的基类，额，不对 java 的叫 interface ，这个比 c++ 更加注重抽象。然后实现这个接口的分别是 Binder（Binder.java） 和 BinderProxy（Binder.java），分别对应 native 的 BBinder 和 BpBinder ，同时也分别代表 java 层的服务端和客户端。</p>
<p>Binder 这边的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Convenience method for associating a specific interface with the Binder.</span></div><div class="line"><span class="comment"> * After calling, queryLocalInterface() will be implemented for you</span></div><div class="line"><span class="comment"> * to return the given owner IInterface when the corresponding</span></div><div class="line"><span class="comment"> * descriptor is requested.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachInterface</span>(IInterface owner, String descriptor) {</div><div class="line">    mOwner = owner;</div><div class="line">    mDescriptor = descriptor;      </div><div class="line">}</div><div class="line">   </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Default implementation returns an empty interface name.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> String <span class="title">getInterfaceDescriptor</span>() {</div><div class="line">    <span class="keyword">return</span> mDescriptor;   </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Use information supplied to attachInterface() to return the</span></div><div class="line"><span class="comment"> * associated IInterface if it matches the requested</span></div><div class="line"><span class="comment"> * descriptor.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span>(String descriptor) {</div><div class="line">    <span class="keyword">if</span> (mDescriptor.equals(descriptor)) {</div><div class="line">        <span class="keyword">return</span> mOwner;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Default implementation is a stub that returns false.  You will want</span></div><div class="line"><span class="comment"> * to override this to do the appropriate unmarshalling of transactions.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * &lt;p&gt;If you want to call this, call transact().</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply,</div><div class="line">        <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (code == INTERFACE_TRANSACTION) {</div><div class="line">        reply.writeString(getInterfaceDescriptor());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (code == DUMP_TRANSACTION) {</div><div class="line">        ParcelFileDescriptor fd = data.readFileDescriptor();</div><div class="line">        String[] args = data.readStringArray(); </div><div class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                dump(fd.getFileDescriptor(), args);</div><div class="line">            } <span class="keyword">finally</span> {   </div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    fd.close();                    </div><div class="line">                } <span class="keyword">catch</span> (IOException e) {      </div><div class="line">                    <span class="comment">// swallowed, not propagated back to the caller</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// Write the StrictMode header.</span></div><div class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span>) {           </div><div class="line">            reply.writeNoException();      </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            StrictMode.clearGatheredViolations();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Default implementation rewinds the parcels and calls onTransact.  On</span></div><div class="line"><span class="comment"> * the remote side, transact calls into the binder to do the IPC.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply,</div><div class="line">        <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"Binder"</span>, <span class="string">"Transact: "</span> + code + <span class="string">" to "</span> + <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) {</div><div class="line">        data.setDataPosition(<span class="number">0</span>);       </div><div class="line">    }</div><div class="line">    <span class="keyword">boolean</span> r = onTransact(code, data, reply, flags);</div><div class="line">    <span class="keyword">if</span> (reply != <span class="keyword">null</span>) {  </div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面几个函数都挺简单的，就是返回 descriptor ，要不返回 IInterface，要不设置下 IInterface 和 desriptor 。transact 这个函数看注释说是啥默认实现，别看它调用了 onTransact （native Bn 端的实现主要在这里）其实就是个摆设，没用的，因为要实现 IBinder 的接口，才必须要有一个实现而已（到后面就就知道了）。然后 onTransact 这个和 native 对应了，不过这里其实也没干声明正事，功能主要是留在service 的接口里实现的。</p>
<p>java 的 Binder 最主要要看的是它有个叫 mObject 的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* mObject is used by native code, do not remove or rename */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mObject;</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释说是 native 层要使用，其实是 jni 要使用。来看看这个 mObject 是怎么使用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> native final <span class="keyword">void</span> init();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Default constructor initializes the object.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> Binder() {</div><div class="line">    init();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) {    </div><div class="line">        final Class&lt;? extends Binder&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&</div><div class="line">                (klass.getModifiers() & Modifier.STATIC) == <span class="number">0</span>) {</div><div class="line">            Log.w(TAG, <span class="string">"The following Binder class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());     </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在 Binder 的构造函数中会调用一个 init 的 native 方法，这个方法在 jni <code>android_util_Binder.cpp</code> 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Binder_init(JNIEnv* env, jobject obj) </div><div class="line">{</div><div class="line">    JavaBBinderHolder* jbh = <span class="keyword">new</span> JavaBBinderHolder();</div><div class="line">    <span class="keyword">if</span> (jbh == NULL) {</div><div class="line">        jniThrowException(env, <span class="string">"java/lang/OutOfMemoryError"</span>, NULL);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    ALOGV(<span class="string">"Java Binder %p: acquiring first ref on holder %p"</span>, obj, jbh);</div><div class="line">    jbh-&gt;incStrong((<span class="keyword">void</span>*)android_os_Binder_init);</div><div class="line">    env-&gt;SetIntField(obj, gBinderOffsets.mObject, (<span class="keyword">int</span>)jbh);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里创建了一个 JavaBBinderHolder （这个是 c++ 的类）的类，然后把这个指针保存在了 mObject 这个变量里面。int 类型是 32bit 的，指针（地址）在 32bit 系统上也是 32bit 的。这里再先看看 gBinderOffsets 这个东西，其实还有一个叫 gBinderProxyOffsets 的。这2个是 jni 里面 java 的类信息变量，弄成全局变量，如果访问频繁的话，能提高速度，因为每次都要去查 java 的类表很慢的，加载的代码在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderPathName = <span class="string">"android/os/Binder"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> int_register_android_os_Binder(JNIEnv* env)</div><div class="line">{</div><div class="line">    jclass clazz;</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(kBinderPathName);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class android.os.Binder"</span>);</div><div class="line"></div><div class="line">    gBinderOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gBinderOffsets.mExecTransact</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"execTransact"</span>, <span class="string">"(IIII)Z"</span>);</div><div class="line">    assert(gBinderOffsets.mExecTransact);</div><div class="line"></div><div class="line">    gBinderOffsets.mObject</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</div><div class="line">    assert(gBinderOffsets.mObject);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(</div><div class="line">        env, kBinderPathName,</div><div class="line">        gBinderMethods, NELEM(gBinderMethods));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> int_register_android_os_BinderProxy(JNIEnv* env)</div><div class="line">{</div><div class="line">    jclass clazz;</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/ref/WeakReference"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class java.lang.ref.WeakReference"</span>);</div><div class="line">    gWeakReferenceOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gWeakReferenceOffsets.mGet</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"get"</span>, <span class="string">"()Ljava/lang/Object;"</span>);</div><div class="line">    assert(gWeakReferenceOffsets.mGet);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Error"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class java.lang.Error"</span>);</div><div class="line">    gErrorOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(kBinderProxyPathName);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class android.os.BinderProxy"</span>);</div><div class="line"></div><div class="line">    gBinderProxyOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gBinderProxyOffsets.mConstructor</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mConstructor);</div><div class="line">    gBinderProxyOffsets.mSendDeathNotice</div><div class="line">        = env-&gt;GetStaticMethodID(clazz, <span class="string">"sendDeathNotice"</span>, <span class="string">"(Landroid/os/IBinder$DeathRecipient;)V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mSendDeathNotice);</div><div class="line"></div><div class="line">    gBinderProxyOffsets.mObject</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mObject);</div><div class="line">    gBinderProxyOffsets.mSelf</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mSelf"</span>, <span class="string">"Ljava/lang/ref/WeakReference;"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mSelf);</div><div class="line">    gBinderProxyOffsets.mOrgue</div><div class="line">        = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mOrgue);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Class"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find java.lang.Class"</span>);</div><div class="line">    gClassOffsets.mGetName = env-&gt;GetMethodID(clazz, <span class="string">"getName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</div><div class="line">    assert(gClassOffsets.mGetName);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(</div><div class="line">        env, kBinderProxyPathName,</div><div class="line">        gBinderProxyMethods, NELEM(gBinderProxyMethods));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> register_android_os_Binder(JNIEnv* env)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (int_register_android_os_Binder(env) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (int_register_android_os_BinderInternal(env) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (int_register_android_os_BinderProxy(env) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    ... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 <code>register_android_os_Binder</code> 会在 android 的 java 初始化的时候调用，这个时候需要的类信息就加载好了。gBinderOffsets 对应的是 Binder， gBinderProxyOffsets 对应的是 BinderProxy 。gBinderOffsets 的 mObject 就是 Binder 的 mObject 变量，所以那个注释说不要乱改这个变量的名字，不然这里就找不到了。gBinderOffsets 还有一个保存了 execTransact 的变量，这个注意一下，后面会说到的。</p>
<p>回过来看下 JavaBBinderHolder 这个东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> JavaBBinderHolder : <span class="keyword">public</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)</div><div class="line">    {</div><div class="line">        AutoMutex _l(mLock);  </div><div class="line">        sp&lt;JavaBBinder&gt; b = mBinder.promote();</div><div class="line">        <span class="keyword">if</span> (b == NULL) {</div><div class="line">            b = <span class="keyword">new</span> JavaBBinder(env, obj); </div><div class="line">            mBinder = b;      </div><div class="line">            ALOGV(<span class="string">"Creating JavaBinder %p (refs %p) for Object %p, weakCount=%d\n"</span>,</div><div class="line">                 b.get(), b-&gt;getWeakRefs(), obj, b-&gt;getWeakRefs()-&gt;getWeakCount());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    }</div><div class="line"></div><div class="line">    sp&lt;JavaBBinder&gt; getExisting()</div><div class="line">    {</div><div class="line">        AutoMutex _l(mLock);  </div><div class="line">        <span class="keyword">return</span> mBinder.promote();      </div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Mutex           mLock;</div><div class="line">    wp&lt;JavaBBinder&gt; mBinder;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个东西继承自 native 的 RefBase，然后在看它的 get 方法的返回值，可以理解为这个东西就是在 java 里面放了一个 natvie 的 sp<ibinder> 一样。它持有的是 JavaBBinder 对象，这个才是重点：</ibinder></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">class JavaBBinder : <span class="keyword">public</span> BBinder</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="title">JavaBBinder</span>(JNIEnv* env, jobject object)</div><div class="line">        : <span class="title">mVM</span>(<span class="title">jnienv_to_javavm</span>(env)), <span class="title">mObject</span>(env-&gt;<span class="title">NewGlobalRef</span>(object))</div><div class="line">    {</div><div class="line">        ALOGV(<span class="string">"Creating JavaBBinder %p\n"</span>, <span class="keyword">this</span>);</div><div class="line">        android_atomic_inc(&gNumLocalRefs);</div><div class="line">        incRefsCreated(env);</div><div class="line">    }</div><div class="line"></div><div class="line">    bool    checkSubclass(<span class="keyword">const</span> <span class="keyword">void</span>* subclassID) <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> subclassID == &gBinderOffsets;</div><div class="line">    }</div><div class="line"></div><div class="line">    jobject object() <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> mObject;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    virtual ~<span class="title">JavaBBinder</span>()</div><div class="line">    {</div><div class="line">        ALOGV(<span class="string">"Destroying JavaBBinder %p\n"</span>, <span class="keyword">this</span>);</div><div class="line">        android_atomic_dec(&gNumLocalRefs);</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line">        env-&gt;DeleteGlobalRef(mObject);</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual status_t onTransact(</div><div class="line">        uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags = <span class="number">0</span>)</div><div class="line">    {</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line"></div><div class="line">        ALOGV(<span class="string">"onTransact() on %p calling object %p in env %p vm %p\n"</span>, <span class="keyword">this</span>, mObject, env, mVM);</div><div class="line"></div><div class="line">        IPCThreadState* thread_state = IPCThreadState::self();</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> strict_policy_before = thread_state-&gt;getStrictModePolicy();</div><div class="line">        thread_state-&gt;setLastTransactionBinderFlags(flags);</div><div class="line"></div><div class="line">        <span class="comment">//printf("Transact from %p to Java code sending: ", this);</span></div><div class="line">        <span class="comment">//data.print();</span></div><div class="line">        <span class="comment">//printf("\n");</span></div><div class="line">        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</div><div class="line">            code, (int32_t)&data, (int32_t)reply, flags);</div><div class="line">        jthrowable excep = env-&gt;ExceptionOccurred();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (excep) {</div><div class="line">            report_exception(env, excep,</div><div class="line">                <span class="string">"*** Uncaught remote exception!  "</span></div><div class="line">                <span class="string">"(Exceptions are not yet supported across processes.)"</span>);</div><div class="line">            res = JNI_FALSE;</div><div class="line"></div><div class="line">            <span class="comment">/* clean up JNI local ref -- we don't return to Java code */</span></div><div class="line">            env-&gt;DeleteLocalRef(excep);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Restore the Java binder thread's state if it changed while</span></div><div class="line">        <span class="comment">// processing a call (as it would if the Parcel's header had a</span></div><div class="line">        <span class="comment">// new policy mask and Parcel.enforceInterface() changed</span></div><div class="line">        <span class="comment">// it...)</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> strict_policy_after = thread_state-&gt;getStrictModePolicy();</div><div class="line">        <span class="keyword">if</span> (strict_policy_after != strict_policy_before) {</div><div class="line">            <span class="comment">// Our thread-local...</span></div><div class="line">            thread_state-&gt;setStrictModePolicy(strict_policy_before);</div><div class="line">            <span class="comment">// And the Java-level thread-local...</span></div><div class="line">            set_dalvik_blockguard_policy(env, strict_policy_before);</div><div class="line">        }</div><div class="line"></div><div class="line">        jthrowable excep2 = env-&gt;ExceptionOccurred();</div><div class="line">        <span class="keyword">if</span> (excep2) {</div><div class="line">            report_exception(env, excep2,</div><div class="line">                <span class="string">"*** Uncaught exception in onBinderStrictModePolicyChange"</span>);</div><div class="line">            <span class="comment">/* clean up JNI local ref -- we don't return to Java code */</span></div><div class="line">            env-&gt;DeleteLocalRef(excep2);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Need to always call through the native implementation of</span></div><div class="line">        <span class="comment">// SYSPROPS_TRANSACTION.</span></div><div class="line">        <span class="keyword">if</span> (code == SYSPROPS_TRANSACTION) {</div><div class="line">            BBinder::onTransact(code, data, reply, flags);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">//aout &lt;&lt; "onTransact to Java code; result=" &lt;&lt; res &lt;&lt; endl</span></div><div class="line">        <span class="comment">//    &lt;&lt; "Transact from " &lt;&lt; this &lt;&lt; " to Java code returning "</span></div><div class="line">        <span class="comment">//    &lt;&lt; reply &lt;&lt; ": " &lt;&lt; *reply &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual status_t dump(<span class="keyword">int</span> fd, <span class="keyword">const</span> Vector&lt;String16&gt;& args)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    JavaVM* <span class="keyword">const</span>   mVM;</div><div class="line">    jobject <span class="keyword">const</span>   mObject;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>JavaBBinder 继承自 native 的 BBinder，这下清楚了，java 层最重要还是持有了 native 的 binder 对象。同时这个东西还保存了 java Binder 的对象（相互保存 -_-||），那个 jobject mObject 就是，构造函数传进来的，然后在 JavaBBinderHolder 的 get 那里第一次会触发 new JavaBBinder，参数就是 java 的 Binder，这里后面再说。然后这个类重载了 BBinder 的 onTransact ，前面 native 说过了， Bn 端的实现主要是要重写 onTransact。然后在 onTransact 通过 java 对象 mObject 调用了 java Binder 的 gBinderOffsets 的 mExecTransact 。还记得前面加载 Binder 类信息的时候，说要注意这个 mExecTransact 的么，就是这里用啦，对应 Binder 的 execTransact 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Entry point from android_util_Binder.cpp's onTransact</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span>(<span class="keyword">int</span> code, <span class="keyword">int</span> dataObj, <span class="keyword">int</span> replyObj,</div><div class="line">        <span class="keyword">int</span> flags) {</div><div class="line">    Parcel data = Parcel.obtain(dataObj); </div><div class="line">    Parcel reply = Parcel.obtain(replyObj);</div><div class="line">    <span class="comment">// theoretically, we should call transact, which will call onTransact,</span></div><div class="line">    <span class="comment">// but all that does is rewind it, and we just got these from an IPC,</span></div><div class="line">    <span class="comment">// so we'll just call it directly.</span></div><div class="line">    <span class="keyword">boolean</span> res;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        res = onTransact(code, data, reply, flags);</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">        reply.writeException(e);       </div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException e) { </div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">        reply.writeException(e);       </div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">catch</span> (OutOfMemoryError e) { </div><div class="line">        RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</div><div class="line">        reply.setDataPosition(<span class="number">0</span>);      </div><div class="line">        reply.writeException(re);      </div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    reply.recycle();</div><div class="line">    data.recycle();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后是调用了 Binder 的 onTransact 函数，所以还是和 native 的一样，Bn 靠重载 onTransact。所以前面说 Binder 实现 IBinder 的 transact 接口是摆设，因为这个不像 native 层 BBinder 的 transact，java 层的压根就没调用到。总结下，java 的 Bn 是通过 native 的 BBinder 的 transact 被调用，然后 natvie BBinder 的 onTransact（JavaBBinder 重载） 的被调用，然后在 jni 中调用 java 的 Binder 的 onTransact 。</p>
<p>然后是 BinderProxy:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> class BinderProxy implements IBinder {</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getInterfaceDescriptor</span>() <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply,</div><div class="line">            <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException; </div><div class="line"></div><div class="line">    <span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span>(String descriptor) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>BinderProxy 很多都直接是 native 方法。queryLocalInterface 直接放回 null，和 native 层的一样， Bp 端不实现 Bn 端的方法。它和 Binder 一样有一个 int mObject 的变量，同样这个也是保存 native 对象指针的，这个其实是 sp<bpbinder>，这个后面再分析了。所以 java 的 BinderProxy transact 方法就直接调用 native BpBinder 的 transact 。</bpbinder></p>
<p>接下来就是接口部分了。IInterface :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Base class for Binder interfaces.  When defining a new interface,</span></div><div class="line"><span class="comment"> * you must derive it from IInterface.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IInterface</span></span></div><div class="line"><span class="class"></span>{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Retrieve the Binder object associated with this interface.</span></div><div class="line"><span class="comment">     * You must use this instead of a plain cast, so that proxy objects</span></div><div class="line"><span class="comment">     * can return the correct result.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> IBinder <span class="title">asBinder</span>();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>和 native 层的很像，但是这个和 Binder 和 BinderProxy 不一样，java 的 IInterface 和 native 层的没啥关系（Binder 和 BinderProxy 可是保存了 native 层对象的指针的），只是为单纯为了对应而已。</p>
<p>然后同样，java 层的 service 需要继续这个接口，自己写一个 IXxManager 定义自己的服务提供的业务逻辑接口（那个 Manager 的后缀不是必须的，但是 android 系统的 service 都很统一，接口都叫 XxManager，服务都叫 XxManagerServices）。然后 Bn 这边的话，实现接口一般都叫 XxManagerNative 去实现这个 IXxManager 的接口，相当于 native 的 BnXx 实现 BnInterface 一样。然后服务模块继承这个 XxManagerNative，真正实现业务逻辑功能，XxManagerNative 里面的 onTransact 负责接受客户端发送过来的请求，并且调用正确的 service 的业务函数完成功能（和 native 流程一样）。</p>
<p>Bp 这边呢，一般由一个叫 XxProxy 的类实现 IXxManager 的接口，然后它有一个 mRemote 的 IBinder 变量，其实就是 BinderProxy （这个后面实例慢慢分析）。然后接口是通过 Parcel 把请求打包好，通过的 mRemote（BinderProxy，BinderProxy 直接调用 native BpBinder 的 transact） 的 transact 发送给 binder 驱动，最后再转给 Bn 端接收。流程也和 native 的是一样的。最后暴露给应用使用的 XxManager 其实一般都保存了一个 XxProxy 对象，然后 XxManager 的接口，基本上都是马甲，直接调用 XxProxy 对应的方法的（同样后面对照实例慢慢分析）。</p>
<p>前面 uml 中我在 XxManagerNative 和 XxProxy 中还有个括号，我前面说了 android 在 java 搞了个代码自动生成的东西——aidl，那个括号里面的类名是工具生成出来的，括号外面是手动写的。android 那一票 services 绝大部分接口的代码是用工具生成的，但是有几个是手写的，原因么，估计刚开始还没这个工具吧。 </p>
<p>android 故意在 java 层上 binder 的框架结构和 native 层保持一致，这是个不错的设计，然后 java 层 binder 通信其实就是 native 的调用而已。上面简单把 binder 的框架梳理了一下，有很多地方后面再慢慢分析，因为 binder 涉及的东西太多了（横跨 java、native 和 kernel），而且进程间通信本来就是比较麻烦的东西，我认为多进程这个是现代智能操作系统的必不可少的基本功能之一。</p>
<p>把基本的东西先弄清楚，后面分析会方便很多。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——原理/" data-title="Android Binder 分析——原理 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/22/Android Broadcast 分析——超时或异常/" title="Android Broadcast 分析——超时或异常">
  <strong>上一篇:</strong><br/>
  <span>
  Android Broadcast 分析——超时或异常</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——通信模型/"  title="Android Binder 分析——通信模型">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——通信模型
</span>
</a>
</div>

</nav>


	
<section class="comment">
	<div class="ds-thread" data-thread-key="Android Binder 分析——原理" data-title="Android Binder 分析——原理" 
      data-author-key="mingming" data-limit=10
      data-url="light3moon.com/2015/01/28/Android Binder 分析——原理/">
    </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用"><span class="toc-number">2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架设计——native"><span class="toc-number">3.</span> <span class="toc-text">框架设计——native</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架设计——java"><span class="toc-number">4.</span> <span class="toc-text">框架设计——java</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>33</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>46</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Server/" title="Server">Server<sup>1</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/android/" title="android">android<sup>79</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">哥的后勤处 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-qqzone"></i> <a href="http://user.qzone.qq.com/544630305" target="_blank">QQ 空间</a></li>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">战斗力</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="commentlist">
  <p class="asidetitle">最近冒泡的小伙伴 ╰(●&#39;◡&#39;●)╮</p>
    <ul>
      <ul class="ds-recent-comments" 
        data-num-items="6" 
        data-show-avatars="1" 
        data-show-title="1"   
        data-show-time="1" 
        data-show-admin="1" 
        data-excerpt-length="30">
      </ul>
      <!-- duoshou js begin load, one page only load once -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"mingming"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- duoshou js load end -->
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	
		<a href="http://user.qzone.qq.com/544630305" target="_blank" title="qqzone"></a>
		         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2016 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"mingming"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
