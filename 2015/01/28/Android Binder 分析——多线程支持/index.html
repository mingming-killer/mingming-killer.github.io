
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——多线程支持 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="前面普通服务篇那里说到 ActivityManager（AM） 里锁的问题，其实不光 AM，WindowManager（WM）、PackageMananger（PM）中基本上很多对外的业务函数里面都是加锁的，所以这些 SS 里面有会有带 Locked 结尾的函数（这些函数都是在锁里执行）。这里就提出">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">三月学长的小站</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——多线程支持/" title="Android Binder 分析——多线程支持" itemprop="url">Android Binder 分析——多线程支持</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T13:42:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2017-02-07T13:47:45.000Z" itemprop="dateModified">2017 2月 7</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SS_多线程的例子"><span class="toc-number">1.</span> <span class="toc-text">SS 多线程的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程对象和线程对象"><span class="toc-number">2.</span> <span class="toc-text">进程对象和线程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程接口实现-上"><span class="toc-number">3.</span> <span class="toc-text">多线程接口实现.上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android_中的线程"><span class="toc-number">4.</span> <span class="toc-text">android 中的线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程接口实现-下"><span class="toc-number">5.</span> <span class="toc-text">多线程接口实现.下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动创建线程"><span class="toc-number">6.</span> <span class="toc-text">自动创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java_层的_SS"><span class="toc-number">7.</span> <span class="toc-text">java 层的 SS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>前面普通服务篇那里说到 ActivityManager（AM） 里锁的问题，其实不光 AM，WindowManager（WM）、PackageMananger（PM）中基本上很多对外的业务函数里面都是加锁的，所以这些 SS 里面有会有带 Locked 结尾的函数（这些函数都是在锁里执行）。这里就提出一个疑问为什么要加锁。这篇就来解答这个问题，顺带扯出 binder 的多线程支持的问题。</p>
<p>照例先把相关源码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java 层 SS 相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/SystemServer.java</div><div class="line"></div><div class="line"><span class="comment"># java 层 zygote 相关接口</span></div><div class="line">frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</div><div class="line">frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</div><div class="line">libcore/dalvik/src/main/java/dalvik/system/Zygote.java</div><div class="line"></div><div class="line"><span class="comment"># jni runtime 接口</span></div><div class="line">frameworks/base/core/jni/AndroidRuntime.cpp</div><div class="line"></div><div class="line"><span class="comment"># native app process 程序</span></div><div class="line">frameworks/base/cmds/app_process/app_main.cpp</div><div class="line"></div><div class="line"><span class="comment"># native binder 库</span></div><div class="line">frameworks/native/libs/binder/ProcessState.cpp</div><div class="line">frameworks/native/libs/binder/IPCThreadState.cpp</div><div class="line">frameworks/native/libs/binder/Static.cpp</div><div class="line"></div><div class="line"><span class="comment"># native SS 主程序</span></div><div class="line">frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</div><div class="line">frameworks/native/services/sensorservice/main_sensorservice.cpp</div><div class="line"></div><div class="line"><span class="comment"># libutils 库（线程支持）</span></div><div class="line">system/core/include/utils/AndroidThreads.h</div><div class="line">system/core/include/utils/Thread.h</div><div class="line">system/core/libutils/Threads.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="SS_多线程的例子">SS 多线程的例子</h2>
<p>前面说了 binder 是 C/S 模型。既然是 C/S 模型，很容易让人想到会服务器同时可能会被多个客户端连接、请求。传统的服务器，都会开一个线程池来应对这种情况，避免请求数一多，某些客户端长时间没响应的情况。</p>
<p>这个在 binder 中是一样的，只不过 binder 是本地的而已（这里说的本地是相对网络上的服务器来说的）。你想想你写 android 代码的时候，经常就 get AM ，然后 AM xx 的调用了。所以说 binder 中的 Bn 端经常会同一时候有多个 Bp 请求的，特别是 SS（谁让它们是公用的）。既然这样的话，我们在写服务的时候是不是也要像传统的服务器一样考虑使用线程池来提高服务的并发响应能力咧。先别急，android 早就帮我们整好一个现成的框架了。</p>
<p>我们先来看看一些实际的列子。我们以 sensorservice 为例（先说 native 的 SS，java 层的要绕好久，后面再说）。sensorservice 的 main 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main_sensorservice.cpp =============================</span></div><div class="line"></div><div class="line"><span class="comment">// 这个 main 函数就一句话 ... ...</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    SensorService::publishAndJoinThreadPool();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>SensorService 是继承自 BinderService 的类，我们去看看 BinderService：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BinderService.h =============================</span></div><div class="line"></div><div class="line"><span class="comment">// 这是一个模板类</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</div><div class="line"><span class="keyword">class</span> BinderService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> status_t publish(<span class="keyword">bool</span> allowIsolated = <span class="keyword">false</span>) {</div><div class="line">        <span class="comment">// 获取 SM</span></div><div class="line">        sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">        <span class="comment">// new Service 对象，然后 add 到 SM 中</span></div><div class="line">        <span class="keyword">return</span> sm-&gt;addService(</div><div class="line">                String16(SERVICE::getServiceName()),</div><div class="line">                <span class="keyword">new</span> SERVICE(), allowIsolated);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> publishAndJoinThreadPool(<span class="keyword">bool</span> allowIsolated = <span class="keyword">false</span>) {</div><div class="line">        publish(allowIsolated);</div><div class="line">        joinThreadPool();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> instantiate() { publish(); }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> status_t shutdown() { <span class="keyword">return</span> NO_ERROR; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> joinThreadPool() {</div><div class="line">        <span class="comment">// 初始化 ProcessState 对象</span></div><div class="line">        sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">        <span class="comment">// 启动线程池</span></div><div class="line">        ps-&gt;startThreadPool();</div><div class="line">        ps-&gt;giveThreadPoolName();</div><div class="line">        <span class="comment">// 当前线程加入线程池</span></div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 BinderService.h 是在 natvie binder 的 include 头文件中，看样子 android 直接提供了一个模板，SS 直接继承，然后在 main 函数调用一句话就行了。模板就是先 new 一个 Service 对象，然后 add 到 SM 中，然后构造一个 ProcessState 对象（这个对象一个进程只有一个），调用 ProcessState-&gt;startThreadPool 开线程池（新开了一个线程），最后调用 IPCThreadState-&gt;joinThreadPool 将当前进程加入到线程池中（开始阻塞等待了）。</p>
<h2 id="进程对象和线程对象">进程对象和线程对象</h2>
<p>new Service 对象不说了，不同的服务逻辑不一样的。先来看 ProcessState。这个东西前面通信篇介绍过的，一个进程就一个对象，怎么保证的呢，来看它的典型调用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Static.cpp =====================================</span></div><div class="line"></div><div class="line"><span class="comment">// 原来整了一个静态变量噻</span></div><div class="line">Mutex gProcessMutex;</div><div class="line">sp&lt;ProcessState&gt; gProcess;</div><div class="line"></div><div class="line"><span class="comment">// ProcessState.h =================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> ProcessState : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 这个也是一个静态函数</span></div><div class="line">    <span class="keyword">static</span>  sp&lt;ProcessState&gt;    self();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// ProcessState.cpp ================================</span></div><div class="line"></div><div class="line">sp&lt;ProcessState&gt; ProcessState::self()</div><div class="line">{</div><div class="line">    Mutex::Autolock _l(gProcessMutex);</div><div class="line">    <span class="keyword">if</span> (gProcess != NULL) {</div><div class="line">        <span class="keyword">return</span> gProcess;        </div><div class="line">    }</div><div class="line">    gProcess = <span class="keyword">new</span> ProcessState;</div><div class="line">    <span class="keyword">return</span> gProcess;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>就是搞了一个静态变量，然后一个进程只会创建一次，之后就直接返回这个静态变量就行了，借此来保证一个进程就只有一个 ProcessState 对象，怪不得叫 ProcessState。然后 self() 是静态的，而且无参数，所以进程任何地方任何时候都能够使用。</p>
<p>既然说到了 ProcessState 的 self()，我们顺带也来看下 IPCThreadState 的 self()。看名字这个应该就是一个线程有一个这样对象的了。这个是怎么实现的咧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IPCThreadState.h ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> IPCThreadState</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span>  IPCThreadState*     self();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IPCThreadState.cpp ==============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gHaveTLS = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">static</span> pthread_key_t gTLS = <span class="number">0</span>; </div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gShutdown = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gDisableBackgroundScheduling = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">IPCThreadState* IPCThreadState::self()</div><div class="line">{</div><div class="line">    <span class="comment">// 首先得确保 pthread_key 创建了</span></div><div class="line">    <span class="keyword">if</span> (gHaveTLS) {</div><div class="line">restart:</div><div class="line">        <span class="keyword">const</span> pthread_key_t k = gTLS;</div><div class="line">        <span class="comment">// 如果之前设置了线程私有变量，取线程私有变量返回</span></div><div class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</div><div class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</div><div class="line">        <span class="comment">// 否则 new 一个新对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 如果线程已经退出了，就直接返回 NULL 了</span></div><div class="line">    <span class="keyword">if</span> (gShutdown) <span class="keyword">return</span> NULL;</div><div class="line">    </div><div class="line">    <span class="comment">// pthread_key 没创建的话，先创建 pthread_key</span></div><div class="line">    pthread_mutex_lock(&gTLSMutex);</div><div class="line">    <span class="keyword">if</span> (!gHaveTLS) {</div><div class="line">        <span class="keyword">if</span> (pthread_key_create(&gTLS, threadDestructor) != <span class="number">0</span>) { </div><div class="line">            pthread_mutex_unlock(&gTLSMutex);</div><div class="line">            <span class="keyword">return</span> NULL;</div><div class="line">        }    </div><div class="line">        gHaveTLS = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    pthread_mutex_unlock(&gTLSMutex);</div><div class="line">    <span class="comment">// 回去取线程私有变量</span></div><div class="line">    <span class="keyword">goto</span> restart;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>IPCThreadState 的 self() 稍微复杂点，因为一个进程有多个线程，要保证一个线程一个对象，这个时候就有利用 linux pthread 的线程私有变量，这个东西可以给每一个 pthread 线程（android 使用 linux 的 pthread 作为多线程的支持）创建一个线程独立的私有变量，这个变量是线程私有的，不用考虑多线程的互斥、锁问题。利用这个特性就很容易显示一个线程一个对象了，把 IPCThreadState 对象保存为 pthread 的线程私有变量就行了，用得的时候就去取线程私有变量，每个线程都是自己的。有了这些知识，上面的代码就不难理解了，就是开始看有没有设置线程私有变量（取之前得先创建 phtread_key，这方面的用法可以去看《UNIX环境高级编程》这本书），有的话直接去线程私有变量就行了，没有的话就 new 一个 IPCThreadState 出来。但是是在哪设置线程私有变量的咧，我们来看看 IPCThreadState 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IPCThreadState::IPCThreadState()</div><div class="line">    : mProcess(ProcessState::self()),</div><div class="line">      mMyThreadId(androidGetTid()),</div><div class="line">      mStrictModePolicy(<span class="number">0</span>),</div><div class="line">      mLastTransactionBinderFlags(<span class="number">0</span>) </div><div class="line">{</div><div class="line">    <span class="comment">// 就是这里把自己的对象设置为线程私有变量啦</span></div><div class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</div><div class="line">    clearCaller();</div><div class="line">    mIn.setDataCapacity(<span class="number">256</span>);</div><div class="line">    mOut.setDataCapacity(<span class="number">256</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>第一句就是设置。然后我们回去看下 <code>pthread_key_create</code> 第二参数 threadDestructor，这是一个函数指针，是说线程退出的话，就调用这个函数，我们看看里面做了什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::threadDestructor(<span class="keyword">void</span> *st)</div><div class="line">{</div><div class="line">        IPCThreadState* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;IPCThreadState*&gt;(st);</div><div class="line">        <span class="keyword">if</span> (self) {</div><div class="line">                self-&gt;flushCommands();</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_ANDROID_OS)</span></div><div class="line">        <span class="keyword">if</span> (self-&gt;mProcess-&gt;mDriverFD &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 向 binder 发送线程退出的命令</span></div><div class="line">            ioctl(self-&gt;mProcess-&gt;mDriverFD, BINDER_THREAD_EXIT, <span class="number">0</span>);</div><div class="line">        }   </div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span>      </span></div><div class="line">                <span class="keyword">delete</span> self;</div><div class="line">        }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个退出函数调用 ioctl 对 binder 驱动发送了一条 <code>BINDER_THREAD_EXIT</code> 退出的消息。这个消息后面再说，不过到最后你会发现这个函数其实暂时没用的。</p>
<p>现在我们知道了在进程任何地方调用 ProcessState::self() 就能取到本进程的进程对象，并且可以调用一些 binder 进程相关的接口，在进程任何地方调用 IPCThreadState::self() 就能取得当前线程的对象，并且可以调用一些 binder 线程相关的接口。</p>
<h2 id="多线程接口实现-上">多线程接口实现.上</h2>
<p>其实前面调用的接口就2个：ProcessState 的 startThreadPool 和 IPCThreadState 的 joinThreadPool。我们先来看 startThreadPool：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ProcessState::startThreadPool()</div><div class="line">{</div><div class="line">    AutoMutex _l(mLock);</div><div class="line">    <span class="comment">// 看样子这个判断，startThreadPool 的调用只会有效一次</span></div><div class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) {</div><div class="line">        mThreadPoolStarted = <span class="keyword">true</span>;     </div><div class="line">        spawnPooledThread(<span class="keyword">true</span>);       </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后看下 spawnPooledThread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面传递过来的 isMain 是 true</span></div><div class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mThreadPoolStarted) {</div><div class="line">        String8 name = makeBinderThreadName(); </div><div class="line">        ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, name.<span class="built_in">string</span>());</div><div class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</div><div class="line">        t-&gt;run(name.<span class="built_in">string</span>());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数很简单，主要是 new 了一个 PoolThread 对象，然后调用了它的 run 方法。这里就先要暂停一下，插说下 android 线程的东西。</p>
<h2 id="android_中的线程">android 中的线程</h2>
<p>android 中的线程到底是啥东西。这里先说下答案：就是 pthread，native 层的从代码可以看得出，java 层的虽然是虚拟机实现的，但是应该还是用 pthread 实现的（我猜的，没去看代码）。这里就看下 natvie 的就行了。</p>
<p>首先之前在 ProcessState 中 new 的 PoolThread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> PoolThread : <span class="keyword">public</span> Thread</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PoolThread(<span class="keyword">bool</span> isMain)</div><div class="line">        : mIsMain(isMain)</div><div class="line">    {</div><div class="line">    }</div><div class="line">       </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> threadLoop()</div><div class="line">    {</div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>PoolThread 很简单，它继承自 libutils 里面的 Thread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Thread : <span class="keyword">virtual</span> <span class="keyword">public</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Create a Thread object, but doesn't create or start the associated</span></div><div class="line">    <span class="comment">// thread. See the run() method.</span></div><div class="line">                        Thread(<span class="keyword">bool</span> canCallJava = <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">virtual</span>             ~Thread();</div><div class="line"></div><div class="line">    <span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></div><div class="line">    <span class="keyword">virtual</span> status_t    run(    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="number">0</span>,</div><div class="line">                                int32_t priority = PRIORITY_DEFAULT,</div><div class="line">                                size_t <span class="built_in">stack</span> = <span class="number">0</span>); </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></div><div class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></div><div class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></div><div class="line">    <span class="comment">//          requestExit() wasn't called.</span></div><div class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span>        threadLoop() = <span class="number">0</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>



<p>这个就算是基类了（父类都是我讨厌的那个引用计数的玩意了）。这类就封装了 android 线程的实现。有2个重要的函数，看注释。一个是 run，看注释说 new 了 Thread 对象后，线程并没有执行，要调用 run 才会跑的。第二是 threadLoop，子类要重载这个函数，就是线程真正的执行函数（回调），如果返回 false，调用一次线程就会结束，如果返回 true，这个函数会循环调用执行。我们看到 PoolThread 重载了 threadLoop 这个函数，在里面调用了 IPCThread 的 joinThreadPool，然后返回 false。</p>
<p>我们一个一个看，首先看下 Thread 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread::Thread(<span class="keyword">bool</span> canCallJava)</div><div class="line">    :   mCanCallJava(canCallJava),</div><div class="line">        mThread(thread_id_t(-<span class="number">1</span>)),</div><div class="line">        mLock(<span class="string">"Thread::mLock"</span>),</div><div class="line">        mStatus(NO_ERROR),</div><div class="line">        mExitPending(<span class="keyword">false</span>), mRunning(<span class="keyword">false</span>)</div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS</span></div><div class="line">        , mTid(-<span class="number">1</span>)</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">Thread::~Thread()</div><div class="line">{</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>构造函数挺简单，我们这里关心的是 mCanCallJava 这个 bool 值，默认是 true，这个值表示在 native 的线程能不能调用虚拟机 java 的环境（例如利用个反射，调用一些 java 层的函数等等）。然后我们看 run：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">status_t Thread::run(<span class="keyword">const</span> <span class="keyword">char</span>* name, int32_t priority, size_t <span class="built_in">stack</span>)</div><div class="line">{</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    </div><div class="line">    <span class="comment">// 正在运行的，不允许再执行</span></div><div class="line">    <span class="keyword">if</span> (mRunning) {</div><div class="line">        <span class="comment">// thread already started</span></div><div class="line">        <span class="keyword">return</span> INVALID_OPERATION;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// reset status and exitPending to their default value, so we can</span></div><div class="line">    <span class="comment">// try again after an error happened (either below, or in readyToRun())</span></div><div class="line">    mStatus = NO_ERROR;</div><div class="line">    mExitPending = <span class="keyword">false</span>;</div><div class="line">    mThread = thread_id_t(-<span class="number">1</span>);</div><div class="line">        </div><div class="line">    <span class="comment">// hold a strong reference on ourself</span></div><div class="line">    mHoldSelf = <span class="keyword">this</span>;</div><div class="line">    </div><div class="line">    mRunning = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 这里，前面说了默认是 true，就是走上面那个分支</span></div><div class="line">    <span class="keyword">bool</span> res;</div><div class="line">    <span class="keyword">if</span> (mCanCallJava) {</div><div class="line">        res = createThreadEtc(_threadLoop,</div><div class="line">                <span class="keyword">this</span>, name, priority, <span class="built_in">stack</span>, &mThread);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        res = androidCreateRawThreadEtc(_threadLoop,</div><div class="line">                <span class="keyword">this</span>, name, priority, <span class="built_in">stack</span>, &mThread);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (res == <span class="keyword">false</span>) {</div><div class="line">        mStatus = UNKNOWN_ERROR;   <span class="comment">// something happened!</span></div><div class="line">        mRunning = <span class="keyword">false</span>;</div><div class="line">        mThread = thread_id_t(-<span class="number">1</span>);</div><div class="line">        mHoldSelf.clear();  <span class="comment">// "this" may have gone away after this.</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Do not refer to mStatus here: The thread is already running (may, in fact</span></div><div class="line">    <span class="comment">// already have exited with a valid mStatus result). The NO_ERROR indication</span></div><div class="line">    <span class="comment">// here merely indicates successfully starting the thread and does not</span></div><div class="line">    <span class="comment">// imply successful termination/execution.</span></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    <span class="comment">// Exiting scope of mLock is a memory barrier and allows new thread to run</span></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数其实最关键就是 mCanCallJava 这里的这个2个分支，这才是创建线程的地方。mCanCallJava 前面说了默认是 true，就是说一般是走前面那个分支的，但是这里我们先说下面那个分支（至于原因后面你就知道了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entryFunction 是线程执行函数指针</span></div><div class="line"><span class="keyword">int</span> androidCreateRawThreadEtc(android_thread_func_t entryFunction,</div><div class="line">                               <span class="keyword">void</span> *userData,                </div><div class="line">                               <span class="keyword">const</span> <span class="keyword">char</span>* threadName,        </div><div class="line">                               int32_t threadPriority,        </div><div class="line">                               size_t threadStackSize,        </div><div class="line">                               android_thread_id_t *threadId) </div><div class="line">{</div><div class="line">    <span class="comment">// 呵呵，是 pthread 的调用了吧</span></div><div class="line">    pthread_attr_t attr;</div><div class="line">    pthread_attr_init(&attr);</div><div class="line">    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS  /* valgrind is rejecting RT-priority create reqs */</span></div><div class="line">    <span class="keyword">if</span> (threadPriority != PRIORITY_DEFAULT || threadName != NULL) {</div><div class="line">        <span class="comment">// Now that the pthread_t has a method to find the associated</span></div><div class="line">        <span class="comment">// android_thread_id_t (pid) from pthread_t, it would be possible to avoid</span></div><div class="line">        <span class="comment">// this trampoline in some cases as the parent could set the properties</span></div><div class="line">        <span class="comment">// for the child.  However, there would be a race condition because the</span></div><div class="line">        <span class="comment">// child becomes ready immediately, and it doesn't work for the name.</span></div><div class="line">        <span class="comment">// prctl(PR_SET_NAME) only works for self; prctl(PR_SET_THREAD_NAME) was</span></div><div class="line">        <span class="comment">// proposed but not yet accepted.</span></div><div class="line">        thread_data_t* t = <span class="keyword">new</span> thread_data_t;</div><div class="line">        t-&gt;priority = threadPriority;  </div><div class="line">        t-&gt;threadName = threadName ? strdup(threadName) : NULL;</div><div class="line">        t-&gt;entryFunction = entryFunction;</div><div class="line">        t-&gt;userData = userData;        </div><div class="line">        entryFunction = (android_thread_func_t)&thread_data_t::trampoline;</div><div class="line">        userData = t;                  </div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (threadStackSize) {</div><div class="line">        pthread_attr_setstacksize(&attr, threadStackSize);</div><div class="line">    }</div><div class="line">    </div><div class="line">    errno = <span class="number">0</span>;</div><div class="line">    pthread_t thread;</div><div class="line">    <span class="keyword">int</span> result = pthread_create(&thread, &attr, </div><div class="line">                    (android_pthread_entry)entryFunction, userData);</div><div class="line">    pthread_attr_destroy(&attr);</div><div class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) {</div><div class="line">        ALOGE(<span class="string">"androidCreateRawThreadEtc failed (entry=%p, res=%d, errno=%d)\n"</span></div><div class="line">             <span class="string">"(android threadPriority=%d)"</span>, </div><div class="line">            entryFunction, result, errno, threadPriority);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Note that *threadID is directly available to the parent only, as it is</span></div><div class="line">    <span class="comment">// assigned after the child starts.  Use memory barrier / lock if the child</span></div><div class="line">    <span class="comment">// or other threads also need access.</span></div><div class="line">    <span class="keyword">if</span> (threadId != NULL) {</div><div class="line">        *threadId = (android_thread_id_t)thread; <span class="comment">// XXX: this is not portable</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面也好说了对 phread 的接口不太清楚的去看《UNIX高级环境编程》。这里简单说下，传了线程执行函数、线程名字、优先级、线程堆栈、用户自定义数据进来，然后那个 threadId 是个输出参数，返回的是线程的 id 号（tid，类似 pid）。函数返回后，<code>pthread_create</code> 就会创建线程，并且执行 entryFunction。这里传过来的 entryFunction 是 <code>_threadLoop</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Thread::_threadLoop(<span class="keyword">void</span>* user)</div><div class="line">{</div><div class="line">    Thread* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;Thread*&gt;(user);</div><div class="line"></div><div class="line">    sp&lt;Thread&gt; strong(self-&gt;mHoldSelf);</div><div class="line">    wp&lt;Thread&gt; weak(strong);</div><div class="line">    self-&gt;mHoldSelf.clear();</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS</span></div><div class="line">    <span class="comment">// this is very useful for debugging with gdb</span></div><div class="line">    self-&gt;mTid = gettid();</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">    <span class="keyword">bool</span> first = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        <span class="comment">// 还是调用 threadLoop 的</span></div><div class="line">        <span class="keyword">bool</span> result;</div><div class="line">        <span class="keyword">if</span> (first) {</div><div class="line">            first = <span class="keyword">false</span>;</div><div class="line">            self-&gt;mStatus = self-&gt;readyToRun();</div><div class="line">            result = (self-&gt;mStatus == NO_ERROR); </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (result && !self-&gt;exitPending()) {</div><div class="line">                <span class="comment">// Binder threads (and maybe others) rely on threadLoop</span></div><div class="line">                <span class="comment">// running at least once after a successful ::readyToRun()</span></div><div class="line">                <span class="comment">// (unless, of course, the thread has already been asked to exit</span></div><div class="line">                <span class="comment">// at that point).             </span></div><div class="line">                <span class="comment">// This is because threads are essentially used like this:</span></div><div class="line">                <span class="comment">//   (new ThreadSubclass())-&gt;run();</span></div><div class="line">                <span class="comment">// The caller therefore does not retain a strong reference to</span></div><div class="line">                <span class="comment">// the thread and the thread would simply disappear after the</span></div><div class="line">                <span class="comment">// successful ::readyToRun() call instead of entering the</span></div><div class="line">                <span class="comment">// threadLoop at least once.</span></div><div class="line">                result = self-&gt;threadLoop();</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            result = self-&gt;threadLoop();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 知道前面的注释为什么说返回 false 只会执行一次了</span></div><div class="line">        <span class="comment">// establish a scope for mLock</span></div><div class="line">        {</div><div class="line">        Mutex::Autolock _l(self-&gt;mLock);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">false</span> || self-&gt;mExitPending) {</div><div class="line">            self-&gt;mExitPending = <span class="keyword">true</span>;</div><div class="line">            self-&gt;mRunning = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// clear thread ID so that requestExitAndWait() does not exit if</span></div><div class="line">            <span class="comment">// called by a new thread using the same thread ID as this one.</span></div><div class="line">            self-&gt;mThread = thread_id_t(-<span class="number">1</span>);</div><div class="line">            <span class="comment">// note that interested observers blocked in requestExitAndWait are</span></div><div class="line">            <span class="comment">// awoken by broadcast, but blocked on mLock until break exits scope</span></div><div class="line">            self-&gt;mThreadExitedCondition.broadcast();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Release our strong reference, to let a chance to the thread</span></div><div class="line">        <span class="comment">// to die a peaceful death.</span></div><div class="line">        strong.clear();</div><div class="line">        <span class="comment">// And immediately, re-acquire a strong reference for the next loop</span></div><div class="line">        strong = weak.promote();</div><div class="line">    } <span class="keyword">while</span>(strong != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>线程函数，一旦执行完，线程就会退出。这里的 <code>_threadLoop</code> 里面是一个循环，取决于 threadLoop 这个的返回值（怪不得叫 loop）。所以 Thread 的子类只要重载 threadLoop 然后根据自己的需要返回合适值就不用管线程的创建、运行之类的了。</p>
<p>然后我们回去看看 mCanCallJava 那个分支上的那个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AndroidThreads.h ==============================</span></div><div class="line"></div><div class="line"><span class="comment">// inline 又挂马甲</span></div><div class="line"><span class="comment">// Create thread with lots of parameters</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> createThreadEtc(thread_func_t entryFunction,</div><div class="line">                            <span class="keyword">void</span> *userData,</div><div class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* threadName = <span class="string">"android:unnamed_thread"</span>,</div><div class="line">                            int32_t threadPriority = PRIORITY_DEFAULT,</div><div class="line">                            size_t threadStackSize = <span class="number">0</span>,</div><div class="line">                            thread_id_t *threadId = <span class="number">0</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> androidCreateThreadEtc(entryFunction, userData, threadName,</div><div class="line">        threadPriority, threadStackSize, threadId) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Threads.cpp ==============================</span></div><div class="line"></div><div class="line"><span class="comment">// 这个函数指针一开始指向的就是 mCanCallJava == false 那个分支的那个函数</span></div><div class="line"><span class="keyword">static</span> android_create_thread_fn gCreateThreadFn = androidCreateRawThreadEtc;</div><div class="line"></div><div class="line"><span class="keyword">int</span> androidCreateThreadEtc(android_thread_func_t entryFunction,</div><div class="line">                            <span class="keyword">void</span> *userData,</div><div class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* threadName,</div><div class="line">                            int32_t threadPriority,</div><div class="line">                            size_t threadStackSize,</div><div class="line">                            android_thread_id_t *threadId)</div><div class="line">{</div><div class="line">    <span class="comment">// 是调用上面那个函数指针说指向的函数</span></div><div class="line">    <span class="keyword">return</span> gCreateThreadFn(entryFunction, userData, threadName,</div><div class="line">        threadPriority, threadStackSize, threadId);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 有接口设置的哦</span></div><div class="line"><span class="keyword">void</span> androidSetCreateThreadFunc(android_create_thread_fn func)</div><div class="line">{</div><div class="line">    gCreateThreadFn = func; </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个分支，按照代码写的最开始和 mCanCallJava == false 是一样的。但是注意，Threads 有个接口可以设置这个函数指针的。我搜了一下代码，发现有一个地方设置了这个函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Register android native functions with the VM.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env) </div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This hook causes all future threads created in this process to be</span></div><div class="line"><span class="comment">     * attached to the JavaVM.  (This needs to go away in favor of JNI</span></div><div class="line"><span class="comment">     * Attach calls.)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</div><div class="line"></div><div class="line">    ALOGV(<span class="string">"--- registering native functions ---\n"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Every "register" function calls one or more things that return</span></div><div class="line"><span class="comment">     * a local reference (e.g. FindClass).  Because we haven't really</span></div><div class="line"><span class="comment">     * started the VM yet, they're all getting stored in the base frame</span></div><div class="line"><span class="comment">     * and never released.  Use Push/Pop to manage the storage.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) { </div><div class="line">        env-&gt;PopLocalFrame(NULL);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line">    env-&gt;PopLocalFrame(NULL);</div><div class="line"></div><div class="line">    <span class="comment">//createJavaThread("fubar", quickTest, (void*) "hello");</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个是 AndroidRuntime.cpp 里面注册 jni 函数的时候设置的。这个前面说 SystemService 好像有说过启 Zygote 会调用这个东西。反正就是初始化 java 虚拟机的时候设置了，看注释是为能让在 natvie 的线程中调用 java 中的东西。设置的函数是 javaCreateThreadEtc:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This is invoked from androidCreateThreadEtc() via the callback</span></div><div class="line"><span class="comment"> * set with androidSetCreateThreadFunc().</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We need to create the new thread in such a way that it gets hooked</span></div><div class="line"><span class="comment"> * into the VM before it really starts executing.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::javaCreateThreadEtc(</div><div class="line">                                android_thread_func_t entryFunction,</div><div class="line">                                <span class="keyword">void</span>* userData,                </div><div class="line">                                <span class="keyword">const</span> <span class="keyword">char</span>* threadName,        </div><div class="line">                                int32_t threadPriority,        </div><div class="line">                                size_t threadStackSize,        </div><div class="line">                                android_thread_id_t* threadId) </div><div class="line">{</div><div class="line">    <span class="keyword">void</span>** args = (<span class="keyword">void</span>**) <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));   <span class="comment">// javaThreadShell must free</span></div><div class="line">    <span class="keyword">int</span> result;</div><div class="line"></div><div class="line">    assert(threadName != NULL);</div><div class="line"></div><div class="line">    <span class="comment">// 真正的线程执行函数</span></div><div class="line">    args[<span class="number">0</span>] = (<span class="keyword">void</span>*) entryFunction;</div><div class="line">    <span class="comment">// 用户自定义数据</span></div><div class="line">    args[<span class="number">1</span>] = userData;</div><div class="line">    <span class="comment">// 线程名字</span></div><div class="line">    args[<span class="number">2</span>] = (<span class="keyword">void</span>*) strdup(threadName);   <span class="comment">// javaThreadShell must free</span></div><div class="line"></div><div class="line">    <span class="comment">// 知道前面为什么先说这个函数了吧，最后还是调用同一个</span></div><div class="line">    result = androidCreateRawThreadEtc(AndroidRuntime::javaThreadShell, args,</div><div class="line">        threadName, threadPriority, threadStackSize, threadId);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>知道前面为什么先说 androidCreateRawThreadEtc 了不，其中最终还是调用同一个，所以之后都是 pthread 的调用。但是执行函数不一样，这里的是 javaThreadShell：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * When starting a native thread that will be visible from the VM, we</span></div><div class="line"><span class="comment"> * bounce through this to get the right attach/detach action.</span></div><div class="line"><span class="comment"> * Note that this function calls free(args)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::javaThreadShell(<span class="keyword">void</span>* args) {</div><div class="line">    <span class="keyword">void</span>* start = ((<span class="keyword">void</span>**)args)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">void</span>* userData = ((<span class="keyword">void</span> **)args)[<span class="number">1</span>];</div><div class="line">    <span class="keyword">char</span>* name = (<span class="keyword">char</span>*) ((<span class="keyword">void</span> **)args)[<span class="number">2</span>];        <span class="comment">// we own this storage</span></div><div class="line">    <span class="built_in">free</span>(args);</div><div class="line">    JNIEnv* env;</div><div class="line">    <span class="keyword">int</span> result;</div><div class="line"></div><div class="line">    <span class="comment">// 就是多了一个 java attach</span></div><div class="line">    <span class="comment">/* hook us into the VM */</span></div><div class="line">    <span class="keyword">if</span> (javaAttachThread(name, &env) != JNI_OK)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* start the thread running */</span></div><div class="line">    result = (*(android_thread_func_t)start)(userData);</div><div class="line"></div><div class="line">    <span class="comment">// 和 unattach 吧</span></div><div class="line">    <span class="comment">/* unhook us */</span></div><div class="line">    javaDetachThread();</div><div class="line">    <span class="built_in">free</span>(name);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就多了一个 attach 到 JVM 中。这里不多分析这个，因为这篇不是主要说 JVM 的，反正这么整一下之后，natvie 的线程对 JVM 可见，native 的线程也可以调用 java 的东西。</p>
<h2 id="多线程接口实现-下">多线程接口实现.下</h2>
<p>简单的说了下 android 的线程后，回来继续到 ProcessState 中。前面说了 spawnPooledThread 那里 new 了一个 PoolThread 出来，然后跑 run，之后就会执行 PoolThread 的 threadLoop：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">virtual</span> <span class="keyword">bool</span> threadLoop()</div><div class="line">{</div><div class="line">    IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>调用的正好是我们下面要说的 IPCThreadState 的 joinThreadPool。这里 mIsMain，PorcessState startThreadPool 转过来的是 true。然后 threadLoop 返回的是 false。就是说这个函数只会执行一次，但是 binder 的 Bn 端不是应该循环等待 Bp 的请求么，往下看你就知道只要一次就够了。</p>
<p>前面那个模板 BinderService 最后也调用了 joinThreadPool 了，这个函数是然当前线程加入到线程池，是当前线程。所以那个模板 BinderService 是主线程加入，这里是 new PoolThread 的线程（pthread 创建的）。我来具体看下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</div><div class="line">{</div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n"</span>, (<span class="keyword">void</span>*)pthread_self(), getpid());</div><div class="line"></div><div class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line">       </div><div class="line">    <span class="comment">// This thread may have been spawned by a thread that was in the background</span></div><div class="line">    <span class="comment">// scheduling group, so first we will make sure it is in the foreground</span></div><div class="line">    <span class="comment">// one to avoid performing an initial transaction in the background.</span></div><div class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">        </div><div class="line">    status_t result;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        processPendingDerefs();        </div><div class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></div><div class="line">        result = getAndExecuteCommand();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR && result != TIMED_OUT && result != -ECONNREFUSED && result != -EBADF) {</div><div class="line">            ALOGE(<span class="string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,</div><div class="line">                  mProcess-&gt;mDriverFD, result);  </div><div class="line">            <span class="built_in">abort</span>();</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></div><div class="line">        <span class="comment">// needed and it is not the main process thread.</span></div><div class="line">        <span class="keyword">if</span>(result == TIMED_OUT && !isMain) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    } <span class="keyword">while</span> (result != -ECONNREFUSED && result != -EBADF);</div><div class="line"></div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%p\n"</span>,</div><div class="line">        (<span class="keyword">void</span>*)pthread_self(), getpid(), (<span class="keyword">void</span>*)result);</div><div class="line">       </div><div class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</div><div class="line">    talkWithDriver(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数其实之前通信模型篇里有说过。里面有个 do while 的循环（前面知道为什么那个 threadLoop 返回 false 了吧，一次就够了，一直在循环咧）。那个 isMain 的区别就是，如果 isMain 是 false， getAndExecuteCommand 如果返回是 <code>TIMED_OUT</code> 的话就会退出这个线程。然后 getAndExecuteCommand 返回 <code>TIMED_OUT</code> 的条件是 kernel binder 驱动给你返回 <code>BR_FINISHED</code>，但是目前的 binder 驱动（通信协议版本 version7）根本就没返回 <code>BR_FINISHED</code> 这个值，所以说目前这个 isMain 可以忽略不计，可以认为都是 true。 </p>
<p>getAndExecuteCommand 这些我就不说了，通信模型篇里说得比较清楚了。但是这里你会有个疑问，按照 BinderService 的写法，目前也就只有2个线程再等待 Bp 端的请求而已。如果同一个时候的 Bp 多于2个的话，不是要等待么。别急，binder 在 kernel 会自动帮你处理这种情况的。接下来我们要去 kernel 里面看看 binder 驱动的处理。</p>
<h2 id="自动创建线程">自动创建线程</h2>
<p>通信模型篇，我们知道 binder 驱动中结构体 <code>binder_proc</code> 代表一个进程，结构体 <code>binder_thread</code> 代表一个线程。我们先看看 <code>binder_proc</code> 中几个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 保存这个进程中所有线程的红黑树的根节点</span></div><div class="line">    <span class="keyword">struct</span> rb_root threads;</div><div class="line"></div><div class="line">    <span class="comment">// 运行开启的最大线程数</span></div><div class="line">    <span class="keyword">int</span> max_threads;</div><div class="line">    <span class="comment">// 请求开启的线程数</span></div><div class="line">    <span class="keyword">int</span> requested_threads;</div><div class="line">    <span class="comment">// 应请求运行的线程数</span></div><div class="line">    <span class="keyword">int</span> requested_threads_started;</div><div class="line">    <span class="comment">// 准备好的线程（空闲的线程）</span></div><div class="line">    <span class="keyword">int</span> ready_threads;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个结构在 <code>binder_open</code> 的时候会创建（binder open 的操作在 ProcessState 的构造函数那，所以一个进程只会 open 一次，所以一个进程 <code>binder_proc</code> 只会创建一次）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_open(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc; </div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">"binder_open: %d:%d\n"</span>,</div><div class="line">             current-&gt;group_leader-&gt;pid, current-&gt;pid);</div><div class="line"></div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == NULL)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;       </div><div class="line">    get_task_struct(current); </div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    INIT_LIST_HEAD(&proc-&gt;todo);</div><div class="line">    init_waitqueue_head(&proc-&gt;wait);</div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line">    mutex_lock(&binder_lock); </div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    hlist_add_head(&proc-&gt;proc_node, &binder_procs);</div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&proc-&gt;delivered_death);</div><div class="line">    filp-&gt;private_data = proc;</div><div class="line">    mutex_unlock(&binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) {</div><div class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];      </div><div class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</div><div class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">            binder_debugfs_dir_entry_proc, proc, &binder_proc_fops);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>没有显示的初始化那几个变量，不过默认都是 0。然后来看 <code>binder_thread</code> 的创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line">    <span class="comment">/*printk(KERN_INFO "binder_ioctl: %d:%d %x %lx\n", proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></div><div class="line"></div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    <span class="keyword">if</span> (thread == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_thread</code> 的创建在 <code>binder_ioctl</code> 的 <code>binder_get_thread</code> 这个函数中。只要调用 binder 的 ioctl 接口就会触发这个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 咋顺带把这个结构体也贴一下</span></div><div class="line"><span class="keyword">struct</span> binder_thread {</div><div class="line">    <span class="comment">// 这个线程所在的进程对象</span></div><div class="line">    <span class="keyword">struct</span> binder_proc *proc; </div><div class="line">    <span class="keyword">struct</span> rb_node rb_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="comment">// 线程当前运行状态</span></div><div class="line">    <span class="keyword">int</span> looper;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction_stack;</div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    uint32_t return_error; <span class="comment">/* Write failed, return error code in read buf */</span></div><div class="line">    uint32_t return_error2; <span class="comment">/* Write failed, return error code in read */</span></div><div class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></div><div class="line">        <span class="comment">/* we are also waiting on */</span>   </div><div class="line">    wait_queue_head_t wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_thread *binder_get_thread(<span class="keyword">struct</span> binder_proc *proc)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread = NULL;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL; </div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;threads.rb_node;</div><div class="line"></div><div class="line">    <span class="comment">// proc 中的 thread 按 pid 保存在 proc 的红黑树中</span></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        thread = rb_entry(parent, <span class="keyword">struct</span> binder_thread, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</div><div class="line">            p = &(*p)-&gt;rb_left;            </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</div><div class="line">            p = &(*p)-&gt;rb_right;           </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;            </div><div class="line">    }</div><div class="line">    <span class="comment">// 如果之前没创建过，就 new 一个新的出来</span></div><div class="line">    <span class="keyword">if</span> (*p == NULL) {</div><div class="line">        thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</div><div class="line">        <span class="keyword">if</span> (thread == NULL)</div><div class="line">            <span class="keyword">return</span> NULL;</div><div class="line">        binder_stats_created(BINDER_STAT_THREAD);</div><div class="line">        <span class="comment">// 设置线程所在的 proc 和 pid</span></div><div class="line">        <span class="comment">// 这里的 pid 相当于是 tid </span></div><div class="line">        thread-&gt;proc = proc;</div><div class="line">        thread-&gt;pid = current-&gt;pid;    </div><div class="line">        init_waitqueue_head(&thread-&gt;wait);</div><div class="line">        INIT_LIST_HEAD(&thread-&gt;todo);</div><div class="line">        <span class="comment">// 保存到 proc 中 </span></div><div class="line">        rb_link_node(&thread-&gt;rb_node, parent, p);</div><div class="line">        rb_insert_color(&thread-&gt;rb_node, &proc-&gt;threads);</div><div class="line">        <span class="comment">// 注意初始化状态</span></div><div class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">        thread-&gt;return_error = BR_OK;  </div><div class="line">        thread-&gt;return_error2 = BR_OK; </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> thread;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>这里要说下 current 这个全局变量。这个东西代表当前运行的线程的一些结构（其实结构应该是 <code>task_struct</code>）。具体的可以去看 linux 内核相关的书。反正用这个东西可以取得到当前运行的线程的一些信息就对了（好像是通过取堆栈最顶的东西）。</p>
<p>然后我们看下 <code>binder_thread_read</code> 这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> { </div><div class="line">    BINDER_LOOPER_STATE_REGISTERED  = <span class="number">0x01</span>,</div><div class="line">    BINDER_LOOPER_STATE_ENTERED     = <span class="number">0x02</span>,</div><div class="line">    BINDER_LOOPER_STATE_EXITED      = <span class="number">0x04</span>,</div><div class="line">    BINDER_LOOPER_STATE_INVALID     = <span class="number">0x08</span>,</div><div class="line">    BINDER_LOOPER_STATE_WAITING     = <span class="number">0x10</span>,</div><div class="line">    BINDER_LOOPER_STATE_NEED_RETURN = <span class="number">0x20</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Bn 会阻塞等待在这等待 Bp 的请求的到来</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                  <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</div><div class="line">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">    }</div><div class="line"></div><div class="line">retry:</div><div class="line">    <span class="comment">// transaction_stack == NULL 代表是第一次的 read（Bn 的阻塞read就是）</span></div><div class="line">    <span class="comment">// Bn 的阻塞等待的 read todo list 也是空的</span></div><div class="line">    <span class="comment">// 所以 Bn 的阻塞 read 这里的 wait_for_proc_work 是 true</span></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == NULL &&</div><div class="line">                list_empty(&thread-&gt;todo);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (thread-&gt;return_error != BR_OK && ptr &lt; end) {</div><div class="line">        <span class="keyword">if</span> (thread-&gt;return_error2 != BR_OK) {</div><div class="line">            <span class="keyword">if</span> (put_user(thread-&gt;return_error2, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="keyword">if</span> (ptr == end)</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            thread-&gt;return_error2 = BR_OK;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (put_user(thread-&gt;return_error, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        thread-&gt;return_error = BR_OK;</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 前面说了这个 looper 是当前线程的状态，</span></div><div class="line">    <span class="comment">// 注意这里设置为 WAITING 了，表示正在等待</span></div><div class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</div><div class="line">    <span class="comment">// Bn read 这里是 true，表示本进程空闲的进程数加1</span></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads++;</div><div class="line">    mutex_unlock(&binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) {</div><div class="line">        <span class="comment">// 这里检测 thread 是不是有下面这2个标志，这2个标志后面会说到。</span></div><div class="line">        <span class="comment">// 还有注意前面设置那个 WAITTING 的是用 | 设置的，然后这里检测是用 &</span></div><div class="line">        <span class="comment">// 然后看看这几个标志定义的值，会发现这里微妙的用法</span></div><div class="line">        <span class="keyword">if</span> (!(thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">                    BINDER_LOOPER_STATE_ENTERED))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></div><div class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></div><div class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</div><div class="line">            wait_event_interruptible(binder_user_error_wait,</div><div class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">        }</div><div class="line">        binder_set_nice(proc-&gt;default_priority);</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            <span class="comment">// 这里就阻塞在这里，等 thread 的 todo list 不为空（Bp 请求）</span></div><div class="line">            ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</div><div class="line">    }</div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    <span class="comment">// 如果这个等待的线程被唤醒了（有 Bp 请求来了），</span></div><div class="line">    <span class="comment">// 把这个进程空闲的线程数减1，</span></div><div class="line">    <span class="comment">// 因为这个线程后面马上就要到用户空间去执行相关业务的函数了。</span></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads--;</div><div class="line">    <span class="comment">// 把线程的 WAITTING 标志去掉</span></div><div class="line">    thread-&gt;looper &= ~BINDER_LOOPER_STATE_WAITING;</div><div class="line"></div><div class="line">    <span class="comment">// wait 出错的话，返回错误值</span></div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">done:</div><div class="line"></div><div class="line">    *consumed = ptr - buffer;</div><div class="line">    <span class="comment">// 最后这里 requested_threads 表示发出请求要启动的线程数，</span></div><div class="line">    <span class="comment">// ready_threads 表示空闲的线程数。</span></div><div class="line">    <span class="comment">// 如果这2个加起来 == 0 就表示当前进程（服务进程）没有空闲的线程来处理请求，</span></div><div class="line">    <span class="comment">// 并且还没请求去启动线程，所以需要启动一个新的线程来等待 Bp 的请求。</span></div><div class="line">    <span class="comment">// requested_threads_started 表示本进程应请求启动的线程数，</span></div><div class="line">    <span class="comment">// 这个不能超过 max_threads 设置的上限。</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &&</div><div class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &&</div><div class="line">        (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">         BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></div><div class="line">         <span class="comment">/*spawn a new thread if we leave this out */</span>) {</div><div class="line">        <span class="comment">// 这里发 BR_SPAWN_LOOPER 到用户去创建新线程去了</span></div><div class="line">        <span class="comment">// 然后把请求启动的线程数加1</span></div><div class="line">        proc-&gt;requested_threads++;</div><div class="line">        binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                 <span class="string">"binder: %d:%d BR_SPAWN_LOOPER\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid);</div><div class="line">        <span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 binder 驱动其实用了个很简单的办法来管理线程。就是假设 Bn 端有一个线程 wait 在 read 那了，就相当于多了一个空闲线程（能够处理 Bp 的请求）。上面分析过了，BinderService 一开始就整个2个线程 wait read 那了。然后如果来一个 Bp 请求，<code>binder_transation</code> 那里找到目标进程，然后把请求放到目标进程的 todo list 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete; </div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list; </div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 第一次 Bp 发请求给 Bn target_thread 是 null，走的是下面那个</span></div><div class="line">    <span class="keyword">if</span> (target_thread) {</div><div class="line">        e-&gt;to_thread = target_thread-&gt;pid;</div><div class="line">        target_list = &target_thread-&gt;todo;</div><div class="line">        target_wait = &target_thread-&gt;wait;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// todo list 是 target_proc 的</span></div><div class="line">        target_list = &target_proc-&gt;todo;</div><div class="line">        target_wait = &target_proc-&gt;wait;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    <span class="comment">// 把请求打包成工作（work），加入到 todo list 中</span></div><div class="line">    list_add_tail(&t-&gt;work.entry, target_list);</div><div class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    list_add_tail(&tcomplete-&gt;entry, &thread-&gt;todo);</div><div class="line">    <span class="comment">// 唤醒等待队列</span></div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_transtion</code> 就是消耗 Bn 工作线程的地方了。通信模型篇里分析过了，Bp 第一次发请求给 Bn，是没 <code>target_thread</code> 的，所以请求就加入到 <code>target_proc</code> 的 todo list 中了。然后唤醒 Bn 在 read 那休眠的线程。</p>
<p>这里说下 wait queue 的小知识，<code>binder_thread_read</code> 使用的 <code>wait_event_interruptible_exclusive</code> 第二参数是一个检测条件，这里是检测 proc 的 todo list 是否为空，这个会是不停的检测的（应该不怎么耗 cpu 吧），一旦条件为 true 就唤醒继续执行。所以 <code>binder_transation</code> 应该没那个唤醒的操作也可以，不过也还是保险一点好。</p>
<p>然后你也发现上面 wait proc 的用的是 <code>wait_event_interruptible_exclusive</code>，下面那个 wait thread 用的是 <code>wait_event_interruptible</code>。这2个有啥区别咧。我查到的是说 <code>wait_event_interruptible_exclusive</code> 在检测唤醒条件的时候是一个互斥过程，是不是说如果有多个线程 wait 的时候只检测一个线程的条件，因为之前的例子，Bn 那已经有2个线程 wait proc 那了。下面那个不带互斥，下面那个由于是 wait 本线程的，所以只会有一个线程 wait。还是说 wait queue 一次只会唤醒一个线程而已。我加的打印发现是唤醒的是最后那个等待的线程。由于比较难写 kernel 的小例子，我这里就不验证这个等待队列的用法了。反正由于种种原因这里一次就只能唤醒一个等待线程。</p>
<p>然后说下 <code>transaction_stack</code> 这个东西，看上面知道第一次 <code>transaction_stack</code> 是 NULL，也就是 Bn 等待 Bp 来请求的时候是 NULL，然后之后 Bp 通过 <code>binder_transaction</code> 把 work 加到 Bn 的 todo list， <code>transaction_stack</code> 就保存了 Bp 的 thread，然后 Bn <code>binder_thread_read</code> 之后，Bn proc 的 <code>transaction_stack</code> Bn 的 thread。然后 <code>binder_transaction</code> 一开始判断 reply == true 从 <code>transaction_stack</code> 去取 target。这么搞是为了保证， Bp 发送请求到 Bn 的线程处理后，Bn 能返回到正确的 Bp 线程，就是保证返回值能送到发送请求的那个线程处理。这个通信原理有具体分析代码，这里再点一下。这里结合后面说一个进程跑多个服务，binder 的多线程机制并不会导致混乱。 </p>
<p>那这样就差把 binder 驱动里面做的事说完了。每当一个 Bn 的线程在 <code>binder_thread_read</code> 等待，<code>proc-&gt;ready_threads</code> 就会 +1，如果 todo list 里接到请求，最后那个等待的线程被唤醒，<code>proc-&gt;ready_threads</code> -1，然后唤醒的线程去执行 IPC 请求业务函数，在最后判断是否还有空闲的线程（已经在等待的（<code>ready_threads</code>）+发送启动请求的（<code>requested_threads</code>）是否为0）。如果没有 Bn 没空闲的线程，并且已经启动的线程（<code>requested_threads_started</code>）没超过限制（<code>max_threas</code>）就发一个 <code>BR_SPAWN_LOOPER</code> 给用户空间去创建线程。</p>
<p>我们来看看用户空间怎么处理 <code>BR_SPAWN_LOOPER</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    ... ...</div><div class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</div><div class="line">        <span class="comment">// 调用的是 ProcessState 的 spawnPooledThread，参数是 false</span></div><div class="line">        mProcess-&gt;spawnPooledThread(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>; </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>结果就是 kernel 帮我们自动调用 ProcessState 的 PooledThread 而已。这里的参数是 false 了，就是说 isMain 是 false 了。这个 isMain 前面说没啥用的，不过还是有点小区别。回去看 joinThreadPool（spwanPooledThread 最后还是调用了 joinThreadPool） 那：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line"></div></pre></td></tr></table></figure>

<p>isMain 的对 binder 发的是 <code>BC_ENTER_LOOPER</code>，false 的发的是 <code>BC_REGISTER_LOOPER</code>。我去看下这2个有啥区别不：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;   </div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) { </div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        }</div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</div><div class="line">            <span class="comment">// 不允许已经 ENTER_LOOPER 的线程再 REGISTER_LOOPER</span></div><div class="line">            binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                     <span class="string">"binder: %d:%d BC_REGISTER_LOOPER\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);</div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper & BINDER_LOOPER_STATE_ENTERED) {</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></div><div class="line">                    <span class="string">"after BC_ENTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            <span class="comment">// 没发起请求的也不允许 REGISTER_LOOPER</span></div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span>) {</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></div><div class="line">                    <span class="string">"without request\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 请求线程数 -1</span></div><div class="line">                proc-&gt;requested_threads--;</div><div class="line">                <span class="comment">// 已经启动的线程数 +1</span></div><div class="line">                proc-&gt;requested_threads_started++;</div><div class="line">            }   </div><div class="line">            <span class="comment">// 设置下线程状态</span></div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</div><div class="line">            <span class="comment">// 不允许 REGISTER_LOOPER 的线程再 ENTER_LOOPER</span></div><div class="line">            binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                     <span class="string">"binder: %d:%d BC_ENTER_LOOPER\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);</div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper & BINDER_LOOPER_STATE_REGISTERED) {</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></div><div class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            }</div><div class="line">            <span class="comment">// 设置下线程状态</span></div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</div><div class="line">            <span class="comment">// 这个退出只是把状态设置了下</span></div><div class="line">            binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                     <span class="string">"binder: %d:%d BC_EXIT_LOOPER\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);</div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>isMain 的除去是否会超时自动退出外（前面说了，这个机制目前是没用的），就是上面那些判断了，isMain 是 true 是手动创建的，所以没什么限制。false 则是 binder 驱动根据当前可用线程数的情况自动请求创建的，所以确定 binder 驱动确实请求了才允许创建（requested_threads 不为 0）。还有 <code>BC_ENTER_LOOPER</code> 的是不算在 <code>requested_threads_started</code> 里面的，所以手动启动的线程理论上可以无限个（不过我看到 SS 除了一开始手动调用一次 startPoolThread，然后把当前线程 joinThreadPool 之外，就再也没手动启动过线程，都是交由驱动管理）。</p>
<p>然后说下既然有创建线程，那什么时候退出呢。前面说了超时暂时没用，joinThreadPool 那里 io 错误也会导致退出，这些异常的不算。正常目前好像没那个地方会退出，binder 启动的线程。是的，没错，目前 binder 的线程一旦启动就不会退出的，直到达到上限为止，只要 binder 一发现当前服务进程没空闲线程了就会 spawn 一个出来。但是由于服务线程一旦执行完 IPC 调用就会变成空闲的，所以只要同一个时候没很多 Bp 请求过来，不会创建太多线程的。而且就算创建了不少线程，这些线程只是休眠而已，不乎占用 cpu 资源，所以没啥太大关系，可能后续的 binder 版本会考虑一段时间这个线程没有执行请求就把这个线程退出吧。</p>
<p>然后 binder 自动创建的线程数可以设置上限的。说起这个 binder 有条命令： <code>BINDER_SET_MAX_THREADS</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// binder_thread_write:</span></div><div class="line"></div><div class="line">    <span class="comment">// 就是把进程的 max_threads 设置了一下</span></div><div class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS:</div><div class="line">        <span class="keyword">if</span> (copy_from_user(&proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) {</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>说到这个，我们来看看默认设置最大线程数是多少吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> open_driver()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR); </div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</div><div class="line">        <span class="keyword">int</span> vers;</div><div class="line">        status_t result = ioctl(fd, BINDER_VERSION, &vers);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) {</div><div class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 最大线程数为 15</span></div><div class="line">        size_t maxThreads = <span class="number">15</span>;        </div><div class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &maxThreads);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ProcessState 的构造函数会调用 <code>open_driver()</code>，binder 默认允许最大的线程数为 15 个。一般来说继承 BindService 的默认就是用这个数量了，但是也有特殊的。SurfaceFlinger（SF）没 BindService，手动写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main_surfaceflinger.cpp =============================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    <span class="comment">// 最大线程数为 4</span></div><div class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></div><div class="line">    <span class="comment">// binder threads to 4.</span></div><div class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 还有一个主线程（isMain）</span></div><div class="line">    <span class="comment">// start the thread pool</span></div><div class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">    ps-&gt;startThreadPool();</div><div class="line"></div><div class="line">    <span class="comment">// instantiate surfaceflinger</span></div><div class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_PTHREADS)</span></div><div class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</div><div class="line"></div><div class="line">    <span class="comment">// initialize before clients can connect</span></div><div class="line">    flinger-&gt;init();</div><div class="line"></div><div class="line">    <span class="comment">// publish surface flinger</span></div><div class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// run in this thread</span></div><div class="line">    flinger-&gt;run();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ProcessState.cpp ===============================</span></div><div class="line"></div><div class="line">status_t ProcessState::setThreadPoolMaxThreadCount(size_t maxThreads) {</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">    <span class="keyword">if</span> (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &maxThreads) == -<span class="number">1</span>) {</div><div class="line">        result = -errno;</div><div class="line">        ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(-result));</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>SF 就只设置了4个可以自动创建的线程，还有一个主线程（应该还有一个吧，当前那个线程跑哪去了，以后分析 SF 再说吧）。这里注意一点，如果要手动写的话，主要设置要放到 IPCThreadState-&gt;joinThreadPool 的前面，因为调用 joinThreadPool 当前线程就加入到 binder 的主线程中去了，阻塞循环就开始了，除非线程退出了，否则后面的代码执行不到的。</p>
<p>前面讨论了线程过多的情况，如果 Bn 中的线程不够的话，会怎么样咧。就是当前服务进程中没空闲的线程了（都在执行业务函数），答案是 Bp 端等待。前面不是说 proc 有 todo list 么（thread 也有的），既然是 list 就可以保存多个工作请求（work），然后一次处理一个，当没空闲线程马上处理的时候，把请求加到 todo list 后面，等线程执行完当前的业务函数，回到 <code>binder_thread_read</code> 那，准备等待的时候，发现 todo list 中不空，就马上取下一个 work 然后执行，就不会进入休眠，直到 todo list 为空。所以如果服务进程空闲线程不足，然后这个时候 Bp 请求又多的话，会导致 IPC 调用非常慢（要排队等，哥又想起排队抢火车票了）。所以要根据自身业务的情况去设置 binder 自动创建线程的上限，不要设得太小。顺带贴下线程取工作请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// binder_thread_read: </span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        uint32_t cmd; </div><div class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line">        <span class="keyword">struct</span> binder_work *w;</div><div class="line">        <span class="keyword">struct</span> binder_transaction *t = NULL;</div><div class="line"></div><div class="line">        <span class="comment">// 去 todo list 中取工作请求</span></div><div class="line">        <span class="keyword">if</span> (!list_empty(&thread-&gt;todo))</div><div class="line">            w = list_first_entry(&thread-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&proc-&gt;todo) && wait_for_proc_work)</div><div class="line">            w = list_first_entry(&proc-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> && !(thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }    </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>) </div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以那些 SS 里面很多函数都加了锁，因为有多线程的支持，可能同一个时间在执行不同客户端的业务函数。有可能 Bp1 的执行的函数是读一个变量，而 Bp2 执行的函数正好要写这个变量，这个时候需要互斥操作，所以很多操作都带锁了。但是注意不要什么操作都带锁，因为互斥锁会影响执行效率的，对于可以重入的函数不需要加锁（例如函数里面全是局部变量）。</p>
<p>还有要注意 SS 协同完成一些任务的时候的问题，例如一个 Proc A IPC 调用 Proc B 的某个函数，这个函数又跑去调用 AM 里面的某个函数，然后 AM 这个函数正好又去 IPC 调用 Proc B 中的某个函数。如果这些 IPC 函数都加了锁的话，就会死锁。关于这个例子可以去看 Binder 对象传递的普通服务篇。</p>
<h2 id="java_层的_SS">java 层的 SS</h2>
<p>前面差不多 binder 多线程的支持说完了，也看了一些 native SS 的例子。最后来看下 java 层的，也是我们应用开发中接触最多的那一票系统服务（AM、WM、PM 等）。前面说这个有点麻烦，主要是它还得启动 java 虚拟机。我们来一点点看吧，顺带把 SS 启动过程也走一下。</p>
<p>首先说了 init.rc 里有启动 zygote（不是 SS 么，怎么变成 zygote 了，别急，往下看）：</p>
<pre config="brush:bash;toolbar:false;">
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
    onrestart restart netd
</pre>

<p>注意那个 <code>--start-system-server</code> 和 <code>--zygote</code> 的参数。其实是启动 <code>app_process</code> 这个 native 程序。我们来先上一张序列图，还挺麻烦的说（因为是通过启动一个程序（zygote），然后再 fork 出另外一个（SS））：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-thread/1.png" alt=""></p>
<p>我来来看下 app_process 的 main 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app_main.cpp ================================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    AppRuntime runtime;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* argv0 = argv[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// Process command line arguments</span></div><div class="line">    <span class="comment">// ignore argv[0]</span></div><div class="line">    argc--;</div><div class="line">    argv++;</div><div class="line"></div><div class="line">    <span class="comment">// Everything up to '--' or first non '-' arg goes to the vm</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = runtime.addVmArguments(argc, argv);</div><div class="line"></div><div class="line">    <span class="comment">// init.rc 传过来的参数 --zygote 和 --start-system-server</span></div><div class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></div><div class="line">    <span class="keyword">bool</span> zygote = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">bool</span> startSystemServer = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">bool</span> application = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* parentDir = NULL;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* niceName = NULL;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* className = NULL;</div><div class="line">    <span class="keyword">while</span> (i &lt; argc) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</div><div class="line">        <span class="keyword">if</span> (!parentDir) {</div><div class="line">            parentDir = arg;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) {</div><div class="line">            zygote = <span class="keyword">true</span>;</div><div class="line">            niceName = <span class="string">"zygote"</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) {</div><div class="line">            startSystemServer = <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) {</div><div class="line">            application = <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) {</div><div class="line">            niceName = arg + <span class="number">12</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            className = arg;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (niceName && *niceName) {</div><div class="line">        setArgv0(argv0, niceName);</div><div class="line">        set_process_name(niceName);</div><div class="line">    }</div><div class="line"></div><div class="line">    runtime.mParentDir = parentDir;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (zygote) {</div><div class="line">        <span class="comment">// 那就是走这里的</span></div><div class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>,</div><div class="line">                startSystemServer ? <span class="string">"start-system-server"</span> : <span class="string">""</span>);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (className) {</div><div class="line">        <span class="comment">// Remainder of args get passed to startup class main()</span></div><div class="line">        runtime.mClassName = className;</div><div class="line">        runtime.mArgC = argc - i;</div><div class="line">        runtime.mArgV = argv + i;</div><div class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>,</div><div class="line">                application ? <span class="string">"application"</span> : <span class="string">"tool"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</div><div class="line">        app_usage();</div><div class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>init.rc 传过来的参数来看，跑去调用 AppRuntime 的 start 去了。AppRuntime 在 <code>app_main.cpp</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AppRuntime : <span class="keyword">public</span> AndroidRuntime</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    AppRuntime()</div><div class="line">        : mParentDir(NULL)</div><div class="line">        , mClassName(NULL)</div><div class="line">        , mClass(NULL)</div><div class="line">        , mArgC(<span class="number">0</span>)</div><div class="line">        , mArgV(NULL)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 注意这个函数</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> onZygoteInit()</div><div class="line">    {</div><div class="line">        <span class="comment">// Re-enable tracing now that we're no longer in Zygote.</span></div><div class="line">        atrace_set_tracing_enabled(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 这里初始化了 ProcessState，并调用了 startThreadPool</span></div><div class="line">        sp&lt;ProcessState&gt; proc = ProcessState::self();</div><div class="line">        ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</div><div class="line">        proc-&gt;startThreadPool();</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mParentDir;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mClassName;</div><div class="line">    jclass mClass;</div><div class="line">    <span class="keyword">int</span> mArgC;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* mArgV;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>



<p>AppRuntime 继承 AndroidRuntime，我们得去看父类里面的 start：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前面传过来的 className 是： com.android.internal.os.ZygoteInit</span></div><div class="line"><span class="comment">// options 是： start-system-server</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></div><div class="line"><span class="comment"> * and calling the "static void main(String[] args)" method in the class</span></div><div class="line"><span class="comment"> * named by "className".</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></div><div class="line"><span class="comment"> * options string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> <span class="keyword">char</span>* options)</div><div class="line">{</div><div class="line">    ALOGD(<span class="string">"\n&gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START %s &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</div><div class="line">            className != NULL ? className : <span class="string">"(unknown)"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">     * 'startSystemServer == true' means runtime is obsolete and not run from</span></div><div class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(options, <span class="string">"start-system-server"</span>) == <span class="number">0</span>) { </div><div class="line">        <span class="comment">/* track our progress through the boot sequence */</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</div><div class="line">        LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,</div><div class="line">                       ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</div><div class="line">    <span class="keyword">if</span> (rootDir == NULL) {</div><div class="line">        rootDir = <span class="string">"/system"</span>;  </div><div class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) {      </div><div class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /android does not exist."</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></div><div class="line">    <span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></div><div class="line"></div><div class="line">    <span class="comment">// 启动 VM，这里不管这个</span></div><div class="line">    <span class="comment">/* start the virtual machine */</span></div><div class="line">    JniInvocation jni_invocation;</div><div class="line">    jni_invocation.Init(NULL);</div><div class="line">    JNIEnv* env;</div><div class="line">    <span class="keyword">if</span> (startVm(&mJavaVM, &env) != <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 之前的子类 AppRuntime 有重载，不过这里启动 zygote 这个函数直接返回的</span></div><div class="line">    onVmCreated(env);</div><div class="line"></div><div class="line">    <span class="comment">// 这个 startReg 还记得不，前面说 android 线程的时候</span></div><div class="line">    <span class="comment">// 改变 libutils Threads 里面的线程函数指针就是在这个函数里面</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Register android functions.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) {</div><div class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></div><div class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></div><div class="line"><span class="comment">     * Create an array to hold them.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    jclass stringClass;</div><div class="line">    jobjectArray strArray;</div><div class="line">    jstring classNameStr;</div><div class="line">    jstring optionsStr;</div><div class="line"></div><div class="line">    <span class="comment">// 下面这一大串就是取 className 的 main 函数，然后执行而已</span></div><div class="line">    <span class="comment">// className 是 com.android.internal.os.ZygoteInit</span></div><div class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</div><div class="line">    assert(stringClass != NULL);</div><div class="line">    strArray = env-&gt;NewObjectArray(<span class="number">2</span>, stringClass, NULL);</div><div class="line">    assert(strArray != NULL);</div><div class="line">    classNameStr = env-&gt;NewStringUTF(className);</div><div class="line">    assert(classNameStr != NULL);</div><div class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</div><div class="line">    optionsStr = env-&gt;NewStringUTF(options);</div><div class="line">    <span class="comment">// 把 start-system-service 参数打包成 java 函数的参数</span></div><div class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">1</span>, optionsStr);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></div><div class="line"><span class="comment">     * not return until the VM exits.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</div><div class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class="line">    <span class="keyword">if</span> (startClass == NULL) {</div><div class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</div><div class="line">        <span class="comment">/* keep going */</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 取 className 的 main 函数</span></div><div class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</div><div class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</div><div class="line">        <span class="keyword">if</span> (startMeth == NULL) {</div><div class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</div><div class="line">            <span class="comment">/* keep going */</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 通过反射调用 main 函数，</span></div><div class="line">            <span class="comment">// 注意把前面的 start-system-service 当作参数传过去了</span></div><div class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</div><div class="line">                threadExitUncaughtException(env);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="built_in">free</span>(slashClassName);</div><div class="line"></div><div class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</div><div class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</div><div class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</div><div class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</div><div class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里忽略了 JVM 的启动过程（和 binder 关系不大），然后后面主要就是启动 java 层里面的东西了。这里是去执行了 com.android.internal.os.ZygoteInit 的 main 函数（下面欢迎进入 java 世界）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String argv[]) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// Start profiling the zygote initialization.</span></div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">        <span class="comment">// 打开 zygote 通信用的 socket</span></div><div class="line">        registerZygoteSocket();</div><div class="line">         <span class="comment">// Finish profiling the zygote initialization.</span></div><div class="line">        <span class="keyword">boolean</span> isFirstBooting = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//if first time booting and zygote restart need preload full class</span></div><div class="line">        <span class="keyword">if</span>(Process.myPid() &gt; <span class="number">300</span> || SystemProperties.getBoolean(PROPERTY_FIRST_TIME_BOOTING, <span class="keyword">true</span>)){</div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">            preload();</div><div class="line">            isFirstBooting = <span class="keyword">true</span>;         </div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">        }                 </div><div class="line">        <span class="comment">// Finish profiling the zygote initialization.</span></div><div class="line">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class="line"></div><div class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></div><div class="line">        gc();</div><div class="line"></div><div class="line">        <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags from</span></div><div class="line">        <span class="comment">// Zygote.</span></div><div class="line">        Trace.setTracingEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If requested, start system server directly from Zygote</span></div><div class="line">        <span class="keyword">if</span> (argv.length != <span class="number">2</span>) {        </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 那个参数传了半天终于有用了，这个函数就是去启动 SS 的进程</span></div><div class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>].equals(<span class="string">"start-system-server"</span>)) {</div><div class="line">            startSystemServer();           </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!argv[<span class="number">1</span>].equals(<span class="string">""</span>)) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</div><div class="line">        }</div><div class="line"></div><div class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</div><div class="line">        <span class="keyword">if</span>(!isFirstBooting){           </div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">            preload();</div><div class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class="line">                SystemClock.uptimeMillis());   </div><div class="line">            gc();</div><div class="line">        }</div><div class="line">        <span class="comment">// 这个就是 zygote 循环阻塞等待请求的函数了</span></div><div class="line">        runSelectLoop();</div><div class="line"></div><div class="line">        <span class="comment">// 上面那个函数退出就说明 zygote 退出了，关闭之前打开的 socket</span></div><div class="line">        closeServerSocket();</div><div class="line">    } <span class="keyword">catch</span> (MethodAndArgsCaller caller) {</div><div class="line">        caller.run();</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException ex) {</div><div class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</div><div class="line">        closeServerSocket();</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们这里主要看 startSystemServer 这个函数，其它的是 zygote 的，zygote 的话，我有一篇工作小笔记（换系统字体那个）有说到，这里不多说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Prepare the arguments and fork for the system server process.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span>()</div><div class="line">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException {</div><div class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</div><div class="line">        OsConstants.CAP_KILL,</div><div class="line">        OsConstants.CAP_NET_ADMIN,</div><div class="line">        OsConstants.CAP_NET_BIND_SERVICE,</div><div class="line">        OsConstants.CAP_NET_BROADCAST,</div><div class="line">        OsConstants.CAP_NET_RAW,</div><div class="line">        OsConstants.CAP_SYS_MODULE,</div><div class="line">        OsConstants.CAP_SYS_NICE,</div><div class="line">        OsConstants.CAP_SYS_RESOURCE,</div><div class="line">        OsConstants.CAP_SYS_TIME,</div><div class="line">        OsConstants.CAP_SYS_TTY_CONFIG</div><div class="line">    );  </div><div class="line">    <span class="comment">// 下面一堆参数，注意最下面那个类名（我们 SS 终于露面了）</span></div><div class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></div><div class="line">    String args[] = { </div><div class="line">        <span class="string">"--setuid=1000"</span>,</div><div class="line">        <span class="string">"--setgid=1000"</span>,</div><div class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007"</span>,</div><div class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</div><div class="line">        <span class="string">"--runtime-init"</span>,</div><div class="line">        <span class="string">"--nice-name=system_server"</span>,</div><div class="line">        <span class="string">"com.android.server.SystemServer"</span>,</div><div class="line">    };  </div><div class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 将上面那堆字符串参数解析成一个专门用来 zygote 通信的数据结构</span></div><div class="line">        <span class="comment">// 不过这里启动 SS 根本没和 zygote 通信，这里纯粹借用这个数据而已</span></div><div class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</div><div class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class="line"></div><div class="line">        <span class="comment">// fork SS 进程</span></div><div class="line">        <span class="comment">/* Request to fork the system server process */</span></div><div class="line">        pid = Zygote.forkSystemServer(</div><div class="line">                parsedArgs.uid, parsedArgs.gid,</div><div class="line">                parsedArgs.gids,</div><div class="line">                parsedArgs.debugFlags,</div><div class="line">                <span class="keyword">null</span>,</div><div class="line">                parsedArgs.permittedCapabilities,</div><div class="line">                parsedArgs.effectiveCapabilities);</div><div class="line">    } <span class="keyword">catch</span> (IllegalArgumentException ex) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">    }   </div><div class="line"></div><div class="line">    <span class="comment">// pid == 0 是 fork 出来的 SS 进程，要去启动 SS 服务了</span></div><div class="line">    <span class="comment">/* For child process */</span></div><div class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</div><div class="line">        handleSystemServerProcess(parsedArgs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们去看下 Zygote.forkSystemServer 这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Special method to start the system server process. In addition to the</span></div><div class="line"><span class="comment"> * common actions performed in forkAndSpecialize, the pid of the child</span></div><div class="line"><span class="comment"> * process is recorded such that the death of the child process will cause</span></div><div class="line"><span class="comment"> * zygote to exit.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param uid the UNIX uid that the new process should setuid() to after</span></div><div class="line"><span class="comment"> * fork()ing and and before spawning any threads.</span></div><div class="line"><span class="comment"> * @param gid the UNIX gid that the new process should setgid() to after</span></div><div class="line"><span class="comment"> * fork()ing and and before spawning any threads.</span></div><div class="line"><span class="comment"> * @param gids null-ok; a list of UNIX gids that the new process should</span></div><div class="line"><span class="comment"> * setgroups() to after fork and before spawning any threads.</span></div><div class="line"><span class="comment"> * @param debugFlags bit flags that enable debugging features.</span></div><div class="line"><span class="comment"> * @param rlimits null-ok an array of rlimit tuples, with the second</span></div><div class="line"><span class="comment"> * dimension having a length of 3 and representing</span></div><div class="line"><span class="comment"> * (resource, rlim_cur, rlim_max). These are set via the posix</span></div><div class="line"><span class="comment"> * setrlimit(2) call.</span></div><div class="line"><span class="comment"> * @param permittedCapabilities argument for setcap()</span></div><div class="line"><span class="comment"> * @param effectiveCapabilities argument for setcap()</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @return 0 if this is the child, pid of the child</span></div><div class="line"><span class="comment"> * if this is the parent, or -1 on error.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span>(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</div><div class="line">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities) {</div><div class="line">    preFork();</div><div class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(</div><div class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</div><div class="line">    postFork();</div><div class="line">    <span class="keyword">return</span> pid;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释这个函数专门为 SS 写的，不去深究这个函数了，最后应该 jni 调用 linux 的 fork 函数吧。SS 是 zygote 第一个 fork 出来的值进程。然后回到 startSystemService 那里，后面有 pid == 0 的，这个就表示 SS 的进程，然后进到 handleSystemServerProcess：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意前面打包的那个参数数据结构</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Finish remaining work for the newly forked system server process.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span>(</div><div class="line">        ZygoteConnection.Arguments parsedArgs)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line"></div><div class="line">    <span class="comment">// 由于 fork 继承了父进程的 socket，</span></div><div class="line">    <span class="comment">// SS 不需要这个，所以关掉</span></div><div class="line">    closeServerSocket();</div><div class="line"></div><div class="line">    <span class="comment">// set umask to 0077 so new files and directories will default to owner-only permissions.</span></div><div class="line">    Libcore.os.umask(S_IRWXG | S_IRWXO);</div><div class="line"></div><div class="line">    <span class="comment">// 这个 niceName 是上面那个 system_server</span></div><div class="line">    <span class="comment">// adb shell ps 能看得到 SS 的名字是 system_server</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) {</div><div class="line">        Process.setArgV0(parsedArgs.niceName);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 上面没设置 inovkeWith 所以走的下面那个分支</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) {</div><div class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class="line">                <span class="keyword">null</span>, parsedArgs.remainingArgs);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这个remainingArgs是最后那个 com.android.server.SystemServer</span></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Pass the remaining arguments to SystemServer.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* should never reach here */</span>  </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面看那个 nineName 设置为 <code>system_server</code>，这个在 adb shell ps 能看得到的，还能看得出 SS 确实是 zygote 的子进程（看 SS 的父进程号）：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-thread/2.png" alt=""></p>
<p>这里终于跑到 SS 进程里面去了，然后我接下去看 RuntimeInit.zygoteInit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The main function called when started through the zygote process. This</span></div><div class="line"><span class="comment"> * could be unified with main(), if the native code in nativeFinishInit()</span></div><div class="line"><span class="comment"> * were rationalized with Zygote startup.&lt;p&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Current recognized args:</span></div><div class="line"><span class="comment"> * &lt;ul&gt;</span></div><div class="line"><span class="comment"> *   &lt;li&gt; &lt;code&gt; [--] &lt;start class name&gt;  &lt;args&gt;</span></div><div class="line"><span class="comment"> * &lt;/ul&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param targetSdkVersion target SDK version</span></div><div class="line"><span class="comment"> * @param argv arg strings</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span>(<span class="keyword">int</span> targetSdkVersion, String[] argv)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 这个不管</span></div><div class="line">    redirectLogStreams();</div><div class="line"></div><div class="line">    <span class="comment">// 这个 commonInit 这里也没什么要特别注意的</span></div><div class="line">    commonInit();</div><div class="line">    <span class="comment">// 下面那个要注意下</span></div><div class="line">    nativeZygoteInit();</div><div class="line"></div><div class="line">    <span class="comment">// 启动 SS 的 java 类的在这个函数里面</span></div><div class="line">    applicationInit(targetSdkVersion, argv);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 nativeZygoteInit 在 AndroidRuntime 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> AndroidRuntime* gCurRuntime = NULL;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class="line">{</div><div class="line">    gCurRuntime-&gt;onZygoteInit();</div><div class="line">}</div><div class="line"></div><div class="line">AndroidRuntime::AndroidRuntime() :</div><div class="line">        mExitWithoutCleanup(<span class="keyword">false</span>)     </div><div class="line">{</div><div class="line">    SkGraphics::Init();</div><div class="line">    <span class="comment">// this sets our preference for 16bit images during decode</span></div><div class="line">    <span class="comment">// in case the src is opaque and 24bit</span></div><div class="line">    SkImageDecoder::SetDeviceConfig(SkBitmap::kRGB_565_Config);</div><div class="line">    <span class="comment">// This cache is shared between browser native images, and java "purgeable"</span></div><div class="line">    <span class="comment">// bitmaps. This globalpool is for images that do not either use the java</span></div><div class="line">    <span class="comment">// heap, or are not backed by ashmem. See BitmapFactory.cpp for the key</span></div><div class="line">    <span class="comment">// java call site.</span></div><div class="line">    SkImageRef_GlobalPool::SetRAMBudget(<span class="number">512</span> * <span class="number">1024</span>);</div><div class="line">    <span class="comment">// There is also a global font cache, but its budget is specified in code</span></div><div class="line">    <span class="comment">// see SkFontHost_android.cpp</span></div><div class="line"></div><div class="line">    <span class="comment">// Pre-allocate enough space to hold a fair number of options.</span></div><div class="line">    mOptions.setCapacity(<span class="number">20</span>);</div><div class="line"></div><div class="line">    <span class="comment">// gCurRuntime 每个进程一个</span></div><div class="line">    assert(gCurRuntime == NULL);        <span class="comment">// one per process</span></div><div class="line">    gCurRuntime = <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得最开始 AppRuntime 这个之类重载的 onZygoteInit 么，没错就是在这里调用了。这里初始化了 ProcessState（打开 binder 驱动，设置 binder 自动线程最大数目为 15），然后手动启动了一个主线程。</p>
<p>然后我们继续看 applicationInit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span>(<span class="keyword">int</span> targetSdkVersion, String[] argv)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></div><div class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></div><div class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></div><div class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></div><div class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></div><div class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 设置一下虚拟机的一些参数</span></div><div class="line">    <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></div><div class="line">    <span class="comment">// holding on to a lot of memory that isn't needed.</span></div><div class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75</span>f);</div><div class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Arguments args;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        args = <span class="keyword">new</span> Arguments(argv);    </div><div class="line">    } <span class="keyword">catch</span> (IllegalArgumentException ex) {</div><div class="line">        Slog.e(TAG, ex.getMessage());  </div><div class="line">        <span class="comment">// let the process exit        </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 终于快到了</span></div><div class="line">    <span class="comment">// Remaining arguments are passed to the start class's static main</span></div><div class="line">    invokeStaticMain(args.startClass, args.startArgs);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续看 invokeStaticMain（名字都叫这个份上了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invokes a static "main(argv[]) method on class "className".</span></div><div class="line"><span class="comment"> * Converts various failing exceptions into RuntimeExceptions, with</span></div><div class="line"><span class="comment"> * the assumption that they will then cause the VM instance to exit.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param className Fully-qualified class name</span></div><div class="line"><span class="comment"> * @param argv Argument vector for main()</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span>(String className, String[] argv)</div><div class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller {</div><div class="line">    Class&lt;?&gt; cl;</div><div class="line"></div><div class="line">    <span class="comment">// com.android.server.SystemServer 这个类名终于有用了</span></div><div class="line">    <span class="keyword">try</span> {                 </div><div class="line">        cl = Class.forName(className); </div><div class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</div><div class="line">                ex);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 终于去取 main 函数了</span></div><div class="line">    Method m;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] { String[].class });</div><div class="line">    } <span class="keyword">catch</span> (NoSuchMethodException ex) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Missing static main on "</span> + className, ex);</div><div class="line">    } <span class="keyword">catch</span> (SecurityException ex) { </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</div><div class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Main method is not public and static on "</span> + className);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这里搞了个花样，好像是通过抛出异常来清理调用堆栈</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></div><div class="line"><span class="comment">     * by invoking the exception's run() method. This arrangement</span></div><div class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></div><div class="line"><span class="comment">     * up the process.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数前面都没什么，关键是最后一句，抛出一个异常。看注释说这个异常在 ZygoteInit.main 中有捕获，我们回去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String argv[]) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">... ...</div><div class="line">         </div><div class="line">        } <span class="keyword">catch</span> (MethodAndArgsCaller caller) {</div><div class="line">            <span class="comment">// 在这里运行抛过来的函数</span></div><div class="line">            caller.run();</div><div class="line">        } <span class="keyword">catch</span> (RuntimeException ex) {</div><div class="line">            Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</div><div class="line">            closeServerSocket();</div><div class="line">            <span class="keyword">throw</span> ex;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>还真有捕获，然后在 catch 直接运行传递过来的 main 函数。看注释说这么做的原因是为了清除函数调用堆栈（确实从调用到 SS 的 main 函数，前面函数堆栈有好几层了）。这样能让 SS 感觉更像直接启动的吧（忽悠谁咧）。</p>
<p>然后我们终于能够去看 SS 的业务了，SS 的 main 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * In case the runtime switched since last boot (such as when</span></div><div class="line"><span class="comment">     * the old runtime was removed in an OTA), set the system</span></div><div class="line"><span class="comment">     * property so that it is in sync. We can't do this in</span></div><div class="line"><span class="comment">     * libnativehelper's JniInvocation::Init code where we already</span></div><div class="line"><span class="comment">     * had to fallback to a different runtime because it is</span></div><div class="line"><span class="comment">     * running as root and we need to be the system user to set</span></div><div class="line"><span class="comment">     * the property. http://b/11463182</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib"</span>,</div><div class="line">                         VMRuntime.getRuntime().vmLibrary());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) {</div><div class="line">        <span class="comment">// If a device's clock is before 1970 (before 0), a lot of</span></div><div class="line">        <span class="comment">// APIs crash dealing with negative numbers, notably</span></div><div class="line">        <span class="comment">// java.io.File#setLastModified, so instead we fake it and</span></div><div class="line">        <span class="comment">// hope that time from cell towers or NTP fixes it</span></div><div class="line">        <span class="comment">// shortly.</span></div><div class="line">        Slog.w(TAG, <span class="string">"System clock is before 1970; setting to 1970."</span>);</div><div class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) {</div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line">        timer = <span class="keyword">new</span> Timer();</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                SamplingProfilerIntegration.writeSnapshot(<span class="string">"system_server"</span>, <span class="keyword">null</span>);</div><div class="line">            }    </div><div class="line">        }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</div><div class="line">    }    </div><div class="line"></div><div class="line">    <span class="comment">// Mmmmmm... more memory!</span></div><div class="line">    dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();</div><div class="line"></div><div class="line">    <span class="comment">// The system server has to run all of the time, so it needs to be</span></div><div class="line">    <span class="comment">// as efficient as possible with its memory usage.</span></div><div class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8</span>f);</div><div class="line"></div><div class="line">    Environment.setUserRequired(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    System.loadLibrary(<span class="string">"android_servers"</span>);</div><div class="line"></div><div class="line">    Slog.i(TAG, <span class="string">"Entered the Android system server!"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 启动 native 服务</span></div><div class="line">    <span class="comment">// Initialize native services.</span></div><div class="line">    nativeInit();</div><div class="line"></div><div class="line">    <span class="comment">// 启动 java 层服务</span></div><div class="line">    <span class="comment">// This used to be its own separate thread, but now it is</span></div><div class="line">    <span class="comment">// just the loop we run on the main thread.</span></div><div class="line">    ServerThread thr = <span class="keyword">new</span> ServerThread();</div><div class="line">    thr.initAndLoop();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 main 其实不长（后面的在后面那个 ServerThread 里面），先是 nativeInit 启动 native 的服务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// com_android_server_SystemServer.cpp  ========================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) {</div><div class="line">    <span class="keyword">char</span> propBuf[PROPERTY_VALUE_MAX];</div><div class="line">    property_get(<span class="string">"system_init.startsensorservice"</span>, propBuf, <span class="string">"1"</span>);</div><div class="line">    <span class="comment">// 就启动了一个 SensorService </span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">"1"</span>) == <span class="number">0</span>) {</div><div class="line">        <span class="comment">// Start the sensor service</span></div><div class="line">        SensorService::instantiate();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后主要工作在 ServerThread 中。这个是 SystemServer 的内部类，看名字就很形象，服务线程啊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 这个函数巨长，有 1000 多行，我只贴一些有代表性的</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAndLoop</span>() {</div><div class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN,</div><div class="line">            SystemClock.uptimeMillis());   </div><div class="line"></div><div class="line">        <span class="comment">// 创建主线程 Looper</span></div><div class="line">        Looper.prepareMainLooper();    </div><div class="line"></div><div class="line">        android.os.Process.setThreadPriority(</div><div class="line">                android.os.Process.THREAD_PRIORITY_FOREGROUND);</div><div class="line"></div><div class="line">        BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</div><div class="line">        android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Check whether we failed to shut down last time we tried.</span></div><div class="line">        {</div><div class="line">            <span class="keyword">final</span> String shutdownAction = SystemProperties.get(</div><div class="line">                    ShutdownThread.SHUTDOWN_ACTION_PROPERTY, <span class="string">""</span>);</div><div class="line">            <span class="keyword">if</span> (shutdownAction != <span class="keyword">null</span> && shutdownAction.length() &gt; <span class="number">0</span>) { </div><div class="line">                <span class="keyword">boolean</span> reboot = (shutdownAction.charAt(<span class="number">0</span>) == <span class="string">'1'</span>);</div><div class="line"></div><div class="line">                <span class="keyword">final</span> String reason;           </div><div class="line">                <span class="keyword">if</span> (shutdownAction.length() &gt; <span class="number">1</span>) {</div><div class="line">                    reason = shutdownAction.substring(<span class="number">1</span>, shutdownAction.length());</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    reason = <span class="keyword">null</span>;                 </div><div class="line">                }</div><div class="line"></div><div class="line">                ShutdownThread.rebootOrShutdown(reboot, reason);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        String factoryTestStr = SystemProperties.get(<span class="string">"ro.factorytest"</span>);</div><div class="line">        <span class="keyword">int</span> factoryTest = <span class="string">""</span>.equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF</div><div class="line">                : Integer.parseInt(factoryTestStr);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> headless = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"ro.config.headless"</span>, <span class="string">"0"</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 看到这一票熟悉的 Manager 了没</span></div><div class="line">        <span class="comment">// 这里不是全部的，下面还有，不贴了</span></div><div class="line">        Installer installer = <span class="keyword">null</span>;</div><div class="line">        AccountManagerService accountManager = <span class="keyword">null</span>;</div><div class="line">        ContentService contentService = <span class="keyword">null</span>;</div><div class="line">        LightsService lights = <span class="keyword">null</span>;</div><div class="line">        PowerManagerService power = <span class="keyword">null</span>;</div><div class="line">        DisplayManagerService display = <span class="keyword">null</span>;</div><div class="line">        BatteryService battery = <span class="keyword">null</span>;</div><div class="line">        VibratorService vibrator = <span class="keyword">null</span>;</div><div class="line">        AlarmManagerService alarm = <span class="keyword">null</span>;</div><div class="line">        MountService mountService = <span class="keyword">null</span>;</div><div class="line">        NetworkManagementService networkManagement = <span class="keyword">null</span>;</div><div class="line">        NetworkStatsService networkStats = <span class="keyword">null</span>;</div><div class="line">        NetworkPolicyManagerService networkPolicy = <span class="keyword">null</span>;</div><div class="line">        ConnectivityService connectivity = <span class="keyword">null</span>;</div><div class="line">        EthernetService eth = <span class="keyword">null</span>;</div><div class="line">        WifiP2pService wifiP2p = <span class="keyword">null</span>;</div><div class="line">        WifiService wifi = <span class="keyword">null</span>;</div><div class="line">        NsdService serviceDiscovery= <span class="keyword">null</span>;</div><div class="line">        IPackageManager pm = <span class="keyword">null</span>;</div><div class="line">        Context context = <span class="keyword">null</span>;</div><div class="line">        WindowManagerService wm = <span class="keyword">null</span>;</div><div class="line">        BluetoothManagerService bluetooth = <span class="keyword">null</span>;</div><div class="line">        DockObserver dock = <span class="keyword">null</span>;</div><div class="line">        UsbService usb = <span class="keyword">null</span>;</div><div class="line">        SerialService serial = <span class="keyword">null</span>;</div><div class="line">        TwilightService twilight = <span class="keyword">null</span>;</div><div class="line">        UiModeManagerService uiMode = <span class="keyword">null</span>;</div><div class="line">        RecognitionManagerService recognition = <span class="keyword">null</span>;</div><div class="line">        NetworkTimeUpdateService networkTimeUpdater = <span class="keyword">null</span>;</div><div class="line">        CommonTimeManagementService commonTimeMgmtService = <span class="keyword">null</span>;</div><div class="line">        InputManagerService inputManager = <span class="keyword">null</span>;</div><div class="line">        TelephonyRegistry telephonyRegistry = <span class="keyword">null</span>;</div><div class="line">        ConsumerIrService consumerIr = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// new Service 对象，然后 add 到 SM 中，非常规范的操作</span></div><div class="line">            <span class="comment">// 这里也只贴前面几个，下面都差不多，无非有几个玩非主流</span></div><div class="line">            <span class="comment">// 后面分析到那些再说。</span></div><div class="line">            Slog.i(TAG, <span class="string">"Display Manager"</span>);</div><div class="line">            display = <span class="keyword">new</span> DisplayManagerService(context, wmHandler);</div><div class="line">            ServiceManager.addService(Context.DISPLAY_SERVICE, display, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            Slog.i(TAG, <span class="string">"Telephony Registry"</span>);</div><div class="line">            telephonyRegistry = <span class="keyword">new</span> TelephonyRegistry(context);</div><div class="line">            ServiceManager.addService(<span class="string">"telephony.registry"</span>, telephonyRegistry);</div><div class="line"></div><div class="line">            Slog.i(TAG, <span class="string">"Scheduling Policy"</span>);</div><div class="line">            ServiceManager.addService(<span class="string">"scheduling_policy"</span>, <span class="keyword">new</span> SchedulingPolicyService());</div><div class="line"></div><div class="line">            AttributeCache.init(context);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!display.waitForDefaultDisplay()) {</div><div class="line">                reportWtf(<span class="string">"Timeout waiting for default display to be initialized."</span>,</div><div class="line">                        <span class="keyword">new</span> Throwable());</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        } <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">            Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</div><div class="line">            Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting core service"</span>, e);</div><div class="line">        }</div><div class="line"></div><div class="line">... ... </div><div class="line"></div><div class="line">        <span class="comment">// 主线程 Looper 开始循环</span></div><div class="line">        Looper.loop();</div><div class="line">        Slog.d(TAG, <span class="string">"System ServerThread is exiting!"</span>);</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看 SS main 最后那里注释说，这些 SS 应该在单独的线程里面跑，但是现在暂时都在主线程中了。看 ServerThread 中代码，是都是在主线程中。SS 是一个典型的一个进程里面多个服务的例子（服务还很多，好像有十几个吧 -_-||）。DDMS 里面的截图很明显了：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-thread/3.png" alt=""><br>（pid 430 是上面 ps 看到的 SS 的）</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-thread/4.png" alt=""></p>
<p>之前还觉得 binder 默认给自动线程设置 15 个是不是有点多，现在看起来这个值是不是就是对着 SS 来设的。结合前面的讨论，15 个加上前面那个主动开的线程应该能应付大多数情况。看截图一般高峰期就 11、12 个 Bp 吧（<code>Binder_C</code>、<code>Binder_D</code>，前面说了 kernel 自动调节的线程目前一旦传了，不会退出的，所以这个最大数差不多能说明最大负载的情况吧）。然后看到这些线程的名字都是 Binder_X、这个名字是在 ProcessState 里取的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String8 ProcessState::makeBinderThreadName() {</div><div class="line">    int32_t s = android_atomic_add(<span class="number">1</span>, &mThreadPoolSeq);</div><div class="line">    String8 name;</div><div class="line">    name.appendFormat(<span class="string">"Binder_%X"</span>, s);</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这不是 isMain 的线程连名字都是大众脸（所以看到 Binder_X 的线程，就知道是 kernel binder 驱动自动调节创建出来的）。</p>
<p>然后这里再讨论一个问题，就是 SS 一个进程同时在跑多个不同的服务，那不同的线程如果能够把不同服务的 Bp 请求发送到对应的服务处理呢。刚开始我也觉得有点不好理解，但是从上一篇 binder 对象传递之后我就明白了，binder 根本不需要区分这个请求是服务进程中哪个服务的。还记得 binder 对象传递篇中，服务向 SM 注册的时候，传递过去的对象是 Bn，然后把本地对象的指针传递过去了，然后在 kernel 的 <code>binder_node</code> 中有保存这个本地指针的。所以只要能找到正确的 node （通过的 Bp 的 handle 值取 ref，再通过 ref 取 node，忘记了的回去看 binder 对象传递篇）就能取得服务的本地对象指针，然后在服务进程的线程中执行这个本地对象的方法就能执行正确的服务函数了。所以这些对于多线程，一个进程多个服务来说是透明，它们不用管这个 binder 对象是本进程内哪个服务的，只管执行它的 transation 方法就行。</p>
<h2 id="总结">总结</h2>
<p>android 真的为 IPC 做了很多事情，前面说的效率、框架封装不说，这里直接帮你把并发多线程支持给你解决了。但是还有 framework 还是有些服务不是用 binder 的（vold、zygote），唉，人多了，另起炉灶就再所难免了。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——多线程支持/" data-title="Android Binder 分析——多线程支持 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递/" title="Android Binder 分析——普通服务 Binder 对象的传递">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——普通服务 Binder 对象的传递</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——懒人的工具[AIDL]/"  title="Android Binder 分析——懒人的工具（AIDL）">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——懒人的工具（AIDL）
</span>
</a>
</div>

</nav>


	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SS_多线程的例子"><span class="toc-number">1.</span> <span class="toc-text">SS 多线程的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程对象和线程对象"><span class="toc-number">2.</span> <span class="toc-text">进程对象和线程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程接口实现-上"><span class="toc-number">3.</span> <span class="toc-text">多线程接口实现.上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android_中的线程"><span class="toc-number">4.</span> <span class="toc-text">android 中的线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程接口实现-下"><span class="toc-number">5.</span> <span class="toc-text">多线程接口实现.下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动创建线程"><span class="toc-number">6.</span> <span class="toc-text">自动创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java_层的_SS"><span class="toc-number">7.</span> <span class="toc-text">java 层的 SS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>35</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>47</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Server/" title="Server">Server<sup>1</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/android/" title="android">android<sup>82</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">我的链接</p>
    <ul>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">网站数据统计</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
      <li><i class="fa fa-book"></i> <a href="https://dongka.github.io" target="_blank">Dongka的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2021 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
