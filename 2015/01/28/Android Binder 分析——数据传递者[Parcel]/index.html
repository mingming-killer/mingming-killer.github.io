
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——数据传递者（Parcel） | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="前面 binder 原理和通信模型中在接口实现部分（Bp 和 Bn）中应该看到很多地方都有使用 parcel。这个 android 专门设计用来跨进程传递数据的，实现在 native，java 层有接口（基本上是 jni 马甲）。照例先说下源代码位置（4.4 的）：
1234567891011121">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">三月学长的小站</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——数据传递者[Parcel]/" title="Android Binder 分析——数据传递者（Parcel）" itemprop="url">Android Binder 分析——数据传递者（Parcel）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T12:41:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2017-02-07T13:47:50.000Z" itemprop="dateModified">2017 2月 7</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小型数据"><span class="toc-number">2.</span> <span class="toc-text">小型数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大型数据"><span class="toc-number">3.</span> <span class="toc-text">大型数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder_对象"><span class="toc-number">4.</span> <span class="toc-text">binder 对象</span></a></li></ol>
		</div>
		
		<p>前面 binder 原理和通信模型中在接口实现部分（Bp 和 Bn）中应该看到很多地方都有使用 parcel。这个 android 专门设计用来跨进程传递数据的，实现在 native，java 层有接口（基本上是 jni 马甲）。照例先说下源代码位置（4.4 的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java parcel （MemoryFile 是封装好的匿名共享内存的接口）</span></div><div class="line">frameworks/base/core/java/os/Parcel.java</div><div class="line">frameworks/base/core/java/os/Parcelable.java</div><div class="line">frameworks/base/core/java/os/ParcelFileDescriptor.java</div><div class="line">frameworks/base/core/java/os/MemoryFile.java</div><div class="line"></div><div class="line"><span class="comment"># parcel jni 相关</span></div><div class="line">frameworks/base/core/jni/android_os_Parcel.h</div><div class="line">frameworks/base/core/jni/android_os_MemoryFile.h</div><div class="line">frameworks/base/core/jni/android_os_Parcel.cpp</div><div class="line"></div><div class="line"><span class="comment"># native parcel 实现（Memory 相关的是封装好的匿名共享内存实现）</span></div><div class="line">frameworks/native/include/binder/Parcel.h</div><div class="line">frameworks/native/include/binder/IMemory.h</div><div class="line">frameworks/native/include/binder/MemoryHeapBase.h</div><div class="line">frameworks/native/include/binder/MemoryBase.h</div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line">frameworks/native/libs/binder/Memory.cpp</div><div class="line">frameworks/native/libs/binder/MemoryHeapBase.cpp</div><div class="line">frameworks/native/libs/binder/MemoryBase.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"><span class="comment"># kernel ahsmem 驱动</span></div><div class="line">kernel/include/linux/ashmem.h</div><div class="line">kernel/mm/ashmem.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="原理">原理</h2>
<p>在 java 层 parcel 有个接口叫 Parcelable，和 java 的 Serializable 很像，刚开始我还没搞明白这2个有什么区别（以前对 java 也不太熟）。这里简单说一下， Serializable 是 java 的接口，翻译过来是序列化的意思，就是通过实现这个接口能够让 java 的对象序列化能够永久保存在的存储介质上，然后反序列化就能从存储介质上实列化出 java 对象（通俗点，就是一个 save/load 的功能）。因为保存到了存储介质上，所以是可以跨进程的（一个进程把数据写入文件，另外一个去读）。但是为什么 android 还要搞一个 parcel 出来，是因为 java 的 Serializable 是通过存储介质的，所以速度慢。parcel 是基于内存传递的，比磁盘I/O要块，而且更加轻量级（这个我是从网上看到的，我没研究过 java 的 Serializable 代码）。</p>
<p>parcel 在内存中的结构是一块连续的内存，会动根据需要自动扩展大小（这个设计比较赞，一些对性能要求不是太高、或是小数据的地方，可以不用废脑想分配多大空间）。parcel 传递数据，可以分为3种，传递方式也不一样：</p>
<ul>
<li><strong>小型数据</strong>： 从用户空间（源进程）copy 到 kernel 空间（binder 驱动中）再写回用户空间（目标进程，binder 驱动负责寻找目标进程）。</li>
<li><strong>大型数据</strong>： 使用 android 的匿名共享内存（Ashmem）传递</li>
<li><strong>binder 对象</strong>： kernel binder 驱动专门处理</li>
</ul>
<p>下面逐一分析。这里我打算从 natvie 到 kernel 再到 java 的顺序进行，因为接着前面通信原型那里，所以从 natvie 开始会比较好，而且实现的地方也在 native。</p>
<h2 id="小型数据">小型数据</h2>
<p>先来看看 Parcel.h 中几个比较关键的几个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">uint8_t*            mData;</div><div class="line">size_t              mDataSize;</div><div class="line">size_t              mDataCapacity;</div><div class="line"><span class="keyword">mutable</span> size_t      mDataPos;</div><div class="line">size_t*             mObjects;</div><div class="line">size_t              mObjectsSize;</div><div class="line">size_t              mObjectsCapacity;</div><div class="line"><span class="keyword">mutable</span> size_t      mNextObjectHint;</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li>mData： 数据指针，也是数据在本进程空间内的内存地址</li>
<li>mDataSize： 存储的数据大小（使用的空间大小）</li>
<li>mDataCapacity： 数据空间大小，如果不够的话，可以动态增长</li>
<li>mDataPos： 数据游标，当前数据的位置，和读文件的游标类似，可以手动设置。声明了 mutbale 属性，可以学习下这个属性应该用在声明地方 ^_^。</li>
<li>mObjects： <code>flat_binder_object</code> 对象的位置数据，注意这个是个指针（其实就是个数组），里面保存的不是数据，而且地址的偏移（后面再具体说）。</li>
<li>mObjectsSize： 这个简单来说其实就是上面那个 objects 数组的大小。</li>
<li>mObjectsCapacity： objects 偏移地址（再次强调一次是地址）的空间大小，同样可以动态增长</li>
<li>mNextObjectHint： 可以理解为 objects 的 dataPos 。</li>
</ul>
<p>还记得通信模型 IPCThreadState 中有2个 Parcel 变量： mIn、mOut，前面分析这2个东西是 binder 通信的时候打包数据用的。我们通过结合前面的例子来分析。</p>
<p>首先是初始化，IPCThreadState 是直接使用变量的（栈内存），使用默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Parcel::Parcel()</div><div class="line">{</div><div class="line">    initState();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::initState()</div><div class="line">{</div><div class="line">    mError = NO_ERROR;</div><div class="line">    mData = <span class="number">0</span>;</div><div class="line">    mDataSize = <span class="number">0</span>;</div><div class="line">    mDataCapacity = <span class="number">0</span>;</div><div class="line">    mDataPos = <span class="number">0</span>;</div><div class="line">    ALOGV(<span class="string">"initState Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">    ALOGV(<span class="string">"initState Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">    mObjects = NULL;</div><div class="line">    mObjectsSize = <span class="number">0</span>;</div><div class="line">    mObjectsCapacity = <span class="number">0</span>;</div><div class="line">    mNextObjectHint = <span class="number">0</span>;</div><div class="line">    mHasFds = <span class="keyword">false</span>;</div><div class="line">    mFdsKnown = <span class="keyword">true</span>;</div><div class="line">    mAllowFds = <span class="keyword">true</span>;</div><div class="line">    mOwner = NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>初始话很简单，几乎都是初始化为 0（NULL） 的。然后看看 IPCThreadState 使用的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">IPCThreadState::IPCThreadState()</div><div class="line">    : mProcess(ProcessState::self()),</div><div class="line">      mMyThreadId(androidGetTid()),</div><div class="line">      mStrictModePolicy(<span class="number">0</span>),</div><div class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</div><div class="line">{</div><div class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</div><div class="line">    clearCaller();</div><div class="line">    mIn.setDataCapacity(<span class="number">256</span>);</div><div class="line">    mOut.setDataCapacity(<span class="number">256</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>首先调用 setDataCapacity 来初始化 parcel 的数据空间大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::setDataCapacity(size_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (size &gt; mDataCapacity) <span class="keyword">return</span> continueWrite(size);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::continueWrite(size_t desired)</div><div class="line">{</div><div class="line">... ...</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mData) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// This is the first data.  Easy!</span></div><div class="line">        uint8_t* data = (uint8_t*)<span class="built_in">malloc</span>(desired);</div><div class="line">        <span class="keyword">if</span> (!data) {</div><div class="line">            mError = NO_MEMORY;</div><div class="line">            <span class="keyword">return</span> NO_MEMORY;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!(mDataCapacity == <span class="number">0</span> && mObjects == NULL</div><div class="line">             && mObjectsCapacity == <span class="number">0</span>)) {</div><div class="line">            ALOGE(<span class="string">"continueWrite: %d/%p/%d/%d"</span>, mDataCapacity, mObjects, mObjectsCapacity, desired);</div><div class="line">        }</div><div class="line"></div><div class="line">        mData = data;</div><div class="line">        mDataSize = mDataPos = <span class="number">0</span>;</div><div class="line">        ALOGV(<span class="string">"continueWrite Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">        ALOGV(<span class="string">"continueWrite Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">        mDataCapacity = desired;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>设置空间大小的，其实主要是调用到了 contiueWrite 函数。前面那个 size &gt; mDataCapacity 判断意思是如果设置的大小比原来的要大，则需要调整申请的内存的大小，如果小的话，就直接使用原来的大小。</p>
<p>接下来看 contiueWrite，前面有个 object 的判断先不管。然后下面主要是分开3个分支，分别是：</p>
<ul>
<li>分支一： 如果设置了 release 函数指针（mOwner是个函数指针），调用 release 函数进行处理。</li>
<li>分支二： 没有设置 release 函数指针，但是 mData 中存在数据，需要在原来的数据的基础上扩展存储空间。</li>
<li>分支三： 没有设置 release 函数指针，并且 mData 中不存在数据（就是注释中说的第一次使用， Easy -_-||），调用 malloc 申请内存块，保存在 mData。设置相应的设置 capacity、size、pos、object 的值。</li>
</ul>
<p>这里先贴出分支三的代码，第一次使用，是走分支三的，其它2个后面再说。这里注意一点，这里只 malloc 了一个块内存，就是 mData 的，前面说 parcel 存储结构是一块连续的内存，mObjects 只是保存的只是地址的偏移，这里可以看到一些端倪（后面就能清楚）。</p>
<p>初始化了之后，我们看看怎么使用的，在通信模型中我们说道 Bp 端发起 IPC 调用，通过 IPCThreadState 对 binder 驱动写入请求数据发送到 Bn 端，我们回想下 Bp 端写数据的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel& data, status_t* statusBuffer)</div><div class="line">{</div><div class="line">    binder_transaction_data tr;</div><div class="line"></div><div class="line">... ...</div><div class="line">       </div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">                              </div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>先看前面 writeInt32 这个，对 parcel 写入一个 32bit 的 int 型数据。parcel 接口中有一类是专门针对基本类型（int、float、double、int数组），writeInt32、writeInt64、writeFloat、writeDouble、writeIntArray 这些（对应有 read 接口）。然后他们都是另一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">status_t Parcel::writeAligned(T val) {</div><div class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) {</div><div class="line">restart_write:</div><div class="line">        *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;</div><div class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));</div><div class="line">    }</div><div class="line"></div><div class="line">    status_t err = growData(<span class="keyword">sizeof</span>(val));</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::finishWrite(size_t len)</div><div class="line">{</div><div class="line">    <span class="comment">//printf("Finish write of %d\n", len);</span></div><div class="line">    mDataPos += len;</div><div class="line">    ALOGV(<span class="string">"finishWrite Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">    <span class="keyword">if</span> (mDataPos &gt; mDataSize) {</div><div class="line">        mDataSize = mDataPos;</div><div class="line">        ALOGV(<span class="string">"finishWrite Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">    }</div><div class="line">    <span class="comment">//printf("New pos=%d, size=%d\n", mDataPos, mDataSize);</span></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>writeAligned 看名字就知道要内存对齐，第一句好像就是验证下是否内存对齐的，好像能够根据编译选项判断，应该是如果打开某个编译选项，如果传过来的 size 没内存对齐直接报错吧，内存对齐的算法都是搞一些位运算（这里好像是4字节对齐吧）：</p>
<pre>
#define PAD_SIZE(s) (((s)+3)&~3)
</pre>

<p>int32、int64、float、double 都是4字节对齐的。接着往下看，有个判断当前 pos + 要写入的数据的所占用的空间是否比 capacity 大，就是看空间是不是够大。前面所了 parcel 能够根据需求自动增长空间，这里我们先看空间够的情况，就是走 if 里面：</p>
<pre>
*reinterpret_cast<t*>(mData+mDataPos) = val;
</t*></pre>

<p>直接取当前地址强制转化指针类型，然后赋值（c/c++语言就是舒服）。然后调用 finishWrite 完成写入。finishWrite 就是把 mDataPos 和 mDataSize 值改了一下（加上刚刚写入数据的大小），从这里可以看得出，对于 write 来说，mDataPos = mDataSize。</p>
<p>然后我们看看当空间不够的情况，就是走 if 后面，有一个 growData 的函数，这个是用来调整内存空间的，然后一个 goto 跳转回 if 里面重写写入（parcel 的实现很多地方有 goto，其实 goto 在本函数里面用还好）。我们来看看 growData：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::growData(size_t len)</div><div class="line">{</div><div class="line">    size_t newSize = ((mDataSize+len)*<span class="number">3</span>)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> (newSize &lt;= mDataSize)</div><div class="line">            ? (status_t) NO_MEMORY         </div><div class="line">            : continueWrite(newSize);      </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 parcel 的增长算法： ((mDataSize+len)*3)/2， 带一定预测性的增长，避免频繁的空间调整（每次调整需要重新 malloc 内存的，频繁的话会影响效率的）。然后这里有个判断 newSize &lt; mDataSize 就认为 NO_MEMORY。这是所如果如果溢出了（是负数），就认为申请不到内存了。然后调用的函数是 continueWrite ，和前面 setCapacity 调用的是同一个。前面说这个函数有3个分支，这里我们就可以来看第2个分支了（mData 有数据的情况）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::continueWrite(size_t desired)</div><div class="line">{</div><div class="line">    <span class="comment">// If shrinking, first adjust for any objects that appear</span></div><div class="line">    <span class="comment">// after the new data size.</span></div><div class="line">    size_t objectsSize = mObjectsSize;</div><div class="line">    <span class="keyword">if</span> (desired &lt; mDataSize) {</div><div class="line">        <span class="keyword">if</span> (desired == <span class="number">0</span>) {</div><div class="line">            objectsSize = <span class="number">0</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">while</span> (objectsSize &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (mObjects[objectsSize-<span class="number">1</span>] &lt; desired)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                objectsSize--;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mData) {</div><div class="line">        <span class="keyword">if</span> (objectsSize &lt; mObjectsSize) {</div><div class="line">            <span class="comment">// Need to release refs on any objects we are dropping.</span></div><div class="line">            <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">            <span class="keyword">for</span> (size_t i=objectsSize; i&lt;mObjectsSize; i++) {</div><div class="line">                <span class="keyword">const</span> flat_binder_object* flat</div><div class="line">                    = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(mData+mObjects[i]);</div><div class="line">                <span class="keyword">if</span> (flat-&gt;type == BINDER_TYPE_FD) {</div><div class="line">                    <span class="comment">// will need to rescan because we may have lopped off the only FDs</span></div><div class="line">                    mFdsKnown = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">                release_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">            }</div><div class="line">            size_t* objects =</div><div class="line">                (size_t*)realloc(mObjects, objectsSize*<span class="keyword">sizeof</span>(size_t));</div><div class="line">            <span class="keyword">if</span> (objects) {</div><div class="line">                mObjects = objects;</div><div class="line">            }</div><div class="line">            mObjectsSize = objectsSize;</div><div class="line">            mNextObjectHint = <span class="number">0</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// We own the data, so we can just do a realloc().</span></div><div class="line">        <span class="keyword">if</span> (desired &gt; mDataCapacity) {</div><div class="line">            uint8_t* data = (uint8_t*)realloc(mData, desired);</div><div class="line">            <span class="keyword">if</span> (data) {</div><div class="line">                mData = data;</div><div class="line">                mDataCapacity = desired;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (desired &gt; mDataCapacity) {</div><div class="line">                mError = NO_MEMORY;</div><div class="line">                <span class="keyword">return</span> NO_MEMORY;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (mDataSize &gt; desired) {</div><div class="line">                mDataSize = desired;</div><div class="line">                ALOGV(<span class="string">"continueWrite Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mDataPos &gt; desired) {</div><div class="line">                mDataPos = desired;</div><div class="line">                ALOGV(<span class="string">"continueWrite Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有关 object 的处理也是先放放，后面再一起说。看后面的，如果需要的空间比原来的大，那么调用 realloc 把空间调整一下。realloc 可以看 man，是说保留原来的内存空间，然后尝试在原来的空间后面扩展需要的内存空间。然后就是把 mDataPos 和 mDataSize 设置一下。如果是要的空间比原来的小，那就什么都不干，就是说用就当成小的用，内存还是以前那么大。</p>
<p>然后回到 IPCThreadState::writeTransactionData 我们看看后面那个 mOut.write： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::write(<span class="keyword">const</span> <span class="keyword">void</span>* data, size_t len)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> d = writeInplace(len);</div><div class="line">    <span class="keyword">if</span> (d) {</div><div class="line">        <span class="built_in">memcpy</span>(d, data, len);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> mError;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span>* Parcel::writeInplace(size_t len)</div><div class="line">{</div><div class="line">    <span class="comment">// 4字节对齐，看样子字节对齐对效率还是有影响的</span></div><div class="line">    <span class="keyword">const</span> size_t padded = PAD_SIZE(len); </div><div class="line"></div><div class="line">    <span class="comment">// sanity check for integer overflow</span></div><div class="line">    <span class="keyword">if</span> (mDataPos+padded &lt; mDataPos) { </div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mDataPos+padded) &lt;= mDataCapacity) {</div><div class="line">restart_write:</div><div class="line">        <span class="comment">//printf("Writing %ld bytes, padded to %ld\n", len, padded);</span></div><div class="line">        uint8_t* <span class="keyword">const</span> data = mData+mDataPos;</div><div class="line"></div><div class="line">        <span class="comment">// Need to pad at end?</span></div><div class="line">        <span class="keyword">if</span> (padded != len) {</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> BYTE_ORDER == BIG_ENDIAN</span></div><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> uint32_t mask[<span class="number">4</span>] = {</div><div class="line">                <span class="number">0x00000000</span>, <span class="number">0xffffff00</span>, <span class="number">0xffff0000</span>, <span class="number">0xff000000</span></div><div class="line">            };</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></div><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> uint32_t mask[<span class="number">4</span>] = {</div><div class="line">                <span class="number">0x00000000</span>, <span class="number">0x00ffffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span></div><div class="line">            };</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">            <span class="comment">//printf("Applying pad mask: %p to %p\n", (void*)mask[padded-len],</span></div><div class="line">            <span class="comment">//    *reinterpret_cast&lt;void**&gt;(data+padded-4));</span></div><div class="line">            *<span class="keyword">reinterpret_cast</span>&lt;uint32_t*&gt;(data+padded-<span class="number">4</span>) &= mask[padded-len];</div><div class="line">        }</div><div class="line"></div><div class="line">        finishWrite(padded);</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    }</div><div class="line"></div><div class="line">    status_t err = growData(padded);</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数首先调用 writeInplace。来看下 writeInplace，这个函数参数是一个大小，返回是一个地址。进去里面看下，除去字节对齐的部分，就是把 mDataPos 和 mDataSize 的值加上了传过去的 len 大小，然后返回 mData + len 的地址。注意这里也有空间不够的情况，和前面的处理一样，调用 growData 去调整空间（parcel 写的接口基本上都有这个 growData 的处理）。这个函数相当于是帮你把内存分配好，然后返回计算好的起始地址给你。然后回到 write 下面直接 memcpy，把传过来的地址中的数据复制过来。</p>
<p>这2个接口的示例很经典，一个是写基本类型，一个是写对象类型的。基本类型可以说是值类型，直接把值写入内存中；对象类型，是把对象的内存数据写进来，这个相当于 c++ 里面的深拷贝，复制数据。上面 IPCThreadState 写入的是 <code>binder_transaction_data</code> 这个结构体，后面具体说说 binder 通信之间的数据格式。现在再来看看 writeString8 这个接口，加深下理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeString8(<span class="keyword">const</span> String8& str)</div><div class="line">{</div><div class="line">    status_t err = writeInt32(str.bytes()); </div><div class="line">    <span class="comment">// only write string if its length is more than zero characters,</span></div><div class="line">    <span class="comment">// as readString8 will only read if the length field is non-zero.</span></div><div class="line">    <span class="comment">// this is slightly different from how writeString16 works.</span></div><div class="line">    <span class="keyword">if</span> (str.bytes() &gt; <span class="number">0</span> && err == NO_ERROR) {</div><div class="line">        err = write(str.<span class="built_in">string</span>(), str.bytes()+<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>String8 是 android 在 native 对 <code>char*</code> 封装了一下，有点像 java 的 String方便字符串操作的。这个也是对象类型，看到 parcel 先是把 String8 的 size 写进去，然后 write 把 <code>char*</code> 数据写在 size 后面的内存中。我们再来看看对应的 readString8：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">String8 Parcel::readString8() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    int32_t size = readInt32();</div><div class="line">    <span class="comment">// watch for potential int overflow adding 1 for trailing NUL</span></div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> && size &lt; INT32_MAX) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* str = (<span class="keyword">const</span> <span class="keyword">char</span>*)readInplace(size+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (str) <span class="keyword">return</span> String8(str, size);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> String8();</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::readInt32(int32_t *pArg) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> readAligned(pArg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">status_t Parcel::readAligned(T *pArg) <span class="keyword">const</span> {</div><div class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(T)) &lt;= mDataSize) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = mData+mDataPos;</div><div class="line">        mDataPos += <span class="keyword">sizeof</span>(T);</div><div class="line">        *pArg =  *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(data);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> NOT_ENOUGH_DATA;        </div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span>* Parcel::readInplace(size_t len) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> ((mDataPos+PAD_SIZE(len)) &gt;= mDataPos && (mDataPos+PAD_SIZE(len)) &lt;= mDataSize) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = mData+mDataPos;</div><div class="line">        mDataPos += PAD_SIZE(len);     </div><div class="line">        ALOGV(<span class="string">"readInplace Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>读是先 readInt32 把 write 写入的 size 取出来，readInt32 是调用 readAligned 的。和前面 writeAligned 对应，先是判断下字节对齐，然后直接取 mData + mDataPos 地址的数据，转化成模版类型（再次感叹一次 c、c++ 爽）。注意一下这个函数最后移动了 mDataPos 的位置（对应 read 的数据的大小）。</p>
<p>然后是调用 readInplace ，有了前面的说明，你也应该知道这个是去返回对应的 writeInplace 的地址。里面果然是，同样注意最后移动了 mDataPos 的位置。然后去返回的地址取之前写入的 <code>char*</code> 数据，基于上面的数据重新构造出新的 String8 对象。这里你看出 pacrel 和 Serializable 很像，只不过 parcel 是在内存中捣腾，还有后面你会发现 parcel 还为 binder 做了一些别的事情。</p>
<p>还有前面说的 read 的接口回自动移动 mDataPos 的位置（parcel 所有 read 的接口都会自动移动 mDataPos），然后看前面的代码，你会发现，write 之后，到 read 的时候，能否取得到正确的数据，依赖于 mDataPos 的位置。这里就要求 binder 通信的时候，双方在用 parcel 读写数据的时候顺序一定要一致。例如说一个 IPC 调用，传递一个函数的参数： int、float、object，用 parcel 写顺序是： writeInt32、writeFloat、write，那么对方接到传过来的 parcel read 的顺序也必须为： readInt32、readFloat、read。就算其中某些参数你不用，你也要 read 一下，主要是要把 mDataPos 的位置移动对。</p>
<p>这里可以看得出 parcel 只是提供的是一块连续的内存块，至于往里面写什么东西，格式是怎么样的，取决于使用的人，所以使用人要要保证自己读得正确（要和写对应），例如前面说的 String8，前面一个 int32 是大小，后面这个大小的是 <code>char*</code> 数据，这个读的人必须按这个格式才重新创建出 String8。这个我们后面看 binder 中的使用能够看得出来。</p>
<p>接下来我们看看 binder 怎么把 parcel 打包的数据传递给另外一个进程的。这里我们结合下通信模型那分析的东西。首先 Bp 端调用 writeTransationData 把 IPC 请求打包发送到 binder 驱动。前面看到打包的是一个 cmd 和一个 <code>binder_transaction_data</code> 结构。先来看看这个结构（在 kernel binder.h 中）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction_data {</div><div class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></div><div class="line"><span class="comment">     * identifying the target and contents of the transaction.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        size_t  handle; <span class="comment">/* target descriptor of command transaction */</span></div><div class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></div><div class="line">    } target;</div><div class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></div><div class="line"></div><div class="line">    <span class="comment">/* General information about the transaction. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    pid_t       sender_pid;</div><div class="line">    uid_t       sender_euid;</div><div class="line">    size_t      data_size;  <span class="comment">/* number of bytes of data */</span></div><div class="line">    size_t      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></div><div class="line"></div><div class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></div><div class="line"><span class="comment">     * follows here; otherwise, it ends with a pointer to</span></div><div class="line"><span class="comment">     * the data buffer.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        <span class="keyword">struct</span> {</div><div class="line">            <span class="comment">/* transaction data */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</div><div class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</div><div class="line">        } ptr;</div><div class="line">        uint8_t buf[<span class="number">8</span>];</div><div class="line">    } data;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们看看 Bp 端对这个结构体填充了什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel& data, status_t* statusBuffer)</div><div class="line">{</div><div class="line">    binder_transaction_data tr;</div><div class="line"></div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    tr.flags = binderFlags;</div><div class="line">    tr.cookie = <span class="number">0</span>;</div><div class="line">    tr.sender_pid = <span class="number">0</span>;</div><div class="line">    tr.sender_euid = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> status_t err = data.errorCheck();</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        tr.data_size = data.ipcDataSize();</div><div class="line">        tr.data.ptr.buffer = data.ipcData();</div><div class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(size_t);</div><div class="line">        tr.data.ptr.offsets = data.ipcObjects();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) {</div><div class="line">        tr.flags |= TF_STATUS_CODE;</div><div class="line">        *statusBuffer = err;</div><div class="line">        tr.data_size = <span class="keyword">sizeof</span>(status_t);</div><div class="line">        tr.data.ptr.buffer = statusBuffer;</div><div class="line">        tr.offsets_size = <span class="number">0</span>;</div><div class="line">        tr.data.ptr.offsets = NULL;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> (mLastError = err);</div><div class="line">    }</div><div class="line"></div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_transatcion_data</code> target 这个 union 先看注释的说明， target.handle 是说是 IPC 目标的标示，这个 handle 这个东西后面再细说。code 是 IPC 接口定义的接口的标示（例如 <code>START_ACTIVITY</code>, <code>GET_TASK</code> 之类的玩意）。然后是检查下 parcel 的错误状态，一般是没啥错误的。然后后面几个赋值，来看看从 parcel 取出的是什么东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> uint8_t* Parcel::ipcData() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> mData;</div><div class="line">}</div><div class="line"></div><div class="line">size_t Parcel::ipcDataSize() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> (mDataSize &gt; mDataPos ? mDataSize : mDataPos);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> size_t* Parcel::ipcObjects() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> mObjects;</div><div class="line">}</div><div class="line"></div><div class="line">size_t Parcel::ipcObjectsCount() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">return</span> mObjectsSize;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释 <code>binder_transatcion_data</code> 的 data 这个变量是个 union，远程传输的时候用的是 ptr 这个结构，里面保存的是数据的地址。ptr.buffer 是 parcel 的 ipcData() ，这个函数返回的是 mData 就是数据地址。注意一下这里 data.ptr 保存的是 IPC Bp 传入的那个 parcel，不是 IPCThreadState mOut 这个用来打包 binder 数据的 parcel（都是用 parcel 容易搞混）。这里 data 这个 parcel 是将 IPC 的接口函数的参数数据打包起来的，例如 int、string 之类的参数。Bn 端返回的数据也是通过 parcel 打包的。而 IPCThreadState 的 mOut 只是写入了 cmd 和 <code>binder_transatcion_data</code> 而已，而 <code>binder_transation_data</code> 保存了 IPC 中传递的真正数据的地址（从参数 parcel 或取的），仅仅是地址而已。所以开头为什么 mOut 和 mIn 只把空间大小设置为 256，刚开始以为是因为 parcel 可以动态增长空间，先在看来，其实根本用不了到 256，因为数据大小只有一个 int32 的 cmd 和 <code>binder_transation_data</code> 这个结构而已。算一下 int32 4字节，<code>binder_transation_data</code> 第一个 target union 2个都是4字节的地址，所以就是4字节，除去后面 data 的 union 其余的7个都是4字节的地址，后面那个 data union 算最大的数据，是 4字节x2，所以 <code>binder_transation_data</code> 结构占 40字节，加上 cmd 就是 44字节。回去通信模型那看看图，是不是 Bp 端发 <code>BC_TRANSACTION</code> write_size 是不是 44。mIn 从 Bn 那读回来的数据也是差不多的，所以 256 足够了，基本上不需要动态调整空间的。</p>
<p>好，回到赋值那，看看后面几个，<code>data_size</code> 是取 mDataSize, mDataPos 比较大的那个（估计是为了保险吧，对于写 mDataSize 应该等于 mDataPos），然后看看后面的把 parcel 的 mObjectsSize 和 mObjects 分别给了 <code>offset_size</code> 和 ptr.offsets，<code>offset_size</code> 还乘了个地址的大小。前面说过了 parcel 的 mObjects 保存的是偏移地址，parcel 的名字很奇怪，kernel 里面的数据结构用名字再次告诉了我们这个是偏移地址。这个到后面就清楚了。</p>
<p>好 mOut 把数据打包好了，到了 waitForResponse 循环调用 talkWithDriver 向 binder 驱动写数据，以及等待 Bn 端返回数据（忘记了的回通信模型看看流程图）。我们先来看第一次写通信命令写了什么东西进去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> -EBADF; </div><div class="line">    }</div><div class="line">        </div><div class="line">    binder_write_read bwr;</div><div class="line">            </div><div class="line">    <span class="comment">// Is the read buffer empty?</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</div><div class="line">        </div><div class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></div><div class="line">    <span class="comment">// from data left in the input buffer and the caller</span></div><div class="line">    <span class="comment">// has requested to read the next data.</span></div><div class="line">    <span class="keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line">            </div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</div><div class="line">                </div><div class="line">    <span class="comment">// This is what we'll read.</span></div><div class="line">    <span class="keyword">if</span> (doReceive && needRead) {</div><div class="line">        bwr.read_size = mIn.dataCapacity();</div><div class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</div><div class="line">    } <span class="keyword">else</span> { </div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    }</div><div class="line">   </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></div><div class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) && (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    status_t err;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        ... ...</div><div class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &bwr) &gt;= <span class="number">0</span>)</div><div class="line">            err = NO_ERROR;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            err = -errno;</div><div class="line">        ... ...</div><div class="line">    } <span class="keyword">while</span> (err == -EINTR);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们在 kernel 的 binder.h 看到 <code>BINDER_WRITE_READ</code> 的参数是 <code>binder_write_read</code> 这个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BINDER_WRITE_READ           _IOWR('b', 1, struct binder_write_read)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * On 64-bit platforms where user code may run in 32-bits the driver must</span></div><div class="line"><span class="comment"> * translate the buffer (and local binder) addresses apropriately.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_write_read {</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span> </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span> </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_write_read</code> 的结构并不复杂，就是一个数据地址，一个数据大小，一个数据确认处理的大小，分为2部分，write 和 read（看注释后面要支持 64bit binder 数据传输这里要改不少东西吧）。回来看下赋值。前面那个那个判断 mIn 中的是否有读的数据，是通过 mDataPos 的位置来判断的，就是说如果 mDataPos 的位置比 mDataSize 小，说明还有数据还没读完，前面说了 parcel 每调用一次 read 接口就会自动移动 mDataPos，如果正好把 read 次数（Bp 端读）对应上 write 次数（Bn 端写），那么 mDataPos 是正好等于 mDataSize 的。后面根据 (!doReceive || needRead) 决定 <code>write_size</code> 的大小，这个后面到 kernel 里可以知道 size 的大小是否为 0 决定了是否调用 binder 驱动的读写处理函数。如果 mIn 中还有数据还没读取完，needRead 为 true， doReceive 默认是 true（默认要接收 Bn 端返回的数据），所以如果还有 Bn 端发过来的数据还没读完，本次循环在 binder 驱动中是发不出数据的。这里开始是能没有读数据的，所以能发得出来，<code>write_size</code> 大小是 mOut parcel 的 mDataSize，<code>write_buffer</code> 是 mOut 的 mData 地址。读的部分相应的取 mIn 的，这里给接收的大小也是 256，后面可以看到 Bn 端发过来也是也是 <code>binder_transatcion_data</code> 结构，所以 256 也够了。然后在 ioctl 前把 consumed 都设置成0。</p>
<p>然后就 ioctl 到 kernel 的 binder 驱动里面去了，我在 binder 驱动中看看，parcel 是怎么从 Bp 端传递到 Bn 端（或者从 Bn 返回到 Bp）的。首先是上面的 Bp 向 binder 发送 <code>BC_TRANSACTION</code> 把 <code>binder_transtion_data</code> 的地址保存到 ioctl 的参数 <code>binder_write_read</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg) </div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line">... ...</div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: {</div><div class="line">        <span class="keyword">struct</span> binder_write_read bwr; </div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) {</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (copy_from_user(&bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }  </div><div class="line">... ...</div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) { </div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) { </div><div class="line">                bwr.read_consumed = <span class="number">0</span>; </div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err; </div><div class="line">            }    </div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) { </div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &bwr.read_consumed, filp-&gt;f_flags & O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            }</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">... ...</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        ret = -EINVAL;</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    }</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有个 kernel 函数调用： <code>copy_from_user</code>，是从用户空间 copy 指定的一段内存数据到 kernel 空间（用户态（空间），kernel态（空间）有啥区别网上查吧，我也不是很清除），这样 IPCThreadState talkWithDriver 那些填写的那个 <code>binder_write_read</code> 就传递到 kernel binder 驱动中了。这里可以看得到，如果 IPCThreadState 把 wirte 或是 read 的 size 设置为 0 的话就不会处理（前面也说过）。我们先看 write， <code>write_buffer</code> 里面的数据是 IPCThreadState 用 mOut 打包的内存数据块。根据前面的分析，应该是这样的格式:</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-parcel/1.png" alt=""></p>
<p>然后去 <code>binder_thread_write</code> 里面去看看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;   </div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t); </div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BC_TRANSACTION:</div><div class="line">        <span class="keyword">case</span> BC_REPLY: {</div><div class="line">            <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (copy_from_user(&tr, ptr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line">            binder_transaction(proc, thread, &tr, cmd == BC_REPLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里有个 while 循环，结束条件是 ptr 指针移动 end 处，就是处理完 IPCThreadState write 进来的数据为止。循环一开始就用 <code>get_user</code> 从 ptr 指向的用户空间出一个 int32 的数据到 kernel 空间（<code>get_user</code> 和 <code>copy_from_user</code> 的区别是，一个是 copy 一个简单的变量，一个是 copy 一块内存块）。然后接着把 ptr 指针移动一个 int32 大小。这里注意下，前面 ioctl 那 <code>copy_from_user</code> 是从用户空间得到 <code>binder_write_read</code> 结构（地址在 ioctl 的参数里面），而这里从用户空间 copy 的是保存在 <code>binder_write_read</code> <code>write_buffer</code> 中的地址，也就是前面 mOut 的 mData 的地址。所以要根据前面打包的格式来读（看上面的图）。前面说了 parcel 的读和写对应。所以这里先取 cmd（是  <code>BC_TRANSACTION</code>），然后 parcel 调用 read 接口会自动移动 mDataPos ，binder 驱动里面要自己手动移动指针位置（这里再次看出，parcel 提供简单的内存读写，很灵活，也比较简单，但是同时也比较容易出错）。然后后面继续 <code>copy_from_user</code> 从用户态的 mOut 地址把 <code>binder_transation_data</code> copy 过来（顺带移动指针），然后交由 <code>binder_transation</code> 函数处理（这篇的流程其实和前面通信模型是一样的，但是本篇主要讲数据的流动）。这里先看到后面，<code>binder_transation</code> 处理完后， consumed 就被设置为相应读取的数据大小（这个 consumed 是个指针，其实就设置 <code>binder_write_read</code> 这个结构 <code>write_consumed</code> 这个变量的， <code>binder_write_read</code> 这个结构最后又会被传回用户空间去的，后面能看到）。</p>
<p>至于 <code>binder_transation</code> 中怎么传递到另一个进程中的去，去看我下一篇 binder 的内存管理篇吧，那里有详细的说明，这里不多说这些。反正最后通过 <code>binder_thread_read</code> 传递用 Bn 端的用户空间，然后借着上一篇 Bn 端的 getAndExecuteCommand 从 talkWithDriver 那的 ioctl 返回得到 Bp 端通过 kernel 发送的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::getAndExecuteCommand()</div><div class="line">{</div><div class="line">    status_t result;</div><div class="line">    int32_t cmd; </div><div class="line"></div><div class="line">    result = talkWithDriver();</div><div class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">        size_t IN = mIn.dataAvail();</div><div class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">        <span class="comment">// 这里先读 cmd</span></div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }    </div><div class="line"></div><div class="line">        result = executeCommand(cmd);</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Bn 端等待 Bp 端的时候，把自己 mIn 的 parcel 的 buffer 传递到 kernel 里面去了，所以 Bp 端发送过来的 parcel 通过 kernel 传递到 Bn 端的 mIn 中去了。<br>内存管理篇那里 <code>binder_thread_read</code> 会把 cmd 写入 mIn buffer 的第一个 int32 的地址，所以这里先读 int32 的 cmd，然后送给 executeCommand 处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        {</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ALOG_ASSERT(result == NO_ERROR,</div><div class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line">... ...</div><div class="line"></div><div class="line">            Parcel reply;</div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) {</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                <span class="keyword">const</span> status_t error = b-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">const</span> status_t error = the_context_object-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((tr.flags & TF_ONE_WAY) == <span class="number">0</span>) {</div><div class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</div><div class="line">                sendReply(reply, <span class="number">0</span>);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</div><div class="line">            }</div><div class="line"></div><div class="line">            mCallingPid = origPid;</div><div class="line">            mCallingUid = origUid;</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//======================================</span></div><div class="line"></div><div class="line">status_t Parcel::read(<span class="keyword">void</span>* outData, size_t len) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> ((mDataPos+PAD_SIZE(len)) &gt;= mDataPos && (mDataPos+PAD_SIZE(len)) &lt;= mDataSize) {</div><div class="line">        <span class="built_in">memcpy</span>(outData, mData+mDataPos, len);</div><div class="line">        mDataPos += PAD_SIZE(len);     </div><div class="line">        ALOGV(<span class="string">"read Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NOT_ENOUGH_DATA;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续看前一篇的那张通信模型的图， Bn 这里是接到的 cmd 是 kernel 发过来的 <code>BR_TRANSACTION</code>， 然后前面 Bp 把 <code>binder_transaction_data</code> 通过 Parcel 写入，这里就要通过 read 来读出来了。内存流的，直接一个强制转化就行了，read 也很简单，就是 memcpy （可以好好看看内存管理篇，kernel 里面传递 parcel data 的 buffer 的技巧很牛x）。然后这里的 Parcel buffer 是临时变量， ipcSetDataReference 设置 freeBuffer 函数怎么回事，内存管理篇都有讲，这里就不多说了。然后最后 </p>
<pre config="brush:bash;toolbar:false;">
b->transact(tr.code, buffer, &reply, tr.flags)
</pre>

<p>就把 Bp 传递过来的 parcel 传递子类实现 binder 业务的 transact 函数去处理的，顺带，把放返回值的 reply 给传过去了。</p>
<p>我们拿 AM 中的一个简单的接口来看一下（frameworks/base/core/java/android/app/ActivityManagerNative.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// ActivityManagerNativeProxy: Bp 端</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishActivity</span>(IBinder token, <span class="keyword">int</span> resultCode, Intent resultData)</div><div class="line">            <span class="keyword">throws</span> RemoteException {</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        <span class="comment">// 写入本服务接口的标志，一个字符串，一般是完整的类名 android.xx.xx</span></div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        <span class="comment">// 参数1： flat_binder_object 特殊类型</span></div><div class="line">        data.writeStrongBinder(token);</div><div class="line">        <span class="comment">// 参数2: int 类型的</span></div><div class="line">        data.writeInt(resultCode);</div><div class="line">        <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 参数3： 一个自定义类型的对象，支持 Parcelable 的</span></div><div class="line">            <span class="comment">// 在开始写一个 1，标记一下</span></div><div class="line">            data.writeInt(<span class="number">1</span>);</div><div class="line">            resultData.writeToParcel(data, <span class="number">0</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 如果传递的参数非法，标记写0</span></div><div class="line">            data.writeInt(<span class="number">0</span>);</div><div class="line">        }    </div><div class="line">        mRemote.transact(FINISH_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        <span class="keyword">boolean</span> res = reply.readInt() != <span class="number">0</span>;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> res; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//============================================</span></div><div class="line"></div><div class="line">    <span class="comment">// ActivityManagerNative： Bn 端</span></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span>(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags) </div><div class="line">            <span class="keyword">throws</span> RemoteException {       </div><div class="line">        <span class="keyword">switch</span> (code) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> FINISH_ACTIVITY_TRANSACTION: {</div><div class="line">            <span class="comment">// 先读接口标志，对比下是不是本服务的 Bp 端发过来的请求</span></div><div class="line">            data.enforceInterface(IActivityManager.descriptor);</div><div class="line">            <span class="comment">// 参数1： 特殊 flat_binder_object</span></div><div class="line">            IBinder token = data.readStrongBinder();</div><div class="line">            Intent resultData = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 参数2： int 类型</span></div><div class="line">            <span class="keyword">int</span> resultCode = data.readInt();</div><div class="line">            <span class="comment">// 参数3： Parcelable 类型自定义对象</span></div><div class="line">            <span class="comment">// 前面如果传递的参数2合法，这里读出的就是 1</span></div><div class="line">            <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) {</div><div class="line">                <span class="comment">// 把内存流的 parcel 传递给实现了 Parcelable 结构的自定义类</span></div><div class="line">                <span class="comment">// 通过数据在 Bn 端重新创建一个对象</span></div><div class="line">                resultData = Intent.CREATOR.createFromParcel(data);</div><div class="line">            }</div><div class="line">            <span class="comment">// 参数解析完毕，调用真正的业务函数实现功能</span></div><div class="line">            <span class="keyword">boolean</span> res = finishActivity(token, resultCode, resultData);</div><div class="line">            reply.writeNoException();</div><div class="line">            reply.writeInt(res ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面看代码中的注释就差不多了，顺序都是一一对应的。然后说说那个 Parcelable 这个接口。这个接口最主要就是2个函数：writeToParcel、createFromParcel 这2个，一个相当于是序列化，一个是反序列化。就是自己类自己实现了的，再复杂的对象都可以通过 Parcel 前面的那些基本类型来存储。</p>
<h2 id="大型数据">大型数据</h2>
<p>大型数据主要是通过 Parcel 的匿名共享内存（Ashmem）接口来使用的（writeBlob、readBlob），当然你也可以使用 writeInPlace 使用普通内存来传递，效率么，呵呵（还有不能超过 binder 的 1MB 大小的限制哦）。 这个话去看我的那篇专门说 ashmem 的吧。</p>
<h2 id="binder_对象">binder 对象</h2>
<p>Parcel 有一个特殊的结构叫 <code>flat_binder_object</code>。这个是专门用来传递 binder 对象的（其实这个在 ashmem 篇里发现这个还可以传递文件描述 fd，咋这只说 binder 句柄）。</p>
<p>这里我略过 Parcel 的 java 接口 和 jni 的马甲了，直接拿 native 的代码说，稍微简洁一些。</p>
<p>我还是以上面 AM 里面那个例子说。里面在 IPC 有个要传递的对象是 IBinder 类型的，通过原型篇的分析，这个就是 binder 对象了，这里说的 binder 句柄传递，就是针对这一类型的数据。这里就是调用了 Parcel 的2个接口，我们先来看看写的那个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;& val)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line">status_t flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;& binder, Parcel* out)</div><div class="line">{</div><div class="line">    flat_binder_object obj;</div><div class="line"></div><div class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    <span class="keyword">if</span> (binder != NULL) {</div><div class="line">        <span class="comment">// 区分是 Bn（localBinder） 还是 Bp（remoteBinder）</span></div><div class="line">        IBinder *local = binder-&gt;localBinder();</div><div class="line">        <span class="keyword">if</span> (!local) {</div><div class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</div><div class="line">            <span class="keyword">if</span> (proxy == NULL) {</div><div class="line">                ALOGE(<span class="string">"null proxy"</span>);</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果是 Bp 的话，则保存 Bp 的 handle 值</span></div><div class="line">            <span class="comment">// Bp 的 type 是 BINDER_TYPE_HANDLE</span></div><div class="line">            <span class="keyword">const</span> int32_t handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</div><div class="line">            obj.type = BINDER_TYPE_HANDLE;</div><div class="line">            obj.handle = handle;</div><div class="line">            obj.cookie = NULL;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 如果是 Bn 的话，直接保存 binder 对象本身</span></div><div class="line">            <span class="comment">// Bn 的 type 是 BINDER_TYPE_BINDER</span></div><div class="line">            obj.type = BINDER_TYPE_BINDER;</div><div class="line">            obj.binder = local-&gt;getWeakRefs();</div><div class="line">            obj.cookie = local;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        obj.type = BINDER_TYPE_BINDER;</div><div class="line">        obj.binder = NULL;</div><div class="line">        obj.cookie = NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 前面只是设置 flat_binder_object，这个函数才是真正写入 parcel 数据</span></div><div class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Parcel 其实还有 writeWeakBinder，但是这里只管 writeStrongBinder，而且一般也是 strong 用的多。先说说 <code>flat_binder_object</code> 这个东西，它是 kernel binder 驱动里面的一个结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This is the flattened representation of a Binder object for transfer</span></div><div class="line"><span class="comment"> * between processes.  The 'offsets' supplied as part of a binder transaction</span></div><div class="line"><span class="comment"> * contains offsets into the data where these structures occur.  The Binder</span></div><div class="line"><span class="comment"> * driver takes care of re-writing the structure type and data as it moves</span></div><div class="line"><span class="comment"> * between processes.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> flat_binder_object {</div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</div><div class="line"></div><div class="line">    <span class="comment">/* 8 bytes of data. */</span></div><div class="line">    <span class="keyword">union</span> {</div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* extra data associated with local object */</span></div><div class="line">    <span class="keyword">void</span>            *cookie;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个注释就已经真相了，这个玩意就是专门拿来传 binder 对象的（前面说了还有 fd），而且 offsets 就是这个东西的在传递数据中的位置，就是前面说的 parcel 中那个 mObjects 其实是个偏移来的啦。然后 binder 和 handle 是一个 union，就是说这个 binder 对象要么是 Bn（local），要么是 Bp（remote）。</p>
<p>那么我接下去看 <code>finish_flatten_binder</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内联函数 -_-||</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">static</span> status_t finish_flatten_binder(</div><div class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;& binder, <span class="keyword">const</span> flat_binder_object& flat, Parcel* out)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line">status_t Parcel::writeObject(<span class="keyword">const</span> flat_binder_object& val, <span class="keyword">bool</span> nullMetaData)</div><div class="line">{</div><div class="line">    <span class="comment">// 这里得同时判断 mData 和 mObjects 够不够咧</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> enoughData = (mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> enoughObjects = mObjectsSize &lt; mObjectsCapacity;</div><div class="line">    <span class="comment">// 空间够，就可以写</span></div><div class="line">    <span class="keyword">if</span> (enoughData && enoughObjects) {</div><div class="line">restart_write:</div><div class="line">        <span class="comment">// 注意这里，flat_binder_object 是保存在 mData 里的</span></div><div class="line">        *<span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(mData+mDataPos) = val;</div><div class="line">        </div><div class="line">        <span class="comment">// Need to write meta-data?    </span></div><div class="line">        <span class="keyword">if</span> (nullMetaData || val.binder != NULL) {</div><div class="line">            <span class="comment">// 再注意这里，保存刚刚写 flat_binder_object 的开始的地址</span></div><div class="line">            <span class="comment">// 这里就能说明 mObjects 保存的是偏移了。</span></div><div class="line">            mObjects[mObjectsSize] = mDataPos;</div><div class="line">            <span class="comment">// 给 flat_binder_object 保存的 binder 对象增加引用计数</span></div><div class="line">            acquire_object(ProcessState::self(), val, <span class="keyword">this</span>);</div><div class="line">            <span class="comment">// 数据中保存的 object 数量 +1</span></div><div class="line">            mObjectsSize++;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// remember if it's a file descriptor</span></div><div class="line">        <span class="keyword">if</span> (val.type == BINDER_TYPE_FD) { </div><div class="line">            <span class="keyword">if</span> (!mAllowFds) {</div><div class="line">                <span class="keyword">return</span> FDS_NOT_ALLOWED;        </div><div class="line">            }</div><div class="line">            mHasFds = mFdsKnown = <span class="keyword">true</span>;    </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(flat_binder_object));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 空间不够就和前面一样，调整内存大小</span></div><div class="line">    <span class="keyword">if</span> (!enoughData) {</div><div class="line">        <span class="keyword">const</span> status_t err = growData(<span class="keyword">sizeof</span>(val));</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">return</span> err;</div><div class="line">    }</div><div class="line">    <span class="comment">// 这里还有可能保存 offset 的空间不够了</span></div><div class="line">    <span class="keyword">if</span> (!enoughObjects) {</div><div class="line">        size_t newSize = ((mObjectsSize+<span class="number">2</span>)*<span class="number">3</span>)/<span class="number">2</span>;</div><div class="line">        size_t* objects = (size_t*)realloc(mObjects, newSize*<span class="keyword">sizeof</span>(size_t));</div><div class="line">        <span class="keyword">if</span> (objects == NULL) <span class="keyword">return</span> NO_MEMORY;</div><div class="line">        mObjects = objects;</div><div class="line">        mObjectsCapacity = newSize;    </div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="comment">// 调整完内存后，重新回去写</span></div><div class="line">    <span class="keyword">goto</span> restart_write;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后是调用 writeObject（object 只能是 <code>flat_binder_object</code>） 来写到 parcel 中去。这里和前面的差不多，都得先判断空间够不够，但是这里还得多判断一个 mObjects 的空间够不够。不够的和前面一样调用 growData 去调整大小。这里同样多处理一个 mObjects 空间调整，这里很简单了就是 realloc 一下就行了。这里看代码就知道 <code>flat_binder_object</code> 是保存在 mData 的区域的，而且后面几句代码彻底说明了 mObjects 保存的是偏移地址。最后 finishWrite 和前面一样，把 mDataPos 移动一下。</p>
<p>这里多嘴说下 <code>acquire_object</code>，我就说我烦 android 的那个啥智能指针，也不是太智能的样子，这里还得显示的增加下引用计数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parcel::acquireObjects()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    size_t i = mObjectsSize;</div><div class="line">    uint8_t* <span class="keyword">const</span> data = mData;</div><div class="line">    size_t* <span class="keyword">const</span> objects = mObjects;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</div><div class="line">        i--;</div><div class="line">        <span class="comment">// 看到 flat_binder_object 怎么取了的没，首地址 + 偏移地址</span></div><div class="line">        <span class="keyword">const</span> flat_binder_object* flat </div><div class="line">            = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);</div><div class="line">        acquire_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> acquire_object(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> flat_binder_object& obj, <span class="keyword">const</span> <span class="keyword">void</span>* who)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (obj.type) {</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p acquiring reference on local %p"</span>, who, obj.cookie);</div><div class="line">                <span class="keyword">static_cast</span>&lt;IBinder*&gt;(obj.cookie)-&gt;incStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder)</div><div class="line">                <span class="keyword">static_cast</span>&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;incWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE: {</div><div class="line">            <span class="keyword">const</span> sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p acquiring reference on remote %p"</span>, who, b.get());</div><div class="line">                b-&gt;incStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="keyword">const</span> wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) b.get_refs()-&gt;incWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="comment">// intentionally blank -- nothing to do to acquire this, but we do</span></div><div class="line">            <span class="comment">// recognize it as a legitimate object type.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGD(<span class="string">"Invalid object type 0x%08lx"</span>, obj.type);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 parcel 中内存分配应该是这样的：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-parcel/2.png" alt=""></p>
<p>然后打包了 <code>flat_binder_object</code> 的 parcel 就传到 kernel 的 binder 驱动里面去了。驱动里面有做特殊处理的，驱动里的处理放到后面一篇说 ServiceManager 那里细说，这里只要知道驱动里面倒腾了一下就到目标进程了，然后目标进程可以使用 parcel 的读接口读到之前写的 binder 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    sp&lt;IBinder&gt; val;</div><div class="line">    unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, &val);</div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个 inline 函数是耍存在感的么 -_-||</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">static</span> status_t finish_unflatten_binder(</div><div class="line">    BpBinder* proxy, <span class="keyword">const</span> flat_binder_object& flat, <span class="keyword">const</span> Parcel& in)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line">    </div><div class="line">status_t unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> Parcel& in, sp&lt;IBinder&gt;* out)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="keyword">false</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (flat) {</div><div class="line">        <span class="keyword">switch</span> (flat-&gt;type) {</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">                <span class="comment">// Bn 本地的直接强转一下</span></div><div class="line">                *out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</div><div class="line">                <span class="keyword">return</span> finish_unflatten_binder(NULL, *flat, in);</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">                <span class="comment">// Bp 的话要通过 handle 构造一个远程的代理对象（Bp 对象）</span></div><div class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</div><div class="line">                <span class="keyword">return</span> finish_unflatten_binder(</div><div class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</div><div class="line">        }        </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> BAD_TYPE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>readStrongBinder 其实挺简单的，是本地的可以直接用，远程的那个 getStrongProxyForHandle 也是放到后面 ServiceManager 再细说。到这里目标进程就收到原始进程传递过来的 binder 对象了，然后可以转化为 binder 的 interface 调用对应的 IPC 接口。</p>
<p>然后最后看下清理的情况，由于 binder 实现的接口中，Parcel 基本都是局部变量，所以 IPC 调用一结束，就会调用析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">Parcel::~Parcel()</div><div class="line">{</div><div class="line">    freeDataNoInit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::freeDataNoInit()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">        <span class="comment">//ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());</span></div><div class="line">        mOwner(<span class="keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这里看下面这个分支，mOwner 是 IPC 传递参数的 parcel 专用的</span></div><div class="line">        <span class="comment">// 减少引用计数，还得手动减少 -_-||</span></div><div class="line">        releaseObjects();</div><div class="line">        <span class="comment">// 直接 free mData 和 mObjects </span></div><div class="line">        <span class="comment">// 申请的是 malloc，释放就是 free 咯</span></div><div class="line">        <span class="keyword">if</span> (mData) <span class="built_in">free</span>(mData);</div><div class="line">        <span class="keyword">if</span> (mObjects) <span class="built_in">free</span>(mObjects);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::releaseObjects()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    size_t i = mObjectsSize;</div><div class="line">    uint8_t* <span class="keyword">const</span> data = mData;</div><div class="line">    size_t* <span class="keyword">const</span> objects = mObjects;</div><div class="line">    <span class="comment">// 这里和 acquireObjects 很像呐</span></div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</div><div class="line">        i--;</div><div class="line">        <span class="keyword">const</span> flat_binder_object* flat</div><div class="line">            = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);</div><div class="line">        release_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> release_object(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> flat_binder_object& obj, <span class="keyword">const</span> <span class="keyword">void</span>* who)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (obj.type) {</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p releasing reference on local %p"</span>, who, obj.cookie);</div><div class="line">                <span class="keyword">static_cast</span>&lt;IBinder*&gt;(obj.cookie)-&gt;decStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER:</div><div class="line">            <span class="keyword">if</span> (obj.binder)</div><div class="line">                <span class="keyword">static_cast</span>&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;decWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE: {</div><div class="line">            <span class="keyword">const</span> sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) {</div><div class="line">                LOG_REFS(<span class="string">"Parcel %p releasing reference on remote %p"</span>, who, b.get());</div><div class="line">                b-&gt;decStrong(who);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="keyword">const</span> wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);</div><div class="line">            <span class="keyword">if</span> (b != NULL) b.get_refs()-&gt;decWeak(who);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="keyword">if</span> (obj.cookie != (<span class="keyword">void</span>*)<span class="number">0</span>) close(obj.handle);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGE(<span class="string">"Invalid object type 0x%08lx"</span>, obj.type);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里的函数都不复杂，我直接贴到底了。其实就是 free 掉之前 malloc 的 mData 和 mObjects，还有就是前面手动增加了的引用计数，这里得再手动减少（这玩意就是麻烦）。</p>
<p>其实传递 binder 对象，最关键的地方其实在 kernel 的 binder 驱动里面，但是鉴于这篇已经够长了，而且这个和 ServiceManager 关系也挺密切的，所以决定把这块地方放到 ServiceManager 那篇去。</p>
<p>Parcel 是 android binder 通信中扮演着数据打包、解包的角色，是比较重要的一个东西。它的内存结构其实很简单，以后自己用的时候要注意下遵守规则（读、写顺序一致）。然后它可以传递一些小数据、也还可以传一些二进制流，对于大型数据提供匿名共享内存（Ashmem）的支持，它还有一个很特殊的功能，就是传递 binder 对象，保证了 binder IPC 通信的正常使用。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——数据传递者[Parcel]/" data-title="Android Binder 分析——数据传递者（Parcel） | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——通信模型/" title="Android Binder 分析——通信模型">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——通信模型</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——匿名共享内存[Ashmem]/"  title="Android Binder 分析——匿名共享内存（Ashmem）">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——匿名共享内存（Ashmem）
</span>
</a>
</div>

</nav>


	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小型数据"><span class="toc-number">2.</span> <span class="toc-text">小型数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大型数据"><span class="toc-number">3.</span> <span class="toc-text">大型数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder_对象"><span class="toc-number">4.</span> <span class="toc-text">binder 对象</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>32</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>49</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>9</sup></a></li>
		
			<li><a href="/categories/Performance/" title="Performance">Performance<sup>4</sup></a></li>
		
			<li><a href="/categories/VR/" title="VR">VR<sup>2</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/android/" title="android">android<sup>85</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>28</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>5</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/vr/" title="vr">vr<sup>4</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">我的链接</p>
    <ul>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">网站数据统计</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
      <li><i class="fa fa-book"></i> <a href="https://dongka.github.io" target="_blank">Dongka的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2021 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
