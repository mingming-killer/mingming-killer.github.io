
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——匿名共享内存（Ashmem） | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="前面分析了 binder 中用来打包、传递数据的 Parcel，一般用来传递 IPC 中的小型参数和返回值。binder 目前每个进程 mmap 接收数据的内存是 1M，所以就算你不考虑效率问题用 Parcel 来传，也无法传过去。只要超过 1M 就会报错（binder 无法分配接收空间）。所以 a">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">〜(￣△￣〜) 三月学长的根据地 (〜￣△￣)〜</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——匿名共享内存[Ashmem]/" title="Android Binder 分析——匿名共享内存（Ashmem）" itemprop="url">Android Binder 分析——匿名共享内存（Ashmem）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T13:00:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2015-03-31T06:33:16.000Z" itemprop="dateModified">2015 3月 31</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理概述"><span class="toc-number">1.</span> <span class="toc-text">原理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java_层接口"><span class="toc-number">2.</span> <span class="toc-text">java 层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#native_层接口"><span class="toc-number">3.</span> <span class="toc-text">native 层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel_驱动"><span class="toc-number">4.</span> <span class="toc-text">kernel 驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子"><span class="toc-number">5.</span> <span class="toc-text">例子</span></a></li></ol>
		</div>
		
		<p>前面分析了 binder 中用来打包、传递数据的 Parcel，一般用来传递 IPC 中的小型参数和返回值。binder 目前每个进程 mmap 接收数据的内存是 1M，所以就算你不考虑效率问题用 Parcel 来传，也无法传过去。只要超过 1M 就会报错（binder 无法分配接收空间）。所以 android 里面有一个专门用来在 IPC 中传递大型数据的东西—— Ashmem（Anonymous Shared Memroy）。照例把相关代码的位置说一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># MemroyFile 是 ashmem java 层接口</span></div><div class="line">frameworks/base/core/java/os/Parcel.java</div><div class="line">frameworks/base/core/java/os/Parcelable.java</div><div class="line">frameworks/base/core/java/os/ParcelFileDescriptor.java</div><div class="line">frameworks/base/core/java/os/MemoryFile.java</div><div class="line"></div><div class="line"><span class="comment"># jni 相关</span></div><div class="line">frameworks/base/core/jni/android_os_Parcel.h</div><div class="line">frameworks/base/core/jni/android_os_MemoryFile.cpp</div><div class="line">frameworks/base/core/jni/android_os_Parcel.cpp</div><div class="line">libnativehelper/JNIHelp.cpp</div><div class="line"></div><div class="line"><span class="comment"># 封装了 ashmem 驱动的 c 接口</span></div><div class="line">system/core/include/cutils/ashmem.h</div><div class="line">system/core/libcutils/ashmem-dev.c</div><div class="line"></div><div class="line"><span class="comment"># MemoryXx 是 ashmem 的 native 接口</span></div><div class="line">frameworks/native/include/binder/Parcel.h</div><div class="line">frameworks/native/include/binder/IMemory.h</div><div class="line">frameworks/native/include/binder/MemoryHeapBase.h</div><div class="line">frameworks/native/include/binder/MemoryBase.h</div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line">frameworks/native/libs/binder/Memory.cpp</div><div class="line">frameworks/native/libs/binder/MemoryHeapBase.cpp</div><div class="line">frameworks/native/libs/binder/MemoryBase.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"><span class="comment"># kernel ashmem 驱动</span></div><div class="line">kernel/include/linux/ashmem.h</div><div class="line">kernel/mm/ashmem.c</div><div class="line"></div></pre></td></tr></table></figure>

<p>（这和 Parcel 篇的基本一样么 -_-||）</p>
<h2 id="原理概述">原理概述</h2>
<p>ashmem 并像 binder 是 android 重新自己搞的一套东西，而是利用了 linux 的 tmpfs 文件系统。关于 tmpfs 我目前还不算很了解，可以先看下这里的2篇，有个基本的了解：</p>
<p><a href="http://blog.chinaunix.net/uid-20779720-id-3078267.html" title="Linux tmpfs " target="_blank" rel="external">Linux tmpfs </a><br><a href="http://blog.csdn.net/dog250/article/details/5303709" title="linux共享内存的设计" target="_blank" rel="external">linux共享内存的设计</a></p>
<p>那么大致能够知道，tmpfs 是一种可以基于 ram 或是 swap 的高速文件系统，然后可以拿它来实现不同进程间的内存共享。</p>
<p>然后大致思路和流程是：</p>
<ul>
<li>Proc A 通过 tmpfs 创建一块共享区域，得到这块区域的 fd（文件描述符）</li>
<li>Proc A 在 fd 上 mmap 一片内存区域到本进程用于共享数据</li>
<li>Proc A 通过某种方法把 fd 倒腾给 Proc B</li>
<li>Proc B 在接到的 fd 上同样 mmap 相同的区域到本进程</li>
<li>然后 A、B 在 mmap 到本进程中的内存中读、写，对方都能看到了</li>
</ul>
<p>其实核心点就是创建一块共享区域，然后2个进程同时把这片区域 mmap 到本进程，然后读写就像本进程的内存一样。这里要解释下第3步，为什么要倒腾 fd，因为在 linux 中 fd 只是对本进程是唯一的，在 Proc A 中打开一个文件得到一个 fd，但是把这个打开的 fd 直接放到 Proc B 中，Proc B 是无法直接使用的。但是文件是唯一的，就是说一个文件（file）可以被打开多次，每打开一次就有一个 fd（文件描述符），所以对于同一个文件来说，需要某种转化，把 Proc A 中的 fd 转化成 Proc B 中的 fd。这样 Proc B 才能通过 fd mmap 同样的共享内存文件（额，其实这里相关知识我也还没了解，瞎扯一下）。 </p>
<h2 id="java_层接口">java 层接口</h2>
<p>java 层的接口要拿 2.3 的来说，因为从 4.1（具体哪个版本我不好说，反正我手上只有 4.1 之后的）之后 java 层的 MemroyFile 应该就无法正常使用了，搜索代码发现，除了 test 有 MemroyFile 其它地方就去掉了。具体原因后面分析代码就知道了。</p>
<p>咋先来点感性的认识（MemroyFile.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> FileDescriptor mFD;        <span class="comment">// ashmem file descriptor</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mAddress;   <span class="comment">// address of ashmem memory</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLength;    <span class="comment">// total length of our ashmem region</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mAllowPurging = <span class="keyword">false</span>;  <span class="comment">// true if our ashmem region is unpinned</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mOwnsRegion;  <span class="comment">// false if this is a ref to an existing ashmem region</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Allocates a new ashmem region. The region is initially not purgable.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param name optional name for the file (can be null).</span></div><div class="line"><span class="comment"> * @param length of the memory file in bytes.</span></div><div class="line"><span class="comment"> * @throws IOException if the memory file could not be created.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="title">MemoryFile</span>(String name, <span class="keyword">int</span> length) <span class="keyword">throws</span> IOException {</div><div class="line">    mLength = length;</div><div class="line">    mFD = native_open(name, length);</div><div class="line">    mAddress = native_mmap(mFD, length, PROT_READ | PROT_WRITE);</div><div class="line">    mOwnsRegion = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>MemroyFile 还是比较简单的，成员变量也比较少，上面基本上就是所有的变量了。FileDescriptor 这个是 java 本身的对象，应该是 natvie fd 的封装吧。后面的地址、长度不说了。后面2个 boolean， mAllowPurging 表示这块 ashmem 是否允许被回收。 ashmem 在驱动那向 kernel 注册了一个内存回收算法，当 kernel 进行内存扫描的时候会调用这个回收算法，当标记了可以回收的时候，会把标记的内存给回收掉。这个设计的目的估计是想更高效的使用内存（能够标记一段共享内存不用了），但是后面你会发现这个东西目前还是个摆设。mOwnsRegion 表示只有创建者才能标记这块共享内存被回收。</p>
<p>MemroyFile 的使用方法，就只有构造函数一个。而且默认 mAllowPurging 是 false。这个构造函数是创建共享内存的，所以 mOwnsRegion 是 true。回想下前面原理，说的 Proc A 首先要创建一块共享内存，然后再 mmap 到本进程。这里正好2个 jni：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jobject android_os_MemoryFile_open(JNIEnv* env, jobject clazz, jstring name, jint length)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* namestr = (name ? env-&gt;GetStringUTFChars(name, NULL) : NULL);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> result = ashmem_create_region(namestr, length);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name)</div><div class="line">        env-&gt;ReleaseStringUTFChars(name, namestr);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem_create_region failed"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> jniCreateFileDescriptor(env, result);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 jni 很简单了，前面的 MemroyFile 传了要创建的共享内存的名字以及大小。这里主要是调用 libcutils 里面的 ashmem-dev.c 的接口去创建共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ASHMEM_DEVICE   "/dev/ashmem"</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * ashmem_create_region - creates a new ashmem region and returns the file</span></div><div class="line"><span class="comment"> * descriptor, or &lt;0 on error</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * `name' is an optional label to give the region (visible in /proc/pid/maps)</span></div><div class="line"><span class="comment"> * `size' is the size of the region, in page-aligned bytes</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> ashmem_create_region(<span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd, ret;</div><div class="line"></div><div class="line">    fd = open(ASHMEM_DEVICE, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> fd;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name) {</div><div class="line">        <span class="keyword">char</span> buf[ASHMEM_NAME_LEN];</div><div class="line"></div><div class="line">        strlcpy(buf, name, <span class="keyword">sizeof</span>(buf));</div><div class="line">        ret = ioctl(fd, ASHMEM_SET_NAME, buf);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> error;</div><div class="line">    }</div><div class="line"></div><div class="line">    ret = ioctl(fd, ASHMEM_SET_SIZE, size);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> error;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line"></div><div class="line">error:</div><div class="line">    close(fd);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>熟悉 linux 环境编程的也没啥要说的， open 打开设备。/dev/ashmem 在前面有篇文章说到，在 init.rc 里面和 /dev/binder 是系统 init 进程创建好的设备节点（虚拟机设备）。然后 ioctl 去设置名字和大小。这里就要走到 kernel 的驱动里面去了，这些后面再说。然后返回 fd。然后回到 jni 里面，通过 fd 构造出 java 的 FileDescriptor（JNIHelp.cpp）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">jobject jniCreateFileDescriptor(C_JNIEnv* env, <span class="keyword">int</span> fd) {</div><div class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</div><div class="line">    <span class="keyword">static</span> jmethodID ctor = e-&gt;GetMethodID(JniConstants::fileDescriptorClass, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</div><div class="line">    jobject fileDescriptor = (*env)-&gt;NewObject(e, JniConstants::fileDescriptorClass, ctor);</div><div class="line">    jniSetFileDescriptorOfFD(env, fileDescriptor, fd);</div><div class="line">    <span class="keyword">return</span> fileDescriptor;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> jniGetFDFromFileDescriptor(C_JNIEnv* env, jobject fileDescriptor) {</div><div class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</div><div class="line">    <span class="keyword">static</span> jfieldID fid = e-&gt;GetFieldID(JniConstants::fileDescriptorClass, <span class="string">"descriptor"</span>, <span class="string">"I"</span>);</div><div class="line">    <span class="keyword">return</span> (*env)-&gt;GetIntField(e, fileDescriptor, fid);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> jniSetFileDescriptorOfFD(C_JNIEnv* env, jobject fileDescriptor, <span class="keyword">int</span> value) {</div><div class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</div><div class="line">    <span class="keyword">static</span> jfieldID fid = e-&gt;GetFieldID(JniConstants::fileDescriptorClass, <span class="string">"descriptor"</span>, <span class="string">"I"</span>);</div><div class="line">    (*env)-&gt;SetIntField(e, fileDescriptor, fid, value);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就能看得出，FileDescriptor 就是把 fd 封装了一下，核心还是这个 int 值啊（通过反射，用 fd 设置了一下 FileDescriptor 的 fileDescriptor 这个变量）。然后看下 mmap：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_mmap(JNIEnv* env, jobject clazz, jobject fileDescriptor,</div><div class="line">        jint length, jint prot)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    jint result = (jint)mmap(NULL, length, prot, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!result)</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"mmap failed"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个更简单，通过 FileDescriptor 得到 fd，直接系统 mmap 。这里 mmap 也是要进到 kernel 的驱动里面的。稍微注意下， port 是 <code>PORT_READ | PORT_WRITE</code> 读写， flag 是 <code>MAP_SHARED</code>，就说明这是专为共享设置的。</p>
<p>Proc A 算是把共享内存创建好了也 mmap 到本进程，现在就要把 fd 倒腾给 Proc B。现在我们假设 Proc A 是 Bn 端，Proc B 是 Bp 端。然后来看看 MemroyFile 的一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Gets a ParcelFileDescriptor for the memory file. See {@link #getFileDescriptor()}</span></div><div class="line"><span class="comment"> * for caveats. This must be here to allow classes outside &lt;code&gt;android.os&lt;/code&lt; to</span></div><div class="line"><span class="comment"> * make ParcelFileDescriptors from MemoryFiles, as</span></div><div class="line"><span class="comment"> * {@link ParcelFileDescriptor#ParcelFileDescriptor(FileDescriptor)} is package private.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @return The file descriptor owned by this memory file object.</span></div><div class="line"><span class="comment"> *         The file descriptor is not duplicated.</span></div><div class="line"><span class="comment"> * @throws IOException If the memory file has been closed.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @hide</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> ParcelFileDescriptor <span class="title">getParcelFileDescriptor</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    FileDescriptor fd = getFileDescriptor();</div><div class="line">    <span class="keyword">return</span> fd != <span class="keyword">null</span> ? <span class="keyword">new</span> ParcelFileDescriptor(fd) : <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ParcelFileDescriptor，看名字你是不是明白了什么咧，能够 Parcelable 的 fd，这个就是让你拿来用 binder 传给 Proc B 的啊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*package */</span>ParcelFileDescriptor(FileDescriptor descriptor) {</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">if</span> (descriptor == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"descriptor must not be null"</span>);</div><div class="line">    }</div><div class="line">    mFileDescriptor = descriptor;</div><div class="line">    mParcelDescriptor = <span class="keyword">null</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * {@inheritDoc}</span></div><div class="line"><span class="comment"> * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,</span></div><div class="line"><span class="comment"> * the file descriptor will be closed after a copy is written to the Parcel.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span>(Parcel out, <span class="keyword">int</span> flags) {</div><div class="line">    out.writeFileDescriptor(mFileDescriptor);</div><div class="line">    <span class="keyword">if</span> ((flags&PARCELABLE_WRITE_RETURN_VALUE) != <span class="number">0</span> && !mClosed) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            close();</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            <span class="comment">// Empty</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;ParcelFileDescriptor&gt; CREATOR</div><div class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;ParcelFileDescriptor&gt;() {</div><div class="line">    <span class="keyword">public</span> ParcelFileDescriptor <span class="title">createFromParcel</span>(Parcel in) {</div><div class="line">        <span class="keyword">return</span> in.readFileDescriptor();</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> ParcelFileDescriptor[] <span class="title">newArray</span>(<span class="keyword">int</span> size) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelFileDescriptor[size];</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>ParcelFileDescriptor 其实挺简单，主要是看它的 Paracelable 接口。又是调用 Parcel 的对应接口（java jni native 放一起了，麻烦，而且下面是 2.3 的代码，4.4 的不一样了，基本上好像太能配合 MemroyFile 使用了）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java ================================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Write a FileDescriptor into the parcel at the current dataPosition(),</span></div><div class="line"><span class="comment">     * growing dataCapacity() if needed.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * &lt;p class="caution"&gt;The file descriptor will not be closed, which may</span></div><div class="line"><span class="comment">     * result in file descriptor leaks when objects are returned from Binder</span></div><div class="line"><span class="comment">     * calls.  Use {@link ParcelFileDescriptor#writeToParcel} instead, which</span></div><div class="line"><span class="comment">     * accepts contextual flags and will close the original file descriptor</span></div><div class="line"><span class="comment">     * if {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set.&lt;/p&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> final native <span class="keyword">void</span> writeFileDescriptor(FileDescriptor val);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Read a FileDescriptor from the parcel at the current dataPosition().</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> final ParcelFileDescriptor readFileDescriptor() {</div><div class="line">        FileDescriptor fd = internalReadFileDescriptor();</div><div class="line">        <span class="keyword">return</span> fd != null ? <span class="keyword">new</span> ParcelFileDescriptor(fd) : null;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// jni ================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Parcel_writeFileDescriptor(JNIEnv* env, jobject clazz, jobject object)</div><div class="line">{</div><div class="line">    Parcel* parcel = parcelForJavaObject(env, clazz);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) {</div><div class="line">        <span class="keyword">const</span> status_t err = parcel-&gt;writeDupFileDescriptor(</div><div class="line">                env-&gt;GetIntField(object, gFileDescriptorOffsets.mDescriptor));</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">            jniThrowException(env, <span class="string">"java/lang/OutOfMemoryError"</span>, NULL);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个在 jni 注册那里是叫 internalReadFileDescriptor -_-||</span></div><div class="line"><span class="keyword">static</span> jobject android_os_Parcel_readFileDescriptor(JNIEnv* env, jobject clazz)</div><div class="line">{</div><div class="line">    Parcel* parcel = parcelForJavaObject(env, clazz);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) {</div><div class="line">        <span class="keyword">int</span> fd = parcel-&gt;readFileDescriptor();</div><div class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> NULL;</div><div class="line">        fd = dup(fd);</div><div class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> NULL;</div><div class="line">        jobject object = env-&gt;NewObject(</div><div class="line">                gFileDescriptorOffsets.mClass, gFileDescriptorOffsets.mConstructor);</div><div class="line">        <span class="keyword">if</span> (object != NULL) {</div><div class="line">            <span class="comment">//LOGI("Created new FileDescriptor %p with fd %d\n", object, fd);</span></div><div class="line">            env-&gt;SetIntField(object, gFileDescriptorOffsets.mDescriptor, fd);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> object;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// native ================================</span></div><div class="line"></div><div class="line">status_t Parcel::writeDupFileDescriptor(<span class="keyword">int</span> fd)</div><div class="line">{</div><div class="line">    flat_binder_object obj;</div><div class="line">    obj.type = BINDER_TYPE_FD;</div><div class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    obj.handle = dup(fd);</div><div class="line">    obj.cookie = (<span class="keyword">void</span>*)<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> writeObject(obj, <span class="keyword">true</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> Parcel::readFileDescriptor() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">const</span> flat_binder_object* flat = readObject(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">if</span> (flat) {</div><div class="line">        <span class="keyword">switch</span> (flat-&gt;type) {</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_FD:           </div><div class="line">                <span class="comment">//LOGI("Returning file descriptor %ld from parcel %p\n", flat-&gt;handle, this);</span></div><div class="line">                <span class="keyword">return</span> flat-&gt;handle;</div><div class="line">        }        </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> BAD_TYPE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后，是到 Parcel ，通过 <code>flat_binder_object</code> 来传递的。回想下前面几篇的内容，Parcel 传递 <code>flat_binder_object</code> 到 binder 驱动的时候，有好几种类型，当时是不是有一种 <code>BINDER_TYPE_FD</code> 类型被选择性的无视了，现在知道这个 FD 是专门拿来倒腾 fd 用的了吧。这里 writeDupFileDescriptor 用 dup 复制了一个 fd 封装在 <code>flat_binder_object</code> 里面，然后 kernel 那里倒腾后面再说。反正 binder 传到 Proc B 那边，通过 Parcelable 的 CREATEOR 调用到 readFileDescriptor 会把 <code>flat_binder_object</code> 读出来，然后这里的 fd 就是经过倒腾的，是 Proc B 进程能够用的了。</p>
<p>Proc B 拿到 fd 后就可以 mmap Proc A 创建的共享内存了（还是创建 MemroyFile）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Creates a reference to an existing memory file. Changes to the original file</span></div><div class="line"><span class="comment"> * will be available through this reference.</span></div><div class="line"><span class="comment"> * Calls to {@link #allowPurging(boolean)} on the returned MemoryFile will fail.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param fd File descriptor for an existing memory file, as returned by</span></div><div class="line"><span class="comment"> *        {@link #getFileDescriptor()}. This file descriptor will be closed</span></div><div class="line"><span class="comment"> *        by {@link #close()}.</span></div><div class="line"><span class="comment"> * @param length Length of the memory file in bytes.</span></div><div class="line"><span class="comment"> * @param mode File mode. Currently only "r" for read-only access is supported.</span></div><div class="line"><span class="comment"> * @throws NullPointerException if &lt;code&gt;fd&lt;/code&gt; is null.</span></div><div class="line"><span class="comment"> * @throws IOException If &lt;code&gt;fd&lt;/code&gt; does not refer to an existing memory file,</span></div><div class="line"><span class="comment"> *         or if the file mode of the existing memory file is more restrictive</span></div><div class="line"><span class="comment"> *         than &lt;code&gt;mode&lt;/code&gt;.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @hide</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="title">MemoryFile</span>(FileDescriptor fd, <span class="keyword">int</span> length, String mode) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"File descriptor is null."</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!isMemoryFile(fd)) {       </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not a memory file."</span>);</div><div class="line">    }</div><div class="line">    mLength = length;</div><div class="line">    mFD = fd;</div><div class="line">    mAddress = native_mmap(mFD, length, modeToProt(mode));</div><div class="line">    mOwnsRegion = <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个就是 Proc A 那里省去了 open 的操作（当然，因为有现成的 fd 了）。Proc B 也把共享内存文件 mmap 到本进程后，A、B 就可以通过 MemroyFile 的 read、write 接口读写了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java ================================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Reads bytes from the memory file.</span></div><div class="line"><span class="comment">     * Will throw an IOException if the file has been purged.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param buffer byte array to read bytes into.</span></div><div class="line"><span class="comment">     * @param srcOffset offset into the memory file to read from.</span></div><div class="line"><span class="comment">     * @param destOffset offset into the byte array buffer to read into.</span></div><div class="line"><span class="comment">     * @param count number of bytes to read.</span></div><div class="line"><span class="comment">     * @return number of bytes read.</span></div><div class="line"><span class="comment">     * @throws IOException if the memory file has been purged or deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> readBytes(byte[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count) </div><div class="line">            throws IOException {           </div><div class="line">        <span class="keyword">if</span> (isDeactivated()) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can't read from deactivated memory file."</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (destOffset &lt; <span class="number">0</span> || destOffset &gt; buffer.length || count &lt; <span class="number">0</span></div><div class="line">                || count &gt; buffer.length - destOffset</div><div class="line">                || srcOffset &lt; <span class="number">0</span> || srcOffset &gt; mLength</div><div class="line">                || count &gt; mLength - srcOffset) { </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> native_read(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Write bytes to the memory file.</span></div><div class="line"><span class="comment">     * Will throw an IOException if the file has been purged.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param buffer byte array to write bytes from.</span></div><div class="line"><span class="comment">     * @param srcOffset offset into the byte array buffer to write from.</span></div><div class="line"><span class="comment">     * @param destOffset offset  into the memory file to write to.</span></div><div class="line"><span class="comment">     * @param count number of bytes to write.</span></div><div class="line"><span class="comment">     * @throws IOException if the memory file has been purged or deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> writeBytes(byte[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count)</div><div class="line">            throws IOException {           </div><div class="line">        <span class="keyword">if</span> (isDeactivated()) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can't write to deactivated memory file."</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (srcOffset &lt; <span class="number">0</span> || srcOffset &gt; buffer.length || count &lt; <span class="number">0</span></div><div class="line">                || count &gt; buffer.length - srcOffset</div><div class="line">                || destOffset &lt; <span class="number">0</span> || destOffset &gt; mLength</div><div class="line">                || count &gt; mLength - destOffset) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">        }</div><div class="line">        native_write(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// jni ================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_read(JNIEnv* env, jobject clazz,</div><div class="line">        jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset,</div><div class="line">        jint count, jboolean unpinned)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    <span class="keyword">if</span> (unpinned && ashmem_pin_region(fd, <span class="number">0</span>, <span class="number">0</span>) == ASHMEM_WAS_PURGED) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem region was purged"</span>);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    env-&gt;SetByteArrayRegion(buffer, destOffset, count, (<span class="keyword">const</span> jbyte *)address + srcOffset);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (unpinned) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_write(JNIEnv* env, jobject clazz,</div><div class="line">        jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset,</div><div class="line">        jint count, jboolean unpinned)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    <span class="keyword">if</span> (unpinned && ashmem_pin_region(fd, <span class="number">0</span>, <span class="number">0</span>) == ASHMEM_WAS_PURGED) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem region was purged"</span>);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    env-&gt;GetByteArrayRegion(buffer, srcOffset, count, (jbyte *)address + destOffset);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (unpinned) {</div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>jni 里面，除去那个 unpinned 不看（mAllowPurging 默认是 false），read 和 write 很简单，就是单纯的从 mAddress（mmap 到本进程的地址）读或写数据（数据都是二进制的，至于怎么用，那是上层业务的事情了）。就算手动设置了 mAllowPurging（2.3 的源码系统里面也没主动设置的地方），<code>ashmem_pin_region</code> 的范围都是 0，在 kernel 驱动中， 0 代表整块区域，所以就算设置了，也暂时没起到分块使用的作用。所以这些就忽略这些东西（主要是我也不太懂 -_-||）。</p>
<p>是用完之后就可以调用 close 接口，先 munmap 内存映射，然后再关掉共享内存文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java ================================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Closes the memory file. If there are no other open references to the memory</span></div><div class="line"><span class="comment">     * file, it will be deleted.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> close() {</div><div class="line">        deactivate();</div><div class="line">        <span class="keyword">if</span> (!isClosed()) {</div><div class="line">            native_close(mFD);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Unmaps the memory file from the process's memory space, but does not close it.</span></div><div class="line"><span class="comment">     * After this method has been called, read and write operations through this object</span></div><div class="line"><span class="comment">     * will fail, but {@link #getFileDescriptor()} will still return a valid file descriptor.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @hide</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> deactivate() {</div><div class="line">        <span class="keyword">if</span> (!isDeactivated()) {        </div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                native_munmap(mAddress, mLength);</div><div class="line">                mAddress = <span class="number">0</span>;</div><div class="line">            } <span class="keyword">catch</span> (IOException ex) {     </div><div class="line">                Log.e(TAG, ex.toString());     </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Checks whether the memory file has been deactivated.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> boolean isDeactivated() {</div><div class="line">        <span class="keyword">return</span> mAddress == <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Checks whether the memory file has been closed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> boolean isClosed() {</div><div class="line">        <span class="keyword">return</span> !mFD.valid();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// jni ================================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jint android_os_MemoryFile_mmap(JNIEnv* env, jobject clazz, jobject fileDescriptor,</div><div class="line">        jint length, jint prot)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    jint result = (jint)mmap(NULL, length, prot, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!result)</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"mmap failed"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line">    </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_MemoryFile_munmap(JNIEnv* env, jobject clazz, jint addr, jint length)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> result = munmap((<span class="keyword">void</span> *)addr, length);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"munmap failed"</span>);</div><div class="line">}</div><div class="line">            </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_MemoryFile_close(JNIEnv* env, jobject clazz, jobject fileDescriptor)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        jniSetFileDescriptorOfFD(env, fileDescriptor, -<span class="number">1</span>);</div><div class="line">        close(fd);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>jni 里面直接就是系统调用了。open 了就要 close，mmap 了就要 munmap， 没啥好说的。前面说为什么 4.1 之后 java 的 MemroyFile 应该就没法用了呢。仔细看下上面，我贴的几个接口，是 hide 的有：</p>
<pre config="brush:bash;toolbar:false;">
public MemoryFile(FileDescriptor fd, int length, String mode) 
public ParcelFileDescriptor getParcelFileDescriptor()
</pre>

<p>这普通应用正常情况下，根本就没办法用 MemroyFile。所以后面直接把这几个 hide 接口给干掉了。所以我感觉 android 在 java 上不想普通应用直接使用 ashmem，因为很多东西是系统帮你使用了 ashmem，例如传递稍微大一点的 Bitmap。可能 android 觉得在该使用 ashmem 的地方，系统帮你弄好了，你就不要瞎操心了。</p>
<h2 id="native_层接口">native 层接口</h2>
<p>java 层的 MemroyFile 基本是残废的，但是 native 层的接口可是齐全的。native 层的 android 搞了2个：</p>
<ul>
<li><strong>MemroyHeapBase</strong>： 这个类代表一块共享内存区域。</li>
<li><strong>MemroyBase</strong>： 这个是上面一块共享内存区域中的一段，就是说 native 层中是支持一段、一段的使用的（不过大多时候是把上面一块就当成一块用 -_-||）。</li>
<li><strong>IMemory</strong>： binder 接口。</li>
</ul>
<p>流程也是和原理一样的，先是 Proc A 创建一块共享内存区域（创建一个 MemroyHeapBase 对象）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, <span class="keyword">char</span> <span class="keyword">const</span> * name)</div><div class="line">    : mFD(-<span class="number">1</span>), mSize(<span class="number">0</span>), mBase(MAP_FAILED), mFlags(flags),</div><div class="line">      mDevice(<span class="number">0</span>), mNeedUnmap(<span class="keyword">false</span>), mOffset(<span class="number">0</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> size_t pagesize = getpagesize();</div><div class="line">    <span class="comment">// 页面字节对齐，native 层的就是讲究效率</span></div><div class="line">    size = ((size + pagesize-<span class="number">1</span>) & ~(pagesize-<span class="number">1</span>));</div><div class="line">    <span class="keyword">int</span> fd = ashmem_create_region(name == NULL ? <span class="string">"MemoryHeapBase"</span> : name, size);</div><div class="line">    ALOGE_IF(fd&lt;<span class="number">0</span>, <span class="string">"error creating ashmem region: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (mapfd(fd, size) == NO_ERROR) {</div><div class="line">            <span class="keyword">if</span> (flags & READ_ONLY) {       </div><div class="line">                ashmem_set_prot_region(fd, PROT_READ);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>底层的接口和 jni 的的一样的，创建也是调用 libcutils 的 ashmem-dev.c 相关接口。然后 mapfd 是 mmap 内存到本进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">status_t MemoryHeapBase::mapfd(<span class="keyword">int</span> fd, size_t size, uint32_t offset)</div><div class="line">{</div><div class="line">    <span class="comment">// 如果不指定大小，则尝试自动分配，不过一般使用者都会指定大小的</span></div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</div><div class="line">        <span class="comment">// try to figure out the size automatically</span></div><div class="line"><span class="preprocessor">#ifdef HAVE_ANDROID_OS</span></div><div class="line">        <span class="comment">// first try the PMEM ioctl    </span></div><div class="line">        pmem_region reg;</div><div class="line">        <span class="keyword">int</span> err = ioctl(fd, PMEM_GET_TOTAL_SIZE, ®);</div><div class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">            size = reg.len;</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) { <span class="comment">// try fstat  </span></div><div class="line">            <span class="keyword">struct</span> stat sb;</div><div class="line">            <span class="keyword">if</span> (fstat(fd, &sb) == <span class="number">0</span>)       </div><div class="line">                size = sb.st_size;             </div><div class="line">        }</div><div class="line">        <span class="comment">// if it didn't work, let mmap() fail.</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 一般也不会指定 DONT_MAP_LOCALLY 这个标志，这个标志就不会 mmap 内存了</span></div><div class="line">    <span class="keyword">if</span> ((mFlags & DONT_MAP_LOCALLY) == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">void</span>* base = (uint8_t*)mmap(<span class="number">0</span>, size, </div><div class="line">                PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);</div><div class="line">        <span class="keyword">if</span> (base == MAP_FAILED) {      </div><div class="line">            ALOGE(<span class="string">"mmap(fd=%d, size=%u) failed (%s)"</span>,</div><div class="line">                    fd, uint32_t(size), strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            <span class="keyword">return</span> -errno;</div><div class="line">        }</div><div class="line">        <span class="comment">//ALOGD("mmap(fd=%d, base=%p, size=%lu)", fd, base, size);</span></div><div class="line">        mBase = base;</div><div class="line">        mNeedUnmap = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">else</span>  {</div><div class="line">        mBase = <span class="number">0</span>; <span class="comment">// not MAP_FAILED</span></div><div class="line">        mNeedUnmap = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    mFD = fd;</div><div class="line">    mSize = size;</div><div class="line">    mOffset = offset;</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数正常情况下，排除那几个特殊标志，就是调用了系统接口 mmap，然后把 fd，映射得到的地址，大小，偏移保存了一下。这下 Proc A 的共享内存区域就创建好了。不过前面说了， native 层的接口，真正使用的是 MemroyBase，这个可以从 MemroyHeapBase 中指定一段区域来使用，这里我们考虑把 MemroyHeapBase 当成一整块来使用。MemroyXx 都实现了 binder 相关的接口（忘记了的，回去看第一篇原理，其实封装搞多了我也是醉了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我把相关代码贴全点，帮大家回想起 binder 相关的接口</span></div><div class="line"><span class="comment">// IMemroy ================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> BnMemoryHeap : <span class="keyword">public</span> BnInterface&lt;IMemoryHeap&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact( </div><div class="line">            uint32_t code,</div><div class="line">            <span class="keyword">const</span> Parcel& data,</div><div class="line">            Parcel* reply,</div><div class="line">            uint32_t flags = <span class="number">0</span>); </div><div class="line">        </div><div class="line">    BnMemoryHeap();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~BnMemoryHeap();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// MemroyHeapBase =========================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> MemoryHeapBase : <span class="keyword">public</span> <span class="keyword">virtual</span> BnMemoryHeap</div><div class="line">{</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// MemroyBase =============================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> MemoryBase : <span class="keyword">public</span> BnMemory </div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MemoryBase(<span class="keyword">const</span> sp&lt;IMemoryHeap&gt;& heap, ssize_t offset, size_t size);</div><div class="line">    <span class="keyword">virtual</span> ~MemoryBase();</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(ssize_t* offset, size_t* size) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    size_t getSize() <span class="keyword">const</span> { <span class="keyword">return</span> mSize; }</div><div class="line">    ssize_t getOffset() <span class="keyword">const</span> { <span class="keyword">return</span> mOffset; }</div><div class="line">    <span class="keyword">const</span> sp&lt;IMemoryHeap&gt;& getHeap() <span class="keyword">const</span> { <span class="keyword">return</span> mHeap; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    size_t          mSize;</div><div class="line">    ssize_t         mOffset;</div><div class="line">    sp&lt;IMemoryHeap&gt; mHeap;</div><div class="line">};</div><div class="line"></div><div class="line">MemoryBase::MemoryBase(<span class="keyword">const</span> sp&lt;IMemoryHeap&gt;& heap,</div><div class="line">        ssize_t offset, size_t size)</div><div class="line">    : mSize(size), mOffset(offset), mHeap(heap)</div><div class="line">{</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以说，举个例子说，Proc A 中创建了一个 2048 byte 的 MemroyHeapBase，要整块一起使用，应该是下面这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ProcA : <span class="keyword">public</span> BinderService&lt;ProcA&gt;, </div><div class="line">                    <span class="keyword">public</span> BnProcA</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="keyword">const</span>* getServiceName() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"ProcA"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    ProcA();</div><div class="line">    ~ProcA();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact(uint32_t code, <span class="keyword">const</span> Parcel& data,</div><div class="line">        Parcel* reply, uint32_t flags);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemory&gt; getMemory();</div><div class="line"></div><div class="line">    sp&lt;MemoryBase&gt; mMemory;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line">ProcA::K7Service()</div><div class="line">    :   BnK7() {</div><div class="line">    sp&lt;MemoryHeapBase&gt; heap = <span class="keyword">new</span> MemoryHeapBase(<span class="number">2048</span>, <span class="number">0</span>, <span class="string">"K7Service"</span>);</div><div class="line">    mMemory = <span class="keyword">new</span> MemoryBase(heap, <span class="number">0</span>, <span class="number">2048</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那么接下来 Proc A 只要把 fd 倒腾给 Proc B 就行了。不过这里 fd 是封装在 MemroyHeapBase 里面的，真正使用的又是 MemroyBase，而且又实现了 binder 接口，当然得一层层转。首先得把 MemroyBase 传给 Proc B，MemroyBase 的 binder 接口是 IMemroy（IBinder），把这个通过 binder 扔给 Proc B 先。我们假设在 Proc A 的 binder 接口中有一个教 getMemroy 的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IProcA =================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> BpProcA : <span class="keyword">public</span> BpInterface&lt;IProcA&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemory&gt; getMemory() {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IProcA::getInterfaceDescriptor());</div><div class="line">        remote()-&gt;transact(BnProcA::GET_MEMORY, data, &reply);</div><div class="line">        sp&lt;IMemory&gt; memory = interface_cast&lt;IMemory&gt;(reply.readStrongBinder());</div><div class="line">        <span class="keyword">return</span> memory;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">status_t BnProcA::onTransact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span>(code) {</div><div class="line">        <span class="keyword">case</span> GET_MEMORY: {</div><div class="line">            CHECK_INTERFACE(IProcA, data, reply);</div><div class="line">            sp&lt;IMemory&gt; memory = getMemory();</div><div class="line">            reply-&gt;writeStrongBinder(memory-&gt;asBinder());</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ProcA ==================================</span></div><div class="line"></div><div class="line">sp&lt;IMemory&gt; K7Service::getMemory() { </div><div class="line">    <span class="keyword">return</span> mMemory;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Parcel 的 readStrongBinder 和 writeStrongBinder 前面说过了，Parcel 的 <code>flat_binder_object</code> 专门用来传递 binder 对象的。IMemroy 传到 Proc B 后，来看看 IMemroy 有哪些接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IMemroy.h ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> IMemory : <span class="keyword">public</span> IInterface</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DECLARE_META_INTERFACE(Memory);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(ssize_t* offset=<span class="number">0</span>, size_t* size=<span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// helpers</span></div><div class="line">    <span class="keyword">void</span>* fastPointer(<span class="keyword">const</span> sp&lt;IBinder&gt;& heap, ssize_t offset) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">void</span>* pointer() <span class="keyword">const</span>;</div><div class="line">    size_t size() <span class="keyword">const</span>;</div><div class="line">    ssize_t offset() <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> BnMemory : <span class="keyword">public</span> BnInterface&lt;IMemory&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact(</div><div class="line">            uint32_t code,</div><div class="line">            <span class="keyword">const</span> Parcel& data,            </div><div class="line">            Parcel* reply,</div><div class="line">            uint32_t flags = <span class="number">0</span>);</div><div class="line"></div><div class="line">    BnMemory();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~BnMemory();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IMemroy.cpp ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">void</span>* IMemory::pointer() <span class="keyword">const</span> {</div><div class="line">    ssize_t offset;</div><div class="line">    sp&lt;IMemoryHeap&gt; heap = getMemory(&offset);</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> base = heap!=<span class="number">0</span> ? heap-&gt;base() : MAP_FAILED;</div><div class="line">    <span class="keyword">if</span> (base == MAP_FAILED)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(base) + offset;</div><div class="line">}</div><div class="line"></div><div class="line">size_t IMemory::size() <span class="keyword">const</span> {</div><div class="line">    size_t size;</div><div class="line">    getMemory(NULL, &size);</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">}</div><div class="line"></div><div class="line">ssize_t IMemory::offset() <span class="keyword">const</span> {</div><div class="line">    ssize_t offset;</div><div class="line">    getMemory(&offset);</div><div class="line">    <span class="keyword">return</span> offset;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>基本上可以看得出， pointer() 是返回共享内存的地址，这个地址是已经映射到 Proc B 中了的，就是可以直接读、写了的。然后 size() 和 offset() 分别是返回大小和偏移（例子中是 2048 和 0）。</p>
<p>然后，它们都调用了一个比较关键的函数叫 getMemroy：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MemroyBase ===============================</span></div><div class="line"></div><div class="line">sp&lt;IMemoryHeap&gt; MemoryBase::getMemory(ssize_t* offset, size_t* size) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset;</div><div class="line">    <span class="keyword">if</span> (size)   *size = mSize;</div><div class="line">    <span class="keyword">return</span> mHeap;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// IMemroy ==================================</span></div><div class="line"></div><div class="line">sp&lt;IMemoryHeap&gt; BpMemory::getMemory(ssize_t* offset, size_t* size) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mHeap == <span class="number">0</span>) {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());</div><div class="line">        <span class="keyword">if</span> (remote()-&gt;transact(GET_MEMORY, data, &reply) == NO_ERROR) {</div><div class="line">            sp&lt;IBinder&gt; heap = reply.readStrongBinder();</div><div class="line">            ssize_t o = reply.readInt32(); </div><div class="line">            size_t s = reply.readInt32();  </div><div class="line">            <span class="keyword">if</span> (heap != <span class="number">0</span>) {</div><div class="line">                mHeap = interface_cast&lt;IMemoryHeap&gt;(heap);</div><div class="line">                <span class="keyword">if</span> (mHeap != <span class="number">0</span>) {              </div><div class="line">                    mOffset = o;                   </div><div class="line">                    mSize = s;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset; </div><div class="line">    <span class="keyword">if</span> (size) *size = mSize;</div><div class="line">    <span class="keyword">return</span> mHeap;</div><div class="line">}</div><div class="line"></div><div class="line">status_t BnMemory::onTransact(</div><div class="line">    uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    <span class="keyword">switch</span>(code) {</div><div class="line">        <span class="keyword">case</span> GET_MEMORY: {</div><div class="line">            CHECK_INTERFACE(IMemory, data, reply);</div><div class="line">            ssize_t offset;</div><div class="line">            size_t size;</div><div class="line">            reply-&gt;writeStrongBinder( getMemory(&offset, &size)-&gt;asBinder() );</div><div class="line">            reply-&gt;writeInt32(offset);     </div><div class="line">            reply-&gt;writeInt32(size);       </div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个叫 getMemroy 的最后其实是把 MemoryBase 用的 MemoryHeapBase 的 binder 接口（IMemroyHeap）传了过来（前面说了要一层层转的吧）。然后我们就得来看看 IMemroyHeap 的接口了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MemroyHeapBase ============================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> MemoryHeapBase::getHeapID() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">return</span> mFD;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// IMemroy.h ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> IMemoryHeap : <span class="keyword">public</span> IInterface</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DECLARE_META_INTERFACE(MemoryHeap);</div><div class="line"></div><div class="line">    <span class="comment">// flags returned by getFlags()</span></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        READ_ONLY   = <span class="number">0x00000001</span>       </div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">int</span>         getHeapID() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>*       getBase() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> size_t      getSize() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> uint32_t    getFlags() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> uint32_t    getOffset() <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// these are there just for backward source compatibility</span></div><div class="line">    int32_t heapID() <span class="keyword">const</span> { <span class="keyword">return</span> getHeapID(); }</div><div class="line">    <span class="keyword">void</span>*   base() <span class="keyword">const</span>  { <span class="keyword">return</span> getBase(); }</div><div class="line">    size_t  virtualSize() <span class="keyword">const</span> { <span class="keyword">return</span> getSize(); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> BnMemoryHeap : <span class="keyword">public</span> BnInterface&lt;IMemoryHeap&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> status_t onTransact(</div><div class="line">            uint32_t code,</div><div class="line">            <span class="keyword">const</span> Parcel& data,            </div><div class="line">            Parcel* reply,</div><div class="line">            uint32_t flags = <span class="number">0</span>);           </div><div class="line">    </div><div class="line">    BnMemoryHeap();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~BnMemoryHeap();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IMemroy.cpp ==================================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> BpMemoryHeap::getHeapID() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mHeapId;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span>* BpMemoryHeap::getBase() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mBase;</div><div class="line">}</div><div class="line"></div><div class="line">size_t BpMemoryHeap::getSize() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mSize;</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t BpMemoryHeap::getFlags() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mFlags;</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t BpMemoryHeap::getOffset() <span class="keyword">const</span> {</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mOffset;</div><div class="line">}</div><div class="line"></div><div class="line">status_t BnMemoryHeap::onTransact(</div><div class="line">        uint32_t code, <span class="keyword">const</span> Parcel& data, Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    <span class="keyword">switch</span>(code) {</div><div class="line">       <span class="keyword">case</span> HEAP_ID: {</div><div class="line">            CHECK_INTERFACE(IMemoryHeap, data, reply);</div><div class="line">            reply-&gt;writeFileDescriptor(getHeapID());</div><div class="line">            reply-&gt;writeInt32(getSize());  </div><div class="line">            reply-&gt;writeInt32(getFlags()); </div><div class="line">            reply-&gt;writeInt32(getOffset());</div><div class="line">            <span class="keyword">return</span> NO_ERROR;  </div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>上面 IMemory 那里获取到 IMemroyHeap 后，调用的是 base(), 这个最后是调用 getBaes() 的。但是这几个 Bp 端的接口实现，无一例外，全都调用了另一个关键的函数（又是关键的 -_-||）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertMapped() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {</div><div class="line">        sp&lt;IBinder&gt; binder(<span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)-&gt;asBinder());</div><div class="line">        sp&lt;BpMemoryHeap&gt; heap(<span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(find_heap(binder).get()));</div><div class="line">        heap-&gt;assertReallyMapped();    </div><div class="line">        <span class="keyword">if</span> (heap-&gt;mBase != MAP_FAILED) {</div><div class="line">            Mutex::Autolock _l(mLock);     </div><div class="line">            <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {           </div><div class="line">                mBase   = heap-&gt;mBase;         </div><div class="line">                mSize   = heap-&gt;mSize;         </div><div class="line">                mOffset = heap-&gt;mOffset;       </div><div class="line">                android_atomic_write( dup( heap-&gt;mHeapId ), &mHeapId );</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// something went wrong        </span></div><div class="line">            free_heap(binder);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertReallyMapped() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {</div><div class="line"></div><div class="line">        <span class="comment">// 注释好像是说为了性能，不在 transact 远程调用加锁，只在后面 mmap 那里加锁</span></div><div class="line">        <span class="comment">// remote call without mLock held, worse case scenario, we end up</span></div><div class="line">        <span class="comment">// calling transact() from multiple threads, but that's not a problem,</span></div><div class="line">        <span class="comment">// only mmap below must be in the critical section.</span></div><div class="line"></div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemoryHeap::getInterfaceDescriptor());</div><div class="line">        status_t err = remote()-&gt;transact(HEAP_ID, data, &reply);</div><div class="line">        <span class="keyword">int</span> parcel_fd = reply.readFileDescriptor();</div><div class="line">        ssize_t size = reply.readInt32();</div><div class="line">        uint32_t flags = reply.readInt32();</div><div class="line">        uint32_t offset = reply.readInt32();</div><div class="line"></div><div class="line">        ALOGE_IF(err, <span class="string">"binder=%p transaction failed fd=%d, size=%ld, err=%d (%s)"</span>,</div><div class="line">                asBinder().get(), parcel_fd, size, err, strerror(-err));</div><div class="line"></div><div class="line">        <span class="keyword">int</span> fd = dup( parcel_fd );</div><div class="line">        ALOGE_IF(fd==-<span class="number">1</span>, <span class="string">"cannot dup fd=%d, size=%ld, err=%d (%s)"</span>,</div><div class="line">                parcel_fd, size, err, strerror(errno));</div><div class="line"></div><div class="line">        <span class="keyword">int</span> access = PROT_READ;</div><div class="line">        <span class="keyword">if</span> (!(flags & READ_ONLY)) {</div><div class="line">            access |= PROT_WRITE;</div><div class="line">        }</div><div class="line"></div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        <span class="keyword">if</span> (mHeapId == -<span class="number">1</span>) {</div><div class="line">            mRealHeap = <span class="keyword">true</span>;</div><div class="line">            mBase = mmap(<span class="number">0</span>, size, access, MAP_SHARED, fd, offset);</div><div class="line">            <span class="keyword">if</span> (mBase == MAP_FAILED) {</div><div class="line">                ALOGE(<span class="string">"cannot map BpMemoryHeap (binder=%p), size=%ld, fd=%d (%s)"</span>,</div><div class="line">                        asBinder().get(), size, fd, strerror(errno));</div><div class="line">                close(fd);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mSize = size;</div><div class="line">                mFlags = flags;</div><div class="line">                mOffset = offset;</div><div class="line">                <span class="comment">// mHeapId 就是 fd 啊</span></div><div class="line">                android_atomic_write(fd, &mHeapId);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 Proc B 是要用到共享内存才会去 mmap 的。assertMapped()、assertReallyMapped() 这2个名字还真直白。 mHeapId 就是 Proc A 倒腾给 Proc B 的 fd，如果为 -1 表示 Proc B 还没 mmap 过，所以进入 assert(Really)Mapped() 进行 mmap 。assertMapped() 那里有个 <code>find_heap</code> 的东西，看起来挺多余的，直接调用自己的函数有那么费劲么，后面看了下注释好像是拿来调试用的，那就不用管它了。然后 assertReallyMapped 就和 java 层的差不多了，先是发一个 <code>HEAP_ID</code> 给 MemoryHeapBase 的 Bn 让它把 Proc A 那边的 fd 通过 Parcel 的 writeFileDescriptor 倒腾<br>过来。注意这里调用的是 native Parcel 的 writeFileDescriptor，而上面 java 的是 writeDupFileDescriptor，所以 Proc B Bp 这边接到后，要自己手动 dup(fd) 一次 -_-||。然后就 mmap 了，报得到的地址、大小、偏移保存一下，Proc B 就能读写了。</p>
<p>native 层的接口返回的直接是地址，读写比 java 层的灵活很多。然后 native 的 close、munmap 都是在析够函数中进行的，可以说配合 android 的智能指针（其实我挺讨厌这玩意），可以说使用无脑（用 sp<imemory>，初始化的时候 new 出来，在析构函数里置为 NULL 就行了）。</imemory></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 因为主要 open、mmap 都是 MemoryHeapBase 做的，MemoryBase 只是把地址、偏移设置了下，</span></div><div class="line"><span class="comment">// 所以 close、munmap 都只要 MemoryHeapBase 来做就行了，MemoryBase 不用做什么清理的。</span></div><div class="line"></div><div class="line"><span class="comment">// Bn 端（Proc A）的关闭</span></div><div class="line"><span class="comment">// MemroyHeapBase ==================================</span></div><div class="line"></div><div class="line">MemoryHeapBase::~MemoryHeapBase()</div><div class="line">{</div><div class="line">    dispose();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> MemoryHeapBase::dispose()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = android_atomic_or(-<span class="number">1</span>, &mFD); </div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (mNeedUnmap) {</div><div class="line">            <span class="comment">//ALOGD("munmap(fd=%d, base=%p, size=%lu)", fd, mBase, mSize);</span></div><div class="line">            munmap(mBase, mSize);          </div><div class="line">        }</div><div class="line">        mBase = <span class="number">0</span>;</div><div class="line">        mSize = <span class="number">0</span>;</div><div class="line">        close(fd);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Bp 端（Proc B）的关闭 </span></div><div class="line"><span class="comment">// IMemroy ==================================</span></div><div class="line"></div><div class="line">BpMemoryHeap::~BpMemoryHeap() {</div><div class="line">    <span class="keyword">if</span> (mHeapId != -<span class="number">1</span>) {</div><div class="line">        close(mHeapId);</div><div class="line">        <span class="keyword">if</span> (mRealHeap) {</div><div class="line">            <span class="comment">// by construction we're the last one</span></div><div class="line">            <span class="keyword">if</span> (mBase != MAP_FAILED) {</div><div class="line">                sp&lt;IBinder&gt; binder = <span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)-&gt;asBinder();</div><div class="line">    </div><div class="line">                <span class="keyword">if</span> (VERBOSE) {</div><div class="line">                    ALOGD(<span class="string">"UNMAPPING binder=%p, heap=%p, size=%d, fd=%d"</span>,</div><div class="line">                            binder.get(), <span class="keyword">this</span>, mSize, mHeapId);</div><div class="line">                    CallStack <span class="built_in">stack</span>(LOG_TAG);</div><div class="line">                }</div><div class="line">    </div><div class="line">                munmap(mBase, mSize);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// remove from list only if it was mapped before</span></div><div class="line">            sp&lt;IBinder&gt; binder = <span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)-&gt;asBinder();</div><div class="line">            free_heap(binder);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>又是 MemoryHeapBase、MemoryBase、IMemoryBase、IMemory 是不是有点头晕咧，主要是 android 在 native 层搞了2个东西，加那一堆 binder 接口，这还没 java 层简洁（虽然 java 层的被废掉了 -_-||）。最后来张图吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-ashmem/1.png" alt=""></p>
<h2 id="kernel_驱动">kernel 驱动</h2>
<p>上面把应用层的接口说往了，下面就要讲 kernel 里面的驱动了。最开始的时候说了， ashmem 是基于 linux 的 tmpfs 实现的，所以最好要有点这方面的知识，不过目前我还是不太清楚 tmpfs 相关的接口用法 -_-||，等以后找点书来看补补吧。</p>
<p>前面那些接口最后面就是调用到 libcutils 的 ashmem-dev.c 中的那些接口，那些接口最后都是 open 或是 ioctl 的系统调用，这些最后都是进入到 kernel 的 ashmem 驱动当中。</p>
<p>我们先来看下 ashmem 驱动加载初始化的时候：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * ashmem_area - anonymous shared memory area</span></div><div class="line"><span class="comment"> * Lifecycle: From our parent file's open() until its release()</span></div><div class="line"><span class="comment"> * Locking: Protected by `ashmem_mutex'</span></div><div class="line"><span class="comment"> * Big Note: Mappings do NOT pin this structure; it dies on close()</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct</span> ashmem_area {</div><div class="line">    <span class="keyword">char</span> name[ASHMEM_FULL_NAME_LEN];<span class="comment">/* optional name for /proc/pid/maps */</span></div><div class="line">    <span class="keyword">struct</span> list_head unpinned_list; <span class="comment">/* list of all ashmem areas */</span> </div><div class="line">    <span class="keyword">struct</span> file *file;      <span class="comment">/* the shmem-based backing file */</span></div><div class="line">    size_t size;            <span class="comment">/* size of the mapping, in bytes */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prot_mask;    <span class="comment">/* allowed prot bits, as vm_flags */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kmem_cache *ashmem_area_cachep __read_mostly;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kmem_cache *ashmem_range_cachep __read_mostly;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init ashmem_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">// 为 ashmem 驱动的数据结构创建一块后备高速缓存</span></div><div class="line">    ashmem_area_cachep = kmem_cache_create(<span class="string">"ashmem_area_cache"</span>,</div><div class="line">                      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_area),</div><div class="line">                      <span class="number">0</span>, <span class="number">0</span>, NULL);</div><div class="line">    <span class="keyword">if</span> (unlikely(!ashmem_area_cachep)) {</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to create slab cache\n"</span>);</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这块数据结构是 pin/unpin 相关的，无视 ... ...</span></div><div class="line">    ashmem_range_cachep = kmem_cache_create(<span class="string">"ashmem_range_cache"</span>,</div><div class="line">                      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_range),</div><div class="line">                      <span class="number">0</span>, <span class="number">0</span>, NULL);</div><div class="line">    <span class="keyword">if</span> (unlikely(!ashmem_range_cachep)) {</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to create slab cache\n"</span>);</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 注册驱动操作相关函数</span></div><div class="line">    ret = misc_register(&ashmem_misc);</div><div class="line">    <span class="keyword">if</span> (unlikely(ret)) {</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to register misc device!\n"</span>);</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 注册内存回收扫描算法，继续无视 ... ...</span></div><div class="line">    register_shrinker(&ashmem_shrinker);</div><div class="line"></div><div class="line">    printk(KERN_INFO <span class="string">"ashmem: initialized\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// exit 函数很多对应上面 init 的注销、销毁操作</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit ashmem_exit(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    unregister_shrinker(&ashmem_shrinker);</div><div class="line"></div><div class="line">    ret = misc_deregister(&ashmem_misc);</div><div class="line">    <span class="keyword">if</span> (unlikely(ret))</div><div class="line">        printk(KERN_ERR <span class="string">"ashmem: failed to unregister misc device!\n"</span>);</div><div class="line"></div><div class="line">    kmem_cache_destroy(ashmem_range_cachep);</div><div class="line">    kmem_cache_destroy(ashmem_area_cachep);</div><div class="line"></div><div class="line">    printk(KERN_INFO <span class="string">"ashmem: unloaded\n"</span>);</div><div class="line">}</div><div class="line"></div><div class="line">module_init(ashmem_init);</div><div class="line">module_exit(ashmem_exit);</div><div class="line"></div></pre></td></tr></table></figure>

<p>init 和 exit 函数是 kernel 第一次加载 ashmem 模块的时候调用的，一般做一些驱动初始化或是申请资源相关的操作。这里首先在 kernel 的后备高速缓存区开辟的一段空间，用来申请 <code>struct ashmem_area</code> 这个驱动相关的结构体的存储空间。这个后备高速缓存据说是应用于反复的多次分配的情况，因为 ashmem 本身就是出于性能考虑设计的，所以选择使用这个吧，能够加快分配内存的速度（注意这里只是分配驱动保存一些状态的数据结构，不是共享内存本身）。这个后备高速缓存好像又叫 slab 分配器，好像是 kernel 里面挺快的一个东西 -_-|| 。</p>
<p>然后后面那个和 pin/unpin 还有内存回收算法相关的，我现在不打算去分析，因为第一，这个东西前面说过了，现在基本上没用；第二，最主要的是我也不是很清楚这些玩意 -_-||。再后注册驱动操作相关函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations ashmem_fops = {</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .open = ashmem_open,</div><div class="line">    .release = ashmem_release,</div><div class="line">        .read = ashmem_read,  </div><div class="line">        .llseek = ashmem_llseek,       </div><div class="line">    .mmap = ashmem_mmap,</div><div class="line">    .unlocked_ioctl = ashmem_ioctl,</div><div class="line">    .compat_ioctl = ashmem_ioctl,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice ashmem_misc = {</div><div class="line">    .minor = MISC_DYNAMIC_MINOR,</div><div class="line">    .name = <span class="string">"ashmem"</span>,</div><div class="line">    .fops = &ashmem_fops,</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>稍微接触过点 linux 驱动的都应该知道，这个 <code>file_operations</code> 就是 linux 文件设备驱动（linux 上所有设置都是文件）的操作函数。例如说上层应用对本设备调用 open 对应的驱动函数就是 .open 对应的，然后依此类推：</p>
<pre>
mmap  --> .mmap(ashmem_mapp)
ioctl --> .unlocked_ioctl(ashmem_ioctl)
          .compat_ioctl(ashmem_ioctl)
close --> .release(ashmem_release)
read  --> .read(ashmem_read)
seek  --> llseek(ashmem_llseek)
</pre>

<p><code>file_operations</code> 的操作函数不止这几个，没实现的就不支持对应的操作，上层调用接口，会返回错误值。以前 2.3 的 ashmem 不支持 read 和 seek 的，4.x 的开始支持啦，不过这里只关注另外几个重要的。</p>
<p>首先是 Proc A 调用 open 创建共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">// 调用系统方法打开文件</span></div><div class="line">    ret = generic_file_open(inode, file);</div><div class="line">    <span class="keyword">if</span> (unlikely(ret))</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">// 在 init 创建的高速缓存区，申请 struct ashmem_area 变量</span></div><div class="line">    asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (unlikely(!asma))</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&asma-&gt;unpinned_list);</div><div class="line">    <span class="comment">// 保持打开的文件的名字</span></div><div class="line">    <span class="built_in">memcpy</span>(asma-&gt;name, ASHMEM_NAME_PREFIX, ASHMEM_NAME_PREFIX_LEN);</div><div class="line">    asma-&gt;prot_mask = PROT_MASK;</div><div class="line">    <span class="comment">// 保持驱动私有变量</span></div><div class="line">    file-&gt;private_data = asma;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数 kernel 传递过来2个参数，第一个 inode 是文件设备节点，前面说了一个真实的文件只有一个设备节点。后面那个是文件指针，但是一个文件可以打开多次，每打开一次就有一个文件指针对应。那个 <code>generic_file_open</code> kernel 的接口，具体目前我也不是很清楚，反正就理解为调用 kernel 接口打开指定的文件设备吧 -_-||。然后利用 init 中开辟的高速缓存创建驱动的私有驱动数据，看上面， ashmem 的私有结构挺简单的，基本上就是名字、大小、打开的文件指针和端口标志（那个 unpin 的 list 咱们无视）。然后这里强制把名字的前缀设置为： </p>
<pre config="brush:bash;toolbar:false;">
#define ASHMEM_NAME_PREFIX "dev/ashmem/"
</pre>

<p>注意这里只是设置前缀而已，后面有 <code>set_name</code> 的 ioctl 接口的，这个接口是把用户设置的名字加在后面而已，基本上名字就是： “dev/shmem/xx”，这个名字感觉除了在 cat /proc/pid/maps 的时候显示一下以外就没啥别的用处了（而且好多应用还不设置）。</p>
<p>然后就是把在高速缓存区创建的 <code>ashmem_area</code> 保持在 file-&gt;private_data 这个字段中。这是很多驱动的通用做法，把私有的数据结构保持在这个字段，在后面的 ioctl 里面能取出来用。</p>
<p>然后 Proc A 就该调用 mmap 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_mmap(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">    mutex_lock(&ashmem_mutex);</div><div class="line"></div><div class="line">    <span class="comment">// 在调用 mmap 之前必须调用 ioctl SET_SIZE -_-||</span></div><div class="line">    <span class="comment">/* user needs to SET_SIZE before mapping */</span></div><div class="line">    <span class="keyword">if</span> (unlikely(!asma-&gt;size)) {</div><div class="line">        ret = -EINVAL;        </div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* requested protection bits must match our allowed protection mask */</span></div><div class="line">    <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags & ~calc_vm_prot_bits(asma-&gt;prot_mask)) &</div><div class="line">                        calc_vm_prot_bits(PROT_MASK))) {</div><div class="line">        ret = -EPERM;         </div><div class="line">        <span class="keyword">goto</span> out;             </div><div class="line">    }</div><div class="line">    vma-&gt;vm_flags &= ~calc_vm_may_flags(~asma-&gt;prot_mask);</div><div class="line"></div><div class="line">    <span class="comment">// 还没创建共享内存文件，则创建</span></div><div class="line">    <span class="keyword">if</span> (!asma-&gt;file) {</div><div class="line">        <span class="keyword">char</span> *name = ASHMEM_NAME_DEF;  </div><div class="line">        <span class="keyword">struct</span> file *vmfile;  </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (asma-&gt;name[ASHMEM_NAME_PREFIX_LEN] != <span class="string">'\0'</span>)</div><div class="line">            name = asma-&gt;name;</div><div class="line"></div><div class="line">        <span class="comment">// 在 tmpfs 文件系统上创建共享内存文件</span></div><div class="line">        <span class="comment">/* ... and allocate the backing shmem file */</span></div><div class="line">        vmfile = shmem_file_setup(name, asma-&gt;size, vma-&gt;vm_flags);</div><div class="line">        <span class="keyword">if</span> (unlikely(IS_ERR(vmfile))) {</div><div class="line">            ret = PTR_ERR(vmfile);</div><div class="line">            <span class="keyword">goto</span> out;</div><div class="line">        }</div><div class="line">        asma-&gt;file = vmfile;</div><div class="line">    }</div><div class="line">    get_file(asma-&gt;file);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags & VM_SHARED)</div><div class="line">        shmem_set_file(vma, asma-&gt;file);</div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (vma-&gt;vm_file)</div><div class="line">            fput(vma-&gt;vm_file);</div><div class="line">        vma-&gt;vm_file = asma-&gt;file;</div><div class="line">    }</div><div class="line">    vma-&gt;vm_flags |= VM_CAN_NONLINEAR;</div><div class="line"></div><div class="line">out:</div><div class="line">    mutex_unlock(&ashmem_mutex);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> ashmem_ioctl(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</div><div class="line">    <span class="keyword">long</span> ret = -ENOTTY;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    <span class="keyword">case</span> ASHMEM_SET_NAME:</div><div class="line">        ret = set_name(asma, (<span class="keyword">void</span> __user *) arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_NAME:</div><div class="line">        ret = get_name(asma, (<span class="keyword">void</span> __user *) arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_SET_SIZE:</div><div class="line">        ret = -EINVAL;</div><div class="line">        <span class="keyword">if</span> (!asma-&gt;file) {</div><div class="line">            ret = <span class="number">0</span>;</div><div class="line">            asma-&gt;size = (size_t) arg;     </div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_SIZE:</div><div class="line">        ret = asma-&gt;size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_SET_PROT_MASK:</div><div class="line">        ret = set_prot_mask(asma, arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_PROT_MASK:</div><div class="line">        ret = asma-&gt;prot_mask;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_PIN:</div><div class="line">    <span class="keyword">case</span> ASHMEM_UNPIN:</div><div class="line">    <span class="keyword">case</span> ASHMEM_GET_PIN_STATUS:</div><div class="line">        ret = ashmem_pin_unpin(asma, cmd, (<span class="keyword">void</span> __user *) arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ASHMEM_PURGE_ALL_CACHES:</div><div class="line">        ret = -EPERM;</div><div class="line">        <span class="keyword">if</span> (capable(CAP_SYS_ADMIN)) {</div><div class="line">            <span class="keyword">struct</span> shrink_control sc = {</div><div class="line">                .gfp_mask = GFP_KERNEL,</div><div class="line">                .nr_to_scan = <span class="number">0</span>,</div><div class="line">            };</div><div class="line">            ret = ashmem_shrink(&ashmem_shrinker, &sc);</div><div class="line">            sc.nr_to_scan = ret;</div><div class="line">            ashmem_shrink(&ashmem_shrinker, &sc);</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>mmap 一开始要在调用前需要调用 ioctl <code>SET_SIZE</code> 设置这片共享内存区域的大小。回去前面看下 <code>ashmem_create_region</code> 是不是在 open 之后，调用了 ioctl 去设置大小。所以我把 ioctl 那部分也贴出来了，<code>SET_SIZE</code> 其实很简单，就是把 asm-&gt;size 设置了一下。但是我觉得有点奇怪，上层调用 mmap 的时候也传了 size 了（size 和 调用 ioctl 的一样），那为什么不像 binder 的那样使用 vma 中的 size 。这点我就暂时无法理解了（对 kernel 相关的知识不太了解）。</p>
<p>然后后面的就能更难理解了，调用 <code>shmem_file_setup</code> 据说好像是 kernel 的 tmpfs 的接口，然后从参数看，姑且就认为在 tmpfs 上创建了一个名字为 name，大小为 asm-&gt;size 的文件，用于共享内存。后面那个 <code>get_file</code> 也不知道用处是什么（主要是没百度到）。然后 flags，前面 mmap 的时候，都设置了 <code>MAP_SHARED</code>，这里 <code>shmem_set_file</code> 就说是 android 在 kernel 中自己加的接口，我就更不知道是干啥用的了。不过看名字，加上参数，好像是激活刚刚创建的文件吧。然后就完了 -_-||。</p>
<p>其实 ashmem 的 kernel 驱动，这里就只能大致讲个原理，具体的因为不太懂 kernel 文件系统、I/O 相关的东西，没办法继续分析下去了，等以后再说吧。</p>
<p>然后就应该到 Proc A 把 fd 倒腾给 Proc B 了，这里倒腾要借助 binder 的驱动。还记得 Parcel 的 <code>flat_binder_object</code> 么，binder 的驱动专门处理这个东西的，那么就要去看 Parcel 的 <code>flat_binder_object</code> 在 binder 里面怎么倒腾的了。前面说 <code>BINDER_TYPE_FD</code> 这个类型就是专门到来倒腾 fd 的，这个在 <code>binder_transaction</code> 中（忘记流程了的，回去复习下前面几篇）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete;</div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list;</div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(size_t))) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">            <span class="string">"invalid offsets size, %zd\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    }</div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line">        <span class="keyword">struct</span> flat_binder_object *fp;</div><div class="line">        <span class="keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            t-&gt;buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">                <span class="string">"invalid offset, %zd\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, *offp);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_offset;</div><div class="line">        }</div><div class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) {</div><div class="line">        ... ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="keyword">int</span> target_fd;</div><div class="line">            <span class="keyword">struct</span> file *file;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (reply) {</div><div class="line">                <span class="comment">// 如果目标对象不接受 fd 的话则报错，前面 Parcel 调用那个相关接口的时候设置了这个标志的</span></div><div class="line">                <span class="keyword">if</span> (!(in_reply_to-&gt;flags & TF_ACCEPT_FDS)) {</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%d got reply with fd, %ld, but target does not allow fds\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_fd_not_allowed;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (!target_node-&gt;accept_fds) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got transaction with fd, %ld, but target does not allow fds\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_fd_not_allowed;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 这个 fp-&gt;handle 就是前面的 fd</span></div><div class="line">            <span class="comment">// 通过 fd 取得 file 文件指针</span></div><div class="line">            file = fget(fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (file == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid fd, %ld\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_fget_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 寻找目标进程（target_proc: Proc B）中空闲的 fd</span></div><div class="line">            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);</div><div class="line">            <span class="keyword">if</span> (target_fd &lt; <span class="number">0</span>) {</div><div class="line">                fput(file);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_get_unused_fd_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 在目标进程空闲的 fd 中安装 file 文件指针</span></div><div class="line">            task_fd_install(target_proc, target_fd, file);</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        fd %ld -&gt; %d\n"</span>, fp-&gt;handle, target_fd);</div><div class="line">            <span class="comment">// 把转化好的目标进程的 fd 设回 flat_binder_object 传递给上层应用</span></div><div class="line">            <span class="comment">/* TODO: fput? */</span></div><div class="line">            fp-&gt;handle = target_fd;</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transactio"</span></div><div class="line">                <span class="string">"n with invalid object type, %lx\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, fp-&gt;type);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_object_type;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里倒腾的主要是另外2个函数： </p>
<p><code>task_get_unused_fd_flags</code>： 在目标进程中找到空闲的 fd<br><code>task_fd_install</code>： 在目标进程空闲的 fd 中安装 Proc A 中打开的文件指针</p>
<p>我看来看下这2个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * copied from get_unused_fd_flags</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> task_get_unused_fd_flags(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> flags)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> files_struct *files = proc-&gt;files;</div><div class="line">    <span class="keyword">int</span> fd, error;</div><div class="line">    <span class="keyword">struct</span> fdtable *fdt;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rlim_cur;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> irqs;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (files == NULL)</div><div class="line">        <span class="keyword">return</span> -ESRCH;</div><div class="line"></div><div class="line">    error = -EMFILE;</div><div class="line">    spin_lock(&files-&gt;file_lock);</div><div class="line"></div><div class="line">repeat:</div><div class="line">    fdt = files_fdtable(files);</div><div class="line">    fd = find_next_zero_bit(fdt-&gt;open_fds-&gt;fds_bits, fdt-&gt;max_fds,</div><div class="line">                files-&gt;next_fd);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * N.B. For clone tasks sharing a files structure, this test</span></div><div class="line"><span class="comment">     * will limit the total number of files that can be opened.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    rlim_cur = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (lock_task_sighand(proc-&gt;tsk, &irqs)) {</div><div class="line">        rlim_cur = proc-&gt;tsk-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur;</div><div class="line">        unlock_task_sighand(proc-&gt;tsk, &irqs);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (fd &gt;= rlim_cur)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">    <span class="comment">/* Do we need to expand the fd array or fd set?  */</span></div><div class="line">    error = expand_files(files, fd);</div><div class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) {</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * If we needed to expand the fs array we</span></div><div class="line"><span class="comment">         * might have blocked - try again.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        error = -EMFILE;</div><div class="line">        <span class="keyword">goto</span> repeat;</div><div class="line">    }</div><div class="line"></div><div class="line">    FD_SET(fd, fdt-&gt;open_fds);</div><div class="line">    <span class="keyword">if</span> (flags & O_CLOEXEC)</div><div class="line">        FD_SET(fd, fdt-&gt;close_on_exec);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        FD_CLR(fd, fdt-&gt;close_on_exec);</div><div class="line">    files-&gt;next_fd = fd + <span class="number">1</span>;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> 1</span></div><div class="line">    <span class="comment">/* Sanity check */</span></div><div class="line">    <span class="keyword">if</span> (fdt-&gt;fd[fd] != NULL) {</div><div class="line">        printk(KERN_WARNING <span class="string">"get_unused_fd: slot %d not NULL!\n"</span>, fd);</div><div class="line">        fdt-&gt;fd[fd] = NULL;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    error = fd;</div><div class="line"></div><div class="line">out:</div><div class="line">    spin_unlock(&files-&gt;file_lock);</div><div class="line">    <span class="keyword">return</span> error;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * copied from fd_install</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> task_fd_install(</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc, <span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">struct</span> file *file)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> files_struct *files = proc-&gt;files;</div><div class="line">    <span class="keyword">struct</span> fdtable *fdt;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (files == NULL)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    spin_lock(&files-&gt;file_lock);</div><div class="line">    fdt = files_fdtable(files);</div><div class="line">    BUG_ON(fdt-&gt;fd[fd] != NULL);</div><div class="line">    rcu_assign_pointer(fdt-&gt;fd[fd], file);</div><div class="line">    spin_unlock(&files-&gt;file_lock);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这2个函数现在的我完全无法解释啥，看注释好像是从 kernel 的文件 I/O 中抄过来的，我又醉了 -_-|| 。反正就知道经过这2个函数的倒腾后，Proc A 的 fd 就能扔给 Proc B 用了。然后 Proc B 就能那这个 fd 去 mmap Proc A 在 tmpfs 上创建的共享内存文件了。然后 mmap 到地址后，就能读、写了。</p>
<p>呃，最后看看 close 的操作吧（这个相对能理解点）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_release(<span class="keyword">struct</span> inode *ignored, <span class="keyword">struct</span> file *file)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> ashmem_range *range, *next;</div><div class="line"></div><div class="line">    mutex_lock(&ashmem_mutex);</div><div class="line">    list_for_each_entry_safe(range, next, &asma-&gt;unpinned_list, unpinned)</div><div class="line">        range_del(range);</div><div class="line">    mutex_unlock(&ashmem_mutex);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (asma-&gt;file)</div><div class="line">        fput(asma-&gt;file);</div><div class="line">    kmem_cache_free(ashmem_area_cachep, asma);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>抛去 pin/unping 的不看，这里就是把 open 里面从高速缓存中申请的 <code>ashmem_area</code> 给释放掉了。</p>
<h2 id="例子">例子</h2>
<p>上面说了那么多，咋来点例子来看下 framework 中是怎么使用 ashmem 的。前面说 java 层 android 不希望开发者自己倒腾 ashmem，这里我们拿用 Parcel 传递 Bitmap 为例子。图片算是比较大型的资源了，大的图片也很占内存，当你使用 Parcel 传递 Bitmap android 自动帮我们使用 ashmem 了，因为 Bitmap 是 Parcelable 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Bitmap&gt; CREATOR</div><div class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;Bitmap&gt;() {</div><div class="line">    <span class="javadoc">/**  </span></div><div class="line"><span class="javadoc">     * Rebuilds a bitmap previously stored with writeToParcel().</span></div><div class="line"><span class="javadoc">     *</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @param</span> p    Parcel object to read the bitmap from</span></div><div class="line"><span class="javadoc">     *<span class="javadoctag"> @return</span> a new bitmap created from the data in the parcel</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">public</span> Bitmap <span class="title">createFromParcel</span>(Parcel p) { </div><div class="line">        Bitmap bm = nativeCreateFromParcel(p);</div><div class="line">        <span class="keyword">if</span> (bm == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to unparcel Bitmap"</span>);</div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span> bm;</div><div class="line">    }    </div><div class="line">    <span class="keyword">public</span> Bitmap[] <span class="title">newArray</span>(<span class="keyword">int</span> size) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bitmap[size];</div><div class="line">    }    </div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * No special parcel contents.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span>() {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Write the bitmap and its pixels to the parcel. The bitmap can be</span></div><div class="line"><span class="comment"> * rebuilt from the parcel by calling CREATOR.createFromParcel().</span></div><div class="line"><span class="comment"> * @param p    Parcel object to write the bitmap data into</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span>(Parcel p, <span class="keyword">int</span> flags) {</div><div class="line">    checkRecycled(<span class="string">"Can't parcel a recycled bitmap"</span>);</div><div class="line">    <span class="keyword">if</span> (!nativeWriteToParcel(mNativeBitmap, mIsMutable, mDensity, p)) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"native writeToParcel failed"</span>);</div><div class="line">    }    </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>挂 jni 的马甲咧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,</div><div class="line">                                     <span class="keyword">const</span> SkBitmap* bitmap,</div><div class="line">                                     jboolean isMutable, jint density,</div><div class="line">                                     jobject parcel) {</div><div class="line">    <span class="keyword">if</span> (parcel == NULL) {</div><div class="line">        SkDebugf(<span class="string">"------- writeToParcel null parcel\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 通过 java 的 Parcel 对象获取 native 层的 parcel 对象</span></div><div class="line">    android::Parcel* p = android::parcelForJavaObject(env, parcel);</div><div class="line"></div><div class="line">    <span class="comment">// 把 bitmap 的一些配置信息写进去</span></div><div class="line">    p-&gt;writeInt32(isMutable);</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;config());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;width());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;height());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;rowBytes());</div><div class="line">    p-&gt;writeInt32(density);</div><div class="line"></div><div class="line">    <span class="comment">// 如果是 index 格式，不使用 ashmem，直接拿 Parcel 申请普通内存传递</span></div><div class="line">    <span class="comment">// 颜色索引格式的图片占用资源一般都不大</span></div><div class="line">    <span class="keyword">if</span> (bitmap-&gt;getConfig() == SkBitmap::kIndex8_Config) {</div><div class="line">        SkColorTable* ctable = bitmap-&gt;getColorTable();</div><div class="line">        <span class="keyword">if</span> (ctable != NULL) {</div><div class="line">            <span class="keyword">int</span> count = ctable-&gt;count();</div><div class="line">            p-&gt;writeInt32(count);</div><div class="line">            <span class="built_in">memcpy</span>(p-&gt;writeInplace(count * <span class="keyword">sizeof</span>(SkPMColor)),</div><div class="line">                   ctable-&gt;lockColors(), count * <span class="keyword">sizeof</span>(SkPMColor));</div><div class="line">            ctable-&gt;unlockColors(<span class="keyword">false</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p-&gt;writeInt32(<span class="number">0</span>);   <span class="comment">// indicate no ctable</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    size_t size = bitmap-&gt;getSize();</div><div class="line"></div><div class="line">    <span class="comment">// 其它格式（最常见的 ARGB）是用 ashmem</span></div><div class="line">    <span class="comment">// 这个 Blob 是 Parcel 的一个简单的封装类</span></div><div class="line">    android::Parcel::WritableBlob blob;</div><div class="line">    <span class="comment">// writeBlob 就是创建 size 大小的 ashmem</span></div><div class="line">    android::status_t status = p-&gt;writeBlob(size, &blob);</div><div class="line">    <span class="keyword">if</span> (status) {</div><div class="line">        doThrowRE(env, <span class="string">"Could not write bitmap to parcel blob."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    bitmap-&gt;lockPixels();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* pSrc =  bitmap-&gt;getPixels();</div><div class="line">    <span class="keyword">if</span> (pSrc == NULL) {</div><div class="line">        <span class="built_in">memset</span>(blob.data(), <span class="number">0</span>, size);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// memcpy， 这里需要 copy 一次</span></div><div class="line">        <span class="built_in">memcpy</span>(blob.data(), pSrc, size);</div><div class="line">    }</div><div class="line">    bitmap-&gt;unlockPixels();</div><div class="line"></div><div class="line">    <span class="comment">// 图片 pixels 复制完了可以 munmap 了</span></div><div class="line">    blob.release();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数主要是调用 Parcel 的 writeBlob 创建 ashmem，并初始化 Blob。然后把 bitmap 的 pixels 数据 copy 到 ashmem 中，注意 copy 完之后 Proc A 就不再需要对 ashmem 进行操作了，所以后面就 munmap（下面 Blob 的代码可以看到 release 只是 munmap 而已，没 close，这里还不能 close 要等 Proc B 读完才能 close）。<br>然后我们看下 Parcel 的 Blob 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Parcel.h ==================================</span></div><div class="line"></div><div class="line">    <span class="keyword">class</span> Blob {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Blob();</div><div class="line">        ~Blob();</div><div class="line"></div><div class="line">        <span class="keyword">void</span> release();</div><div class="line">        <span class="keyword">inline</span> size_t size() <span class="keyword">const</span> { <span class="keyword">return</span> mSize; } </div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="keyword">void</span> init(<span class="keyword">bool</span> mapped, <span class="keyword">void</span>* data, size_t size);</div><div class="line">        <span class="keyword">void</span> clear();</div><div class="line"></div><div class="line">        <span class="comment">// true 表示 mmap 过，release 的时候需要 munmap</span></div><div class="line">        <span class="keyword">bool</span> mMapped;</div><div class="line">        <span class="comment">// mmap 的内存地址</span></div><div class="line">        <span class="keyword">void</span>* mData;    </div><div class="line">        <span class="comment">// mmap 的内存大小      </span></div><div class="line">        size_t mSize;</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="comment">// Parcel.cpp ==================================</span></div><div class="line"></div><div class="line">Parcel::Blob::Blob() :</div><div class="line">        mMapped(<span class="keyword">false</span>), mData(NULL), mSize(<span class="number">0</span>) {</div><div class="line">}</div><div class="line"></div><div class="line">Parcel::Blob::~Blob() {</div><div class="line">    release();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::Blob::release() {</div><div class="line">    <span class="keyword">if</span> (mMapped && mData) {</div><div class="line">        ::munmap(mData, mSize);        </div><div class="line">    }</div><div class="line">    clear();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::Blob::init(<span class="keyword">bool</span> mapped, <span class="keyword">void</span>* data, size_t size) {</div><div class="line">    mMapped = mapped;</div><div class="line">    mData = data;</div><div class="line">    mSize = size;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Parcel::Blob::clear() {</div><div class="line">    mMapped = <span class="keyword">false</span>;</div><div class="line">    mData = NULL;</div><div class="line">    mSize = <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>十分简单，然后再来看 Parcel Blob 相关操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)</div><div class="line">{</div><div class="line">    status_t status;</div><div class="line"></div><div class="line">    <span class="comment">// 这里判断下，如果禁用 ashmem 或是要创建的 ashmem 不够大，不让使用</span></div><div class="line">    <span class="comment">// 直接用普通内存代替，果然前面 bitmap 判断小空间不用是正确的</span></div><div class="line">    <span class="keyword">if</span> (!mAllowFds || len &lt;= IN_PLACE_BLOB_LIMIT) {</div><div class="line">        ALOGV(<span class="string">"writeBlob: write in place"</span>);</div><div class="line">        status = writeInt32(<span class="number">0</span>);        </div><div class="line">        <span class="keyword">if</span> (status) <span class="keyword">return</span> status;     </div><div class="line"></div><div class="line">        <span class="keyword">void</span>* ptr = writeInplace(len); </div><div class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> NO_MEMORY;    </div><div class="line"></div><div class="line">        outBlob-&gt;init(<span class="keyword">false</span> <span class="comment">/*mapped*/</span>, ptr, len);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 调用 libcutils 的接口创建 ashmem</span></div><div class="line">    ALOGV(<span class="string">"writeBlob: write to ashmem"</span>);</div><div class="line">    <span class="keyword">int</span> fd = ashmem_create_region(<span class="string">"Parcel Blob"</span>, len);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> NO_MEMORY;</div><div class="line"></div><div class="line">    <span class="comment">// 设置下 ashmem 的读、写权限</span></div><div class="line">    <span class="keyword">int</span> result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">        status = result;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 记起我们的例子：创建完之后，Proc A mmap 内存到本进程空间</span></div><div class="line">        <span class="keyword">void</span>* ptr = ::mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (ptr == MAP_FAILED) {       </div><div class="line">            status = -errno;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 这里这么又把端口设成只读的啦？？</span></div><div class="line">            result = ashmem_set_prot_region(fd, PROT_READ);</div><div class="line">            <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">                status = result;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 1 标志是用 ashmem 的</span></div><div class="line">                status = writeInt32(<span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (!status) {</div><div class="line">                    <span class="comment">// 前面分析的，用 flat_binder_object` 传 fd</span></div><div class="line">                    <span class="comment">// 注意下后面的 takeOwnership 是 true</span></div><div class="line">                    status = writeFileDescriptor(fd, <span class="keyword">true</span> <span class="comment">/*takeOwnership*/</span>);</div><div class="line">                    <span class="keyword">if</span> (!status) {</div><div class="line">                        <span class="comment">// 不错误的把地址保存在 Blob 中</span></div><div class="line">                        outBlob-&gt;init(<span class="keyword">true</span> <span class="comment">/*mapped*/</span>, ptr, len);</div><div class="line">                        <span class="keyword">return</span> NO_ERROR;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        ::munmap(ptr, len);</div><div class="line">    }</div><div class="line">    ::close(fd);</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后回去看 Bitmap createFromParcel 接口的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {</div><div class="line">    <span class="keyword">if</span> (parcel == NULL) {</div><div class="line">        SkDebugf(<span class="string">"-------- unparcel parcel is NULL\n"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 继续先获取 native Parcel 对象</span></div><div class="line">    android::Parcel* p = android::parcelForJavaObject(env, parcel);</div><div class="line"></div><div class="line">    <span class="comment">// 把之前写的配置读出来</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span>              isMutable = p-&gt;readInt32() != <span class="number">0</span>;</div><div class="line">    <span class="keyword">const</span> SkBitmap::Config  config = (SkBitmap::Config)p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               width = p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               height = p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               rowBytes = p-&gt;readInt32();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span>               density = p-&gt;readInt32();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (SkBitmap::kARGB_8888_Config != config && </div><div class="line">            SkBitmap::kRGB_565_Config != config &&</div><div class="line">            SkBitmap::kARGB_4444_Config != config &&</div><div class="line">            SkBitmap::kIndex8_Config != config &&</div><div class="line">            SkBitmap::kA8_Config != config) {</div><div class="line">        SkDebugf(<span class="string">"Bitmap_createFromParcel unknown config: %d\n"</span>, config);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    SkBitmap* bitmap = <span class="keyword">new</span> SkBitmap;</div><div class="line"></div><div class="line">    bitmap-&gt;setConfig(config, width, height, rowBytes);</div><div class="line"></div><div class="line">    <span class="comment">// 索引格式直接使用普通内存</span></div><div class="line">    SkColorTable* ctable = NULL;</div><div class="line">    <span class="keyword">if</span> (config == SkBitmap::kIndex8_Config) {</div><div class="line">        <span class="keyword">int</span> count = p-&gt;readInt32();</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</div><div class="line">            size_t size = count * <span class="keyword">sizeof</span>(SkPMColor);</div><div class="line">            <span class="keyword">const</span> SkPMColor* src = (<span class="keyword">const</span> SkPMColor*)p-&gt;readInplace(size);</div><div class="line">            ctable = <span class="keyword">new</span> SkColorTable(src, count);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 根据图片的大小申请内存空间</span></div><div class="line">    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);</div><div class="line">    <span class="keyword">if</span> (NULL == buffer) {</div><div class="line">        SkSafeUnref(ctable);</div><div class="line">        <span class="keyword">delete</span> bitmap;</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    SkSafeUnref(ctable);</div><div class="line"></div><div class="line">    size_t size = bitmap-&gt;getSize();</div><div class="line"></div><div class="line">    <span class="comment">// 在传过来的 Parcel 中通过 Blob 读取 ashmem 的内容</span></div><div class="line">    android::Parcel::ReadableBlob blob;</div><div class="line">    android::status_t status = p-&gt;readBlob(size, &blob);</div><div class="line">    <span class="keyword">if</span> (status) {</div><div class="line">        doThrowRE(env, <span class="string">"Could not read bitmap from parcel blob."</span>);</div><div class="line">        <span class="keyword">delete</span> bitmap;</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    bitmap-&gt;lockPixels();</div><div class="line">    <span class="comment">// 把 Proc A ashmem 里的内容（bitmap 的 pixels 数据）</span></div><div class="line">    <span class="comment">// copy 到刚刚申请的内存中，这里算第二次了吧</span></div><div class="line">    <span class="built_in">memcpy</span>(bitmap-&gt;getPixels(), blob.data(), size);</div><div class="line">    bitmap-&gt;unlockPixels();</div><div class="line"></div><div class="line">    <span class="comment">// 用完了释放下</span></div><div class="line">    blob.release();</div><div class="line"></div><div class="line">    <span class="comment">// 拿之前申请的内存（已经 copy 了 Proc A 的pixels）创建一个 Bitmap 对象</span></div><div class="line">    <span class="keyword">return</span> GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),</div><div class="line">            NULL, NULL, density);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 Parcel 的 readBlob：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    <span class="comment">// 前面 writeBlob 的时候，第一个 int 是 1 来着</span></div><div class="line">    int32_t useAshmem;</div><div class="line">    status_t status = readInt32(&useAshmem);</div><div class="line">    <span class="keyword">if</span> (status) <span class="keyword">return</span> status;</div><div class="line"></div><div class="line">    <span class="comment">// 第一个 int 不是 1 就表示是普通的内存</span></div><div class="line">    <span class="keyword">if</span> (!useAshmem) {</div><div class="line">        ALOGV(<span class="string">"readBlob: read in place"</span>);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* ptr = readInplace(len);</div><div class="line">        <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> BAD_VALUE;    </div><div class="line"></div><div class="line">        outBlob-&gt;init(<span class="keyword">false</span> <span class="comment">/*mapped*/</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">void</span>*&gt;(ptr), len);</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// readFileDescriptor 和 writeFileDescriptor 对应</span></div><div class="line">    <span class="comment">// Proc B 得到经过倒腾的 fd</span></div><div class="line">    ALOGV(<span class="string">"readBlob: read from ashmem"</span>);</div><div class="line">    <span class="keyword">int</span> fd = readFileDescriptor(); </div><div class="line">    <span class="keyword">if</span> (fd == <span class="keyword">int</span>(BAD_TYPE)) <span class="keyword">return</span> BAD_VALUE;</div><div class="line"></div><div class="line">    <span class="comment">// Proc B mmap 内存到本进程</span></div><div class="line">    <span class="keyword">void</span>* ptr = ::mmap(NULL, len, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>); </div><div class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">return</span> NO_MEMORY;</div><div class="line"></div><div class="line">    <span class="comment">// 把 mmap 到的地址、大小保存在 Blob 中</span></div><div class="line">    outBlob-&gt;init(<span class="keyword">true</span> <span class="comment">/*mapped*/</span>, ptr, len);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后最后是释放共享内存。前面 Proc A 写完后，Blob 的 release 只是 munmap 了而已，Proc B 也是读完，重新创建完 Bitmap 后，也是 release 只是 munmap。我们来看看是在哪里关闭 fd 的。本着谁 open、谁 close 的原则，应该是 Proc A 这边关闭的。后面有篇内存管理篇的， Parcel 的析构函数会调用 freeDataNoInit：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parcel::freeDataNoInit()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mOwner) {</div><div class="line">        <span class="comment">//ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());</span></div><div class="line">        mOwner(<span class="keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        releaseObjects();</div><div class="line">        <span class="keyword">if</span> (mData) <span class="built_in">free</span>(mData);        </div><div class="line">        <span class="keyword">if</span> (mObjects) <span class="built_in">free</span>(mObjects);  </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>内存管理那里是设置了 mOwner 了的，所以跑的是自己的 freeBuffer 回调，这里走的是下面，那主要是看 releaseObjects：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parcel::releaseObjects() </div><div class="line">{</div><div class="line">    <span class="keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    size_t i = mObjectsSize;</div><div class="line">    uint8_t* <span class="keyword">const</span> data = mData;</div><div class="line">    size_t* <span class="keyword">const</span> objects = mObjects;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</div><div class="line">        i--;</div><div class="line">        <span class="keyword">const</span> flat_binder_object* flat </div><div class="line">            = <span class="keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);</div><div class="line">        release_object(proc, *flat, <span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> release_object(<span class="keyword">const</span> sp&lt;ProcessState&gt;& proc,</div><div class="line">    <span class="keyword">const</span> flat_binder_object& obj, <span class="keyword">const</span> <span class="keyword">void</span>* who)</div><div class="line">{</div><div class="line">    <span class="keyword">switch</span> (obj.type) {</div><div class="line">        ... ...</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: {</div><div class="line">            <span class="comment">// 前面设置了 takeOwnership 是 true 的话，cookie 就是 1</span></div><div class="line">            <span class="keyword">if</span> (obj.cookie != (<span class="keyword">void</span>*)<span class="number">0</span>) close(obj.handle);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ALOGE(<span class="string">"Invalid object type 0x%08lx"</span>, obj.type);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然是在 Proc A 关闭 fd 的咧，前面 writeFileDescriptor 那里设置的 takeOwnership 是 true，所以 <code>flat_binder_object</code> 的 cookie 是 1 。Parcel 析构的时候，正好可以 close 掉 fd。一般 IPC 通信，Proc A 传过去的 Parcel 都是局部变量，等 IPC 通信完成，就析构了（Proc B 那边也用完了，所以这个时候 close 是安全的）。</p>
<p>所以从上面来看，java 层的 MemroyFile 确实没啥用，不过感觉可以用 Parcel 来代替咧，Parcel 的 Blob 就是封装好的 ashmem，也有 read、write 接口。然后如果在 binder 中传递 Bitmap 的话，使用 ashmem 需要 copy 2次 bitmap 的 pixels 数据，这个 android 应该是出于安全性考虑，把原始的 bitmap copy 了一份出来，扔 ashmem 里面，然后对方再申请一片空间把 ashmem 里的内容 copy 过去。这样话，Proc A 后面怎么折腾原始的 bitmap 都不会对 Proc B 的 bitmap有影响（包括 recycle）。</p>
<p>当然这样在高性能的环境下是不行的，可以自己通过 Parcel 的接口改造一下： Proc A 创建 ashmem，拿 ashmem 的 buffer 解码 bitmap，然后传 ashmem 给 Proc B，Proc B 直接在 ashmem 的 buffer 上再创建出 Bitmap。不过这样带来的风险就是你自己要管理好 ashmem 的 buffer，确保 Proc B 不用了，才能 munmap、close 。好像 SurfacFlinger 用的就是类似这样的方案，这个后面有时间再慢慢说。所以说不要有事没事跨进程传图片，还是大图片。</p>
<p>最后来个对比，如果 bitmap 不用 ashmem 传递，把 binder mmap 的内存改大，那么使用普通内存传递，需要 3次 copy（Proc A、Proc B 各自一次，Proc A —&gt; kernel 一次）。如果使用普通的 IPC 那么需要 4次 copy（Proc A、Proc B 各自一次，Proc A —&gt; kernel, kernel —&gt; Proc B）。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——匿名共享内存[Ashmem]/" data-title="Android Binder 分析——匿名共享内存（Ashmem） | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——数据传递者[Parcel]/" title="Android Binder 分析——数据传递者（Parcel）">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——数据传递者（Parcel）</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——内存管理/"  title="Android Binder 分析——内存管理">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——内存管理
</span>
</a>
</div>

</nav>


	
<section class="comment">
	<div class="ds-thread" data-thread-key="Android Binder 分析——匿名共享内存（Ashmem）" data-title="Android Binder 分析——匿名共享内存（Ashmem）" 
      data-author-key="mingming" data-limit=10
      data-url="light3moon.com/2015/01/28/Android Binder 分析——匿名共享内存[Ashmem]/">
    </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理概述"><span class="toc-number">1.</span> <span class="toc-text">原理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java_层接口"><span class="toc-number">2.</span> <span class="toc-text">java 层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#native_层接口"><span class="toc-number">3.</span> <span class="toc-text">native 层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel_驱动"><span class="toc-number">4.</span> <span class="toc-text">kernel 驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子"><span class="toc-number">5.</span> <span class="toc-text">例子</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>31</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>46</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>23</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/android/" title="android">android<sup>77</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">哥的后勤处 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-qqzone"></i> <a href="http://user.qzone.qq.com/544630305" target="_blank">QQ 空间</a></li>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">战斗力</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="commentlist">
  <p class="asidetitle">最近冒泡的小伙伴 ╰(●&#39;◡&#39;●)╮</p>
    <ul>
      <ul class="ds-recent-comments" 
        data-num-items="6" 
        data-show-avatars="1" 
        data-show-title="1"   
        data-show-time="1" 
        data-show-admin="1" 
        data-excerpt-length="30">
      </ul>
      <!-- duoshou js begin load, one page only load once -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"mingming"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- duoshou js load end -->
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	
		<a href="http://user.qzone.qq.com/544630305" target="_blank" title="qqzone"></a>
		         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2015 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"mingming"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
