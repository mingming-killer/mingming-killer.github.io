
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——通信模型 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="通信就要搞一些协议，binder 的比较简单，但是也有一个基本的模型，这里以最基本的一次 IPC 调用来说明一下。然后涉及的代码主要在（这里不列 java 层的代码了，java 层的代码前面原理篇分析过了，主要是挂马甲调用 native 的方法的）：
123456789# native binder">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">三月学长的小站</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——通信模型/" title="Android Binder 分析——通信模型" itemprop="url">Android Binder 分析——通信模型</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T12:29:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2017-02-07T13:47:51.000Z" itemprop="dateModified">2017 2月 7</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#流程"><span class="toc-number">1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、服务端等待请求"><span class="toc-number">2.</span> <span class="toc-text">1、服务端等待请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-_客户端发起_IPC_请求"><span class="toc-number">3.</span> <span class="toc-text">2. 客户端发起 IPC 请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-_服务端处理请求，并返回结果"><span class="toc-number">4.</span> <span class="toc-text">3. 服务端处理请求，并返回结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-_客户端接收到服务端返回的数据"><span class="toc-number">5.</span> <span class="toc-text">4. 客户端接收到服务端返回的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>通信就要搞一些协议，binder 的比较简单，但是也有一个基本的模型，这里以最基本的一次 IPC 调用来说明一下。然后涉及的代码主要在（这里不列 java 层的代码了，java 层的代码前面原理篇分析过了，主要是挂马甲调用 native 的方法的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># native binder 头文件</span></div><div class="line">frameworks/native/include/binder</div><div class="line"><span class="comment"># native binder 实现</span></div><div class="line">frameworks/native/libs/binder</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="流程">流程</h2>
<p>先上张图先，图我尽量简化，只画了 IPC 调用相关的东西（是 4.4 来分析的，之前的版本有点点小区别）：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-transaction/1.png" alt=""></p>
<h2 id="1、服务端等待请求">1、服务端等待请求</h2>
<p>首先看图上右边的服务（service）部分。service 进程运行起来，然后通过调用 IPCThreadState 的 joinThreadLoop 在本线程中开始等待客户端请求的到来。这里有2个问题：第一个，system service 必须向 service manager 注册自己；第二个，服务端的多线程支持问题。这里都后面再说。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</div><div class="line">{</div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n"</span>, (<span class="keyword">void</span>*)pthread_self(), getpid());</div><div class="line"></div><div class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line">    </div><div class="line">    <span class="comment">// This thread may have been spawned by a thread that was in the background</span></div><div class="line">    <span class="comment">// scheduling group, so first we will make sure it is in the foreground</span></div><div class="line">    <span class="comment">// one to avoid performing an initial transaction in the background.</span></div><div class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">             </div><div class="line">    status_t result;</div><div class="line">    <span class="keyword">do</span> { </div><div class="line">        processPendingDerefs();</div><div class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></div><div class="line">        result = getAndExecuteCommand();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR && result != TIMED_OUT && result != -ECONNREFUSED && result != -EBADF) {</div><div class="line">            ALOGE(<span class="string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,</div><div class="line">                  mProcess-&gt;mDriverFD, result);</div><div class="line">            <span class="built_in">abort</span>();</div><div class="line">        }    </div><div class="line">             </div><div class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></div><div class="line">        <span class="comment">// needed and it is not the main process thread.</span></div><div class="line">        <span class="keyword">if</span>(result == TIMED_OUT && !isMain) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }    </div><div class="line">    } <span class="keyword">while</span> (result != -ECONNREFUSED && result != -EBADF);</div><div class="line"></div><div class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%p\n"</span>,</div><div class="line">        (<span class="keyword">void</span>*)pthread_self(), getpid(), (<span class="keyword">void</span>*)result);</div><div class="line">    </div><div class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</div><div class="line">    talkWithDriver(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里看得出，这个函数是个循环（等待——处理——等待 … … 一般服务器的模型都是这样），参数 isMain 表示这个 service thread 是不是主线程，这个东西后面再说。循环里面主要是调用 getAndExecuteCommand 来处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::getAndExecuteCommand()</div><div class="line">{</div><div class="line">    status_t result;</div><div class="line">    int32_t cmd;</div><div class="line">        </div><div class="line">    result = talkWithDriver();</div><div class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">        size_t IN = mIn.dataAvail();</div><div class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        result = executeCommand(cmd);</div><div class="line">    </div><div class="line">        <span class="comment">// After executing the command, ensure that the thread is returned to the</span></div><div class="line">        <span class="comment">// foreground cgroup before rejoining the pool.  The driver takes care of</span></div><div class="line">        <span class="comment">// restoring the priority, but doesn't do anything with cgroups so we</span></div><div class="line">        <span class="comment">// need to take care of that here in userspace.  Note that we do make</span></div><div class="line">        <span class="comment">// sure to go in the foreground after executing a transaction, but</span></div><div class="line">        <span class="comment">// there are other callbacks into user code that could have changed</span></div><div class="line">        <span class="comment">// our group so we want to make absolutely sure it is put back.</span></div><div class="line">        set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>getAndExecuteCommand 这个名字就可以看得出这个函数主要干2个事情，一个取请求数据、一个就是处理请求数据：正好又分了2个函数： talkWithDriver 和 executeCommand（下面那个好像是设置线程优先级，先不理这些东西先）。</p>
<p>先来看下 talkWithDriver：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> -EBADF;</div><div class="line">    }</div><div class="line"> </div><div class="line">    binder_write_read bwr;</div><div class="line">        </div><div class="line">    <span class="comment">// Is the read buffer empty?</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</div><div class="line">    </div><div class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></div><div class="line">    <span class="comment">// from data left in the input buffer and the caller</span></div><div class="line">    <span class="comment">// has requested to read the next data.</span></div><div class="line">    <span class="keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line">    </div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</div><div class="line">        </div><div class="line">    <span class="comment">// This is what we'll read.</span></div><div class="line">    <span class="keyword">if</span> (doReceive && needRead) {</div><div class="line">        bwr.read_size = mIn.dataCapacity();</div><div class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        TextOutput::Bundle _b(alog);</div><div class="line">        <span class="keyword">if</span> (outAvail != <span class="number">0</span>) {</div><div class="line">            alog &lt;&lt; <span class="string">"Sending commands to driver: "</span> &lt;&lt; indent;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* cmds = (<span class="keyword">const</span> <span class="keyword">void</span>*)bwr.write_buffer;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* end = ((<span class="keyword">const</span> uint8_t*)cmds)+bwr.write_size;</div><div class="line">            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;</div><div class="line">            <span class="keyword">while</span> (cmds &lt; end) cmds = printCommand(alog, cmds);</div><div class="line">            alog &lt;&lt; dedent;</div><div class="line">        }</div><div class="line">        alog &lt;&lt; <span class="string">"Size of receive buffer: "</span> &lt;&lt; bwr.read_size</div><div class="line">            &lt;&lt; <span class="string">", needRead: "</span> &lt;&lt; needRead &lt;&lt; <span class="string">", doReceive: "</span> &lt;&lt; doReceive &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></div><div class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) && (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    status_t err;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"About to read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; endl;</div><div class="line">        }</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_ANDROID_OS)</span></div><div class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &bwr) &gt;= <span class="number">0</span>)</div><div class="line">            err = NO_ERROR;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            err = -errno;</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">        err = INVALID_OPERATION;</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) {</div><div class="line">            err = -EBADF;</div><div class="line">        }</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Finished read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    } <span class="keyword">while</span> (err == -EINTR);</div><div class="line"></div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        alog &lt;&lt; <span class="string">"Our err: "</span> &lt;&lt; (<span class="keyword">void</span>*)err &lt;&lt; <span class="string">", write consumed: "</span></div><div class="line">            &lt;&lt; bwr.write_consumed &lt;&lt; <span class="string">" (of "</span> &lt;&lt; mOut.dataSize()</div><div class="line">                        &lt;&lt; <span class="string">"), read consumed: "</span> &lt;&lt; bwr.read_consumed &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())</div><div class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                mOut.setDataSize(<span class="number">0</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) {</div><div class="line">            mIn.setDataSize(bwr.read_consumed);</div><div class="line">            mIn.setDataPosition(<span class="number">0</span>);</div><div class="line">        }</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            TextOutput::Bundle _b(alog);</div><div class="line">            alog &lt;&lt; <span class="string">"Remaining data size: "</span> &lt;&lt; mOut.dataSize() &lt;&lt; endl;</div><div class="line">            alog &lt;&lt; <span class="string">"Received commands from driver: "</span> &lt;&lt; indent;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* cmds = mIn.data();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* end = mIn.data() + mIn.dataSize();</div><div class="line">            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;</div><div class="line">            <span class="keyword">while</span> (cmds &lt; end) cmds = printReturnCommand(alog, cmds);</div><div class="line">            alog &lt;&lt; dedent;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>talkWithDriver 主要是调用 ioctl 去 kernel 的 binder 设备那里读数据。这里的 mDriverFD 是打开 binder 设备的文件描述符。在 ProcessState 的构造函数中会打开 binder 设备（一个进程只会开打一次，然后所有线程共用一个 fd）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ProcessState::ProcessState()</div><div class="line">    : mDriverFD(open_driver())</div><div class="line">... ...</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> open_driver()</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</div><div class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</div><div class="line">        <span class="keyword">int</span> vers;</div><div class="line">        status_t result = ioctl(fd, BINDER_VERSION, &vers);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) {</div><div class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</div><div class="line">            close(fd);</div><div class="line">            fd = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        size_t maxThreads = <span class="number">15</span>;</div><div class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &maxThreads);</div><div class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) {</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</div><div class="line">    } </div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>回到 talkWithDriver，ioctl 调用的命令是 <code>BINDER_WRITE_READ</code>，参数是 <code>binder_write_read</code> 这个结构。这里每个 IPCThreadState（service 的线程）都还有2个 Parcel 变量：mIn、mOut 分别用于打包发送和接收读取的数据。这些后面再分析 binder 的数据包的时候再说。这里只说前面要向 binder 发命令，就调用 mOut 写命令，要接收数据的话，talkWithDriver 的参数 doRevice 默认是 true，ioctl 能一次性完成读、写操作。</p>
<p>这里第一次 service 写是 0btye，读是 256btye（初始化的 mIn 的 Capacity 是 256，但是 service 开始并没有写入命令）。</p>
<p>然后 ioctl 就到了 kernel 的 binder 驱动里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line">    <span class="comment">/*printk(KERN_INFO "binder_ioctl: %d:%d %x %lx\n", proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></div><div class="line"></div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret; </div><div class="line"></div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    <span class="keyword">if</span> (thread == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err; </div><div class="line">    }</div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: {</div><div class="line">        <span class="keyword">struct</span> binder_write_read bwr; </div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) {</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">        <span class="keyword">if</span> (copy_from_user(&bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">        binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">                 <span class="string">"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</div><div class="line">                 bwr.read_size, bwr.read_buffer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) {</div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</div><div class="line">                bwr.read_consumed = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) {</div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &bwr.read_consumed, filp-&gt;f_flags & O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">                 <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</div><div class="line">                 bwr.read_consumed, bwr.read_size);</div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &bwr, <span class="keyword">sizeof</span>(bwr))) {</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>关于 ioctl 的一些基本知识可以参看下我的这篇文章：<br><a href="http://light3moon.com/2015/01/19/[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" title="[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" target="_blank" rel="external">[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</a> </p>
<p>这里稍微注意下，ioctl 里面 proc 表示本次调用的进程，thread 表示调用本次调用的线程（这2个主要是记录了进程号 pid 和线程号 tid）。然后第一次 write 的 size 是 0，所以没有处理 <code>binder_thread_write</code>。接下来是取数据： <code>binder_thread_read</code>（这里可以看到出，kernel 是先处理 write 再处理 read 的，原因到后面就知道了）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                  <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</div><div class="line">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</div><div class="line">{</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">    }</div><div class="line"></div><div class="line">retry:</div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == NULL &&</div><div class="line">                list_empty(&thread-&gt;todo);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (thread-&gt;return_error != BR_OK && ptr &lt; end) {</div><div class="line">        <span class="keyword">if</span> (thread-&gt;return_error2 != BR_OK) {</div><div class="line">            <span class="keyword">if</span> (put_user(thread-&gt;return_error2, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="keyword">if</span> (ptr == end)</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            thread-&gt;return_error2 = BR_OK;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (put_user(thread-&gt;return_error, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        thread-&gt;return_error = BR_OK;</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads++;</div><div class="line">    mutex_unlock(&binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) {</div><div class="line">        <span class="keyword">if</span> (!(thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">                    BINDER_LOOPER_STATE_ENTERED))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></div><div class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></div><div class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</div><div class="line">            wait_event_interruptible(binder_user_error_wait,</div><div class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">        }</div><div class="line">        binder_set_nice(proc-&gt;default_priority);</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (non_block) {</div><div class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</div><div class="line">    }</div><div class="line">    mutex_lock(&binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads--;</div><div class="line">    thread-&gt;looper &= ~BINDER_LOOPER_STATE_WAITING;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>来看下 <code>binder_thread_read</code> 的前面部分。这里 service 的 <code>wait_for_proc_work</code> 的值为 1，也是 true 的意思。一开始的 <code>thread-&gt;transaction_stack</code> 是 NULL 的，这个是表示这个线程的传递堆栈，类似于函数调用堆栈的东西，一开始没传递，这个堆栈肯定是空的（这个也后面再具体分析）。然后一开始 thread-&gt;todo 这链表也是空的，这个是表示这个线程上需要完成的工作，这个后面会知道是什么东西。</p>
<p>那根据上面的条件，这里 service 的 ioctl 调用就会跑到这里：</p>
<p><code>wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</code></p>
<p>wait event 是 kernel 里面的等待队列，在前面那篇 ioctl 的文章里有详细说明，它现在阻塞于 proc-&gt;wait 这个变量，如果唤醒 proc-&gt;wait 阻塞会结束。还有如果后面那个 <code>binder_has_proc_work</code> 返回值为 1（条件为 true） 阻塞也会结束。但是这里 <code>binder_has_proc_work</code> 不为 true：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个其实就是判断 proc 有没有需要完成的工作（前面那个是判断是 thread 的）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_has_proc_work(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                <span class="keyword">struct</span> binder_thread *thread)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> !list_empty(&proc-&gt;todo) ||</div><div class="line">        (thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<p>所以这里 <code>binder_thread_read</code> 要不阻塞，要么跑进来的时候 proc-&gt;todo 不为空（就是该进程有需要处理的工作），要么就只能等待有人唤醒 proc-&gt;wait 。这里对应图中 service 在等待客户端请求的到来，这个是在 kernel 中使用 wait queue（等待队列）实现的。</p>
<p>所以为什么先处理 <code>binder_thread_write</code> ，因为 <code>binder_thread_read</code> 会阻塞。</p>
<h2 id="2-_客户端发起_IPC_请求">2. 客户端发起 IPC 请求</h2>
<p>服务端已经在阻塞等待了，现在来看看客户端（client）这边（图中的左边部分）。client 调用一个 IPC 接口函数（例如调用 ActivityManager 的 startActivity 之类的），发起 IPC 调用，IPC 接口函数调用 Bp 的 transaction 函数，这些在前面的原理篇里有说过，获取 Bp 是通过 service manager 获取的（前面说 service 要在 service manager 注册就是为了 client 能通过 service manager 获取自己的 Bp），这里细节后面再说。</p>
<p>Bp 的 transaction 直接调用 IPCThreadState 的 transaction 函数（注意别头晕，servie、client 是共用一份代码的，加上前面 ioctl 读、写一个命令 -_-||）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::transact(int32_t handle,</div><div class="line">                                  uint32_t code, <span class="keyword">const</span> Parcel& data,</div><div class="line">                                  Parcel* reply, uint32_t flags) </div><div class="line">{</div><div class="line">    status_t err = data.errorCheck();</div><div class="line"></div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line"></div><div class="line">    IF_LOG_TRANSACTIONS() {</div><div class="line">        TextOutput::Bundle _b(alog);   </div><div class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span></div><div class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</div><div class="line">            (flags & TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>); </div><div class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        <span class="keyword">return</span> (mLastError = err);     </div><div class="line">    }</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> ((flags & TF_ONE_WAY) == <span class="number">0</span>) {</div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        <span class="keyword">if</span> (reply) {</div><div class="line">            err = waitForResponse(reply);  </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Parcel fakeReply;</div><div class="line">            err = waitForResponse(&fakeReply); </div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) { <span class="comment">// relayout</span></div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</div><div class="line">        }</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">        </div><div class="line">        IF_LOG_TRANSACTIONS() {        </div><div class="line">            TextOutput::Bundle _b(alog);   </div><div class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></div><div class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</div><div class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        err = waitForResponse(NULL, NULL);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里也是分为2个部分：第一部分： writeTransactionData 向 service 写请求数据，第二部分： waitForResponse，等待 service 返回请求结果。不难理解，一个函数调用，一般都有返回值（就算是 void 的也需要等待 service 返回结果），所以要发起请求后，要等待 service 返回结果。</p>
<p>先来看下写请求数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel& data, status_t* statusBuffer)</div><div class="line">{</div><div class="line">    binder_transaction_data tr;</div><div class="line">        </div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    tr.flags = binderFlags;</div><div class="line">    tr.cookie = <span class="number">0</span>;</div><div class="line">    tr.sender_pid = <span class="number">0</span>;</div><div class="line">    tr.sender_euid = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> status_t err = data.errorCheck();</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        tr.data_size = data.ipcDataSize();</div><div class="line">        tr.data.ptr.buffer = data.ipcData();</div><div class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(size_t);</div><div class="line">        tr.data.ptr.offsets = data.ipcObjects();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) {</div><div class="line">        tr.flags |= TF_STATUS_CODE;</div><div class="line">        *statusBuffer = err;</div><div class="line">        tr.data_size = <span class="keyword">sizeof</span>(status_t);</div><div class="line">        tr.data.ptr.buffer = statusBuffer;</div><div class="line">        tr.offsets_size = <span class="number">0</span>;</div><div class="line">        tr.data.ptr.offsets = NULL;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> (mLastError = err);</div><div class="line">    }</div><div class="line"></div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>传过去的 cmd（命令）是 <code>BC_TRANSACTION</code> 这个要记住。这里把上层 app 传递过来的数据（Pacrel 封装的，主要是 IPC 的参数），打包到 <code>binder_transaction_data</code> 这个数据结构中，这个是 kernel binder 驱动 ioctl 参数里带的数据（后面再说）。这里都是通过 mOut Pacrel 打包的（后面再说）。注意这里只是把数据包打好，还没发送。</p>
<p>然后到 IPCThreadState transaction 的第二部分：waitForResponse 等待 service 返回处理结果。这里注意一下 transaction 有个判断：</p>
<p><code>if ((flags &amp; TF_ONE_WAY) == 0)</code></p>
<p>这个是表示 IPC 调用需要不需要返回，一般都是需要的，所以这里 waitForResponese 的参数 reply 不是 NULL，这个 reply 会返回给 IPC 的调用者，里来带有返回的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</div><div class="line">{</div><div class="line">    int32_t cmd;</div><div class="line">    int32_t err;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里看到有一个循环，至于为什么，到后面会知道的。循环开始调用 talkWithDriver，这个函数前面在 service 那里看过了，是调用 ioctl 去 bidner 那里写数据和读数据。service 那里只是读了，但是没写。client 不一样了，前面 writeTransactionData 把 <code>BC_TRANSACTION</code> 命令和参数全都打包好了，就通过 ioctl 发到 kernel 的 binder 那去了。</p>
<p>这里 <code>binder_ioctl</code> 那会跑 <code>binder_thread_write</code> 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;   </div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) { </div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        }</div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BC_TRANSACTION:</div><div class="line">        <span class="keyword">case</span> BC_REPLY: {</div><div class="line">            <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (copy_from_user(&tr, ptr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line">            binder_transaction(proc, thread, &tr, cmd == BC_REPLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">... ...</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>write 这里是一个 while 循环 ptr 是前面用户空间（client）打包传进入来的数据，end 是数据结束的地址。这么搞这一个循环，其实是因为这个数据是支持打包多条命令的，虽然这里没体现出来，但是后面有些地方能体现出来，例如说释放内存的命令有些时候就是和其其它命令打包在一起传进来的。取完数据，数据指针会移动，移动到 end 地址了，就结束处处理了，所以可以处理多条命令。感觉 binder 这里经常一次搞多种东西，让代码上让人感觉怪怪的。主要看用的人了，因为是支持打包多条命令的。</p>
<p>不过这里先关心我们之前 client 写入的 <code>BC_TRANSACTION</code> 命令。看下面的处理的处理。传输命令交由 <code>binder_transaction</code> 函数处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete;</div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list;</div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">    e = binder_transaction_log_add(&binder_transaction_log);</div><div class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags & TF_ONE_WAY);</div><div class="line">    e-&gt;from_proc = proc-&gt;pid;</div><div class="line">    e-&gt;from_thread = thread-&gt;pid;</div><div class="line">    e-&gt;target_handle = tr-&gt;target.handle;</div><div class="line">    e-&gt;data_size = tr-&gt;data_size;</div><div class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got "</span></div><div class="line">                    <span class="string">"transaction to invalid handle\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_invalid_target_handle;</div><div class="line">            }</div><div class="line">            target_node = ref-&gt;node;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">            <span class="keyword">if</span> (target_node == NULL) {</div><div class="line">                return_error = BR_DEAD_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_no_context_mgr_node;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        e-&gt;to_node = target_node-&gt;debug_id;</div><div class="line">        target_proc = target_node-&gt;proc;</div><div class="line">        <span class="keyword">if</span> (target_proc == NULL) {</div><div class="line">            return_error = BR_DEAD_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_dead_binder;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (!(tr-&gt;flags & TF_ONE_WAY) && thread-&gt;transaction_stack) {</div><div class="line">            <span class="keyword">struct</span> binder_transaction *tmp;</div><div class="line">            tmp = thread-&gt;transaction_stack;</div><div class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got new "</span></div><div class="line">                    <span class="string">"transaction with bad transaction stack"</span></div><div class="line">                    <span class="string">", transaction %d has target %d:%d\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</div><div class="line">                    tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="number">0</span>,</div><div class="line">                    tmp-&gt;to_thread ?</div><div class="line">                    tmp-&gt;to_thread-&gt;pid : <span class="number">0</span>);</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_bad_call_stack;</div><div class="line">            }</div><div class="line">            <span class="keyword">while</span> (tmp) {</div><div class="line">                <span class="keyword">if</span> (tmp-&gt;from && tmp-&gt;from-&gt;proc == target_proc)</div><div class="line">                    target_thread = tmp-&gt;from;</div><div class="line">                tmp = tmp-&gt;from_parent;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (target_thread) {</div><div class="line">        e-&gt;to_thread = target_thread-&gt;pid;</div><div class="line">        target_list = &target_thread-&gt;todo;</div><div class="line">        target_wait = &target_thread-&gt;wait;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        target_list = &target_proc-&gt;todo;</div><div class="line">        target_wait = &target_proc-&gt;wait;</div><div class="line">    }</div><div class="line">    e-&gt;to_proc = target_proc-&gt;pid;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>先来看看这个函数前面一段，前面有一个是否是 reply 的判断，前面 <code>BC_TRANSACTION</code> 命令传过来的是 true，所以走的下面分支。其实这段是查找服务端进程的。tr-&gt;target.handle 这个由最开始 client 所持有的 Bp 传进来的，通过这个 kernel binder 驱动可以找对应的 service 的 proc。这里具体后面再说，这里就简单知道通过 handle 找到远程目标 service 的 proc，还有这里走的是下面 target_proc 的分支，<code>target_thread</code> 是后面 service 写返回值用的。还有注意，这里通过找到 <code>target_proc</code> 确定了 <code>target_wait</code>，回想下前面 service 在 <code>binder_thread_read</code> 那里 wait，就是 wait 这个变量。</p>
<p>接下去继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/* TODO: reuse incoming transaction for reply */</span></div><div class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (t == NULL) {</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</div><div class="line">    }</div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</div><div class="line"></div><div class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (tcomplete == NULL) {</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</div><div class="line">    }</div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line"></div><div class="line">    t-&gt;debug_id = ++binder_last_id;</div><div class="line">    e-&gt;debug_id = t-&gt;debug_id;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> tmp_pid = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (target_thread) {</div><div class="line">        tmp_pid = target_thread-&gt;pid;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!reply && !(tr-&gt;flags & TF_ONE_WAY))</div><div class="line">        t-&gt;from = thread;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t-&gt;from = NULL;</div><div class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</div><div class="line">    t-&gt;to_proc = target_proc;</div><div class="line">    t-&gt;to_thread = target_thread;</div><div class="line">    t-&gt;code = tr-&gt;code;</div><div class="line">    t-&gt;flags = tr-&gt;flags;</div><div class="line">    t-&gt;priority = task_nice(current);</div><div class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</div><div class="line">        tr-&gt;offsets_size, !reply && (t-&gt;flags & TF_ONE_WAY));</div><div class="line">    <span class="keyword">if</span> (t-&gt;buffer == NULL) {</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</div><div class="line">    }</div><div class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</div><div class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</div><div class="line">    t-&gt;buffer-&gt;transaction = t;</div><div class="line">    t-&gt;buffer-&gt;target_node = target_node;</div><div class="line">    <span class="keyword">if</span> (target_node)</div><div class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, NULL);</div><div class="line"></div><div class="line">    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(size_t))) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">            <span class="string">"invalid offsets size, %zd\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    }</div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</div><div class="line">        binder_pop_transaction(target_thread, in_reply_to);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags & TF_ONE_WAY)) {</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</div><div class="line">        t-&gt;need_reply = <span class="number">1</span>;</div><div class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</div><div class="line">        thread-&gt;transaction_stack = t;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        BUG_ON(target_node == NULL);</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) {</div><div class="line">            target_list = &target_node-&gt;async_todo;</div><div class="line">            target_wait = NULL;</div><div class="line">        } <span class="keyword">else</span>  </div><div class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</div><div class="line">    }</div><div class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    list_add_tail(&t-&gt;work.entry, target_list);</div><div class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    list_add_tail(&tcomplete-&gt;entry, &thread-&gt;todo);</div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里创建了2个对象：<code>binder_transaction</code> 和 <code>binder_work</code>，后面的代码就是填充这2个结构。<code>binder_transaction</code> 主要是把目标（<code>target_proc</code> 或是 <code>traget_thread</code>）和数据填写好。数据从用户层 ioctl 传过来的 <code>binder_transaction_data</code>（前面 client writeTransactionData 那里），把 IPC 的参数打包封装起来了，这里通过 <code>copy_from_user</code> 把这里数据再填写到 <code>binder_transaction</code> 带的数据结构的指针中。<br>下面又有一个 for 循环，这个循环是处理 Parcel 保存的 object 的数据的，其实就是 Bp 或是 Bn，这个是和 service manager 通信用的，这里先暂时不管。</p>
<p>这里还有一点，保存了传递堆栈，<code>!(t-&gt;flags &amp; TF_ONE_WAY)</code> 这里一般 IPC 都是需要返回的，所以把当前的 <code>binder_transaction</code> 保存到 <code>transaction_stack</code> 中去了。后面 service 写返回值的时候回通过这个找到要返回的目标进程的。</p>
<p>最后， <code>binder_transaction</code> 的 work type 设置为 <code>BINDER_WORK_TRANSACTION 然后 binder_work 设置为 BINDER_WORK_TRANSACTION_COMPLETE</code> ，分别加入到了 <code>target_list</code> 中（这个这里是 <code>target_proc</code> 的 todo list，也就是 service 的进程工作列表）和 thread 的 todo list（也就是 client 发起 IPC 调用的线程的 todo list）。然后，如果目标 service 进程在等待中（前面第一部分确实在等待），就唤醒它。（回去看看最开始的图稍微好理解些）</p>
<p>其实到这里，client 已经把 IPC 请求发出去了，而 service 那把阻塞在 <code>binder_thread_read</code> 那里的也应该唤醒了，开始执行后面的处理了。不过这里还是继续看 client 这边。</p>
<p>client 这边 <code>binder_thread_write</code> 处理完了，就到 <code>binder_thread_read</code> 了。前面 service 那里分析过阻塞的情况（前面说过了 service、client 代码都是共用的）。这里因为前面 <code>binder_thread_write</code> 那里把一个 <code>binder_work</code> 插入到 thread-&gt;todo 中，所以这里是不会阻塞的。这里会不会觉得有点奇怪，应该正常的模型应该是要阻塞等待 service 那边返回结果才对，不过先别着急。慢慢看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        uint32_t cmd;</div><div class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line">        <span class="keyword">struct</span> binder_work *w;</div><div class="line">        <span class="keyword">struct</span> binder_transaction *t = NULL;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!list_empty(&thread-&gt;todo))</div><div class="line">            w = list_first_entry(&thread-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&proc-&gt;todo) && wait_for_proc_work)</div><div class="line">            w = list_first_entry(&proc-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> && !(thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></div><div class="line">                <span class="keyword">goto</span> retry;   </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (w-&gt;type) {</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: {</div><div class="line">            t = container_of(w, <span class="keyword">struct</span> binder_transaction, work);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: {</div><div class="line">            cmd = BR_TRANSACTION_COMPLETE; </div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;                </div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line"></div><div class="line">            binder_stat_br(proc, thread, cmd);</div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION_COMPLETE,</div><div class="line">                     <span class="string">"binder: %d:%d BR_TRANSACTION_COMPLETE\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid);       </div><div class="line"></div><div class="line">            list_del(&w-&gt;entry);           </div><div class="line">            kfree(w);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">... ...</div><div class="line">        }   </div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!t) </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line">    </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>有是一个 while 循环，前面已经有好多了，见怪不怪。前面把一个 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 的 <code>binder_work</code> 插入到了 thread-&gt;todo 中，所以这里的分支是 switch 那里的 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 。这里只是把一个 <code>BR_TRANSACTION_COMPLETE</code> 返回给用户了（<code>put_user</code> 是 kernel 向用户空间写单个变量，<code>copy_user</code> 是传递一片数据）。然后就把这个 work 从 todo list 中删掉了。</p>
<p>然后走到下面，t 是 NULL 所以又回到循环开始地方，由于处理完了 work 就删掉了，所以这里取不到任何 todo work 了，就会走最后没那个 else 分支，然后这个<br><code>(ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))</code></p>
<p>这个判断是没有任何读数据的时候，就是没做任何处理。前面最开始有向用户空间写入 <code>BR_NOOP</code> 的操作（可以回到 service 那里仔细看一下），所以如果没做任何处理， ptr 应该被移动了4个字节。但是前面处理了 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 有移动了4个字节，所以这里条件不满足。然后就 break 跳出循环了。然后 <code>binder_thread_read</code> 就结束了。这次 ioctl 也就结束了，然后又回到用户空间 client 那里。</p>
<p>这里会到前面 client waitForResponse 那里，从 talkWithDrvier 返回了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        err = mIn.errorCheck();</div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        cmd = mIn.readInt32();</div><div class="line"></div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></div><div class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</div><div class="line">            <span class="keyword">if</span> (!reply && !acquireResult) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }  <span class="comment">// end while(1)</span></div><div class="line"></div><div class="line">finish:</div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        mLastError = err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 kernel <code>binder_thread_read</code> 返回的 cmd 是 <code>BR_TRANSACTION_COMPLETE</code> ，这边分支除了一个判断，要跳转到 finish 以外其它什么处理都没了。前面 client waitForResponse 是有传入参数 reply 的（这个是拿来存 IPC 函数的返回值的），所以这里只是 break 而已，没跳转去 finish（跳转到 finish 这个函数就结束了）。如果是不需要返回的，reply 传入 NULL 的话，接收到 kernel 的返回值，就直接退出了。</p>
<p>从这个含义来看， <code>BR_TRANSACTION_COMPLETE</code> 是 kernel binder 告诉调用者，命令发送已经处理完毕（前面 client 有对 kernel 发送 <code>BC_TRANSACTION</code> 命令）。所以 kernel 会把 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 的 work 插入到本线程的 todo list 中，为了就是告诉调用者，发送已经完成而已。而看样子，现阶段这个返回值好像没啥用，因为调用者没做啥处理。这个理解下设计者的意图，后面 service 还会有。</p>
<p>然后继续循环，然后调用 talkWithDriver，这里和前面第一部分 service 那里很像，因为前面把 mOut 中数据已经写完了，所以这里写入就是 0byte，读入 256btye，然后就和前面 service 一样了，阻塞在 <code>binder_thread_read</code> 那里等待 service 返回的值。这里才是符合前面所的模型，client 发送了请求后，就要等待 service 的返回。这里是通过 client 那里 waitForResponse 的 while 来实现的，因为这个函数需要处理多个命令（kernel 的返回值），这里知道为什么这里要用循环了吧。</p>
<h2 id="3-_服务端处理请求，并返回结果">3. 服务端处理请求，并返回结果</h2>
<p>client 在等待 service 的处理，我们回到 service 这边。之前 service 阻塞在 <code>binder_thread_read</code> 的 ioctl 调用那（回到图中右边部分），后面 client 发送了一个 IPC 请求，然后把一个 work 插入到了 service proc（<code>target_proc</code>） 的 todo lsit 上，service 的阻塞就被唤醒了。我们接着看后面的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">  </div><div class="line">... ...</div><div class="line"></div><div class="line">        BUG_ON(t-&gt;buffer == NULL);</div><div class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) {</div><div class="line">            <span class="keyword">struct</span> binder_node *target_node = t-&gt;buffer-&gt;target_node;</div><div class="line">            tr.target.ptr = target_node-&gt;ptr;</div><div class="line">            tr.cookie =  target_node-&gt;cookie;</div><div class="line">            t-&gt;saved_priority = task_nice(current);</div><div class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &&</div><div class="line">                !(t-&gt;flags & TF_ONE_WAY))</div><div class="line">                binder_set_nice(t-&gt;priority);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags & TF_ONE_WAY) ||</div><div class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</div><div class="line">                binder_set_nice(target_node-&gt;min_priority);</div><div class="line">            cmd = BR_TRANSACTION;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            tr.target.ptr = NULL;</div><div class="line">            tr.cookie = NULL;</div><div class="line">            cmd = BR_REPLY;</div><div class="line">        }</div><div class="line">        tr.code = t-&gt;code;</div><div class="line">        tr.flags = t-&gt;flags;</div><div class="line">        tr.sender_euid = t-&gt;sender_euid;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (t-&gt;from) {</div><div class="line">            <span class="keyword">struct</span> task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;</div><div class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</div><div class="line">                            current-&gt;nsproxy-&gt;pid_ns);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            tr.sender_pid = <span class="number">0</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</div><div class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</div><div class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</div><div class="line">                    proc-&gt;user_buffer_offset;</div><div class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</div><div class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</div><div class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &tr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line"></div><div class="line">        binder_stat_br(proc, thread, cmd);</div><div class="line">        binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                 <span class="string">"binder: %d:%d %s %d %d:%d, cmd %d"</span></div><div class="line">                 <span class="string">"size %zd-%zd ptr %p-%p\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid,</div><div class="line">                 (cmd == BR_TRANSACTION) ? <span class="string">"BR_TRANSACTION"</span> :</div><div class="line">                 <span class="string">"BR_REPLY"</span>,</div><div class="line">                 t-&gt;debug_id, t-&gt;from ? t-&gt;from-&gt;proc-&gt;pid : <span class="number">0</span>,</div><div class="line">                 t-&gt;from ? t-&gt;from-&gt;pid : <span class="number">0</span>, cmd,</div><div class="line">                 t-&gt;buffer-&gt;data_size, t-&gt;buffer-&gt;offsets_size,</div><div class="line">                 tr.data.ptr.buffer, tr.data.ptr.offsets);</div><div class="line"></div><div class="line">        list_del(&t-&gt;work.entry);</div><div class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION && !(t-&gt;flags & TF_ONE_WAY)) {</div><div class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</div><div class="line">            t-&gt;to_thread = thread;</div><div class="line">            thread-&gt;transaction_stack = t;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            t-&gt;buffer-&gt;transaction = NULL;</div><div class="line">            kfree(t);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION);</div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>由于 client 把一个 work 插入到 service proc 中的 todo list 中， work type 是 <code>BINDER_WORK_TRANSACTION</code>，这个处理就自己把前面写入的 <code>binder_transaction</code> 这个数据结构给取出来了，所以 t 那个判断 t != NULL 就会继续走下面的处理（看前面 client 的代码分析）。</p>
<p>这里有个分支判断： t-&gt;buffer-&gt;target_node 是否为 NULL，前面 client <code>binder_transaction</code> 那里通过 Bp 的 handle 找到了目标（service）的 target node 了的（每个 Bn 都是一个 binder node，这个后面再说），然后把 <code>target_node</code> 写入了 <code>binder_transaction</code> 中，所以这里走 <code>BR_TRANSACTION</code> 命令这个分支。这个分支把 <code>target_node</code> 的 ptr 和 cookie 写了返回给 service 的数据中，这个东西就是 Bn 的地址指针（这个后面 service manager 那再具体说）。</p>
<p>然后下面，就是把 <code>binder_transaction</code> 中的数据地址 copy 到准备返回给 service 的 <code>binder_transaction_data</code> 中。然后先是一个 <code>put_user</code> 把 <code>BR_TRANSACTION</code> 命令写给用户空间，后面 <code>copy_to_user</code> 把数据给写给用户空间。最后分支是 <code>BR_TRANSACTION</code> 然后也需要返回，保存下传送堆栈。</p>
<p>之后 service 在 kernel 中的 ioctl 阻塞结束，返回到用户空间。之前在 getAndExecuteCommand 的 talkWithDriver 阻塞，现在继续往下执行，在 ioctl 读取到数据后，读取 kernel 返回的命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">    size_t IN = mIn.dataAvail();   </div><div class="line">    <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">    cmd = mIn.readInt32();</div><div class="line">    IF_LOG_COMMANDS() {</div><div class="line">        alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">             &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    result = executeCommand(cmd);  </div><div class="line"></div><div class="line">    <span class="comment">// After executing the command, ensure that the thread is returned to the</span></div><div class="line">    <span class="comment">// foreground cgroup before rejoining the pool.  The driver takes care of</span></div><div class="line">    <span class="comment">// restoring the priority, but doesn't do anything with cgroups so we</span></div><div class="line">    <span class="comment">// need to take care of that here in userspace.  Note that we do make</span></div><div class="line">    <span class="comment">// sure to go in the foreground after executing a transaction, but</span></div><div class="line">    <span class="comment">// there are other callbacks into user code that could have changed</span></div><div class="line">    <span class="comment">// our group so we want to make absolutely sure it is put back.</span></div><div class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>之前 kernel 返回的是 <code>BR_TRANSACTION</code>，然后到 executeCommand 处理命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">       </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        {</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ALOG_ASSERT(result == NO_ERROR,</div><div class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</div><div class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(size_t), freeBuffer, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> pid_t origPid = mCallingPid;</div><div class="line">            <span class="keyword">const</span> uid_t origUid = mCallingUid;</div><div class="line"></div><div class="line">            mCallingPid = tr.sender_pid;</div><div class="line">            mCallingUid = tr.sender_euid;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> curPrio = getpriority(PRIO_PROCESS, mMyThreadId);</div><div class="line">            <span class="keyword">if</span> (gDisableBackgroundScheduling) {</div><div class="line">                <span class="keyword">if</span> (curPrio &gt; ANDROID_PRIORITY_NORMAL) {</div><div class="line">                    <span class="comment">// We have inherited a reduced priority from the caller, but do not</span></div><div class="line">                    <span class="comment">// want to run in that state in this process.  The driver set our</span></div><div class="line">                    <span class="comment">// priority already (though not our scheduling class), so bounce</span></div><div class="line">                    <span class="comment">// it back to the default before invoking the transaction.</span></div><div class="line">                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (curPrio &gt;= ANDROID_PRIORITY_BACKGROUND) {</div><div class="line">                    <span class="comment">// We want to use the inherited priority from the caller.</span></div><div class="line">                    <span class="comment">// Ensure this thread is in the background scheduling class,</span></div><div class="line">                    <span class="comment">// since the driver won't modify scheduling classes for us.</span></div><div class="line">                    <span class="comment">// The scheduling group is reset to default by the caller</span></div><div class="line">                    <span class="comment">// once this method returns after the transaction is complete.</span></div><div class="line">                    set_sched_policy(mMyThreadId, SP_BACKGROUND);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">//ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);</span></div><div class="line"></div><div class="line">            Parcel reply;</div><div class="line">            IF_LOG_TRANSACTIONS() {</div><div class="line">                TextOutput::Bundle _b(alog);</div><div class="line">                alog &lt;&lt; <span class="string">"BR_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self()</div><div class="line">                    &lt;&lt; <span class="string">" / obj "</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">" / code "</span></div><div class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; buffer</div><div class="line">                    &lt;&lt; dedent &lt;&lt; endl</div><div class="line">                    &lt;&lt; <span class="string">"Data addr = "</span></div><div class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer)</div><div class="line">                    &lt;&lt; <span class="string">", offsets addr="</span></div><div class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) {</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                <span class="keyword">const</span> status_t error = b-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line"></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">const</span> status_t error = the_context_object-&gt;transact(tr.code, buffer, &reply, tr.flags);</div><div class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">//ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",</span></div><div class="line">            <span class="comment">//     mCallingPid, origPid, origUid);</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((tr.flags & TF_ONE_WAY) == <span class="number">0</span>) {</div><div class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</div><div class="line">                sendReply(reply, <span class="number">0</span>);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</div><div class="line">            }</div><div class="line"></div><div class="line">            mCallingPid = origPid;</div><div class="line">            mCallingUid = origUid;</div><div class="line"></div><div class="line">            IF_LOG_TRANSACTIONS() {</div><div class="line">                TextOutput::Bundle _b(alog);</div><div class="line">                alog &lt;&lt; <span class="string">"BC_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / obj "</span></div><div class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</div><div class="line">            }</div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续从 mIn 中把前面 kernel 写入的 <code>binder_transaction_data</code> 数据取出来，然后把 buffer 数据地址写入到 Parcel 中，这个相当于把 client 传入的 IPC 参数取出来了。</p>
<p>然后关键的来了， 判断 tr.target.ptr 是否为 NULL，前面 kernel 把 service Bn 的指针地址写进去了，后面直接转化为 BBinder* ，然后调用 transaction 方法。这个就想当于调用 serivce Bn 的 transaction 方法，最后参数调用到 service 中真正实现的函数，具体的看前一篇原理的分析（这里实现 IPC 调用，前面图中有一个流程 impl IPC API）。</p>
<p>在调用 transaction 的时候，有个引用参数 reply，service 的业务函数会把返回值通过 Parcel 打包好，然后后面那个判断前面见过很多次，是需要返回值的，所以调用 sendReply 把返回值，通过 kernel binder 发送给 client：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::sendReply(<span class="keyword">const</span> Parcel& reply, uint32_t flags) </div><div class="line">{</div><div class="line">    status_t err;</div><div class="line">    status_t statusBuffer;</div><div class="line">    err = writeTransactionData(BC_REPLY, flags, -<span class="number">1</span>, <span class="number">0</span>, reply, &statusBuffer);</div><div class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</div><div class="line">       </div><div class="line">    <span class="keyword">return</span> waitForResponse(NULL, NULL);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数十分简洁，调用的2个函数前面（client 发命令那里）也都见过，而且顺序都一样，只不过参数不一样而已。writeTransactionData 打包的命令是 <code>BC_REPLY</code>，而 waitForReponse 参数是 NULL，根据前面的分析，参数是 NULL 的话，那么得到 kernel 返回 <code>BR_TRANSACTION_COMPLETE</code> 函数就结束了（前面的图中是 no reply）。</p>
<p>这里就不贴代码了，和前面是一样的，writeTransactionData 把数据打好包后，waitForReponse 通过 talkWithDriver 的 ioctl 就到 kernel 里面了，这次 <code>binder_thread_write</code> 调用 <code>binder_transaction</code> 的参数 reply 是 true，来看看有什么不一样（前面 client 是 false）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">        in_reply_to = thread-&gt;transaction_stack;</div><div class="line">        <span class="keyword">if</span> (in_reply_to == NULL) {     </div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got reply transaction "</span></div><div class="line">                      <span class="string">"with no transaction stack\n"</span>, </div><div class="line">                      proc-&gt;pid, thread-&gt;pid);       </div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_empty_call_stack;     </div><div class="line">        }</div><div class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</div><div class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got reply transaction "</span></div><div class="line">                <span class="string">"with bad transaction stack,"</span>  </div><div class="line">                <span class="string">" transaction %d has target %d:%d\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,</div><div class="line">                in_reply_to-&gt;to_proc ?         </div><div class="line">                in_reply_to-&gt;to_proc-&gt;pid : <span class="number">0</span>, </div><div class="line">                in_reply_to-&gt;to_thread ?       </div><div class="line">                in_reply_to-&gt;to_thread-&gt;pid : <span class="number">0</span>);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            in_reply_to = NULL;            </div><div class="line">            <span class="keyword">goto</span> err_bad_call_stack;       </div><div class="line">        }</div><div class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</div><div class="line">        target_thread = in_reply_to-&gt;from;</div><div class="line">        <span class="keyword">if</span> (target_thread == NULL) {   </div><div class="line">            return_error = BR_DEAD_REPLY;  </div><div class="line">            <span class="keyword">goto</span> err_dead_binder;          </div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got reply transaction "</span></div><div class="line">                <span class="string">"with bad target transaction stack %d, "</span></div><div class="line">                <span class="string">"expected %d\n"</span>,               </div><div class="line">                proc-&gt;pid, thread-&gt;pid,        </div><div class="line">                target_thread-&gt;transaction_stack ?</div><div class="line">                target_thread-&gt;transaction_stack-&gt;debug_id : <span class="number">0</span>,</div><div class="line">                in_reply_to-&gt;debug_id);        </div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            in_reply_to = NULL;            </div><div class="line">            target_thread = NULL;          </div><div class="line">            <span class="keyword">goto</span> err_dead_binder;          </div><div class="line">        }</div><div class="line">        target_proc = target_thread-&gt;proc;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">... ... </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里主要的不同是寻找目标进程（线程）的不同，前面 client 那里寻找目标 service proc 是通过从 service manager 取到的 service Bp 的 handle 取到 service Bn 的 node，进而找到 service proc 的。这里却是通过前面 client 保存的 <code>transaction_stack</code>（传送堆栈）取到要返回的 client 的 thread 的。而且还根据这个校验这次的传送是否是有效的，就是保存的堆栈中的 <code>in_reply_to</code> 必须是本线程（就是前面 client 发送到的目标线程序必须是自己），否则就认为是一次无效的调用，就不处理（这个可能对某些恶意注入、拦截有用吧）。 </p>
<p>然后后面就和 client 那里一样了，创建 <code>binder_transaction</code> 和 <code>binder_work</code> 把数据和 work type 写到里面去。有一点，后面如果是 reply 则调用 <code>binder_pop_transaction</code> 把之前 client 保存堆栈出栈（因为这里是返回到 client，所以要出栈，之前 client 到 service 是入栈）。</p>
<p>然后也和前面 client 一样，插入了2个 work，一个插到 client 的 thread todo （这里是 thread 的 todo list，因为前面找到的 <code>target_thread</code> != NULL）里面，一个插到自己 thread 的 todo 里面，并唤醒在等待的 client 线程。</p>
<p>这里和前面一样，先不管 client 那边先，先继续看 service 这边。这边从 <code>binder_thread_write</code> 写完后，就到 <code>binder_thread_read</code> 了。和前面 client 一样，由于插入了 <code>BINDER_WORK_COMPLETE</code> 的 work 到 thread-&gt;todo list 所以这里不会阻塞。然后和 client 一样了，返回 <code>BR_TRANSACTION_COMPLETE</code> 给用户空间，然后退出循环，结束 ioctl 调用。</p>
<p>到用户空间， waitForReponse 前面说了，参数为 NULL，直接跳到 finish，结束，然后 sendReply 执行结束， exectueCommand 执行结束，然后 getAndExecuteCommand 执行结束。这里本次 IPC 调用， service 端的工作就算是结束了。然后进入下一个 joinThreadLoop 循环，等待下一次 client 请求的到来。</p>
<h2 id="4-_客户端接收到服务端返回的数据">4. 客户端接收到服务端返回的数据</h2>
<p>service 端结束了，回到 client 这边（继续图的左边部分）。前面 client 为等待 service 返回的结果，阻塞在 <code>binder_thread_read</code> 那里。上一个部分， service 把返回数据用 <code>BC_REPLY</code> 写入 kernel 后，client 就被唤醒了，然后继续往下走：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">        BUG_ON(t-&gt;buffer == NULL);</div><div class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) {</div><div class="line">... ...</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            tr.target.ptr = NULL;</div><div class="line">            tr.cookie = NULL;</div><div class="line">            cmd = BR_REPLY;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面取数据都一样了，然后主要是这里不一样，前面 service 那 <code>t-&gt;buffer-&gt;target_node</code> 是为 NULL 的，但是这里是 NULL（上面一部 service 是通过 <code>transaction_stack</code> 取的 target thread，所以没有 <code>target_node</code>），所以走下面。Bn 的地址直接设置为 NULL（client 那当然没 Bn，那里的是 Bp），返回的命令的是 <code>BR_REPLY</code> 。后面的处理就和前面差不多了，方法就返回到用户空间了。</p>
<p>这里就从 talkWithDriver 回到了 waitForReponse ，继续下面的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        err = mIn.errorCheck();</div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        cmd = mIn.readInt32();</div><div class="line"></div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></div><div class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line">        <span class="keyword">case</span> BR_REPLY:</div><div class="line">            {</div><div class="line">                binder_transaction_data tr;    </div><div class="line">                err = mIn.read(&tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</div><div class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (reply) {</div><div class="line">                    <span class="keyword">if</span> ((tr.flags & TF_STATUS_CODE) == <span class="number">0</span>) {</div><div class="line">                        reply-&gt;ipcSetDataReference(    </div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                            tr.data_size,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(size_t),</div><div class="line">                            freeBuffer, <span class="keyword">this</span>);</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        err = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> status_t*&gt;(tr.data.ptr.buffer);</div><div class="line">                        freeBuffer(NULL,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                            tr.data_size,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    freeBuffer(NULL,</div><div class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),</div><div class="line">                        tr.data_size,</div><div class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),</div><div class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(size_t), <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">goto</span> finish;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">finish:</div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        mLastError = err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里从 kernel 返回的命令是 <code>BR_REPLY</code>，处理也比较简单，就是把 service 写给 kernel 的数据指针设置给了 reply （Parcel）而已。然后就跳出循环 finish 了。然后后面就是通过 Parcel 从 reply 中读出 service 打包的数据，作为函数的返回值。</p>
<p>到这里 client 发起的一次 IPC 调用就结束了。</p>
<h2 id="总结">总结</h2>
<p>前面写了很多，稍微简化一下流程是：</p>
<ol>
<li>service 运行，阻塞于 ioctl，等待 client 发起请求</li>
<li>client 通过 ioctl 发起 IPC 请求，等待 service 结果<br> 2.1. client send <strong><code>BC_TRANSACTION</code></strong> —&gt; kernel<br> 2.2. kernel return <strong><code>BR_TRANSACTION_COMPLETE</code></strong> —&gt; client<br> 2.3. client 阻塞于 ioctl，等待 service 返回结果</li>
<li>service 被唤醒，完成业务，返回结果<br> 3.1. kernel return <strong><code>BR_TRANSACTION</code></strong> —&gt; service<br> 3.2. service impl IPC call<br> 3.3. service send <strong><code>BC_REPLY</code></strong> —&gt; kernel<br> 3.4. kernel return <strong><code>BR_TRANSACTION_COMPLETE</code></strong> —&gt; service</li>
<li>client 被唤醒，读取 service 返回结果， IPC 结束<br> 4.1. kernel return <strong><code>BR_REPLY</code></strong> —&gt; client<br> 4.2. IPC call end</li>
</ol>
<p>可以看到 BC 开头的协议都是用户空间对 kernel 发送的， BR 开头的协议都是 kernel 返回给用户空间的。所以应用程序是通过 kernel 的 binder 驱动进行通信的（之前我搞混过，一开始我以为这些 <code>BC_XX</code>, <code>BR_XX</code> 是 client 发往 service，其实不是它们都只与 kernel 通信而已，不知道对方彼此的存在）。向 kernel 发送传送请求的命令（<code>BC_TRANSACTION</code>, <code>BC_REPLY</code>），kernel 会返回 <code>BR_TRANSACTION_COMPLETE</code> 告诉发送者，传送完成。</p>
<p>kernel binder 驱动 binder.h 中定义2个 enum ，分别是： BinderDriverReturnProtocol 和 BinderDriverCommandProtocol 。里面除了上面提到的 <code>BC_TRANSACTION</code>, <code>BC_REPLY</code>, <code>BR_TRANSACTION_COMPLETE</code>, <code>BR_TRANSACTION</code>, <code>BR_REPLY</code> 还有很多别的命令，而且有一些还是没实现的（看注释有写）。其它一些用处，后面一些篇章会说到。其实名字还是挺形象的（BC、BR），只不过我一开始理解错了。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——通信模型/" data-title="Android Binder 分析——通信模型 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——原理/" title="Android Binder 分析——原理">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——原理</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——数据传递者[Parcel]/"  title="Android Binder 分析——数据传递者（Parcel）">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——数据传递者（Parcel）
</span>
</a>
</div>

</nav>


	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#流程"><span class="toc-number">1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、服务端等待请求"><span class="toc-number">2.</span> <span class="toc-text">1、服务端等待请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-_客户端发起_IPC_请求"><span class="toc-number">3.</span> <span class="toc-text">2. 客户端发起 IPC 请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-_服务端处理请求，并返回结果"><span class="toc-number">4.</span> <span class="toc-text">3. 服务端处理请求，并返回结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-_客户端接收到服务端返回的数据"><span class="toc-number">5.</span> <span class="toc-text">4. 客户端接收到服务端返回的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>32</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>49</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>9</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>9</sup></a></li>
		
			<li><a href="/categories/Performance/" title="Performance">Performance<sup>6</sup></a></li>
		
			<li><a href="/categories/VR/" title="VR">VR<sup>2</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/android/" title="android">android<sup>88</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>9</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>7</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>28</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>4</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/tool/" title="tool">tool<sup>10</sup></a></li>
		
			<li><a href="/tags/vr/" title="vr">vr<sup>4</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">我的链接</p>
    <ul>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">网站数据统计</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
      <li><i class="fa fa-book"></i> <a href="https://dongka.github.io" target="_blank">Dongka的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2021 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
