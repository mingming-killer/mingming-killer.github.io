
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——系统服务 Binder 对象的传递 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="前面 binder 说了那多，但是有一个关键的一点前面忽略掉了，就是 binder 对象是传递给另外一个进程使用的，然后还引伸出一个问题，Proc A 是怎么通过 binder 接口找到 Proc B 进行 IPC 调用的。
那这篇主要就是分析这些，照例先把源代码位置啰嗦一下（4.4）：
12345">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">三月学长的小站</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——系统服务 Binder 对象的传递/" title="Android Binder 分析——系统服务 Binder 对象的传递" itemprop="url">Android Binder 分析——系统服务 Binder 对象的传递</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T13:23:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2017-02-07T13:47:47.000Z" itemprop="dateModified">2017 2月 7</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SM_相关接口"><span class="toc-number">1.</span> <span class="toc-text">SM 相关接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#natvie_层接口"><span class="toc-number">1.1.</span> <span class="toc-text">natvie 层接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java_层接口"><span class="toc-number">1.2.</span> <span class="toc-text">java 层接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceManager"><span class="toc-number">2.</span> <span class="toc-text">ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本体"><span class="toc-number">2.1.</span> <span class="toc-text">本体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通信模型"><span class="toc-number">2.2.</span> <span class="toc-text">通信模型</span></a></li></ol></li></ol>
		</div>
		
		<p>前面 binder 说了那多，但是有一个关键的一点前面忽略掉了，就是 binder 对象是传递给另外一个进程使用的，然后还引伸出一个问题，Proc A 是怎么通过 binder 接口找到 Proc B 进行 IPC 调用的。</p>
<p>那这篇主要就是分析这些，照例先把源代码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java 层 Service Manager 接口</span></div><div class="line">frameworks/base/core/java/android/os/IServiceManager.java</div><div class="line">frameworks/base/core/java/android/os/ServiceManagerNative.java</div><div class="line">frameworks/base/core/java/android/os/ServiceManager.java</div><div class="line">frameworks/base/core/java/com/android/internal/os/BinderInternal.java</div><div class="line"></div><div class="line"><span class="comment"># jni Service Manager 接口</span></div><div class="line">frameworks/base/core/jni/android_util_Binder.cpp</div><div class="line"></div><div class="line"><span class="comment"># Service Manager 模块（app）</span></div><div class="line">frameworks/native/cmds/servicemanager</div><div class="line"></div><div class="line"><span class="comment"># native 层 Service Manager 接口</span></div><div class="line">frameworks/native/include/binder/IServiceManager.h</div><div class="line">frameworks/native/include/binder/BinderService.h</div><div class="line">frameworks/native/libs/binder/IServiceManager.cpp</div><div class="line">frameworks/native/libs/binder/ProcessState.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<p>binder 对象的传递分为2种：一种是系统服务的 binder 对象（System Service，简称 SS 吧），一种是普通的第三方应用的服务。为什么会有这2种区别咧，主要是因为 SS 有 ServiceManager（简称 SM 吧）来管理（其实是保存）SS 的 binder 对象，所以可以直接向 SM 取，而第三方应用的服务没 SM 的待遇。 </p>
<h2 id="SM_相关接口">SM 相关接口</h2>
<h3 id="natvie_层接口">natvie 层接口</h3>
<p>在说 SM 之前，我们把 SM 的相关接口说下，也就是 SS 是怎么使用的。SM 的接口就下面4个（我的贴的是 native 层的，马甲 java 层的不贴了，一样的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IServiceManager.h ===========================</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Retrieve an existing service, blocking for a few seconds</span></div><div class="line"><span class="comment">     * if it doesn't yet exist.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;         getService( <span class="keyword">const</span> String16& name) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Retrieve an existing service, non-blocking.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;         checkService( <span class="keyword">const</span> String16& name) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Register a service.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> status_t            addService( <span class="keyword">const</span> String16& name,</div><div class="line">                                            <span class="keyword">const</span> sp&lt;IBinder&gt;& service,</div><div class="line">                                            <span class="keyword">bool</span> allowIsolated = <span class="keyword">false</span>) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Return list of all existing services.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">virtual</span> Vector&lt;String16&gt;    listServices() = <span class="number">0</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>常用的就2个： addService 和 getService。一个拿来注册、一个用来取。这里你会觉得奇怪怎么没有 removeService， SM 是 SS 专用的，SS 正常来说直到系统 shutdown（reboot），都一直存在的，所以不需要 remove。</p>
<p>我们从实际使用来看看 SM 的接口怎么使用。先说 natvie 层的，以 SurfaceFlinger（SF） 为例，在 SF 的 main 函数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main_surfaceflinger.cpp ===========================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></div><div class="line">    <span class="comment">// binder threads to 4.</span></div><div class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">// start the thread pool</span></div><div class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">    ps-&gt;startThreadPool();</div><div class="line"></div><div class="line">    <span class="comment">// instantiate surfaceflinger</span></div><div class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_PTHREADS)</span></div><div class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</div><div class="line"></div><div class="line">    <span class="comment">// initialize before clients can connect</span></div><div class="line">    flinger-&gt;init();</div><div class="line"></div><div class="line">    <span class="comment">// 关键的2句话，第一个句获取 SM 的接口（Bp 端）</span></div><div class="line">    <span class="comment">// publish surface flinger</span></div><div class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">    <span class="comment">// 调用 addService 向 SM 注册</span></div><div class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// run in this thread</span></div><div class="line">    flinger-&gt;run();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面说了 SS（SF 姑且算 natvie 的 SS 吧） 的原理是，通过向 SM 注册，然其它进程可以通过 SM 取到 SS 的 binder 对象。由于本身向 SM 注册就是跨进程的操作，那么 SS 是怎么取到 SM 的 binder 对象的呢。这是不是有点像鸡生蛋、蛋生鸡呢。结论是 SM 的 binder 对象是特殊的，可以通过特殊的方法可以取得到。</p>
<p>这个 defaultServiceManager() 是 IServiceManager 中的一个全局函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (gDefaultServiceManager != NULL) <span class="keyword">return</span> gDefaultServiceManager;</div><div class="line">                                            </div><div class="line">    {</div><div class="line">        AutoMutex _l(gDefaultServiceManagerLock);</div><div class="line">        <span class="keyword">while</span> (gDefaultServiceManager == NULL) {</div><div class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</div><div class="line">                ProcessState::self()-&gt;getContextObject(NULL));</div><div class="line">            <span class="keyword">if</span> (gDefaultServiceManager == NULL)</div><div class="line">                sleep(<span class="number">1</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> gDefaultServiceManager;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>关键的在于 ProcessState 的 getContextObject：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;& caller)</div><div class="line">{</div><div class="line">    <span class="comment">// 注意这个 0，这个 handle 是 0 就是特殊的地方</span></div><div class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</div><div class="line">}</div><div class="line"></div><div class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</div><div class="line">{</div><div class="line">    sp&lt;IBinder&gt; result;</div><div class="line"></div><div class="line">    AutoMutex _l(mLock);</div><div class="line"></div><div class="line">    handle_entry* e = lookupHandleLocked(handle);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e != NULL) {</div><div class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></div><div class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></div><div class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></div><div class="line">        IBinder* b = e-&gt;binder;        </div><div class="line">        <span class="keyword">if</span> (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) {</div><div class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) {</div><div class="line">                <span class="comment">// Special case for context manager...</span></div><div class="line">                <span class="comment">// The context manager is the only object for which we create</span></div><div class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></div><div class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></div><div class="line">                <span class="comment">// is registered before we create the first local reference</span></div><div class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></div><div class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></div><div class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></div><div class="line">                <span class="comment">// provide a reference to the context manager, but the</span></div><div class="line">                <span class="comment">// driver API does not return status.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></div><div class="line">                <span class="comment">// dies while this code runs.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// TODO: add a driver API to wait for context manager, or</span></div><div class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></div><div class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></div><div class="line">                <span class="comment">// proper reference counting.</span></div><div class="line"></div><div class="line">                Parcel data;</div><div class="line">                status_t status = IPCThreadState::self()-&gt;transact(</div><div class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, NULL, <span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</div><div class="line">                   <span class="keyword">return</span> NULL;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 以 handle 0 创建了 Bp 端对象</span></div><div class="line">            b = <span class="keyword">new</span> BpBinder(handle);</div><div class="line">            e-&gt;binder = b;</div><div class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</div><div class="line">            result = b;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></div><div class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></div><div class="line">            <span class="comment">// but another team is sending the handle to us.</span></div><div class="line">            result.force_set(b);</div><div class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那一串长长注释好像是说为了验证 SM 是不是已经注册到 binder 驱动里面去了（后面会说到），所以要 ping 一下。前面那个 lookupHandleLocked 好像是 cache 之类的东西，也不管先。还有那几个我讨厌的引用计数也不管先。最关键的是通过这个函数创建了一个 handle 为 0 的 Bp 端对象。前面几篇说过 handle 就是 binder 对象寻找目标的关键，其他的 Bp handle 都是动态分配的，只有这个 0 是代表 SM 的。</p>
<p>取得 Bp 端之后，就可以调用 IPC 接口了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IServiceManager.cpp  ==============================</span></div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; getService(<span class="keyword">const</span> String16& name) <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        <span class="keyword">unsigned</span> n;           </div><div class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">5</span>; n++){       </div><div class="line">            sp&lt;IBinder&gt; svc = checkService(name);</div><div class="line">            <span class="keyword">if</span> (svc != NULL) <span class="keyword">return</span> svc;   </div><div class="line">            ALOGI(<span class="string">"Waiting for service %s...\n"</span>, String8(name).<span class="built_in">string</span>());</div><div class="line">            sleep(<span class="number">1</span>);         </div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; checkService( <span class="keyword">const</span> String16& name) <span class="keyword">const</span></div><div class="line">    {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</div><div class="line">        data.writeString16(name);      </div><div class="line">        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &reply);</div><div class="line">        <span class="keyword">return</span> reply.readStrongBinder();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> status_t addService(<span class="keyword">const</span> String16& name, <span class="keyword">const</span> sp&lt;IBinder&gt;& service,</div><div class="line">            <span class="keyword">bool</span> allowIsolated)            </div><div class="line">    {</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</div><div class="line">        data.writeString16(name);      </div><div class="line">        data.writeStrongBinder(service);</div><div class="line">        data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &reply);</div><div class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 Parcel 篇说了 parcel 怎么打包 binder 对象的（<code>flat_binder_object</code>）的，这里就没啥难度了。不过你翻遍 IServiceManager.cpp 你发现怎么只有 Bp 端的实现，没有 Bn 端的实现，这好像不太科学。那因为 SM 本身就没用 Binder 面向对象那套东西，当然不会有谁去实现 Bn 端。这个我们在讲 SM 之前，还得先把 java 层的接口讲完先。</p>
<h3 id="java_层接口">java 层接口</h3>
<p>同样，我们拿 java 层的 ActivityManager（AM）为例看看 java 层的 SM 接口怎么用，下面是 AM 的一个初始化函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ActivityManagerService.java ===============================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span>() {</div><div class="line">        <span class="keyword">try</span> { </div><div class="line">            ActivityManagerService m = mSelf;</div><div class="line"></div><div class="line">            <span class="comment">// java 层的好方便呐，static 函数直接调用</span></div><div class="line">            ServiceManager.addService(Context.ACTIVITY_SERVICE, m, <span class="keyword">true</span>);</div><div class="line">            ServiceManager.addService(ProcessStats.SERVICE_NAME, m.mProcessStats);</div><div class="line">            ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(m));</div><div class="line">            ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(m));</div><div class="line">            ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(m));</div><div class="line">            <span class="keyword">if</span> (MONITOR_CPU_USAGE) {</div><div class="line">                ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(m));</div><div class="line">            }     </div><div class="line">            ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(m));</div><div class="line"></div><div class="line">... ...</div><div class="line">        } <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Unable to find android system package"</span>, e);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>java 层的 SM 接口在 ServiceManager 这个类中，而且都是 static 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServiceManager.java ===========================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Returns a reference to a service with the given name.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param name the name of the service to get</span></div><div class="line"><span class="comment">     * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span>(String name) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            IBinder service = sCache.get(name);</div><div class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">return</span> service;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">return</span> getIServiceManager().getService(name);</div><div class="line">            }     </div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Log.e(TAG, <span class="string">"error in getService"</span>, e);</div><div class="line">        } </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Place a new @a service called @a name into the service</span></div><div class="line"><span class="comment">     * manager.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param name the name of the new service</span></div><div class="line"><span class="comment">     * @param service the service object</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span>(String name, IBinder service) {</div><div class="line">        <span class="keyword">try</span> {   </div><div class="line">            getIServiceManager().addService(name, service, <span class="keyword">false</span>);</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Log.e(TAG, <span class="string">"error in addService"</span>, e);</div><div class="line">        }   </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>又套马甲了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager sServiceManager;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, IBinder&gt; sCache = <span class="keyword">new</span> HashMap&lt;String, IBinder&gt;();</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span>() {</div><div class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> sServiceManager;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Find the service manager</span></div><div class="line">    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</div><div class="line">    <span class="keyword">return</span> sServiceManager;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ServiceManagerNative 就是前面原理篇中说的 java 层 IInterface 的实现，这里懒得重复贴了（忘记了的回去看看原理篇）。这里主要说参数关键的 IBinder 对象的来源。额，看这名字，多半又是 jni 套 native 层的马甲调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp =============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)</div><div class="line">{</div><div class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</div><div class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然是，最后还是通过 ProcessState 的 getContextObject 获取 handle 为 0 的 Bp 端对象。</p>
<p>那接下可以说说作为 Bn 端的 SM 的实现了。</p>
<h2 id="ServiceManager">ServiceManager</h2>
<h3 id="本体">本体</h3>
<p>SM 的本体是一个 native 的 app，在 init.rc 中开机启动：</p>
<pre config="brush:bash;toolbar:false;">
service servicemanager /system/bin/servicemanager
    class core
    user system
    group system
    critical
    onrestart restart healthd
    onrestart restart zygote
    onrestart restart media
    onrestart restart surfaceflinger
    onrestart restart drm 
</pre>

<p>SM 的主要功能就是接受 SS 的注册（addService），对其他进程提供 getService 的服务。所以它其实和 SS 差不多，只不过是 natvie 的而已。但是从它 native 层接口的位置来看，好像 android 把它当成 binder 组成的一部分了。</p>
<p>SM 的原理其实很简单：就是保存了所有的 SS 的 Bp 端的 handle 而已（可以通过这个东西找到 binder node，这个留到后面分析）。然后有人要用服务的时候，能够通过 SM 取得对应的 IBinder 接口（如果在同一进程空间接口是 BBinder，如果不在，则是 BpBinder）。</p>
<p>因此，所有的 SS 都需要向 SM 注册，然后应用可以通过 SM 查询（获取）到注册过的 service 的 IBinder 接口，进而调用 service 提供的服务接口。</p>
<p>既然 SM 是一个单独的程序，那么其他系统 service 要向它注册，或是 apk 通过它获取系统 service 的接口，都需要跨进程。没错， SM 也是使用 binder 通信的，它也提供一些列接口。但是它却没有使用 binder 那一套接口设计的框架，而是直接使用 binder 的驱动接口来完成功能的。怪不得代码是 c，不是 c++ 。</p>
<p>来看 SM 的本体代码，其实代码比较少，模块不算测试代码，就3个文件：</p>
<pre>
binder.h
binder.c
service_manager.c
</pre>

<p>main 函数在 service_manager.c 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_state *bs;</div><div class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 /dev/binder 驱动设备</span></div><div class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 设置自己成为 binder 的 context manager</span></div><div class="line">    <span class="comment">// binder 里面的 context 就是进程的意思吧，其实 SM 在 binder 可以看成是进程管理</span></div><div class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) {</div><div class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    svcmgr_handle = svcmgr;</div><div class="line">    <span class="comment">// 循环等待 binder 驱动 I/O 请求数据到来，并处理</span></div><div class="line">    binder_loop(bs, svcmgr_handler);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>很简洁。大部分功能都在调用的函数里完成了，一个一个来看。</p>
<p>1、开打 binder 设备驱动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个结构挺简单的，主要是设备 fd</span></div><div class="line"><span class="comment">// 然后是映射的内存地址，和映射的内存大小</span></div><div class="line"><span class="keyword">struct</span> binder_state</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> fd; </div><div class="line">    <span class="keyword">void</span> *mapped;</div><div class="line">    <span class="keyword">unsigned</span> mapsize;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_state *binder_open(<span class="keyword">unsigned</span> mapsize)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_state *bs;</div><div class="line"></div><div class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</div><div class="line">    <span class="keyword">if</span> (!bs) {</div><div class="line">        errno = ENOMEM;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 以读写打开 binder 设备，保存设备 fd</span></div><div class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder: cannot open device (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">        <span class="keyword">goto</span> fail_open;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 映射一下接收数据的内存，大小前面有设置： 128x1024</span></div><div class="line">    <span class="comment">// 看样子通信数据不是很大（确实 SM 的通信数据不大，普通的是 1024x1024 咧）</span></div><div class="line">    bs-&gt;mapsize = mapsize;</div><div class="line">    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>); </div><div class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder: cannot map device (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">        <span class="keyword">goto</span> fail_map;</div><div class="line">    }</div><div class="line"></div><div class="line">        <span class="comment">/* TODO: check version */</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> bs; </div><div class="line"></div><div class="line">fail_map:</div><div class="line">    close(bs-&gt;fd);</div><div class="line">fail_open:</div><div class="line">    <span class="built_in">free</span>(bs);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>打开 binder 设备比较简单，linux 的基本操作。</p>
<p>2、告诉 binder 自己的进程是 context manager。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_become_context_manager(<span class="keyword">struct</span> binder_state *bs)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>ioctl 调用到 binder 驱动中的 <code>binder_ioctl</code> 这个函数，然后我们看下 <code>BINDER_SET_CONTEXT_MGR</code> 命令的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</div><div class="line">    <span class="comment">// 判断下 binder_context_mgr_node 是否已经被创建了</span></div><div class="line">    <span class="comment">// 如果已经创建了，则直接返回错误代码</span></div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node != NULL) {</div><div class="line">        printk(KERN_ERR <span class="string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);</div><div class="line">        ret = -EBUSY;</div><div class="line">        <span class="keyword">goto</span> err; </div><div class="line">    }</div><div class="line">    <span class="comment">// 双重检测啊，前面检测了 binder_node ，这里接着检测设置进程的 uid    </span></div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_uid != -<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) {</div><div class="line">            printk(KERN_ERR <span class="string">"binder: BINDER_SET_"</span></div><div class="line">                   <span class="string">"CONTEXT_MGR bad uid %d != %d\n"</span>,</div><div class="line">                   current-&gt;cred-&gt;euid,</div><div class="line">                   binder_context_mgr_uid);</div><div class="line">            ret = -EPERM;</div><div class="line">            <span class="keyword">goto</span> err; </div><div class="line">        }    </div><div class="line">    } <span class="keyword">else</span> </div><div class="line">        binder_context_mgr_uid = current-&gt;cred-&gt;euid;</div><div class="line">    <span class="comment">// 通过检测后，创建 binder_context_mgr_node 节点</span></div><div class="line">    binder_context_mgr_node = binder_new_node(proc, NULL, NULL);</div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node == NULL) {</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err; </div><div class="line">    }    </div><div class="line">    <span class="comment">// 我讨厌的 android 的引用计数</span></div><div class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</div><div class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</div><div class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>; </div><div class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>; </div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>binder 驱动里的处理除去前面的检测（防止多次设置 binder 的 context manager，并且也能有效防止一些恶意程序伪造 SM，SM 的由 init.rc 启动，所以可以说是比较早去 binder 驱动里面注册的），就只干了一件事：在 binder 驱动中，创建了一个 <code>binder_context_mgr_node</code> 的东西，这个是一个类型为 <code>binder_node</code> 的结构体。<code>binder_node</code> 在 binder 驱动中代表每一个 Bn 端，binder 驱动可以通过 <code>binder_node</code> 找到对应提供服务的进程，从而找到远程目标，这里后面再慢慢说。这里 <code>binder_new_node</code> 后面2个参数都是 NULL， 这2个参数，一个是 IBinder 的 wp 指针，一个是 IBinder 的指针（Bn 端的）， SM 的 <code>binder_node</code> 是很特殊的，直接用一个单独的变量保存。前面说的 SM 的 handle 是 0 固定的，因为人家有单独的变量保存。</p>
<p>3、循环阻塞的等待 binder I/O 的请求数据的到来。</p>
<p><code>svcmgr_handle</code> 应该是一个函数指针地址，但是这里用法好像很奇怪，我都有点搞不懂：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (*binder_handler)(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                              <span class="keyword">struct</span> binder_txn *txn,</div><div class="line">                              <span class="keyword">struct</span> binder_io *msg,</div><div class="line">                              <span class="keyword">struct</span> binder_io *reply);</div><div class="line"></div><div class="line"><span class="keyword">int</span> svcmgr_handler(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   <span class="keyword">struct</span> binder_txn *txn,</div><div class="line">                   <span class="keyword">struct</span> binder_io *msg, </div><div class="line">                   <span class="keyword">struct</span> binder_io *reply)</div><div class="line">{</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> binder_loop(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</div><div class="line">{</div><div class="line">... ... </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* the one magic object */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BINDER_SERVICE_MANAGER ((void*) 0)</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">svcmgr_handle = svcmgr;</div><div class="line">binder_loop(bs, svcmgr_handler);</div><div class="line"></div></pre></td></tr></table></figure>

<p>弄不清楚就算了，反正 <code>binder_loop</code> 那个 handle 函数肯定是 <code>svcmgr_handler</code> 就对了。</p>
<h3 id="通信模型">通信模型</h3>
<p>接着上一节最后的 <code>binder_loop</code> ，这个其实就是 SM 的通信模型了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> binder_loop(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> res; </div><div class="line">    <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</div><div class="line">    </div><div class="line">    bwr.write_size = <span class="number">0</span>;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 对 binder 写入 BC_ENTER_LOOPER，告诉 binder 有一个新的 binder 线程</span></div><div class="line">    <span class="comment">// 加入，相当于 IPCThreadState 的 joinThreadPool</span></div><div class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</div><div class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line">    </div><div class="line">    <span class="comment">// service 常见的无限循环模型</span></div><div class="line">    <span class="keyword">for</span> (;;) {</div><div class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</div><div class="line">        bwr.read_consumed = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</div><div class="line">    </div><div class="line">        <span class="comment">// ioctl 阻塞等待 Bp 端的请求到来</span></div><div class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &bwr);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">            ALOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="comment">// 解析命令，并调用 svcmgr_handler 回调执行命令</span></div><div class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</div><div class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) {</div><div class="line">            ALOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">            ALOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> binder_write(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">    <span class="comment">// 只填充 write 的变量</span></div><div class="line">    bwr.write_size = len;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</div><div class="line">    bwr.read_size = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    <span class="comment">// ioctl 对 binder 驱动写入命令</span></div><div class="line">    <span class="comment">// 由于只有 write 变量，所以 binder 驱动里面不会有 read 的阻塞</span></div><div class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &bwr);</div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实后面的东西， SM 和前面分析的 IPCThreadState 很像，毕竟 IPCThreadState 是封装的 binder 的接口。先是对驱动写一个 <code>BC_ENTER_LOOP</code> 命令，告诉驱动有一个新的线程加入。然后就开始循环等待 Bp 端的请求了（忘记了的回去看通信模型篇）。</p>
<p>然后是真正做事情的 <code>binder_parse</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_parse(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</div><div class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 按 4字节 来算的咧</span></div><div class="line">    uint32_t *end = ptr + (size / <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 和 IPCThreadState 的 waitForResponse 差不多的处理</span></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end) {</div><div class="line">        <span class="comment">// 获取 cmd 命令</span></div><div class="line">        uint32_t cmd = *ptr++;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> TRACE</span></div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"%s:\n"</span>, cmd_name(cmd));</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">        <span class="keyword">switch</span>(cmd) {</div><div class="line">        <span class="keyword">case</span> BR_NOOP:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:  </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_INCREFS:</div><div class="line">        <span class="keyword">case</span> BR_ACQUIRE:</div><div class="line">        <span class="keyword">case</span> BR_RELEASE:</div><div class="line">        <span class="keyword">case</span> BR_DECREFS:</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> TRACE</span></div><div class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">"  %08x %08x\n"</span>, ptr[<span class="number">0</span>], ptr[<span class="number">1</span>]);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">            <span class="comment">// 引用相关的命令直接无视，呵呵</span></div><div class="line">            ptr += <span class="number">2</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION: {</div><div class="line">            <span class="comment">// binder_txn 就是 kernel 里的 binder_transtion_data </span></div><div class="line">            <span class="keyword">struct</span> binder_txn *txn = (<span class="keyword">void</span> *) ptr;</div><div class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(uint32_t) &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_txn)) { </div><div class="line">                ALOGE(<span class="string">"parse: txn too small!\n"</span>);</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line">            binder_dump_txn(txn);          </div><div class="line">            <span class="keyword">if</span> (func) {</div><div class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];         </div><div class="line">                <span class="keyword">struct</span> binder_io msg;          </div><div class="line">                <span class="keyword">struct</span> binder_io reply;        </div><div class="line">                <span class="keyword">int</span> res;</div><div class="line"></div><div class="line">                <span class="comment">// 根据 kernel 传递过来的数据填充下自己的数据结构</span></div><div class="line">                bio_init(&reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</div><div class="line">                bio_init_from_txn(&msg, txn);  </div><div class="line">                <span class="comment">// 执行 svcmgr_handler 回调，完成 IPC 业务</span></div><div class="line">                res = func(bs, txn, &msg, &reply); </div><div class="line">                <span class="comment">// 对 binder 发送返回值命令</span></div><div class="line">                binder_send_reply(bs, &reply, txn-&gt;data, res);</div><div class="line">            }</div><div class="line">            <span class="comment">// 移动下数据指针</span></div><div class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BR_REPLY: {</div><div class="line">            <span class="keyword">struct</span> binder_txn *txn = (<span class="keyword">void</span>*) ptr; </div><div class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(uint32_t) &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_txn)) { </div><div class="line">                ALOGE(<span class="string">"parse: reply too small!\n"</span>);</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line">            binder_dump_txn(txn);</div><div class="line">            <span class="keyword">if</span> (bio) {</div><div class="line">                bio_init_from_txn(bio, txn);</div><div class="line">                bio = <span class="number">0</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">/* todo FREE BUFFER */</span></div><div class="line">            }</div><div class="line">            ptr += (<span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(uint32_t));</div><div class="line">            r = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: {</div><div class="line">            <span class="keyword">struct</span> binder_death *death = (<span class="keyword">void</span>*) *ptr++;</div><div class="line">            death-&gt;func(bs, death-&gt;ptr);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</div><div class="line">            r = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</div><div class="line">            r = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ALOGE(<span class="string">"parse: OOPS %d\n"</span>, cmd);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里差不多感觉就差不多是 IPCThreadState 一个模子里映出来的。前面分析了，Bp transtion 发 <code>BC_TRANSTION</code> 给 binder，binder 会给 Bn 端发 <code>BR_TRANSTION</code> 命令，然后前面 parcel 封装的数据格式是：</p>
<pre>
cmd + binder_transtion_data
</pre>

<p>然后看下这里定义的 <code>binder_txn</code> 这个玩意的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_txn</div><div class="line">{</div><div class="line">    <span class="comment">// target union 取 void* ptr</span></div><div class="line">    <span class="keyword">void</span> *target;</div><div class="line">    <span class="keyword">void</span> *cookie;</div><div class="line">    uint32_t code;</div><div class="line">    uint32_t flags;</div><div class="line"></div><div class="line">    uint32_t sender_pid;</div><div class="line">    uint32_t sender_euid;</div><div class="line"></div><div class="line">    uint32_t data_size;</div><div class="line">    uint32_t offs_size;</div><div class="line">    <span class="comment">// data union 取 struct ptr</span></div><div class="line">    <span class="keyword">void</span> *data; </div><div class="line">    <span class="keyword">void</span> *offs;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>去 Parcel 篇对比下 kernel 的 <code>binder_transtion_data</code> 这里因为参数确定（因为接口就3个），所以直接把那2个 union 给确定下来了。这就是把 binder 驱动的结构扣了出来（我更加确定是2个人写的了，其中有一个就不用原来写好的东西 -_-||）。</p>
<p>然后是 <code>binder_io</code> 这个东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_io</div><div class="line">{</div><div class="line">    <span class="keyword">char</span> *data;            <span class="comment">/* pointer to read/write from */</span></div><div class="line">    uint32_t *offs;        <span class="comment">/* array of offsets */</span></div><div class="line">    uint32_t data_avail;   <span class="comment">/* bytes available in data buffer */</span></div><div class="line">    uint32_t offs_avail;   <span class="comment">/* entries available in offsets array */</span></div><div class="line"></div><div class="line">    <span class="keyword">char</span> *data0;           <span class="comment">/* start of data buffer */</span></div><div class="line">    uint32_t *offs0;       <span class="comment">/* start of offsets buffer */</span></div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t unused;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个从结构上看虽然不太像直接扣某个东西，其实是为了迁就 Parcel 的结构，回忆下 Parcel 篇说的，对的，data 相当于是 mDataPos， offs 相当于是 mObjectPos（Parcel 没这个东西，但是这里的意义相当于是这个），data0 相当于 mData，offs0 相当于 mObjects，<code>data_avail</code> 相当于是 mDataSize，<code>offs_avail</code> 相当于是 mObjectSize。这些后面用的时候就能看出来了。再吐槽下 reply 这个名字都和 IPCThreadState 中的一样。</p>
<p>然后我们接下来看那看 <code>bio_init</code> 这2个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> bio_init_from_txn(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">struct</span> binder_txn *txn)</div><div class="line">{</div><div class="line">    bio-&gt;data = bio-&gt;data0 = txn-&gt;data;</div><div class="line">    bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs;</div><div class="line">    bio-&gt;data_avail = txn-&gt;data_size;</div><div class="line">    bio-&gt;offs_avail = txn-&gt;offs_size / <span class="number">4</span>;</div><div class="line">    bio-&gt;flags = BIO_F_SHARED;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> bio_init(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">void</span> *data,</div><div class="line">              uint32_t maxdata, uint32_t maxoffs)</div><div class="line">{</div><div class="line">    <span class="comment">// 这个就是放 offset 数据的空间</span></div><div class="line">    uint32_t n = maxoffs * <span class="keyword">sizeof</span>(uint32_t);</div><div class="line"></div><div class="line">    <span class="comment">// 放 offset 的超过总空间了</span></div><div class="line">    <span class="keyword">if</span> (n &gt; maxdata) {</div><div class="line">        bio-&gt;flags = BIO_F_OVERFLOW;   </div><div class="line">        bio-&gt;data_avail = <span class="number">0</span>;  </div><div class="line">        bio-&gt;offs_avail = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这里把 offset 数组放到前面去了，后面是 data 数据</span></div><div class="line">    bio-&gt;data = bio-&gt;data0 = (<span class="keyword">char</span> *) data + n;</div><div class="line">    bio-&gt;offs = bio-&gt;offs0 = data; </div><div class="line">    bio-&gt;data_avail = maxdata - n; </div><div class="line">    bio-&gt;offs_avail = maxoffs;</div><div class="line">    bio-&gt;flags = <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>回去看下 Parcel 篇的内存结构，放 <code>flat_binder_object</code> offset 的数组和本体的 data 数据是分开放的，这里图省事，放到一起了，从目前传递参数来看，前 4x4字节 是存放 offset 数组的（最多只能放4个 <code>flat_binder_object</code>），然后紧接着就是 256/4 - 4*4 的数据了。内存结构应该是这样的（懒得画图了，凑活一下）：</p>
<pre>
| offset |        data        |
</pre>

<p>然后那个 <code>bio_init_from_txn</code> 由于用的是 <code>binder_txn</code>（<code>binder_transtion_data</code>） 的数据，所以 data 和 offs 指向的是 <code>binder_txn</code> 的 data 和 offs。</p>
<p>然后是到真正实现 SM 业务的函数了，这里说2个主要功能： addService 和 getService：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> svcmgr_handler(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   <span class="keyword">struct</span> binder_txn *txn,</div><div class="line">                   <span class="keyword">struct</span> binder_io *msg,</div><div class="line">                   <span class="keyword">struct</span> binder_io *reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    uint16_t *s; </div><div class="line">    <span class="keyword">unsigned</span> len;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    uint32_t strict_policy;</div><div class="line">    <span class="keyword">int</span> allow_isolated;</div><div class="line"></div><div class="line"><span class="comment">//    ALOGI("target=%p code=%d pid=%d uid=%d\n",</span></div><div class="line"><span class="comment">//         txn-&gt;target, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span></div><div class="line"></div><div class="line">    <span class="comment">// 验证一下，如果 target 不是 SM 的话，就直接返回</span></div><div class="line">    <span class="keyword">if</span> (txn-&gt;target != svcmgr_handle)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line"></div><div class="line">    <span class="comment">// 这个注释说得很清楚了，相当于 Parcel::enforceInterface()</span></div><div class="line">    <span class="comment">// 验证下 service id</span></div><div class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></div><div class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></div><div class="line">    <span class="comment">// Note that we ignore the strict_policy and don't propagate it</span></div><div class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></div><div class="line">    strict_policy = bio_get_uint32(msg);</div><div class="line">    s = bio_get_string16(msg, &len);</div><div class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</div><div class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"invalid id %s\n"</span>, str8(s));</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// service 接口的 cmd</span></div><div class="line">    <span class="keyword">switch</span>(txn-&gt;code) {</div><div class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</div><div class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</div><div class="line">        s = bio_get_string16(msg, &len);</div><div class="line">        ptr = do_find_service(bs, s, len, txn-&gt;sender_euid);</div><div class="line">        <span class="keyword">if</span> (!ptr)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        bio_put_ref(reply, ptr);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</div><div class="line">        s = bio_get_string16(msg, &len);</div><div class="line">        ptr = bio_get_ref(msg);</div><div class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> SVC_MGR_LIST_SERVICES: {</div><div class="line">        <span class="keyword">unsigned</span> n = bio_get_uint32(msg);</div><div class="line"></div><div class="line">        si = svclist;</div><div class="line">        <span class="keyword">while</span> ((n-- &gt; <span class="number">0</span>) && si)</div><div class="line">            si = si-&gt;next;</div><div class="line">        <span class="keyword">if</span> (si) {</div><div class="line">            bio_put_string16(reply, si-&gt;name);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        ALOGE(<span class="string">"unknown code %d\n"</span>, txn-&gt;code);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    bio_put_uint32(reply, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>在说真正的业务函数之前，先把一些细节说一下。最开始 txn-&gt;target != svcmgr_handle 这里，我终于知道前面那个 </p>
<pre>
#define BINDER_SERVICE_MANAGER ((void*) 0)
</pre>

<p>是什么意思了。SM 的 Bp handle 是 0，所以 <code>binder_transtion_data</code> 的 target 肯定是 0，这里做一个验证。然后后面那个取字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把取简单数据的都贴了</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *bio_get(<span class="keyword">struct</span> binder_io *bio, uint32_t size) </div><div class="line">{</div><div class="line">    <span class="comment">// 4 字节对齐</span></div><div class="line">    size = (size + <span class="number">3</span>) & (~<span class="number">3</span>); </div><div class="line"></div><div class="line">    <span class="comment">// 数据越界了</span></div><div class="line">    <span class="keyword">if</span> (bio-&gt;data_avail &lt; size){</div><div class="line">        bio-&gt;data_avail = <span class="number">0</span>;  </div><div class="line">        bio-&gt;flags |= BIO_F_OVERFLOW;  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }  <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 这个和 parcel 直接的内存读取是一样的</span></div><div class="line">        <span class="keyword">void</span> *ptr = bio-&gt;data;</div><div class="line">        bio-&gt;data += size;    </div><div class="line">        bio-&gt;data_avail -= size;       </div><div class="line">        <span class="keyword">return</span> ptr;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">uint32_t bio_get_uint32(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    uint32_t *ptr = bio_get(bio, <span class="keyword">sizeof</span>(*ptr));</div><div class="line">    <span class="keyword">return</span> ptr ? *ptr : <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line">uint16_t *bio_get_string16(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">unsigned</span> *sz)</div><div class="line">{</div><div class="line">    <span class="keyword">unsigned</span> len;</div><div class="line">    len = bio_get_uint32(bio);</div><div class="line">    <span class="keyword">if</span> (sz)</div><div class="line">        *sz = len;</div><div class="line">    <span class="keyword">return</span> bio_get(bio, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t)); </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里的代码就是和 parcel 读、写差不多。回到前面，注释说得很清楚了，因为 IPC 的协议定死了，前面一串字符是 service 的 id 标志，在 Bn 端可以用来验证，是不是本 service 的 Bp 端发送过来的请求，所以这里取前面一串字符（第一个 int32 是长度），然后和自己的 id 对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SM 中定义的 id 标识</span></div><div class="line">uint16_t svcmgr_id[] = {</div><div class="line">    <span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'i'</span>,<span class="string">'d'</span>,<span class="string">'.'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'.'</span>,</div><div class="line">    <span class="string">'I'</span>,<span class="string">'S'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'v'</span>,<span class="string">'i'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>,<span class="string">'M'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>,<span class="string">'r'</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IServiceManager 中定义 id 标志</span></div><div class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后后面 <code>binder_transtion_data</code> 中的 code 了，唉，前面连结构体都能扣出来，几个 int 值还搞不定么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SM 中的定义（binder.h） ==========================</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> {</div><div class="line">    SVC_MGR_GET_SERVICE = <span class="number">1</span>,</div><div class="line">    SVC_MGR_CHECK_SERVICE,</div><div class="line">    SVC_MGR_ADD_SERVICE,</div><div class="line">    SVC_MGR_LIST_SERVICES,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// IServiceManager.h ===============================</span></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</div><div class="line">        CHECK_SERVICE_TRANSACTION,</div><div class="line">        ADD_SERVICE_TRANSACTION,</div><div class="line">        LIST_SERVICES_TRANSACTION,</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="comment">// 附上 IBinder 里面的定义：</span></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>,</div><div class="line">        LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>, </div><div class="line"></div><div class="line">        PING_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'G'</span>),</div><div class="line">        DUMP_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>),</div><div class="line">        INTERFACE_TRANSACTION   = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'N'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>),</div><div class="line">        SYSPROPS_TRANSACTION    = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'R'</span>),</div><div class="line">                                            </div><div class="line">        <span class="comment">// Corresponds to TF_ONE_WAY -- an asynchronous call.</span></div><div class="line">        FLAG_ONEWAY             = <span class="number">0x00000001</span></div><div class="line">    };</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们先讲 addService。SS 自己把自己 new 出来之后（Bn 端对象），然后通过 SM<br>的 Bp 端把自己（sp<ibinder>&amp;）当作参数传递给 addService 然后传给 SM。再传到 SM 这里之前，我们这里可以把前面几篇中留的一些坑给填上，就是 binder 驱动里面是怎么找到指定的目标进程的。这里我们先说特殊的 Bp 端（SM 的）。</ibinder></p>
<p>前面说 SM 的 Bp handle 是 0，然后也是经过 IPCThreadState transation，然后 ioctl 一步步写到 kernel 的驱动里面，这里 addService 的话，就应该到了 <code>binder_transtion</code> 那里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete; </div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list; </div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">    e = binder_transaction_log_add(&binder_transaction_log);</div><div class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags & TF_ONE_WAY);</div><div class="line">    e-&gt;from_proc = proc-&gt;pid; </div><div class="line">    e-&gt;from_thread = thread-&gt;pid;</div><div class="line">    e-&gt;target_handle = tr-&gt;target.handle;</div><div class="line">    e-&gt;data_size = tr-&gt;data_size;</div><div class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) {</div><div class="line">... ...</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 注意和这个 handle， SM 的 Bp 传过来的是 0</span></div><div class="line">        <span class="comment">// 所以走的是下面的分支</span></div><div class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) {       </div><div class="line">... ...</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 前面 SM SET_CONTEXT_MGR 的时候 new 了一个 binder_node </span></div><div class="line">            <span class="comment">// 保存在 binder_context_mgr_node 中</span></div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">            <span class="keyword">if</span> (target_node == NULL) {     </div><div class="line">                return_error = BR_DEAD_REPLY;  </div><div class="line">                <span class="keyword">goto</span> err_no_context_mgr_node;  </div><div class="line">            }</div><div class="line">        }</div><div class="line">        e-&gt;to_node = target_node-&gt;debug_id;</div><div class="line">        <span class="comment">// 这里通过 binder_node 可以找到找到 SM 的进程</span></div><div class="line">        target_proc = target_node-&gt;proc;</div><div class="line">        <span class="keyword">if</span> (target_proc == NULL) {     </div><div class="line">            return_error = BR_DEAD_REPLY;  </div><div class="line">            <span class="keyword">goto</span> err_dead_binder;          </div><div class="line">        }</div><div class="line">... ...</div><div class="line">    }</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们再回过头来看看当时 SM <code>SET_CONTEXT_MGR</code> 的时候 new 出来的 <code>binder
_node</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_node *binder_new_node(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                       <span class="keyword">void</span> __user *ptr,              </div><div class="line">                       <span class="keyword">void</span> __user *cookie)           </div><div class="line">{</div><div class="line">    <span class="comment">// 提供 Service 的 proc 保存了自己进程提供的 binder 接口的 node</span></div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;nodes.rb_node;</div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL; </div><div class="line">    <span class="keyword">struct</span> binder_node *node; </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        node = rb_entry(parent, <span class="keyword">struct</span> binder_node, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)  </div><div class="line">            p = &(*p)-&gt;rb_left;            </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)      </div><div class="line">            p = &(*p)-&gt;rb_right;           </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> NULL;      </div><div class="line">    }</div><div class="line"></div><div class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (node == NULL)</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    binder_stats_created(BINDER_STAT_NODE);</div><div class="line">    rb_link_node(&node-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&node-&gt;rb_node, &proc-&gt;nodes);</div><div class="line">    node-&gt;debug_id = ++binder_last_id;</div><div class="line">    <span class="comment">// node 保存了自己所在的进程</span></div><div class="line">    node-&gt;proc = proc;</div><div class="line">    <span class="comment">// node 保存 binder 本地对象</span></div><div class="line">    node-&gt;ptr = ptr;</div><div class="line">    node-&gt;cookie = cookie;</div><div class="line">    node-&gt;work.type = BINDER_WORK_NODE;</div><div class="line">    INIT_LIST_HEAD(&node-&gt;work.entry);</div><div class="line">    INIT_LIST_HEAD(&node-&gt;async_todo);</div><div class="line">    binder_debug(BINDER_DEBUG_INTERNAL_REFS,</div><div class="line">             <span class="string">"binder: %d:%d node %d u%p c%p created\n"</span>,</div><div class="line">             proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,</div><div class="line">             node-&gt;ptr, node-&gt;cookie);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_new_node</code> new 出来的 node 保存了 binder 对象本地指针（后面会发现只有 Bn 端对象才会创建 node， Bp 端的全是引用（ref）），和相应的进程信息。这样通过 <code>binder_node</code> 就可以找到通信的目标进程。 SM 传递过去的 ptr 和 cookie 是 NULL， SM 的接口就没实现 Bn 端，所以不需要吧。</p>
<p>通过 handle 0 找到了 SM 的 <code>binder_node</code> 节点，进而找到 SM 的进程，然后根据通信篇讲的，唤醒 ioctl 等待 read 的线程，就能够从 ioctl 那返回了，上面就是前面的回到 SM 的 <code>svcmgr_handler</code> 的 <code>SVC_MGR_ADD_SERVICE</code> 处理那里了（代码再贴一次吧）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</div><div class="line">    <span class="comment">// 取注册的 service 的名字</span></div><div class="line">    s = bio_get_string16(msg, &len);</div><div class="line">    <span class="comment">// 取打包的 flat_binder_object 对象 </span></div><div class="line">    ptr = bio_get_ref(msg);</div><div class="line">    allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 保存解析出来的 flat_binder_object 对象</span></div><div class="line">    <span class="keyword">if</span> (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里和 Parcel 篇的一样，要注意读、写顺序，咋贴下 SM 接口实现中写的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span>(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</div><div class="line">        <span class="keyword">throws</span> RemoteException {</div><div class="line">    Parcel data = Parcel.obtain();</div><div class="line">    Parcel reply = Parcel.obtain();</div><div class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</div><div class="line">    data.writeString(name);</div><div class="line">    data.writeStrongBinder(service);</div><div class="line">    data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>); </div><div class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>); </div><div class="line">    reply.recycle();</div><div class="line">    data.recycle();</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Bn 端的标志字符串最开始读去了，然后是 addService 要传递一个字符串名字，代表这个 SS 的名字（Context 里面定义的那一堆 <code>ACTIVITY_SERVICE</code> 之类的东西就是一个字符串，而且不是以包名来命名的，但是 SS 是系统开发的，所以可以人为的保证不重复）。然后是 Parcel 篇说到 writeStrongBinder 接口了，这个接口把 <code>flat_binder_object</code> 对象写入 Parcel 的数据内存中。如果是 Bn 端的话 <code>flat_binder_object</code> 的 binder 指针就是 binder 对象本身（addService 当然是 Bn 端）。SM 使用 <code>bio_get_ref</code> 取 <code>flat_binder_object</code> 数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_object *_bio_get_obj(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    <span class="keyword">unsigned</span> n;</div><div class="line">    <span class="keyword">unsigned</span> off = bio-&gt;data - bio-&gt;data0;</div><div class="line"></div><div class="line">    <span class="comment">// 这里直接取 off 不就好了，还费这事</span></div><div class="line">        <span class="comment">/* TODO: be smarter about this? */</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; bio-&gt;offs_avail; n++) { </div><div class="line">        <span class="keyword">if</span> (bio-&gt;offs[n] == off)</div><div class="line">            <span class="comment">// bio_get 自己去前面去看</span></div><div class="line">            <span class="keyword">return</span> bio_get(bio, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_object)); </div><div class="line">    }</div><div class="line"></div><div class="line">    bio-&gt;data_avail = <span class="number">0</span>;</div><div class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> *bio_get_ref(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_object *obj;</div><div class="line"></div><div class="line">    obj = _bio_get_obj(bio);</div><div class="line">    <span class="keyword">if</span> (!obj)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 注意这个判断</span></div><div class="line">    <span class="keyword">if</span> (obj-&gt;type == BINDER_TYPE_HANDLE)</div><div class="line">        <span class="keyword">return</span> obj-&gt;pointer;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里取 <code>flat_binder_object</code> 有好几个地方要说，一个一个来。首先上面那个 <code>_bio_get_object</code> 的写法有点奇怪，注释也说是不是要采用才好的办法，其实还是和写的顺序有关，前面把 writeInterfaceToken、writeString 的都取完了，那么现在指针的位置就应该在 <code>flat_binder_object</code> 那了，而且 offset 数组的第一个就是 object 的偏移，就是说直接 bio-&gt;data0 + bio_offs[0] 或者 bio-&gt;data 都是可以直接取地址的。但是它偏得麻烦的判断一下，我也不知道为什么要这样。</p>
<p>然后取出来的， SM 把它转成 <code>binder_object</code> 这个结构了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_object</div><div class="line">{</div><div class="line">    uint32_t type;</div><div class="line">    uint32_t flags;</div><div class="line">    <span class="keyword">void</span> *pointer;</div><div class="line">    <span class="keyword">void</span> *cookie;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>我这里就懒得贴 <code>flat_binder_object</code> 的结构对比了（你以为你改下变量名我就不认识你啦）。</p>
<p>然后下面 <code>if (obj-&gt;type == BINDER_TYPE_HANDLE)</code> 这个判断，就是说只有 type 是 handle 的时候才会返回有效值。但是通过前面的讲解我们知道，type handle 表示的是 Bp 端，但是 SS addService 传过来的 <code>flat_binder_object</code> 是 <code>BINDER_TYPE_BINDER</code>（Bn 端） 来的。这不是矛盾的么。这里还得再回到 binder 驱动的 <code>binder_transtion</code> 这个函数里，我们把 Parcel 篇中忽略的东西在这里说清楚：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                   <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> binder_work *tcomplete; </div><div class="line">    size_t *offp, *off_end;</div><div class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *target_thread = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_node *target_node = NULL;</div><div class="line">    <span class="keyword">struct</span> list_head *target_list; </div><div class="line">    wait_queue_head_t *target_wait;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = NULL;</div><div class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</div><div class="line">    uint32_t return_error;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 计算留给 parcel 的 object offset 数据的内存地址</span></div><div class="line">    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    <span class="comment">// 从用户空间 copy parcel 的 data 数据</span></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="comment">// 从用户空间 copy parcel 的 object offset 数据到刚刚留给 offset 的地址</span></div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></div><div class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(size_t))) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">            <span class="string">"invalid offsets size, %zd\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    }</div><div class="line">    <span class="comment">// 计算出 object offset 的结束地址</span></div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="comment">// 循环转化 flat_binder_object 对象</span></div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) {</div><div class="line">        <span class="keyword">struct</span> flat_binder_object *fp;</div><div class="line">        <span class="comment">// 判断 offset 的有效性</span></div><div class="line">        <span class="keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            t-&gt;buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</div><div class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) {</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></div><div class="line">                <span class="string">"invalid offset, %zd\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, *offp);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_offset;</div><div class="line">        }</div><div class="line">        <span class="comment">// 从 offset 取得 flat_binder_object 对象</span></div><div class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) {</div><div class="line">        <span class="comment">// 分情况处理，这里传递过来的 flat_binder_object 是 binder 的情况，也就是 Bn 端的情况</span></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            <span class="comment">// 看看之前有没有创建过这个 Bn 的 node</span></div><div class="line">            <span class="keyword">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;binder);</div><div class="line">            <span class="keyword">if</span> (node == NULL) {</div><div class="line">                <span class="comment">// 没有的话，新创建一个，这里和 SM 不同，不再是 NULL 了</span></div><div class="line">                <span class="comment">// 注意这里先把 fp-&gt;binder 对象保存到 binder node 里面去了</span></div><div class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</div><div class="line">                <span class="keyword">if</span> (node == NULL) {</div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</div><div class="line">                }</div><div class="line">                node-&gt;min_priority = fp-&gt;flags & FLAT_BINDER_FLAG_PRIORITY_MASK;</div><div class="line">                node-&gt;accept_fds = !!(fp-&gt;flags & FLAT_BINDER_FLAG_ACCEPTS_FDS);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d sending u%p "</span></div><div class="line">                    <span class="string">"node %d, cookie mismatch %p != %p\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    fp-&gt;binder, node-&gt;debug_id,</div><div class="line">                    fp-&gt;cookie, node-&gt;cookie);</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 分配在目标进程对这个 node 的 ref</span></div><div class="line">            ref = binder_get_ref_for_node(target_proc, node);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 注意这里， BINDER 变 HANDLE（Bn 变 Bp）</span></div><div class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</div><div class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</div><div class="line">            <span class="comment">// 保存刚刚分配的 ref desc（我觉得可以理解为id）到 Bp 的 handle</span></div><div class="line">            <span class="comment">// 然后这里用 decs 把 flat_binder_object 的binder对象覆盖掉了</span></div><div class="line">            fp-&gt;handle = ref-&gt;desc;</div><div class="line">            <span class="comment">// 增加下引用计数</span></div><div class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</div><div class="line">                       &thread-&gt;todo);</div><div class="line"></div><div class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                     <span class="string">"        node %d u%p -&gt; ref %d desc %d\n"</span>,</div><div class="line">                     node-&gt;debug_id, node-&gt;ptr, ref-&gt;debug_id,</div><div class="line">                     ref-&gt;desc);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d got transactio"</span></div><div class="line">                <span class="string">"n with invalid object type, %lx\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, fp-&gt;type);</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_object_type;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最开始 offp 获取内存那里，还记得内存管理篇，说每个 binder 进程分配的那 1M 的用来接收数据的内存不，这里派上用场了（其实主要用的还是目标进程，这里只是把 <code>flat_binder_object</code> 加工一下而已）。用来接收 Proc A parcel 打包的数据（data + offset）。下面，先把 data copy 过来，然后再是 offset。由于 <code>flat_binder_object</code> 可以打包多个，所以是一个循环。Parcle 篇不止说了一次 mObects 是偏移地址，这里取 <code>flat_binder_object</code> 又再一次证明了。<code>flat_binder_object</code> 里面放的东西，这里要经过一些转化才能传递给目标进程使用。</p>
<p>这得分情况，这里先说 <code>BINDER_TYPE_BINDER</code> 的情况。因为之前一直在说 addService。那么作为 Bn 端的 service 传递过来的肯定是 <code>BINDER_TYPE_BINDER</code>。</p>
<p>首先先去 addService 的进程中去查找是不是已经创建过 <code>binder_node</code> 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_node *binder_get_node(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                       <span class="keyword">void</span> __user *ptr)              </div><div class="line">{</div><div class="line">    <span class="comment">// 进程保存自己本进程内 node 的红黑树</span></div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;nodes.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_node *node; </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (n) {</div><div class="line">        node = rb_entry(n, <span class="keyword">struct</span> binder_node, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)  </div><div class="line">            n = n-&gt;rb_left;   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)      </div><div class="line">            n = n-&gt;rb_right;  </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> node;      </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>`</p>
<p>前面看到 <code>binder_new_node</code> 是会把创建的 node 保存到 proc 的一颗红黑树里面的。如果没找到（也就是之前没创建过），那就创建一个。这里要注意一点，这里把 <code>flat_binder_object</code> 的 binder 对象保存到 node 里面去了。为什么要注意这点，后面创建 ref 的时候会知道原因的。接着就要分配一个这个 node 的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_ref *binder_get_ref_for_node(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                          <span class="keyword">struct</span> binder_node *node)      </div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> rb_node *n;</div><div class="line">    <span class="keyword">struct</span> rb_node **p = &proc-&gt;refs_by_node.rb_node; </div><div class="line">    <span class="keyword">struct</span> rb_node *parent = NULL; </div><div class="line">    <span class="keyword">struct</span> binder_ref *ref, *new_ref;</div><div class="line"></div><div class="line">    <span class="comment">// 先查看是不是能通过 node 查找到 ref</span></div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        ref = rb_entry(parent, <span class="keyword">struct</span> binder_ref, rb_node_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (node &lt; ref-&gt;node) </div><div class="line">            p = &(*p)-&gt;rb_left;            </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; ref-&gt;node)     </div><div class="line">            p = &(*p)-&gt;rb_right;           </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> ref;       </div><div class="line">    }</div><div class="line">    <span class="comment">// 如果查找不到就新创建一个 ref</span></div><div class="line">    new_ref = kzalloc(<span class="keyword">sizeof</span>(*ref), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (new_ref == NULL)</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    binder_stats_created(BINDER_STAT_REF);</div><div class="line">    new_ref-&gt;debug_id = ++binder_last_id;</div><div class="line">    <span class="comment">// 设置引用这个 binder 的进程</span></div><div class="line">    new_ref-&gt;proc = proc;</div><div class="line">    <span class="comment">// 设置这个 ref 指向的 node</span></div><div class="line">    new_ref-&gt;node = node;</div><div class="line">    <span class="comment">// 把新创建的 ref 保存到通过 node 查找 ref 的红黑树中</span></div><div class="line">    rb_link_node(&new_ref-&gt;rb_node_node, parent, p);</div><div class="line">    rb_insert_color(&new_ref-&gt;rb_node_node, &proc-&gt;refs_by_node);</div><div class="line"></div><div class="line">    <span class="comment">// 初始化 ref（如果是 SM 的话从 0 开始）</span></div><div class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</div><div class="line">    <span class="comment">// 看看已经有几个 ref 指向这个 node 了， desc（id） 是累加的</span></div><div class="line">    <span class="keyword">for</span> (n = rb_first(&proc-&gt;refs_by_desc); n != NULL; n = rb_next(n)) {</div><div class="line">        ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</div><div class="line">        <span class="keyword">if</span> (ref-&gt;desc &gt; new_ref-&gt;desc) </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        new_ref-&gt;desc = ref-&gt;desc + <span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 然后根据 new ref 的 desc 保存到根据 desc 查找的红黑树中</span></div><div class="line">    p = &proc-&gt;refs_by_desc.rb_node; </div><div class="line">    <span class="keyword">while</span> (*p) {</div><div class="line">        parent = *p;</div><div class="line">        ref = rb_entry(parent, <span class="keyword">struct</span> binder_ref, rb_node_desc);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (new_ref-&gt;desc &lt; ref-&gt;desc)</div><div class="line">            p = &(*p)-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_ref-&gt;desc &gt; ref-&gt;desc)</div><div class="line">            p = &(*p)-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            BUG();</div><div class="line">    }</div><div class="line">    rb_link_node(&new_ref-&gt;rb_node_desc, parent, p);</div><div class="line">    rb_insert_color(&new_ref-&gt;rb_node_desc, &proc-&gt;refs_by_desc);</div><div class="line">    <span class="keyword">if</span> (node) {</div><div class="line">        hlist_add_head(&new_ref-&gt;node_entry, &node-&gt;refs);</div><div class="line"></div><div class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</div><div class="line">                 <span class="string">"binder: %d new ref %d desc %d for "</span></div><div class="line">                 <span class="string">"node %d\n"</span>, proc-&gt;pid, new_ref-&gt;debug_id,</div><div class="line">                 new_ref-&gt;desc, node-&gt;debug_id);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</div><div class="line">                 <span class="string">"binder: %d new ref %d desc %d for "</span></div><div class="line">                 <span class="string">"dead node\n"</span>, proc-&gt;pid, new_ref-&gt;debug_id,</div><div class="line">                  new_ref-&gt;desc);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> new_ref;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里可以说下 node 和 ref 的关系了。一个 Bn 端对应一个 node，一个 Bp 端对应一个 ref， 同一个 service 的 Bn 端只有一个，所以 node 只有一个，但是一个 service 可以被多个 client 请求（Bp 端），所以 ref 可以有多个，并且是进程相关的。就是说 ref 的 desc 是进程相关的，一个进程内唯一，但是放到别的进程无法识别。desc 0 代表 SM 的 Bp 端，SM 的 node 由特殊的变量保存。binder 对象 Bn 端传递到目标进程变成 Bp 端，然后 Bp 端通过 desc 在 kernel 中可以找到 ref，通过 ref 可以找到引用的 node，然后通过 node 可以找到这个 node 的 Bn 端所在的进程，就能把请求发送到目标进程了。来张图，形象点：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-system-service/1.png" alt=""></p>
<p>分配好 ref 后，就有了 ref 的 desc（handle），然后把这个 handle 保存在了 fp-&gt;handle 里面。这里是一个需要注意的地方，回忆下 <code>flat_binder_object</code> 的结构，你会发现 binder 和 handle 是一个 union，就是说同一个时候只能用一个。这里设置了 handle 就会把 binder 的值给覆盖掉。这个是关键的一点，后面 SM 保存 <code>flat_binder_object</code> 的时候能看到这么处理的意义。</p>
<p>然后这里说下为什么后面把 <code>BINDER_TYPE_BINDER</code> 变成了 <code>BINDER_TYPE_HANDLE</code> 。因为 binder 对象自身是本地对象，只能在 Bn 端才有效（通过它调用本地的接口），在远程是无法使用的（要能用就没 IPC 什么事了），所以远程要持有 Bp 对象才有用。因此 Bn 端通过 writeStrong 把本地的 binder 对象打包成 <code>flat_binder_object</code>，经过 kernel 的时候，要传递到对方（目标进程），就需要把 Proc A 的本地 binder 对象变成 Proc B 中的 远程对象（Bp 对象），所以这里才有了 <code>BINDER_TYPE_BINDER</code> 变 <code>BINDER_TYPE_HANDLE</code> 的处理。同理如果 Proc B 中把 Proc A 的 Bp 对象反过来传递给 Proc A 的话，kernel 会把 Bp 转成 Bn 的，<code>binder_transtion</code> 的后面那个 case 会有这样的处理，后面会看到。 </p>
<p>到这里你就应该能理解为什么 addService 调用的 <code>bio_get_ref</code> 后面会判断 type 要是 <code>BINDER_TYPE_HANDLE</code> 才会返回 <code>flat_binder_object</code> 的有效值吧。如果这里是 <code>BINDER_TYPE_HANDLE</code> 对方传递的才是 Bn。然后回想下 SM 山寨的 <code>binder_object</code> 结构体，那个 pointer 其实就是 <code>flat_binder_object</code> 的 union，本来我以为 SS 传递过来的应该是本地的 binder 指针的，但是 kernel 那里一转化，就用 Bp 的 handle 值把本地的 binder 对象给覆盖掉了，SS 的本地 binder 对象是保存在了 kernel 的 node 里面，SM 里保存的是 Bp 的 handle 值而已。其实想想看也应该是这样，在另一个进程里面保存本地的 binder 对象根本就没意义，只有在 SS 本进程中本地 binder 对象才于意义，所以另外进程里有意义的是 Bp 的 handle 值。</p>
<p>然后最后我们可以来看看 <code>do_add_service</code> 的处理了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里从 kernel 那里传递过来的 ptr 其实一个 int 指针（Bp handle 值），</span></div><div class="line"><span class="comment">// 不是本地 binder 对象指针</span></div><div class="line"><span class="keyword">int</span> do_add_service(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   uint16_t *s, <span class="keyword">unsigned</span> len,     </div><div class="line">                   <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid, <span class="keyword">int</span> allow_isolated)</div><div class="line">{</div><div class="line">    <span class="comment">// SM 保存 SS 的结构体</span></div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    <span class="comment">//ALOGI("add_service('%s',%p,%s) uid=%d\n", str8(s), ptr,</span></div><div class="line">    <span class="comment">//        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 通过 uid 判断 SS 所在的进程是否能是系统进程，</span></div><div class="line">    <span class="comment">// 只有系统进程才有权限注册 SS</span></div><div class="line">    <span class="keyword">if</span> (!svc_can_register(uid, s)) {</div><div class="line">        ALOGE(<span class="string">"add_service('%s',%p) uid=%d - PERMISSION DENIED\n"</span>,</div><div class="line">             str8(s), ptr, uid);            </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 查找下之前是否注册过</span></div><div class="line">    si = find_svc(s, len);</div><div class="line">    <span class="keyword">if</span> (si) {</div><div class="line">        <span class="comment">// 如果之前注册过的话，弄死原来那个服务，用这个新的代替原来那个 -_-||</span></div><div class="line">        <span class="keyword">if</span> (si-&gt;ptr) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</div><div class="line">                 str8(s), ptr, uid);            </div><div class="line">            svcinfo_death(bs, si);         </div><div class="line">        }</div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 没注册过的话，就 new 新的结构体来保存 binder 对象</span></div><div class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        <span class="keyword">if</span> (!si) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - OUT OF MEMORY\n"</span>,</div><div class="line">                 str8(s), ptr, uid);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 保存 handle 值</span></div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">        si-&gt;len = len;</div><div class="line">        <span class="comment">// 保存 SS 的注册的名字</span></div><div class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</div><div class="line">        <span class="comment">// 设置下死亡通知回调</span></div><div class="line">        si-&gt;death.func = svcinfo_death;</div><div class="line">        si-&gt;death.ptr = si;</div><div class="line">        si-&gt;allow_isolated = allow_isolated;</div><div class="line">        <span class="comment">// SM 拿了一个链表来保存 svcinfo，把这个新的对象插入到到链表中</span></div><div class="line">        si-&gt;next = svclist;</div><div class="line">        svclist = si;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 对新的 SS 的 binder node 增加下引用计数（还是得手动么）</span></div><div class="line">    binder_acquire(bs, ptr);</div><div class="line">    binder_link_to_death(bs, ptr, &si-&gt;death);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>首先看一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> svcinfo</div><div class="line">{</div><div class="line">    <span class="comment">// 首地址变量当作链表的下一个元素的节点，活用 kernel 链表的精髓</span></div><div class="line">    <span class="keyword">struct</span> svcinfo *next;</div><div class="line">    <span class="comment">// handle 值</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">struct</span> binder_death death;</div><div class="line">    <span class="keyword">int</span> allow_isolated;</div><div class="line">    <span class="comment">// 注册名字的长度</span></div><div class="line">    <span class="keyword">unsigned</span> len;</div><div class="line">    <span class="comment">// 注册的名字字符串</span></div><div class="line">    uint16_t name[<span class="number">0</span>];</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>SM 拿了一个链表来保存 svcinfo 结构，svclist 这个变量就是链表头。然后 <code>do_add_service</code> 这个函数的处理也挺简单的，先是检测请求注册的进程是否有权限能够注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 允许注册的 uid 组和服务的名字</span></div><div class="line"><span class="comment">/* TODO:</span></div><div class="line"><span class="comment"> * These should come from a config file or perhaps be</span></div><div class="line"><span class="comment"> * based on some namespace rules of some sort (media</span></div><div class="line"><span class="comment"> * uid can register media.*, etc)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> {</div><div class="line">    <span class="keyword">unsigned</span> uid;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">} allowed[] = {</div><div class="line">    { AID_MEDIA, <span class="string">"media.audio_flinger"</span> },</div><div class="line">    { AID_MEDIA, <span class="string">"media.log"</span> },</div><div class="line">    { AID_MEDIA, <span class="string">"media.player"</span> }, </div><div class="line">    { AID_MEDIA, <span class="string">"media.camera"</span> }, </div><div class="line">    { AID_MEDIA, <span class="string">"media.audio_policy"</span> },</div><div class="line">    { AID_DRM,   <span class="string">"drm.drmManager"</span> }, </div><div class="line">    { AID_NFC,   <span class="string">"nfc"</span> },</div><div class="line">    { AID_BLUETOOTH, <span class="string">"bluetooth"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.phone"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.sms"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.phonesubinfo"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"radio.simphonebook"</span> },</div><div class="line"><span class="comment">/* TODO: remove after phone services are updated: */</span></div><div class="line">    { AID_RADIO, <span class="string">"phone"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"sip"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"isms"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"iphonesubinfo"</span> },</div><div class="line">    { AID_RADIO, <span class="string">"simphonebook"</span> }, </div><div class="line">    { AID_MEDIA, <span class="string">"common_time.clock"</span> },</div><div class="line">    { AID_MEDIA, <span class="string">"common_time.config"</span> },</div><div class="line">    { AID_KEYSTORE, <span class="string">"android.security.keystore"</span> }, </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> svc_can_register(<span class="keyword">unsigned</span> uid, uint16_t *name)</div><div class="line">{</div><div class="line">    <span class="keyword">unsigned</span> n;</div><div class="line">    </div><div class="line">    <span class="comment">// uid 0 好像是 root</span></div><div class="line">    <span class="comment">// AID_SYSTEM 是 /system/app 下面的进程</span></div><div class="line">    <span class="keyword">if</span> ((uid == <span class="number">0</span>) || (uid == AID_SYSTEM))</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果上面2个都不是的，查询下是否在最开始定义的 allowed 表里面</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="keyword">sizeof</span>(allowed) / <span class="keyword">sizeof</span>(allowed[<span class="number">0</span>]); n++)</div><div class="line">        <span class="keyword">if</span> ((uid == allowed[n].uid) && str16eq(name, allowed[n].name))</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子 root 启动的进程、系统程序、还有一些特殊的 uid 能够向 SM 注册 SS。当然自己定义的系统的话，可以加一些 uid 进去。</p>
<p>之后就是查找发过来的 Service 之前是否注册过：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> svcinfo *find_svc(uint16_t *s16, <span class="keyword">unsigned</span> len)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) {</div><div class="line">        <span class="comment">// 果然是以名字来区分的</span></div><div class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &&        </div><div class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(uint16_t))) {</div><div class="line">            <span class="keyword">return</span> si;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>SM 里标示 SS 的是 SS 的 name，所以自己定制系统的时候新加一个 SS 不要取和原来系统名字一样的。已经注册过了把原来的弄死，就用的代替原来旧的，没有的话就新创建一个 svcinfo 结构，然后插入到链表中。后面设置一些死亡通知的回调，后面再说。之后就是要手动增加 <code>binder_node</code> 的引用计数（这里不贴这部分的源码了）。</p>
<p>addService 算是说完了，就是 SM 拿了一个链表来保存所有的 SS 在 SM 本进程中的 Bp handle 值。那么相应的 getService 就是从这个链表中取出 SS 的 Bp，然后通过 kernel 传递给对应的进程（又重复贴代码了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SVC_MGR_GET_SERVICE:</div><div class="line"><span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</div><div class="line">    <span class="comment">// SM 接口 getService 的参数是 SS 注册的名字</span></div><div class="line">    s = bio_get_string16(msg, &len);</div><div class="line">    <span class="comment">// 通过 name 来查找 svcinfo </span></div><div class="line">    ptr = do_find_service(bs, s, len, txn-&gt;sender_euid);</div><div class="line">    <span class="keyword">if</span> (!ptr)</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="comment">// 取到对应 SS 的 Bp handle 后，然后仿照 Parcel 打包</span></div><div class="line">    <span class="comment">// 注意这里调用的函数名字证明了我上面说的结论，put 的是 ref</span></div><div class="line">    bio_put_ref(reply, ptr);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>从接口 getService 传递过来的 name，这个 name 是 SS 向 SM addService 的时候传递过来的 name。然后通过这个 name 查找 svcinfo 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *do_find_service(<span class="keyword">struct</span> binder_state *bs, uint16_t *s, <span class="keyword">unsigned</span> len, <span class="keyword">unsigned</span> uid)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    <span class="comment">// 通过 name 查找 svcinfo</span></div><div class="line">    si = find_svc(s, len);</div><div class="line"></div><div class="line"><span class="comment">//    ALOGI("check_service('%s') ptr = %p\n", str8(s), si ? si-&gt;ptr : 0);</span></div><div class="line">    <span class="keyword">if</span> (si && si-&gt;ptr) {</div><div class="line">        <span class="keyword">if</span> (!si-&gt;allow_isolated) {     </div><div class="line">            <span class="comment">// If this service doesn't allow access from isolated processes,</span></div><div class="line">            <span class="comment">// then check the uid to see if it is isolated.</span></div><div class="line">            <span class="keyword">unsigned</span> appid = uid % AID_USER;</div><div class="line">            <span class="keyword">if</span> (appid &gt;= AID_ISOLATED_START && appid &lt;= AID_ISOLATED_END) {</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// 找到后返回 Bp handle</span></div><div class="line">        <span class="keyword">return</span> si-&gt;ptr;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后通过 <code>binder_put_ref</code> 使用 handle 构造 <code>flat_binder_object</code> 打包到要返回的数据里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> bio_put_ref(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">void</span> *ptr)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_object *obj;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr)</div><div class="line">        <span class="comment">// 为 flat_binder_object 对象分配内存</span></div><div class="line">        obj = bio_alloc_obj(bio);      </div><div class="line">    <span class="keyword">else</span></div><div class="line">        obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!obj)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    <span class="comment">// type 是 handle</span></div><div class="line">    obj-&gt;type = BINDER_TYPE_HANDLE;</div><div class="line">    <span class="comment">// 这个 pointer 是 handle 值，所以这个 flat_binder_object 是 Bp</span></div><div class="line">    obj-&gt;pointer = ptr;</div><div class="line">    obj-&gt;cookie = <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_object *bio_alloc_obj(<span class="keyword">struct</span> binder_io *bio)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_object *obj;</div><div class="line"></div><div class="line">    obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</div><div class="line">       </div><div class="line">    <span class="keyword">if</span> (obj && bio-&gt;offs_avail) {</div><div class="line">        bio-&gt;offs_avail--;</div><div class="line">        *bio-&gt;offs++ = ((<span class="keyword">char</span>*) obj) - ((<span class="keyword">char</span>*) bio-&gt;data0);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    }</div><div class="line"></div><div class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *bio_alloc(<span class="keyword">struct</span> binder_io *bio, uint32_t size) </div><div class="line">{</div><div class="line">    size = (size + <span class="number">3</span>) & (~<span class="number">3</span>); </div><div class="line">    <span class="keyword">if</span> (size &gt; bio-&gt;data_avail) {</div><div class="line">        bio-&gt;flags |= BIO_F_OVERFLOW;  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">void</span> *ptr = bio-&gt;data;</div><div class="line">        bio-&gt;data += size;</div><div class="line">        bio-&gt;data_avail -= size;       </div><div class="line">        <span class="keyword">return</span> ptr;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里使用的 <code>bio_put_ref</code>，这个函数填充的 <code>flat_binder_object</code> 类型是 handle，此外 SM 还有一个函数叫 <code>bio_put_obj</code>，那个是填充的是 binder 类型，不过 <code>bio_put_obj</code> 目前并没有被使用。所以 SM 保存的是 Bp 的 handle 值。其他的我不想多解释啥了，自己去对比下 Parcel 篇，writeStrongBinder 相关的代码，就几乎是一样的东西，换几个函数名而已。</p>
<p>那么 <code>svcmgr_handler</code> 的业务逻辑处理完了，主要是把数据都打包好了，然后后面就把把数据当作返回值发回去（通过 kernel 的 binder）。这里就要回去看 <code>binder_parse</code> <code>BR_TRANSTION</code> 最后那里的 <code>binder_send_reply</code>（名字都和 IPCThreadState 的 sendReply 很像）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> binder_send_reply(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                       <span class="keyword">struct</span> binder_io *reply,       </div><div class="line">                       <span class="keyword">void</span> *buffer_to_free,          </div><div class="line">                       <span class="keyword">int</span> status)                    </div><div class="line">{</div><div class="line">    <span class="comment">// 这里一次性打包发送了2条命令：</span></div><div class="line">    <span class="comment">// 一条是释放前面发送 BC_TRANSTION 那次命令的 buffer 的</span></div><div class="line">    <span class="comment">// 一条是 BC_REPLY 发送返回值命令</span></div><div class="line">    <span class="keyword">struct</span> {</div><div class="line">        uint32_t cmd_free;</div><div class="line">        <span class="keyword">void</span> *buffer;</div><div class="line">        uint32_t cmd_reply;   </div><div class="line">        <span class="keyword">struct</span> binder_txn txn;</div><div class="line">    } __attribute__((packed)) data;</div><div class="line"></div><div class="line">    data.cmd_free = BC_FREE_BUFFER;</div><div class="line">    data.buffer = buffer_to_free;</div><div class="line">    data.cmd_reply = BC_REPLY;</div><div class="line">    data.txn.target = <span class="number">0</span>;</div><div class="line">    data.txn.cookie = <span class="number">0</span>;</div><div class="line">    data.txn.code = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (status) {</div><div class="line">        data.txn.flags = TF_STATUS_CODE;</div><div class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">        data.txn.offs_size = <span class="number">0</span>;        </div><div class="line">        data.txn.data = &status;       </div><div class="line">        data.txn.offs = <span class="number">0</span>;    </div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        data.txn.flags = <span class="number">0</span>;   </div><div class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</div><div class="line">        data.txn.offs_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</div><div class="line">        data.txn.data = reply-&gt;data0;  </div><div class="line">        data.txn.offs = reply-&gt;offs0;  </div><div class="line">    }</div><div class="line">    <span class="comment">// 写入 binder 驱动</span></div><div class="line">    binder_write(bs, &data, <span class="keyword">sizeof</span>(data));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> binder_write(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len) </div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">    <span class="comment">// 只填充 write 部分，binder 驱动不会在阻塞等待 read</span></div><div class="line">    bwr.write_size = len;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</div><div class="line">    bwr.read_size = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    <span class="comment">// ioctl 发送读、写命令</span></div><div class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &bwr);</div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) {</div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</div><div class="line">                strerror(errno));              </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实这段有了前面 Parcel 篇的分析就不需要再多说什么了。只不过这里我们可以接着下面看完 kernel 中 <code>binder_transtion</code> <code>BINDER_TYPE_HANDLE</code> 的处理，上面 SM 是通过保存的 binder 对象指针发送 <code>BINDER_TYPE_HANDLE</code> 过去的（Bp）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:       </div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {</div><div class="line">            <span class="comment">// 在本进程中取 ref，这里是 SM，前面 addService 的时候</span></div><div class="line">            <span class="comment">// 发送 flat_binder_object 创建 node 的时候在 SM 中分配了 ref</span></div><div class="line">            <span class="comment">// 这里正好能取回来</span></div><div class="line">            <span class="keyword">struct</span> binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d got "</span></div><div class="line">                    <span class="string">"transaction with invalid "</span>    </div><div class="line">                    <span class="string">"handle, %ld\n"</span>, proc-&gt;pid,    </div><div class="line">                    thread-&gt;pid, fp-&gt;handle);      </div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_failed;</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果 getService 的进程就是 SS 所在的进程，直接转化为 Bn</span></div><div class="line">            <span class="comment">// 这典型的出口转内销 -_-||</span></div><div class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) {</div><div class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</div><div class="line">                    fp-&gt;type = BINDER_TYPE_BINDER; </div><div class="line">                <span class="keyword">else</span></div><div class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</div><div class="line">                <span class="comment">// 本地 binder 对象在 node 中有保存</span></div><div class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;   </div><div class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</div><div class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, NULL);</div><div class="line">                binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                         <span class="string">"        ref %d desc %d -&gt; node %d u%p\n"</span>,</div><div class="line">                         ref-&gt;debug_id, ref-&gt;desc, ref-&gt;node-&gt;debug_id,</div><div class="line">                         ref-&gt;node-&gt;ptr);               </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 如果是不同的进程的话，老老实实分配 ref 吧</span></div><div class="line">                <span class="keyword">struct</span> binder_ref *new_ref;    </div><div class="line">                <span class="comment">// 注意分配 ref 都要在调用进程分配的，ref 是进程相关的</span></div><div class="line">                <span class="comment">// 进程别搞错了。</span></div><div class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</div><div class="line">                <span class="keyword">if</span> (new_ref == NULL) {         </div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">                }</div><div class="line">                <span class="comment">// 分配好的 desc（handle）要保存好</span></div><div class="line">                fp-&gt;handle = new_ref-&gt;desc;    </div><div class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);</div><div class="line">                binder_debug(BINDER_DEBUG_TRANSACTION,</div><div class="line">                         <span class="string">"        ref %d desc %d -&gt; ref %d desc %d (node %d)\n"</span>,</div><div class="line">                         ref-&gt;debug_id, ref-&gt;desc, new_ref-&gt;debug_id,</div><div class="line">                         new_ref-&gt;desc, ref-&gt;node-&gt;debug_id);</div><div class="line">            }</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_ref *binder_get_ref(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                     uint32_t desc)                 </div><div class="line">{</div><div class="line">    <span class="comment">// 前面分配好 ref，把 ref 保存到相关进程的这颗红黑树当中的</span></div><div class="line">    <span class="comment">// 忘记了的回去看前面的 addService 那的代码</span></div><div class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;refs_by_desc.rb_node;</div><div class="line">    <span class="keyword">struct</span> binder_ref *ref;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (n) {</div><div class="line">        ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (desc &lt; ref-&gt;desc) </div><div class="line">            n = n-&gt;rb_left;   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;desc)     </div><div class="line">            n = n-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> ref;       </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>要 getService，肯定得先 addService，如果之前 SS 有 addService，那么这里的 <code>binder_get_ref</code> 肯定能取得对应 handle 值的 ref（这的 proc 是 SM，是 SM进 程发送 getService 的返回值的引起的 kernel binder 的 ioctl 调用的，别那么容易晕）。ref 有保存对应的 Service 所在的 proc。这里要判断下“出口转内销”的情况。就是发起 getService 的进程正好就是要取的 Service 所在的进程（这种情况很常见的，SS 的进程中有很多个 Service 的，经常要在一个 Service 调用另一个 Service 的接口，其实它们都在同一个进程，可以直接调用的，但是既然 binder 都封装好了，开发人员就应该专注业务功能，不用理会这些）。如果是的话，就把 <code>flat_binder_object</code> 变成 binder 类型的（node 中有保存本地的 binder 对象指针，所以可以转化的）。</p>
<p>如果不是的话，就老老实实调用 <code>binder_get_ref_for_node</code> 创建新的 ref 。这个函数前面 new SM 的 ref 的时候分析过了。唯一要注意的是传递的过去的 proc 是发起 getService 的。前面说了 ref 是进程相关的，必须要分配到要用 Bp 端的进程中才能正常使用。这个说这么多次，然我们们来看下原因吧。因为还是在 <code>binder_transtion</code> 这个函数里面，在这个函数最开始，通过 Bp handle 找 ref 那：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这段代码前面贴过了，这里再强调一下</span></div><div class="line"><span class="keyword">if</span> (tr-&gt;target.handle) {</div><div class="line">    <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">    <span class="comment">// 注意这个 proc </span></div><div class="line">    ref = binder_get_ref(proc, tr-&gt;target.handle);</div><div class="line">    <span class="keyword">if</span> (ref == NULL) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d got "</span></div><div class="line">            <span class="string">"transaction to invalid handle\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid);</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_invalid_target_handle;</div><div class="line">    }</div><div class="line">    target_node = ref-&gt;node;</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们假设，client proc 通过 getService 取得了 Bp 对象，然后通过 Bp 发起一次 IPC 调用。那么最后也是要到 <code>binder_transtion</code> 这里。然后这个 target.handle 就是通过 getService 取得的 Service 的 Bp 的 handle。这个 handle 是当初在 kernel 在 client proc 中分配的，并且保存在 client proc 的一颗红黑树中。所以这里就从 client proc 的这颗红黑树中取当初分配的 ref（key 是 handle 值，当然保存的时候也是按 handle 值构造红黑树的，所以现在查找的时候速度会非常快）。所以说 ref 是进程相关的，其实 node 也是进程相关的，就是提供 service 的进程自己保存了 node。 ref 中保存有 node，node 中保存有 proc ，所以 client 的请求可以激活阻塞等待的 service 进程，然后 service 执行 IPC 调用。 </p>
<p><code>binder_transtion</code> 转化 <code>flat_binder_object</code> 最后还有一个 case： <code>BINDER_TYPE_FD</code>，这个是转化 fd 的，去共享内存篇去看吧。</p>
<p>这样前面那几篇中的疑问就都清楚了。client 的 IPC 是怎么找到 service 的？？ binder 对象怎么传递到别的进程使用？？ 其实主要是在 kernel 的 binder 驱动中，所有的进程都可见，才能实现这些功能，可以说 kernel 给各个进程穿针引线了。最后来张图总结一下吧：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Binder-system-service/2.png" alt=""></p>
<p>（稍微说明下，图中一共三条线；第一条 SS（ProcA）通过 addService 向 SM 注册，第二条 ProcB 通过 getService 向 SM 取 ProcA 的 binder 对象；第三条 ProcB 取回 ProcA 的 binder 对象后，通过其发起 IPC 调用）</p>
<p>那么 SS binder 对象的传递就说完了，那么还有第三方应用的咧。我发现这篇已经很长了，哎，本来先一篇讲完的，但是还是分开一篇吧。那么第三方应用 binder 对象传递就去看下一篇吧。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——系统服务 Binder 对象的传递/" data-title="Android Binder 分析——系统服务 Binder 对象的传递 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——内存管理/" title="Android Binder 分析——内存管理">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——内存管理</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递/"  title="Android Binder 分析——普通服务 Binder 对象的传递">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——普通服务 Binder 对象的传递
</span>
</a>
</div>

</nav>


	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SM_相关接口"><span class="toc-number">1.</span> <span class="toc-text">SM 相关接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#natvie_层接口"><span class="toc-number">1.1.</span> <span class="toc-text">natvie 层接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java_层接口"><span class="toc-number">1.2.</span> <span class="toc-text">java 层接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceManager"><span class="toc-number">2.</span> <span class="toc-text">ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本体"><span class="toc-number">2.1.</span> <span class="toc-text">本体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通信模型"><span class="toc-number">2.2.</span> <span class="toc-text">通信模型</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>35</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>48</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Server/" title="Server">Server<sup>1</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/android/" title="android">android<sup>83</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">我的链接</p>
    <ul>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">网站数据统计</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
      <li><i class="fa fa-book"></i> <a href="https://dongka.github.io" target="_blank">Dongka的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2021 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
