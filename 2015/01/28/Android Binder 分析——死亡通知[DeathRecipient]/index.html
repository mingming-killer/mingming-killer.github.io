
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Binder 分析——死亡通知（DeathRecipient） | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="binder 是跨进程间的通信，那就是说有本地和远程之说，通过前面几篇也知道 Bp 需要发请求到 Bn 端。但是写过网络通信程序的都知道，远程不一定“靠谱”，就是说可能某些时候远程服务器挂了。所以一般网络通信程序会弄一个心跳的机制，就是每隔一段时间向服务发一些东西，看服务是否还有响应。同理的还有看门">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">〜(￣△￣〜) 三月学长的根据地 (〜￣△￣)〜</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/28/Android Binder 分析——死亡通知[DeathRecipient]/" title="Android Binder 分析——死亡通知（DeathRecipient）" itemprop="url">Android Binder 分析——死亡通知（DeathRecipient）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-28T14:12:16.000Z" itemprop="datePublished">2015 1月 28</time>
    更新日期:<time datetime="2015-03-31T06:28:16.000Z" itemprop="dateModified">2015 3月 31</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#native_层的接口"><span class="toc-number">1.</span> <span class="toc-text">native 层的接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册死亡通知到_kernel"><span class="toc-number">2.</span> <span class="toc-text">注册死亡通知到 kernel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触发死亡通知"><span class="toc-number">3.</span> <span class="toc-text">触发死亡通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java_层接口"><span class="toc-number">4.</span> <span class="toc-text">java 层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊的_SM"><span class="toc-number">5.</span> <span class="toc-text">特殊的 SM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>binder 是跨进程间的通信，那就是说有本地和远程之说，通过前面几篇也知道 Bp 需要发请求到 Bn 端。但是写过网络通信程序的都知道，远程不一定“靠谱”，就是说可能某些时候远程服务器挂了。所以一般网络通信程序会弄一个心跳的机制，就是每隔一段时间向服务发一些东西，看服务是否还有响应。同理的还有看门狗，如果不定时去“喂狗”（证明程序还活着），机器就会重启之类的。所以 binder 通信也存在这个问题，不过同样也是 android 帮我们弄好框架了。</p>
<p>照例先把相关源码位置啰嗦一下（4.4）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># java binder 相关接口</span></div><div class="line">frameworks/base/core/android/os/IBinder.java</div><div class="line">frameworks/base/core/android/os/Binder.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line"></div><div class="line"><span class="comment"># jni binder 相关接口</span></div><div class="line">frameworks/base/core/jni/android_util_Binder.cpp</div><div class="line"></div><div class="line"><span class="comment"># SM 程序</span></div><div class="line">frameworks/native/cmds/servicemanager/binder.c</div><div class="line">frameworks/native/cmds/servicemanager/binder.h</div><div class="line">frameworks/native/cmds/servicemanager/service_manager.c</div><div class="line"></div><div class="line"><span class="comment"># native binder 库</span></div><div class="line">frameworks/native/include/binder/Binder.h</div><div class="line">frameworks/native/include/binder/BpBinder.h</div><div class="line">frameworks/native/include/binder/IPCThreadState.h</div><div class="line">frameworks/native/include/binder/ProcessState.h</div><div class="line">frameworks/native/libs/binder/IInterface.cpp</div><div class="line">frameworks/native/libs/binder/Binder.cpp</div><div class="line">frameworks/native/libs/binder/BpBinder.cpp</div><div class="line">frameworks/native/libs/binder/IPCThreadState.cpp</div><div class="line">frameworks/native/libs/binder/ProcessState.cpp</div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line"></div><div class="line"><span class="comment"># kernel binder 驱动</span></div><div class="line">kernel/drivers/staging/android/binder.h</div><div class="line">kernel/drivers/staging/android/binder.c</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="native_层的接口">native 层的接口</h2>
<p>binder 的东西是 native，java 层挂马甲的，所以先说 native 层的。在 libbinder 中的 IBinder.h 中有一个函数和一个接口类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment"> * This method allows you to add data that is transported through</span></div><div class="line"><span class="comment"> * IPC along with your IBinder pointer.  When implementing a Binder</span></div><div class="line"><span class="comment"> * object, override it to write your desired data in to @a outData.</span></div><div class="line"><span class="comment"> * You can then call getConstantData() on your IBinder to retrieve</span></div><div class="line"><span class="comment"> * that data, from any process.  You MUST return the number of bytes</span></div><div class="line"><span class="comment"> * written in to the parcel (including padding).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class</span> DeathRecipient : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> binderDied(<span class="keyword">const</span> wp&lt;IBinder&gt;& who) = <span class="number">0</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment"> * Register the @a recipient for a notification if this binder</span></div><div class="line"><span class="comment"> * goes away.  If this binder object unexpectedly goes away</span></div><div class="line"><span class="comment"> * (typically because its hosting process has been killed),</span></div><div class="line"><span class="comment"> * then DeathRecipient::binderDied() will be called with a reference</span></div><div class="line"><span class="comment"> * to this.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The @a cookie is optional -- if non-NULL, it should be a</span></div><div class="line"><span class="comment"> * memory address that you own (that is, you know it is unique).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @note You will only receive death notifications for remote binders,</span></div><div class="line"><span class="comment"> * as local binders by definition can't die without you dying as well.</span></div><div class="line"><span class="comment"> * Trying to use this function on a local binder will result in an</span></div><div class="line"><span class="comment"> * INVALID_OPERATION code being returned and nothing happening.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @note This link always holds a weak reference to its recipient.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @note You will only receive a weak reference to the dead</span></div><div class="line"><span class="comment"> * binder.  You should not try to promote this to a strong reference.</span></div><div class="line"><span class="comment"> * (Nor should you need to, as there is nothing useful you can</span></div><div class="line"><span class="comment"> * directly do with it now that it has passed on.)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> status_t        linkToDeath(<span class="keyword">const</span> sp&lt;DeathRecipient&gt;& recipient,</div><div class="line">                                    <span class="keyword">void</span>* cookie = NULL,</div><div class="line">                                    uint32_t flags = <span class="number">0</span>) = <span class="number">0</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>注释很长，意思就是 linkToDeath 可以允许你注册一个回调接口 DeathRecipient 到 Bp。然后当 Bp 对应的 Bn 挂掉了，DeathRecipient 中的 binderDied 会被调用，然后你可以根据你的业务情况做一些处理。那个 binderDied 的参数就是 Bp 对象自己（看后面的代码）。</p>
<p>注意了，虽然 linkToDeath 是 IBinder 的接口，但是只允许在 Bp 端注册。下面的代码能看得出。而且你想想看，这个东西是通知服务端（Bn）挂了的，如果你注册在 Bn 端，你都挂了，还能掉回调么。所以 <strong>注册死亡通知只有在 Bp 才有效</strong>。</p>
<p>然后我们接下去看实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">status_t BpBinder::linkToDeath(</div><div class="line">    <span class="keyword">const</span> sp&lt;DeathRecipient&gt;& recipient, <span class="keyword">void</span>* cookie, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="comment">// 保存回调的数据结构，单词 Obituary 好像是仆告的意思</span></div><div class="line">    <span class="comment">// 看后面的代码，这个结构就只有recipient有用而已（这是回调的指针，最重要）</span></div><div class="line">    Obituary ob;</div><div class="line">    ob.recipient = recipient;</div><div class="line">    ob.cookie = cookie;</div><div class="line">    ob.flags = flags;</div><div class="line"></div><div class="line">    LOG_ALWAYS_FATAL_IF(recipient == NULL,</div><div class="line">                        <span class="string">"linkToDeath(): recipient must be non-NULL"</span>);</div><div class="line"></div><div class="line">    {</div><div class="line">        AutoMutex _l(mLock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!mObitsSent) {</div><div class="line">            <span class="comment">// 用了一个 Vector 来保存，这么说一个 Bp 可以注册多个死亡通知回调</span></div><div class="line">            <span class="keyword">if</span> (!mObituaries) {            </div><div class="line">                mObituaries = <span class="keyword">new</span> Vector&lt;Obituary&gt;;</div><div class="line">                <span class="keyword">if</span> (!mObituaries) {            </div><div class="line">                    <span class="keyword">return</span> NO_MEMORY;              </div><div class="line">                }</div><div class="line">                ALOGV(<span class="string">"Requesting death notification: %p handle %d\n"</span>, <span class="keyword">this</span>, mHandle);</div><div class="line">                <span class="comment">// 又得手动增加引用计数 </span></div><div class="line">                getWeakRefs()-&gt;incWeak(<span class="keyword">this</span>);</div><div class="line">                <span class="comment">// 调用到 IPCThreadState 里面去了  </span></div><div class="line">                IPCThreadState* self = IPCThreadState::self(); </div><div class="line">                <span class="comment">// 注意参数，把自己 ref 的 handle 值和自己的对象传过去了</span></div><div class="line">                self-&gt;requestDeathNotification(mHandle, <span class="keyword">this</span>);</div><div class="line">                <span class="comment">// 类似 flush 的函数，看样子应该对 binder 驱动发命令了</span></div><div class="line">                self-&gt;flushCommands();         </div><div class="line">            }</div><div class="line">            ssize_t res = mObituaries-&gt;add(ob);</div><div class="line">            <span class="keyword">return</span> res &gt;= (ssize_t)NO_ERROR ? (status_t)NO_ERROR : res;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> DEAD_OBJECT;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>BpBinder 拿一个 Vector 来保存死亡回调，说明一个 Bp 可以注册多个回调的。然后我们在去看 IPCThreadState 的处理之前，来看下 Binder 里 linkToDeath 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">status_t BBinder::linkToDeath(</div><div class="line">    <span class="keyword">const</span> sp&lt;DeathRecipient&gt;& recipient, <span class="keyword">void</span>* cookie, uint32_t flags)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> INVALID_OPERATION;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然和前面说的一样，Bn 端的 linkToDeath 是不允许调用的。然后我们可以去 IPCThreadState 来看看 requestDeathNotification 的处理了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)</div><div class="line">{</div><div class="line">    <span class="comment">// 果然是对 binder 驱动发命令</span></div><div class="line">    <span class="comment">// 注意下面的参数，一个是 Bp 的 handle 值，一个 Bp 自身的对象指针</span></div><div class="line">    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);</div><div class="line">    mOut.writeInt32((int32_t)handle);</div><div class="line">    mOut.writeInt32((int32_t)proxy);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面把 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 命令写入要发送的数据包（BC 开头的命令是用户空间往内核空间发送的，忘记的回去看通信篇）。然后把 Bp 的 handle 也写入（Bp 的 handle 值在 kernel 中可能找到 node 的 ref，忘记的回去看对象传递篇）。最后把 Bp 自己对象指针也写入（注意是指针，4字节的地址，看过前面的都应该知道，保存指针能用的只能是本进程而已（Bn 的本地指针是到 Bn 进程才能调用的），所以注册死亡通知只能在 Bp 端注册，所以这里可以保存 Bp 指针）。</p>
<p>然后后面还有个 flushCommands：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> IPCThreadState::flushCommands()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// talkWithDriver 就调用 ioctl 发送 BINDER_WRITE_READ 命令。</span></div><div class="line">    <span class="comment">// false 表示不需要返回，只会写，不会阻塞等待读，马上就返回。</span></div><div class="line">    talkWithDriver(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>Bp 本来要等到 transact（调用 talkWithDriver） 才会真正去对驱动写数据。这个 flushCommands 意思就是马上把命令发出去（很多 I/O 接口都有类似的叫 flush 的函数）。原来就是直接调用了 talkWithDriver 而已（false 不需要返回的）。下面就是到 kernel 的 binder 驱动中去了。我们继续去 kernel 里面去看。</p>
<h2 id="注册死亡通知到_kernel">注册死亡通知到 kernel</h2>
<p>IPCThreadState 调用的 ioctl 发送的是 <code>BINDER_WRITE_READ</code> 命令，然后不需要返回，那就是只会调用 <code>binder_thread_write</code> 而已，然后我来看看 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 命令的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</div><div class="line">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">{</div><div class="line">    uint32_t cmd; </div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end && thread-&gt;return_error == BR_OK) {</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {</div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        }    </div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line">        </div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 注册死亡通知和清除走一个分支，又搞在一起 -_-||</span></div><div class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</div><div class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">            uint32_t target;</div><div class="line">            <span class="keyword">void</span> __user *cookie;</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line"></div><div class="line">            <span class="comment">// 取 Bp 的 handle 值</span></div><div class="line">            <span class="keyword">if</span> (get_user(target, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="comment">// 取从用户空间传下来的指针，刚刚上面传过来的是 Bp 指针</span></div><div class="line">            <span class="comment">// 这里为什么保持用户空间的指针，而不转化成一个具体的类型，</span></div><div class="line">            <span class="comment">// 后面看到 SM 的例子的时候就会知道。</span></div><div class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            <span class="comment">// 通过 handle 值取 ref</span></div><div class="line">            ref = binder_get_ref(proc, target);</div><div class="line">            <span class="keyword">if</span> (ref == NULL) {</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d %s "</span></div><div class="line">                    <span class="string">"invalid ref %d\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    cmd == BC_REQUEST_DEATH_NOTIFICATION ?</div><div class="line">                    <span class="string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :</div><div class="line">                    <span class="string">"BC_CLEAR_DEATH_NOTIFICATION"</span>, </div><div class="line">                    target);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">                     <span class="string">"binder: %d:%d %s %p ref %d desc %d s %d w %d for node %d\n"</span>,</div><div class="line">                     proc-&gt;pid, thread-&gt;pid,        </div><div class="line">                     cmd == BC_REQUEST_DEATH_NOTIFICATION ?</div><div class="line">                     <span class="string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :</div><div class="line">                     <span class="string">"BC_CLEAR_DEATH_NOTIFICATION"</span>, </div><div class="line">                     cookie, ref-&gt;debug_id, ref-&gt;desc,</div><div class="line">                     ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);</div><div class="line"></div><div class="line">            <span class="comment">// 说走一条分支么，后面还不是分开啦</span></div><div class="line">            <span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) {</div><div class="line">                <span class="comment">// 上面好像 Bp 可以注册多个，但是在kernel里面只能注册一个咧</span></div><div class="line">                <span class="keyword">if</span> (ref-&gt;death) {</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">                        <span class="string">"d BC_REQUEST_DEATH_NOTI"</span></div><div class="line">                        <span class="string">"FICATION death notific"</span></div><div class="line">                        <span class="string">"ation already set\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                <span class="comment">// 这个 binder_ref_death 是kernel中保存死亡通知回调的结构</span></div><div class="line">                death = kzalloc(<span class="keyword">sizeof</span>(*death), GFP_KERNEL);</div><div class="line">                <span class="keyword">if</span> (death == NULL) {</div><div class="line">                    thread-&gt;return_error = BR_ERROR;</div><div class="line">                    binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</div><div class="line">                             <span class="string">"binder: %d:%d "</span></div><div class="line">                             <span class="string">"BC_REQUEST_DEATH_NOTIFICATION failed\n"</span>,</div><div class="line">                             proc-&gt;pid, thread-&gt;pid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                binder_stats_created(BINDER_STAT_DEATH);</div><div class="line">                <span class="comment">// 初始化的工作队列列表</span></div><div class="line">                INIT_LIST_HEAD(&death-&gt;work.entry);</div><div class="line">                <span class="comment">// 把用户空间传过来的那个指针保存起来</span></div><div class="line">                death-&gt;cookie = cookie;</div><div class="line">                <span class="comment">// 每一个 ref 保存有一个 binder_ref_death</span></div><div class="line">                ref-&gt;death = death;</div><div class="line">                <span class="comment">// 如果 ref 对应的 node 的 进程已经挂了，这里直接就发通知了</span></div><div class="line">                <span class="comment">// 这种情况不属于一般情况，我们这里讨论</span></div><div class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == NULL) {</div><div class="line">                    ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</div><div class="line">                    printk(KERN_INFO <span class="string">"binder: %d:%d in binder_thread_write BC_REQUEST_DEATH or CLEAR: 0x%08x \n"</span>,</div><div class="line">                            proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">                    <span class="keyword">if</span> (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {</div><div class="line">                        list_add_tail(&ref-&gt;death-&gt;work.entry, &thread-&gt;todo);</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        list_add_tail(&ref-&gt;death-&gt;work.entry, &proc-&gt;todo);</div><div class="line">                        wake_up_interruptible(&proc-&gt;wait);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line"><span class="comment">// 下面是清除已经注册的死亡通知的，我们先不看</span></div><div class="line">... ...</div><div class="line">            }</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printk(KERN_ERR <span class="string">"binder: %d:%d unknown command %d\n"</span>,</div><div class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        }</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后先来看看相关的数据结构先：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个 work 其实前面通信篇有涉及到，不过那个时候好像没贴代码出来</span></div><div class="line"><span class="keyword">struct</span> binder_work {</div><div class="line">    <span class="comment">// 其实这个结构就只是一个列表而已，要不然怎么叫工作队列 -_-||</span></div><div class="line">    <span class="keyword">struct</span> list_head entry;</div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,   </div><div class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</div><div class="line">        BINDER_WORK_NODE,</div><div class="line">        BINDER_WORK_DEAD_BINDER,       </div><div class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</div><div class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</div><div class="line">    } type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 这个其实也挺简单，一个工作结构，下面是用户空间那个指针</span></div><div class="line"><span class="keyword">struct</span> binder_ref_death {</div><div class="line">    <span class="keyword">struct</span> binder_work work; </div><div class="line">    <span class="keyword">void</span> __user *cookie;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_ref {</div><div class="line">    <span class="comment">/* Lookups needed: */</span></div><div class="line">    <span class="comment">/*   node + proc =&gt; ref (transaction) */</span></div><div class="line">    <span class="comment">/*   desc + proc =&gt; ref (transaction, inc/dec ref) */</span></div><div class="line">    <span class="comment">/*   node =&gt; refs + procs (proc exit) */</span></div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="keyword">struct</span> rb_node rb_node_desc;</div><div class="line">    <span class="keyword">struct</span> rb_node rb_node_node;</div><div class="line">    <span class="keyword">struct</span> hlist_node node_entry;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc; </div><div class="line">    <span class="keyword">struct</span> binder_node *node;</div><div class="line">    uint32_t desc;</div><div class="line">    <span class="keyword">int</span> strong;</div><div class="line">    <span class="keyword">int</span> weak;</div><div class="line">    <span class="comment">// 注册了的死亡通知结构</span></div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>数据结构不算复杂。然后这个注册过程就算结束了。当 Bp 注册了死亡回调后，native 的 Bp 会把 DeathRecipient 保存到自己的一个结构中，然后发命令给 kernel，在 kernel 中的 Bp 对应的 ref 中也保存到了一个结构中。就是说这个回调最终是注册到 kernel 里面的。</p>
<h2 id="触发死亡通知">触发死亡通知</h2>
<p>上面说了注册最终是注册到 kernel 里面的，那触发也应该是由 kernel 来触发的。实际就是这样的。那我们来看下是怎么触发死亡通知的。binder 驱动有个关闭（释放）操作的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = {</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .poll = binder_poll,</div><div class="line">    .unlocked_ioctl = binder_ioctl,</div><div class="line">    .mmap = binder_mmap,</div><div class="line">    .open = binder_open,</div><div class="line">    .flush = binder_flush,</div><div class="line">    .release = binder_release,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_release(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    debugfs_remove(proc-&gt;debugfs_entry);</div><div class="line">    <span class="comment">// 定义了一个 kernel 的工作队列</span></div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们来看最后那个函数 <code>binder_defer_work</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> HLIST_HEAD(binder_procs);</div><div class="line"><span class="comment">// 全局的延迟工作列表</span></div><div class="line"><span class="keyword">static</span> HLIST_HEAD(binder_deferred_list);</div><div class="line"><span class="keyword">static</span> HLIST_HEAD(binder_dead_nodes); </div><div class="line"></div><div class="line"><span class="comment">// 全局的工作队列</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> workqueue_struct *binder_deferred_workqueue;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init binder_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建单线程的工作队列</span></div><div class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</div><div class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 静态定义一个工作队列</span></div><div class="line"><span class="keyword">static</span> DECLARE_WORK(binder_deferred_work, binder_deferred_func);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">binder_defer_work(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">enum</span> binder_deferred_state defer)</div><div class="line">{</div><div class="line">    mutex_lock(&binder_deferred_lock);</div><div class="line">    <span class="comment">// 设置进程工作的类型，这里是前面那个 BINDER_DEFERRED_RELEASE</span></div><div class="line">    proc-&gt;deferred_work |= defer;</div><div class="line">    <span class="comment">// 判断这个进程是不是已经加到工作队列里去了</span></div><div class="line">    <span class="keyword">if</span> (hlist_unhashed(&proc-&gt;deferred_work_node)) {</div><div class="line">        <span class="comment">// 还没有的话把这个进程的工作节点加到全局的工作队列里</span></div><div class="line">        hlist_add_head(&proc-&gt;deferred_work_node,</div><div class="line">                &binder_deferred_list);</div><div class="line">        <span class="comment">// 这里是加到 kernel 的工作队列中        </span></div><div class="line">        queue_work(binder_deferred_workqueue, &binder_deferred_work);</div><div class="line">    }</div><div class="line">    mutex_unlock(&binder_deferred_lock);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数是设置一个工作队列。注意这里的工作队列是 kernel 提供的机制，不是前面说的 binder 添加的那个工作列队。kernel 提供的 workqueue 是提供一种延迟执行的机制，通常硬件设备需要一定的时间才能执行完指令操作，所以需要这种机制。这里应该是等 binder 设备关闭完成才执行吧（关于 workqueue 可以自己去查一些 kernel 相关的资料）。看这个函数的名字： <code>binder_defer_work</code>，名字都带延迟（defer 就是延迟的意思）。反正这里就理解为 binder 设备关闭之后，会执行工作队列设置的那个函数 <code>binder_deferred_func</code> 就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_deferred_func(<span class="keyword">struct</span> work_struct *work)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;</div><div class="line">    <span class="keyword">struct</span> files_struct *files;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> defer;</div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        mutex_lock(&binder_lock);      </div><div class="line">        mutex_lock(&binder_deferred_lock);</div><div class="line">        <span class="keyword">if</span> (!hlist_empty(&binder_deferred_list)) {</div><div class="line">            <span class="comment">// 在全局的工作队列中取最靠前的那个</span></div><div class="line">            proc = hlist_entry(binder_deferred_list.first,</div><div class="line">                    <span class="keyword">struct</span> binder_proc, deferred_work_node);</div><div class="line">            <span class="comment">// 取出来后，从全局工作队列中删除</span></div><div class="line">            hlist_del_init(&proc-&gt;deferred_work_node);</div><div class="line">            <span class="comment">// 取之前 binder_defer_work 设置的变量，</span></div><div class="line">            <span class="comment">// 就是那个 BINDER_DEFERRED_RELEASE</span></div><div class="line">            defer = proc-&gt;deferred_work;   </div><div class="line">            proc-&gt;deferred_work = <span class="number">0</span>;       </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            proc = NULL;</div><div class="line">            defer = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        mutex_unlock(&binder_deferred_lock);</div><div class="line"></div><div class="line">        files = NULL;</div><div class="line">        <span class="keyword">if</span> (defer & BINDER_DEFERRED_PUT_FILES) { </div><div class="line">            files = proc-&gt;files;           </div><div class="line">            <span class="keyword">if</span> (files)</div><div class="line">                proc-&gt;files = NULL;            </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (defer & BINDER_DEFERRED_FLUSH)</div><div class="line">            binder_deferred_flush(proc);</div><div class="line"></div><div class="line">        <span class="comment">// 所以这里是走这个分支</span></div><div class="line">        <span class="keyword">if</span> (defer & BINDER_DEFERRED_RELEASE)</div><div class="line">            binder_deferred_release(proc); <span class="comment">/* frees proc */</span></div><div class="line"></div><div class="line">        mutex_unlock(&binder_lock);</div><div class="line">        <span class="keyword">if</span> (files)</div><div class="line">            put_files_struct(files);</div><div class="line">    } <span class="keyword">while</span> (proc);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接下去看 <code>binder_deferred_release</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意这里传过来的 proc 是 Bn 的</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_deferred_release(<span class="keyword">struct</span> binder_proc *proc)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> hlist_node *pos;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *t;</div><div class="line">    <span class="keyword">struct</span> rb_node *n;</div><div class="line">    <span class="keyword">int</span> threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;</div><div class="line"></div><div class="line">    BUG_ON(proc-&gt;vma);</div><div class="line">    BUG_ON(proc-&gt;files);</div><div class="line"></div><div class="line">    hlist_del(&proc-&gt;proc_node);</div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node && binder_context_mgr_node-&gt;proc == proc) {</div><div class="line">        binder_debug(BINDER_DEBUG_DEAD_BINDER,</div><div class="line">                 <span class="string">"binder_release: %d context_mgr_node gone\n"</span>,</div><div class="line">                 proc-&gt;pid);</div><div class="line">        binder_context_mgr_node = NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    threads = <span class="number">0</span>;</div><div class="line">    active_transactions = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 这里是释放之前申请的 thread 相关的变量的内存吧。</span></div><div class="line">    <span class="comment">// 前面线程篇有说 Bn 每开一个线程会 new 一个 binder_thread 的</span></div><div class="line">    <span class="keyword">while</span> ((n = rb_first(&proc-&gt;threads))) {</div><div class="line">        <span class="keyword">struct</span> binder_thread *thread = rb_entry(n, <span class="keyword">struct</span> binder_thread, rb_node);</div><div class="line">        threads++;</div><div class="line">        active_transactions += binder_free_thread(proc, thread);</div><div class="line">    }</div><div class="line">    nodes = <span class="number">0</span>;</div><div class="line">    incoming_refs = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 这里是遍历进程的每一个 node（一个 node 对应一个 Bn）</span></div><div class="line">    <span class="keyword">while</span> ((n = rb_first(&proc-&gt;nodes))) {</div><div class="line">        <span class="keyword">struct</span> binder_node *node = rb_entry(n, <span class="keyword">struct</span> binder_node, rb_node);</div><div class="line"></div><div class="line">        nodes++;</div><div class="line">        rb_erase(&node-&gt;rb_node, &proc-&gt;nodes);</div><div class="line">        list_del_init(&node-&gt;work.entry);</div><div class="line">        <span class="keyword">if</span> (hlist_empty(&node-&gt;refs)) {</div><div class="line">            <span class="comment">// 如果这个 node 没有 ref 的话，可以直接删除</span></div><div class="line">            kfree(node);</div><div class="line">            binder_stats_deleted(BINDER_STAT_NODE);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">struct</span> binder_ref *ref;</div><div class="line">            <span class="keyword">int</span> death = <span class="number">0</span>;</div><div class="line"></div><div class="line">            node-&gt;proc = NULL;</div><div class="line">            node-&gt;local_strong_refs = <span class="number">0</span>;</div><div class="line">            node-&gt;local_weak_refs = <span class="number">0</span>;</div><div class="line">            hlist_add_head(&node-&gt;dead_node, &binder_dead_nodes);</div><div class="line"></div><div class="line">            <span class="comment">// 否则得看看 ref 里面是否设置了死亡通知回调</span></div><div class="line">            hlist_for_each_entry(ref, pos, &node-&gt;refs, node_entry) {</div><div class="line">                incoming_refs++;</div><div class="line">                <span class="keyword">if</span> (ref-&gt;death) {</div><div class="line">                    death++;</div><div class="line">                    <span class="comment">// 如果有设置的话，要发送死亡通知回调</span></div><div class="line">                    <span class="comment">//这里先判断这个死亡回调是否正在发送，如果是就不用再发送了</span></div><div class="line">                    <span class="keyword">if</span> (list_empty(&ref-&gt;death-&gt;work.entry)) {</div><div class="line">                        <span class="comment">// 没发送的话，就把死亡回调的工作状态设置一下</span></div><div class="line">                        <span class="comment">// 死亡回调发送也和前面 Bp 发请求差不多，</span></div><div class="line">                        <span class="comment">// 弄成了一个binder_work的东西，其实就是一个状态。</span></div><div class="line">                        ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</div><div class="line">                        <span class="comment">// 然后把这个 work 添加到 ref 的进程的 todo list</span></div><div class="line">                        <span class="comment">// 注意添加到的是 ref 的进程，就是 Bp 的进程。</span></div><div class="line">                        list_add_tail(&ref-&gt;death-&gt;work.entry, &ref-&gt;proc-&gt;todo);</div><div class="line">                        <span class="comment">// 然后唤醒 ref 的进程（Bp 进程）</span></div><div class="line">                        wake_up_interruptible(&ref-&gt;proc-&gt;wait);</div><div class="line">                    } <span class="keyword">else</span></div><div class="line">                        BUG();</div><div class="line">                }</div><div class="line">            }</div><div class="line">            binder_debug(BINDER_DEBUG_DEAD_BINDER,</div><div class="line">                     <span class="string">"binder: node %d now dead, "</span></div><div class="line">                     <span class="string">"refs %d, death %d\n"</span>, node-&gt;debug_id,</div><div class="line">                     incoming_refs, death);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="comment">// 后面就是 binder_proc 结构的清理，</span></div><div class="line"><span class="comment">// 例如清除一些引用和之前申请的一些结构体的内存等。这里不细看了。</span></div><div class="line">... ...</div><div class="line"></div><div class="line">    kfree(proc);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子是在释放 Bn 的 kernel 的 proc 时候去检测在 proc 的 node 的 ref 有没有注册死亡通知回调（前面上层发注册命令注册）。如果注册了，就添加一个 work 到 ref 的进程的 todo list，并唤醒它。这个 ref 的进程就是 Bp 了，前面注册也是 Bp 注册的。然后根据前面通信篇说的，这个唤醒的是 <code>binder_thread_read</code>，但是不是所有 Bp 都会阻塞在 read 那的，一般 Bn 才会（不过很多 Bn 也经常当 Bp 的，例如请求别的服务）。如果是普通单纯的 Bp 的要等到下一次 transact 才能有机会收到这个通知。好了，我们继续去 Bp 的 <code>binder_thread_read</code> 里面去看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</div><div class="line">                  <span class="keyword">struct</span> binder_thread *thread,  </div><div class="line">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</div><div class="line">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block) </div><div class="line">{</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        uint32_t cmd;</div><div class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</div><div class="line">        <span class="keyword">struct</span> binder_work *w;</div><div class="line">        <span class="keyword">struct</span> binder_transaction *t = NULL;</div><div class="line"></div><div class="line">        <span class="comment">//printk(KERN_INFO "binder: %d:%d ptr=%08lx end=%08lx buffer=%08lx\n", proc-&gt;pid, thread-&gt;pid, ptr, end, buffer);</span></div><div class="line">        <span class="keyword">if</span> (!list_empty(&thread-&gt;todo)) </div><div class="line">            w = list_first_entry(&thread-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&proc-&gt;todo) && wait_for_proc_work) </div><div class="line">            w = list_first_entry(&proc-&gt;todo, <span class="keyword">struct</span> binder_work, entry);</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> && !(thread-&gt;looper & BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span> </div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (w-&gt;type) {</div><div class="line">... ...</div><div class="line">        <span class="comment">// 又一是堆走一个分支，</span></div><div class="line">        <span class="comment">// 刚刚前面发过来的 work type 是 BINDER_WORK_DEAD_BINDER</span></div><div class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">            <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">            uint32_t cmd;</div><div class="line"></div><div class="line">            <span class="comment">// 从发过来的 work 中取 death 结构</span></div><div class="line">            death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">// 这里返回给用户的是 BR_DEAD_BINDER             </span></div><div class="line">                cmd = BR_DEAD_BINDER;</div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">            <span class="comment">// 把用户空间注册过来时传过来的那个指针，原封不动的传回去</span></div><div class="line">            <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">                     <span class="string">"binder: %d:%d %s %p\n"</span>,</div><div class="line">                      proc-&gt;pid, thread-&gt;pid,</div><div class="line">                      cmd == BR_DEAD_BINDER ?</div><div class="line">                      <span class="string">"BR_DEAD_BINDER"</span> :</div><div class="line">                      <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>,</div><div class="line">                      death-&gt;cookie);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {</div><div class="line">                <span class="comment">// 如果是清除死亡通知的话，可以释放之前申请的death结构的内存</span></div><div class="line">                list_del(&w-&gt;entry);</div><div class="line">                kfree(death);</div><div class="line">                binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">            } <span class="keyword">else</span></div><div class="line">                <span class="comment">// 这里不是清除，是触发通知，</span></div><div class="line">                <span class="comment">// 把这个 work 队列放到该进程的 delivered_death 队列中</span></div><div class="line">                list_move(&w-&gt;entry, &proc-&gt;delivered_death);</div><div class="line">            <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)</div><div class="line">                <span class="comment">// 这个很省事，直接就完工了，下面的处理都不用跑了</span></div><div class="line">                <span class="comment">// 看注释是说发送死亡通知可以中断传输</span></div><div class="line">                <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">done:</div><div class="line"></div><div class="line">    *consumed = ptr - buffer;</div><div class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &&</div><div class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &&</div><div class="line">        (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">         BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></div><div class="line">         <span class="comment">/*spawn a new thread if we leave this out */</span>) {</div><div class="line">        proc-&gt;requested_threads++;</div><div class="line">        binder_debug(BINDER_DEBUG_THREADS,</div><div class="line">                 <span class="string">"binder: %d:%d BR_SPAWN_LOOPER\n"</span>,</div><div class="line">                 proc-&gt;pid, thread-&gt;pid);</div><div class="line">        <span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>根据前面通信篇的分析，这里 kernel 向用户空间发送了一个返回值： <code>BR_DEAD_BINDER</code>，并把之前用户空间注册时候发过来的那个指针原封不动的发了回去。我们现在要去用户空间看下，最终是怎么触发用户空间的回调的。我们发现 IPCThreadState 有处理 <code>BR_DEAD_BINDER</code> 的地方是 executeCommand。这个函数我们看看在哪几个地方会调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::getAndExecuteCommand()</div><div class="line">{</div><div class="line">    status_t result;</div><div class="line">    int32_t cmd;</div><div class="line"></div><div class="line">    result = talkWithDriver();</div><div class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) {</div><div class="line">        size_t IN = mIn.dataAvail();   </div><div class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(int32_t)) <span class="keyword">return</span> result;</div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></div><div class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这里调用了</span></div><div class="line">        result = executeCommand(cmd);  </div><div class="line"></div><div class="line">        <span class="comment">// After executing the command, ensure that the thread is returned to the</span></div><div class="line">        <span class="comment">// foreground cgroup before rejoining the pool.  The driver takes care of</span></div><div class="line">        <span class="comment">// restoring the priority, but doesn't do anything with cgroups so we</span></div><div class="line">        <span class="comment">// need to take care of that here in userspace.  Note that we do make</span></div><div class="line">        <span class="comment">// sure to go in the foreground after executing a transaction, but</span></div><div class="line">        <span class="comment">// there are other callbacks into user code that could have changed</span></div><div class="line">        <span class="comment">// our group so we want to make absolutely sure it is put back.</span></div><div class="line">        set_sched_policy(mMyThreadId, SP_FOREGROUND);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</div><div class="line">{</div><div class="line">    int32_t cmd;</div><div class="line">    int32_t err;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        err = mIn.errorCheck();        </div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;     </div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">        cmd = mIn.readInt32();</div><div class="line">        </div><div class="line">        IF_LOG_COMMANDS() {</div><div class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></div><div class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) {</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// 还有这里</span></div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">finish:</div><div class="line">    <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</div><div class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</div><div class="line">        mLastError = err;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个2个函数，一个 getAndExecuteCommand 是当 Bn 的服务循环阻塞等待请求的时候调用的；一个 waitForResponse 是 Bp 发请求给 Bn，等待服务返回的时候调用的。正好对应上面说的2种情况，一个是服务中当别服务的 Bp，一个是普通应用的 Bp。</p>
<p>然后我们继续看 executeCommand：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">       </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">case</span> BR_DEAD_BINDER:</div><div class="line">        {</div><div class="line">            <span class="comment">// 这里转化成 Bp 指针了，前面注意就是 Bp 指针</span></div><div class="line">            BpBinder *proxy = (BpBinder*)mIn.readInt32();</div><div class="line">            <span class="comment">// 然后调用 Bp 的发送仆告的函数</span></div><div class="line">            proxy-&gt;sendObituary();</div><div class="line">            <span class="comment">// 然后对 kernel 发 BC_DEAD_BINDER_DONE 通知放送完成的命令</span></div><div class="line">            mOut.writeInt32(BC_DEAD_BINDER_DONE);</div><div class="line">            <span class="comment">// 把 Bp 的 handle 写进入刚刚的命名包里</span></div><div class="line">            mOut.writeInt32((int32_t)proxy);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>前面 Bp 注册把自己的指针传到注册里面去，这里又取出，调用自己的函数。所以前面说注册只能在 Bp 里面注册，要是在 Bn 里注册，这里怎么调用 Bp 的函数。我们去看下 Bp 的 sendObituary 函数（名字真形象，发送仆告）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BpBinder::sendObituary()</div><div class="line">{</div><div class="line">    ALOGV(<span class="string">"Sending obituary for proxy %p handle %d, mObitsSent=%s\n"</span>,</div><div class="line">        <span class="keyword">this</span>, mHandle, mObitsSent ? <span class="string">"true"</span> : <span class="string">"false"</span>);</div><div class="line"></div><div class="line">    mAlive = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果通知已经发送，就返回</span></div><div class="line">    <span class="keyword">if</span> (mObitsSent) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    mLock.lock();</div><div class="line">    <span class="comment">// 取前面注册保存的回调</span></div><div class="line">    Vector&lt;Obituary&gt;* obits = mObituaries;</div><div class="line">    <span class="keyword">if</span>(obits != NULL) {</div><div class="line">        ALOGV(<span class="string">"Clearing sent death notification: %p handle %d\n"</span>, <span class="keyword">this</span>, mHandle);</div><div class="line">        <span class="comment">// 这里发通知前先把已经注册了通知清理掉</span></div><div class="line">        IPCThreadState* self = IPCThreadState::self(); </div><div class="line">        self-&gt;clearDeathNotification(mHandle, <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// 马上对 kernel 发清理命令</span></div><div class="line">        self-&gt;flushCommands();</div><div class="line">        mObituaries = NULL;</div><div class="line">    }</div><div class="line">    <span class="comment">// 设置当前通知已经发送</span></div><div class="line">    mObitsSent = <span class="number">1</span>;</div><div class="line">    mLock.unlock();</div><div class="line"></div><div class="line">    ALOGV(<span class="string">"Reporting death of proxy %p for %d recipients\n"</span>,</div><div class="line">        <span class="keyword">this</span>, obits ? obits-&gt;size() : <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (obits != NULL) {</div><div class="line">        <span class="keyword">const</span> size_t N = obits-&gt;size();</div><div class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">            <span class="comment">// 发送通知   </span></div><div class="line">            reportOneDeath(obits-&gt;itemAt(i));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">delete</span> obits;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子，这个死亡通知会如果被触发过一次就会被自动清理掉。想想看，确实，发送过一次，说明那个服务已经挂了，当然不会死二次。那我们先去看看这个回调怎么清理掉的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::clearDeathNotification(int32_t handle, BpBinder* proxy)</div><div class="line">{</div><div class="line">    mOut.writeInt32(BC_CLEAR_DEATH_NOTIFICATION);</div><div class="line">    mOut.writeInt32((int32_t)handle);</div><div class="line">    mOut.writeInt32((int32_t)proxy);</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>简单明了的处理。对 kernel 发了一个 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 命令，然后后面一个 flushCommands，马上调用 ioctl 能马上发送到 kernel。这个处理在 <code>binder_thread_write</code> 里面，还记得前面发注册命令 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 时候那个分支也有 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 的么，现在可以来看一下了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面取用户空间写的 Bp 的 handle，然后可以取得到 ref </span></div><div class="line"><span class="comment">// 然后那个 cookie 就是用户空间传过来那个指针</span></div><div class="line"><span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) {</div><div class="line">    <span class="comment">// 这里是上面处理注册回调的</span></div><div class="line">    ... ...</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    <span class="comment">// 这里是清理回调的</span></div><div class="line">    <span class="comment">// 如果 ref 的 death 没有，要是没注册，要么是已经清理过了</span></div><div class="line">    <span class="keyword">if</span> (ref-&gt;death == NULL) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">            <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></div><div class="line">            <span class="string">"CATION death notificat"</span></div><div class="line">            <span class="string">"ion not active\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    death = ref-&gt;death;</div><div class="line">    <span class="comment">// 这里拿传过来那个指针做下验证</span></div><div class="line">    <span class="keyword">if</span> (death-&gt;cookie != cookie) {</div><div class="line">        binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">            <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></div><div class="line">            <span class="string">"CATION death notificat"</span></div><div class="line">            <span class="string">"ion cookie mismatch "</span></div><div class="line">            <span class="string">"%p != %p\n"</span>,</div><div class="line">            proc-&gt;pid, thread-&gt;pid,</div><div class="line">            death-&gt;cookie, cookie);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 把 ref 的回调设置为空</span></div><div class="line">    ref-&gt;death = NULL;</div><div class="line">    <span class="comment">// 这里一般这个死亡通知回调的 work 列队是空的</span></div><div class="line">    <span class="comment">// 前面触发了通知后，把这个队列移到 proc-&gt;delivered_death 去了 </span></div><div class="line">    <span class="keyword">if</span> (list_empty(&death-&gt;work.entry)) {</div><div class="line">        <span class="comment">// work 状态又变了</span></div><div class="line">        death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</div><div class="line">        <span class="comment">// 这里是改变那个 work 状态，然后根据这个线程的情况加到</span></div><div class="line">        <span class="comment">// 对应的 todo list，唤醒 binder_thread_read</span></div><div class="line">        <span class="keyword">if</span> (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &thread-&gt;todo);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &proc-&gt;todo);</div><div class="line">            wake_up_interruptible(&proc-&gt;wait);</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);</div><div class="line">        death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><code>binder_thead_write</code> 里面的清理只是把 ref 的回调设置成 NULL 了。然后要靠下一次 <code>binder_thread_read</code> 继续清理。注意这里是要等到下一次 ioctl 才能有 <code>binder_thread_read</code> 的，因为前面用 flushCommads 调用 talkWithDeriver 是不带返回值的，所以这次不会调用 <code>binder_thread_read</code> 的。那个我们先提前来看下吧（<code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> 前面也有看到，都是走一个分支的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:  </div><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line"><span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">    uint32_t cmd;</div><div class="line"></div><div class="line">    death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">        <span class="comment">// 这次返回给用户空间的是这个命令咯</span></div><div class="line">        cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        cmd = BR_DEAD_BINDER;</div><div class="line">    <span class="comment">// 继续原封不动的把这些东西传给用户空间          </span></div><div class="line">    <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">    <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);         </div><div class="line">    binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">             <span class="string">"binder: %d:%d %s %p\n"</span>,       </div><div class="line">              proc-&gt;pid, thread-&gt;pid,        </div><div class="line">              cmd == BR_DEAD_BINDER ?        </div><div class="line">              <span class="string">"BR_DEAD_BINDER"</span> :             </div><div class="line">              <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>,</div><div class="line">              death-&gt;cookie);                </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {</div><div class="line">        <span class="comment">// 删除死亡通知的 work 队列</span></div><div class="line">        list_del(&w-&gt;entry);       </div><div class="line">        <span class="comment">// 这里把注册的时候 kalloc 申请的 binder_death 给释放掉了    </span></div><div class="line">        kfree(death); </div><div class="line">        binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">    } <span class="keyword">else</span></div><div class="line">        list_move(&w-&gt;entry, &proc-&gt;delivered_death);</div><div class="line">    <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)     </div><div class="line">        <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">} <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这样之前注册时候申请的资源就差不多释放完了。不过还要继续去用户空间看看 <code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> 的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">{</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">   </div><div class="line">    <span class="keyword">switch</span> (cmd) {</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 我就说我恨这些啥引用计数</span></div><div class="line">    <span class="keyword">case</span> BR_CLEAR_DEATH_NOTIFICATION_DONE:</div><div class="line">        {</div><div class="line">            BpBinder *proxy = (BpBinder*)mIn.readInt32();</div><div class="line">            proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</div><div class="line">        } <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</div><div class="line">        result = UNKNOWN_ERROR;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">            </div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) {</div><div class="line">        mLastError = result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>死亡通知回调就差不多清理完了。然后我们可以继续来看死亡通知的发送了（搞了半天还没触发回调咧）。我们回到 sendObituary 的后面那部分，循环取 mObituaries 的每一元素，然后调用 reportOneDeath： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BpBinder::reportOneDeath(<span class="keyword">const</span> Obituary& obit)</div><div class="line">{</div><div class="line">    <span class="comment">// 之前注册，new Obituary 的时候有传 Bp 的 this 指针过去，</span></div><div class="line">    <span class="comment">// 又要搞啥弱引用转强引用</span></div><div class="line">    sp&lt;DeathRecipient&gt; recipient = obit.recipient.promote();</div><div class="line">    ALOGV(<span class="string">"Reporting death to recipient: %p\n"</span>, recipient.get());</div><div class="line">    <span class="keyword">if</span> (recipient == NULL) <span class="keyword">return</span>; </div><div class="line"></div><div class="line">    <span class="comment">// 终于调用死亡通知的回调函数了，参数就是 Bp 自己的指针</span></div><div class="line">    recipient-&gt;binderDied(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>到这里就算把死亡通知通知到位了。调用了 Bp 注册的回调，然后就是不同的业务不同的处理了。</p>
<p>通知发送完了，但是上面 IPCThreadState 的 <code>BR_DEAD_BINDER</code> 最后还有一个处理：对 kernel 发了一条 <code>BC_DEAD_BINDER_DONE</code> 命令，我们来看看最后的处理吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BC_DEAD_BINDER_DONE: {    </div><div class="line">    <span class="keyword">struct</span> binder_work *w;         </div><div class="line">    <span class="keyword">void</span> __user *cookie;           </div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death = NULL;</div><div class="line">    <span class="comment">// 这个是注册的时候写的用户空间那个指针</span></div><div class="line">    <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line"></div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);    </div><div class="line">    <span class="comment">// 前面在触发通知的时候，death 的work移动到了delivered_death了</span></div><div class="line">    <span class="comment">// 这里在 delivered_death 中通过那个指针找到对应的 death      </span></div><div class="line">    list_for_each_entry(w, &proc-&gt;delivered_death, entry) {</div><div class="line">        <span class="keyword">struct</span> binder_ref_death *tmp_death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">        <span class="keyword">if</span> (tmp_death-&gt;cookie == cookie) {</div><div class="line">            death = tmp_death;             </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    binder_debug(BINDER_DEBUG_DEAD_BINDER,</div><div class="line">             <span class="string">"binder: %d:%d BC_DEAD_BINDER_DONE %p found %p\n"</span>,</div><div class="line">             proc-&gt;pid, thread-&gt;pid, cookie, death);</div><div class="line">    <span class="keyword">if</span> (death == NULL) {           </div><div class="line">        binder_user_error(<span class="string">"binder: %d:%d BC_DEAD"</span></div><div class="line">            <span class="string">"_BINDER_DONE %p not found\n"</span>, </div><div class="line">            proc-&gt;pid, thread-&gt;pid, cookie);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 删除 death 中 work 队列</span></div><div class="line">    list_del_init(&death-&gt;work.entry);</div><div class="line">    <span class="comment">// 最后把 work 的 type 设置一下，最后还要发送到 read 去处理下，</span></div><div class="line">    <span class="comment">// 看样子最后还要清理一下，申请的 death 结构还没释放咧</span></div><div class="line">    <span class="keyword">if</span> (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {</div><div class="line">        death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</div><div class="line">        <span class="keyword">if</span> (thread-&gt;looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &thread-&gt;todo);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            list_add_tail(&death-&gt;work.entry, &proc-&gt;todo);</div><div class="line">            wake_up_interruptible(&proc-&gt;wait);</div><div class="line">        }</div><div class="line">    }</div><div class="line">} <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接着去看 <code>binder_thread_read</code> 里面看看 <code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> 的处理（前面好像有看到过）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:  </div><div class="line"><span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line"><span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {</div><div class="line">    <span class="keyword">struct</span> binder_ref_death *death;</div><div class="line">    uint32_t cmd;     </div><div class="line"></div><div class="line">    death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</div><div class="line">    <span class="comment">// 完成还要返回给用户空间一个 DONE 消息</span></div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">        cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        cmd = BR_DEAD_BINDER;          </div><div class="line">    <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(uint32_t);       </div><div class="line">    <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">        <span class="keyword">return</span> -EFAULT;                </div><div class="line">    ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);         </div><div class="line">    binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</div><div class="line">             <span class="string">"binder: %d:%d %s %p\n"</span>,       </div><div class="line">              proc-&gt;pid, thread-&gt;pid,        </div><div class="line">              cmd == BR_DEAD_BINDER ?        </div><div class="line">              <span class="string">"BR_DEAD_BINDER"</span> :             </div><div class="line">              <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>,</div><div class="line">              death-&gt;cookie);                </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {</div><div class="line">        <span class="comment">// 果然把 death 释放掉，然后把 work 也删掉了</span></div><div class="line">        list_del(&w-&gt;entry);           </div><div class="line">        kfree(death); </div><div class="line">        binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">    } <span class="keyword">else</span></div><div class="line">        list_move(&w-&gt;entry, &proc-&gt;delivered_death);</div><div class="line">    <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)     </div><div class="line">        <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">} <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后接着回去 IPCThreadState 再去看看 <code>BR_CLEAR_DEATH_NOTIFICATION_DONE</code> 的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BR_CLEAR_DEATH_NOTIFICATION_DONE:</div><div class="line">    {</div><div class="line">        <span class="comment">// 之前手动增加的引用计数，还是手动减少</span></div><div class="line">        BpBinder *proxy = (BpBinder*)mIn.readInt32();</div><div class="line">        proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</div><div class="line">    } <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>到这里处理终于完了。上一张图吧：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Binder-death/1.png" alt=""></p>
<p>但是这里还有一个疑问。根据前面的分析，最后能触发调用注册的死亡通知回调，最开始是因为 Bn 的 binder 驱动关闭函数（<code>binder_release</code>）里面设置的延迟工作队列触发的。我们很清楚 ProcessState 的构造函数里有明确的 open 过 binder 驱动，但是好像没哪里 close 过。是的，没错，我 grep 了代码好久，确实没哪里 close 过。</p>
<p>于是我就猜测是不是在程序结束后会自动关闭打开过的设备驱动。我询问我们那弄 kernel 的同事，他说应该不会的。然后我做了个小试验，我弄了 native 的服务，跑在命令行下面。不管我是 ctrl + C 发信号量退出，还是写个 client 发个命令让它正常退出，还是直接 kill -9 强制终止，<code>binder_release</code> 都会调用（我有在 kernel 的 binder 驱动里面加打印）。我刚开始怀疑是不是注册了一些信号量函数，然后在收到一个些信号量里面做写什么处理。但是又去翻了好久，没找到相关的代码。</p>
<p>后来没办法，我就专门写了个小程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {</div><div class="line">    <span class="comment">// 打开 binder 设备驱动</span></div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="comment">// 不手动关闭</span></div><div class="line">    <span class="comment">//close(fd);</span></div><div class="line">    <span class="comment">// 然后直接退出</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>通过 dmesg 的 kernel 打印，发现这个程序退出后，<code>binder_release</code> 依然调用了。后面去度娘查了下，好像 kernel 从哪个版本开始加入了文件设备的计数引用支持。难道又是啥引用计数自动检测到这个打开的文件描述符没人用了，然后就自动关闭啦。后面又拿这个现象去问了下搞 kernel 的同事，他说有可能在文件系统级别有支持。不过这个就比较复杂了。</p>
<p>哎，没办法了，这里我们只能简单的理解为：<strong>当打开了 binder 设备的程序，停止运行后（不管是正常退出，还是异常结束）会自动关闭打开过的 binder 设备</strong>。然后由 <code>binder_release</code> 设置的延迟工作队列就会触发上面一系列的处理，最终调用到注册的死亡通知回调函数。</p>
<h2 id="java_层接口">java 层接口</h2>
<p>前面从 native 层接口，说到 kernel 怎么触发死亡通知。现在我们来看下 java 层的接口是怎么样的。其实从原理篇就应该能看得出，java 层只不过套着 jni 调用 native 层 binder 的接口而已。这里先看看 java 层 binder 的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBinder</span> </span>{</div><div class="line">    </div><div class="line">    ... ....</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Interface for receiving a callback when the process hosting an IBinder</span></div><div class="line"><span class="comment">     * has gone away.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @see #linkToDeath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeathRecipient</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Register the recipient for a notification if this binder</span></div><div class="line"><span class="comment">     * goes away.  If this binder object unexpectedly goes away</span></div><div class="line"><span class="comment">     * (typically because its hosting process has been killed),</span></div><div class="line"><span class="comment">     * then the given {@link DeathRecipient}'s</span></div><div class="line"><span class="comment">     * {@link DeathRecipient#binderDied DeathRecipient.binderDied()} method</span></div><div class="line"><span class="comment">     * will be called.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * &lt;p&gt;You will only receive death notifications for remote binders,</span></div><div class="line"><span class="comment">     * as local binders by definition can't die without you dying as well.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @throws RemoteException if the target IBinder's</span></div><div class="line"><span class="comment">     * process has already died.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @see #unlinkToDeath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Remove a previously registered death notification.</span></div><div class="line"><span class="comment">     * The recipient will no longer be called if this object</span></div><div class="line"><span class="comment">     * dies.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @return {@code true} if the &lt;var&gt;recipient&lt;/var&gt; is successfully</span></div><div class="line"><span class="comment">     * unlinked, assuring you that its</span></div><div class="line"><span class="comment">     * {@link DeathRecipient#binderDied DeathRecipient.binderDied()} method</span></div><div class="line"><span class="comment">     * will not be called;  {@code false} if the target IBinder has already</span></div><div class="line"><span class="comment">     * died, meaning the method has been (or soon will be) called.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @throws java.util.NoSuchElementException if the given</span></div><div class="line"><span class="comment">     * &lt;var&gt;recipient&lt;/var&gt; has not been registered with the IBinder, and</span></div><div class="line"><span class="comment">     * the IBinder is still alive.  Note that if the &lt;var&gt;recipient&lt;/var&gt;</span></div><div class="line"><span class="comment">     * was never registered, but the IBinder has already died, then this</span></div><div class="line"><span class="comment">     * exception will &lt;em&gt;not&lt;/em&gt; be thrown, and you will receive a false</span></div><div class="line"><span class="comment">     * return value instead.</span></div><div class="line"><span class="comment">     */</span> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>总体来看和 native 的几乎是一样的。那个 DeathRecipient 的 interface 就是少了自己的对象的参数而已（这个参数 native 层的不要也没关系，反正是自己）。然后我们再来看看 java 层 binder 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Binder.java ====================================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>{</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 和 native 层的一样，Bn 不允许注册的（这里是空函数而已）</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Local implementation is a no-op.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags) {</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Local implementation is a no-op.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">final</span> class BinderProxy implements IBinder {</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// Bp 的直接去调 jni 的去了</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">linkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span>(DeathRecipient recipient, <span class="keyword">int</span> flags);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>java 的 Bn 的接口实现是空函数（和 native 一样，不予以实现），Bp 直接去调 jni，我们去看下 jni：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_BinderProxy_linkToDeath(JNIEnv* env, jobject obj,</div><div class="line">        jobject recipient, jint flags) <span class="comment">// throws RemoteException</span></div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (recipient == NULL) {</div><div class="line">        jniThrowNullPointerException(env, NULL);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 前面原理篇说的这个 mObject 就是 native 层的 binder 对象指针</span></div><div class="line">    IBinder* target = (IBinder*)</div><div class="line">        env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</div><div class="line">    <span class="keyword">if</span> (target == NULL) {</div><div class="line">        ALOGW(<span class="string">"Binder has been finalized when calling linkToDeath() with recip=%p)\n"</span>, recipient);</div><div class="line">        assert(<span class="keyword">false</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    LOGDEATH(<span class="string">"linkToDeath: binder=%p recipient=%p\n"</span>, target, recipient);</div><div class="line"></div><div class="line">    <span class="comment">// 这里再判断下要是 Bp 才行</span></div><div class="line">    <span class="keyword">if</span> (!target-&gt;localBinder()) {</div><div class="line">        <span class="comment">// 这里估计是要保持和 native 层一样，搞一个列表出来</span></div><div class="line">        DeathRecipientList* <span class="built_in">list</span> = (DeathRecipientList*)</div><div class="line">                env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</div><div class="line">        <span class="comment">// 然后 new 一个 jni 层对象，应该是封装了 java 层的死亡通知回调</span></div><div class="line">        sp&lt;JavaDeathRecipient&gt; jdr = <span class="keyword">new</span> JavaDeathRecipient(env, recipient, <span class="built_in">list</span>);</div><div class="line">        <span class="comment">// 果然还是调用 native 层 binder 的注册接口</span></div><div class="line">        status_t err = target-&gt;linkToDeath(jdr, NULL, flags);</div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">            <span class="comment">// Failure adding the death recipient, so clear its reference</span></div><div class="line">            <span class="comment">// now.</span></div><div class="line">            jdr-&gt;clearReference(); </div><div class="line">            signalExceptionForError(env, obj, err, <span class="keyword">true</span> <span class="comment">/*canThrowRemoteException*/</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个列表我们不去管他，主要看下 JavaDeathRecipient 这个对象（那个 gBinderProxyOffsets 保存了 java 层 BinderProxy 的一些类信息的，完了的回去看下原理篇的 java 层那里）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp ===============================</span></div><div class="line"></div><div class="line"><span class="comment">// 看继承关系就知道这个是实现了 native 层 binder 的那个死亡通知回调</span></div><div class="line"><span class="keyword">class</span> JavaDeathRecipient : <span class="keyword">public</span> IBinder::DeathRecipient </div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    JavaDeathRecipient(JNIEnv* env, jobject object, <span class="keyword">const</span> sp&lt;DeathRecipientList&gt;& <span class="built_in">list</span>)</div><div class="line">        : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object)),</div><div class="line">          mObjectWeak(NULL), mList(<span class="built_in">list</span>) </div><div class="line">    {</div><div class="line">        <span class="comment">// 把死亡通知回调对象保存到那个 list 中</span></div><div class="line">        <span class="comment">// These objects manage their own lifetimes so are responsible for final bookkeeping.</span></div><div class="line">        <span class="comment">// The list holds a strong reference to this object.</span></div><div class="line">        LOGDEATH(<span class="string">"Adding JDR %p to DRL %p"</span>, <span class="keyword">this</span>, <span class="built_in">list</span>.get());</div><div class="line">        <span class="built_in">list</span>-&gt;add(<span class="keyword">this</span>);      </div><div class="line"></div><div class="line">        android_atomic_inc(&gNumDeathRefs);</div><div class="line">        incRefsCreated(env);  </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">void</span> binderDied(<span class="keyword">const</span> wp&lt;IBinder&gt;& who)</div><div class="line">    {</div><div class="line">        LOGDEATH(<span class="string">"Receiving binderDied() on JavaDeathRecipient %p\n"</span>, <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (mObject != NULL) {</div><div class="line">            JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line"></div><div class="line">            <span class="comment">// 然后在这个函数里面调 java 层的回调</span></div><div class="line">            env-&gt;CallStaticVoidMethod(gBinderProxyOffsets.mClass,</div><div class="line">                    gBinderProxyOffsets.mSendDeathNotice, mObject);</div><div class="line">            jthrowable excep = env-&gt;ExceptionOccurred();</div><div class="line">            <span class="keyword">if</span> (excep) {</div><div class="line">                report_exception(env, excep,   </div><div class="line">                        <span class="string">"*** Uncaught exception returned from death notification!"</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Demote from strong ref to weak after binderDied() has been delivered,</span></div><div class="line">            <span class="comment">// to allow the DeathRecipient and BinderProxy to be GC'd if no longer needed.</span></div><div class="line">            mObjectWeak = env-&gt;NewWeakGlobalRef(mObject);</div><div class="line">            env-&gt;DeleteGlobalRef(mObject); </div><div class="line">            mObject = NULL;   </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> ~JavaDeathRecipient()</div><div class="line">    {</div><div class="line">        <span class="comment">//ALOGI("Removing death ref: recipient=%p\n", mObject);</span></div><div class="line">        android_atomic_dec(&gNumDeathRefs);</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line">        <span class="keyword">if</span> (mObject != NULL) {</div><div class="line">            env-&gt;DeleteGlobalRef(mObject);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            env-&gt;DeleteWeakGlobalRef(mObjectWeak);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    JavaVM* <span class="keyword">const</span> mVM;</div><div class="line">    jobject mObject;</div><div class="line">    jweak mObjectWeak; <span class="comment">// will be a weak ref to the same VM-side DeathRecipient after binderDied()</span></div><div class="line">    wp&lt;DeathRecipientList&gt; mList;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>咋再去复习下 gBinderProxyOffsets 获取的那几个 java 类的函数方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android_util_Binder.cpp ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> int_register_android_os_BinderProxy(JNIEnv* env)</div><div class="line">{</div><div class="line">    jclass clazz;</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Error"</span>);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class java.lang.Error"</span>);</div><div class="line">    gErrorOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line"></div><div class="line">    clazz = env-&gt;FindClass(kBinderProxyPathName);</div><div class="line">    LOG_FATAL_IF(clazz == NULL, <span class="string">"Unable to find class android.os.BinderProxy"</span>);</div><div class="line"></div><div class="line">    gBinderProxyOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class="line">    gBinderProxyOffsets.mConstructor</div><div class="line">        = env-&gt;GetMethodID(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mConstructor);</div><div class="line">    <span class="comment">// 上面那个实现 native 层 binder 的死亡通知回调，</span></div><div class="line">    <span class="comment">// 最后是调用 java 层的 BinderProxy 的 sendDeathNotice 函数的</span></div><div class="line">    gBinderProxyOffsets.mSendDeathNotice</div><div class="line">        = env-&gt;GetStaticMethodID(clazz, <span class="string">"sendDeathNotice"</span>, <span class="string">"(Landroid/os/IBinder$DeathRecipient;)V"</span>);</div><div class="line">    assert(gBinderProxyOffsets.mSendDeathNotice);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(</div><div class="line">        env, kBinderProxyPathName,     </div><div class="line">        gBinderProxyMethods, NELEM(gBinderProxyMethods));</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们去看下 BinderProxy 的 sendDeathNotice：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Binder.java ===============================</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendDeathNotice</span>(DeathRecipient recipient) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"JavaBinder"</span>, <span class="string">"sendDeathNotice to "</span> + recipient);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            recipient.binderDied();</div><div class="line">        }</div><div class="line">        <span class="keyword">catch</span> (RuntimeException exc) { </div><div class="line">            Log.w(<span class="string">"BinderNative"</span>, <span class="string">"Uncaught exception from death notification"</span>,</div><div class="line">                    exc);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以说 java 层其实还是要靠 native 框架运作才行，然后 jni 里面把 native 对象和 java 对象倒腾一下，相互调用一下。</p>
<p>然后 java 层要使用的话，直接调用 java 层 IBinder 的 linkToDeath 接口注册自己的监听对象就行了。不过回想一下前面普通对象传递篇中，ServiceConnection 接口中有一个函数是：</p>
<pre config="brush:bash;toolbar:false;">
public void onServiceDisconnected(ComponentName name);
</pre>

<p>没错，这个就是绑定了普通服务的 Bp 端的死亡通知函数。通过这个函数，我们可以指定我们绑定的远程服务已经挂了。不过我们并没调用 linkToDeath 接口啊。这个一猜就知道是系统帮我们调用了。</p>
<p>我们回想下普通对象传递篇。bindService 后，如果服务启动了，就会调用 LoadedApk 里面的一个内部类的 ServiceDispatcher 的 doConnected 函数，进程调用 ServiceConnection 接口的 onServiceConnected 通知我们普通已经连接上了。现在我们再来看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoadedApk.cpp ===============================</span></div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span>(ComponentName name, IBinder service) {</div><div class="line">            ServiceDispatcher.ConnectionInfo old; </div><div class="line">            ServiceDispatcher.ConnectionInfo info;</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">                <span class="keyword">if</span> (mForgotten) {</div><div class="line">                    <span class="comment">// We unbound before receiving the connection; ignore</span></div><div class="line">                    <span class="comment">// any connection received.</span></div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }    </div><div class="line">                old = mActiveConnections.get(name);</div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span> && old.binder == service) {</div><div class="line">                    <span class="comment">// Huh, already have this one.  Oh well!</span></div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }    </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">// A new service is being connected... set it all up.</span></div><div class="line">                    mDied = <span class="keyword">false</span>;</div><div class="line">                    info = <span class="keyword">new</span> ConnectionInfo();</div><div class="line">                    info.binder = service;</div><div class="line">                    info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        <span class="comment">// 果然帮我们调用了</span></div><div class="line">                        service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</div><div class="line">                        mActiveConnections.put(name, info);</div><div class="line">                    } <span class="keyword">catch</span> (RemoteException e) { </div><div class="line">                        <span class="comment">// This service was dead before we got it...  just</span></div><div class="line">                        <span class="comment">// don't do anything with it.</span></div><div class="line">                        mActiveConnections.remove(name);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    }    </div><div class="line"></div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// The named service is being disconnected... clean up.</span></div><div class="line">                    mActiveConnections.remove(name);</div><div class="line">                }    </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (old != <span class="keyword">null</span>) {</div><div class="line">                    old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</div><div class="line">                }    </div><div class="line">            }   </div><div class="line"></div><div class="line">            <span class="comment">// If there was an old service, it is not disconnected.</span></div><div class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) {</div><div class="line">                mConnection.onServiceDisconnected(name);</div><div class="line">            }</div><div class="line">            <span class="comment">// If there is a new service, it is now connected.</span></div><div class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) {</div><div class="line">                mConnection.onServiceConnected(name, service);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>系统的处理是，当服务一连接上，在触发的 onServiceConnected 的函数里面，帮我们调用了 linkToDeath，自动注册死亡通知函数。不过好像还绕了几下，我继续跟进去看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoadedApk.cpp ===============================</span></div><div class="line"></div><div class="line">        <span class="comment">// 这是 LoadedApk 里面 ServiceDispatcher 的一个内部类 -_-||</span></div><div class="line">        <span class="comment">// 实现了 java 的 IBinder.DeathRecipient</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathMonitor</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span></span></div><div class="line"><span class="class">        </span>{</div><div class="line">            DeathMonitor(ComponentName name, IBinder service) {</div><div class="line">                mName = name;</div><div class="line">                mService = service;            </div><div class="line">            }                 </div><div class="line"></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>() {     </div><div class="line">                death(mName, mService);        </div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">final</span> ComponentName mName;     </div><div class="line">            <span class="keyword">final</span> IBinder mService;        </div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>那个 death 是 ServiceDispatcher 的一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span>(ComponentName name, IBinder service) {</div><div class="line">    ServiceDispatcher.ConnectionInfo old;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {          </div><div class="line">        mDied = <span class="keyword">true</span>;</div><div class="line">        old = mActiveConnections.remove(name);</div><div class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span> || old.binder != service) {</div><div class="line">            <span class="comment">// Death for someone different than who we last</span></div><div class="line">            <span class="comment">// reported...  just ignore it.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 把老的回调清理掉</span></div><div class="line">        old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 要搞那么复杂么，如果有可能的话尽量在 Handler 中处理回调函数</span></div><div class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) { </div><div class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">1</span>));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        doDeath(name, service);        </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后如果有跑 activity 线程的 Handler 就发到 Handler 里面去处理，如果没有的话，就直接调用 doDeath：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeath</span>(ComponentName name, IBinder service) {</div><div class="line">    <span class="comment">// 终于调用这个接口了</span></div><div class="line">    mConnection.onServiceDisconnected(name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunConnection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</div><div class="line">    RunConnection(ComponentName name, IBinder service, <span class="keyword">int</span> command) {</div><div class="line">        mName = name;</div><div class="line">        mService = service;            </div><div class="line">        mCommand = command;            </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {            </div><div class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) {           </div><div class="line">            doConnected(mName, mService);  </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) {    </div><div class="line">            <span class="comment">// 上面 death 的 post 是 1，</span></div><div class="line">            <span class="comment">// 所以和上面直接执行 doDeath 差不多</span></div><div class="line">            doDeath(mName, mService);      </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ComponentName mName;     </div><div class="line">    <span class="keyword">final</span> IBinder mService;        </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCommand;            </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以对普通应用来说，android 给你层层封装好了，什么时候服务准备好了，告诉你可以使用 IPC 进行通信了，什么时候服务挂了，你要么重新启动服务，要么做别的处理。</p>
<h2 id="特殊的_SM">特殊的 SM</h2>
<p>最后，再说一个特殊的列子。还记得前面系统传递 binder 对象篇中说 SM 是很特殊的一个和程序么。它用到了 binder，但是却没有使用 binder 库的那一套框架，而已自己直接写通信程序（为此它把 kernel 里面的一堆数据结构扣了出来）。对了，这里又是 SM 玩非主流。它注册的死亡通知回调和普通又不太一样。</p>
<p>SM 怎么个不一样法，让我们先来看看它注册的是什么东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// service_manager.c ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> do_add_service(<span class="keyword">struct</span> binder_state *bs,</div><div class="line">                   uint16_t *s, <span class="keyword">unsigned</span> len,</div><div class="line">                   <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid, <span class="keyword">int</span> allow_isolated)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si;</div><div class="line">    <span class="comment">//ALOGI("add_service('%s',%p,%s) uid=%d\n", str8(s), ptr,</span></div><div class="line">    <span class="comment">//        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!svc_can_register(uid, s)) {</div><div class="line">        ALOGE(<span class="string">"add_service('%s',%p) uid=%d - PERMISSION DENIED\n"</span>,</div><div class="line">             str8(s), ptr, uid);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">    }</div><div class="line"></div><div class="line">    si = find_svc(s, len);</div><div class="line">    <span class="keyword">if</span> (si) {</div><div class="line">        <span class="keyword">if</span> (si-&gt;ptr) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</div><div class="line">                 str8(s), ptr, uid);</div><div class="line">            svcinfo_death(bs, si);</div><div class="line">        }   </div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        <span class="keyword">if</span> (!si) {</div><div class="line">            ALOGE(<span class="string">"add_service('%s',%p) uid=%d - OUT OF MEMORY\n"</span>,</div><div class="line">                 str8(s), ptr, uid);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">        }   </div><div class="line">        si-&gt;ptr = ptr;</div><div class="line">        si-&gt;len = len;</div><div class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint16_t));</div><div class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</div><div class="line">        <span class="comment">// 保存回调函数指针</span></div><div class="line">        si-&gt;death.func = svcinfo_death;</div><div class="line">        <span class="comment">// 保存 svcinfo 对象自己</span></div><div class="line">        si-&gt;death.ptr = si; </div><div class="line">        si-&gt;allow_isolated = allow_isolated;</div><div class="line">        si-&gt;next = svclist;</div><div class="line">        svclist = si; </div><div class="line">    }</div><div class="line"></div><div class="line">    binder_acquire(bs, ptr);</div><div class="line">    <span class="comment">// 这个是向 kernel 注册死亡通知回调的函数</span></div><div class="line">    binder_link_to_death(bs, ptr, &si-&gt;death);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>原来每当一个 SS 向 SM 注册的时候，SM 都会为这个 SS 注册一个死亡通知回调。我们来看看这个 <code>binder_link_to_death</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> binder_link_to_death(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *ptr, <span class="keyword">struct</span> binder_death *death)</div><div class="line">{</div><div class="line">    uint32_t cmd[<span class="number">3</span>];</div><div class="line">    <span class="comment">// 和 IPCThreadState 的 requestDeathNotification 发的是一样的命令</span></div><div class="line">    cmd[<span class="number">0</span>] = BC_REQUEST_DEATH_NOTIFICATION;</div><div class="line">    <span class="comment">// 第一个参数也是一样， SM 这个 ptr 就是 Bp 的 handle 值</span></div><div class="line">    cmd[<span class="number">1</span>] = (uint32_t) ptr;</div><div class="line">    <span class="comment">// 但是注意第二参数，是一个 binder_death 的结构的指针</span></div><div class="line">    cmd[<span class="number">2</span>] = (uint32_t) death;</div><div class="line">    binder_write(bs, cmd, <span class="keyword">sizeof</span>(cmd));</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得前面说 kernel 那个保存用户空间传过来的那个地址的时候，为什么要原封不动的保存，然后再原封不动的传回去了不。因为这个指针有2套东西，普通的 IPCThreadState 发下去的是 Bp 对象的指针，而 SM 发下去的是自己的一个 <code>binder_death</code> 结构体的指针。标准不一样，你让人家底下驱动也没办法处理，所以只要原封不动的，发回注册的人自己处理。</p>
<p>我们来看这个 <code>binder_death</code> 里面有什么东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// binder.h ===============================</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> binder_death {</div><div class="line">    <span class="comment">// 一个是一个函数指针</span></div><div class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *ptr);</div><div class="line">    <span class="comment">// 一个是一个数据指针</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们前面 SM 处理 SS 那里，这个函数指针被指向了一个叫 <code>svcinfo_death</code> 的函数，然后 ptr 是把 svcinfo 这个 SM 保存 SS 信息的数据结构保存了起来。我们看下 <code>svcinfo_death</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> svcinfo_death(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">void</span> *ptr)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> svcinfo *si = ptr;</div><div class="line">    <span class="comment">// 打印一条信息</span></div><div class="line">    ALOGI(<span class="string">"service '%s' died\n"</span>, str8(si-&gt;name));</div><div class="line">    <span class="keyword">if</span> (si-&gt;ptr) {</div><div class="line">        <span class="comment">// 然后释放注册 SS 申请的资源</span></div><div class="line">        binder_release(bs, si-&gt;ptr);</div><div class="line">        si-&gt;ptr = <span class="number">0</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数没什么特别要说的，就是打印一条信息，然后释放下资源。前面说了 SM 是自己写 binder 通信的，我们来看看它收到 kernel 发送过来的死亡消息的时候怎么处理的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_parse(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</div><div class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</div><div class="line">    uint32_t *end = ptr + (size / <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end) {</div><div class="line">        uint32_t cmd = *ptr++;</div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> TRACE</span></div><div class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">"%s:\n"</span>, cmd_name(cmd));</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line">        <span class="keyword">switch</span>(cmd) {</div><div class="line"></div><div class="line">        ... ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: {</div><div class="line">            <span class="comment">// 果然 kernel 原封不动的发回来，</span></div><div class="line">            <span class="comment">// 然后这边就可以转化成 binder_death 使用了</span></div><div class="line">            <span class="keyword">struct</span> binder_death *death = (<span class="keyword">void</span>*) *ptr++;</div><div class="line">            <span class="comment">// 搞了半天也就相当于只传递了这个指针而已</span></div><div class="line">            death-&gt;func(bs, death-&gt;ptr);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        ... ...</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ALOGE(<span class="string">"parse: OOPS %d\n"</span>, cmd);</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }   </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到这个处理，我感觉 <code>binder_death</code> 这个结构完全没必要定义，那个函数是固定的，所以真正传递是那个 svcinfo 的指针，所以发 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 这个命令的第二参数直接写 svcinfo 的指针就行了。然后死亡通知函数固定调 svcinfo_death 就行。难不成以后还有不同的 SS 死亡通知函数不同不成。</p>
<h2 id="总结">总结</h2>
<p>android binder 这套框架还是包括了很多东西的，android 也帮我们处理了很多东西。要提供一套高效、易用、可靠的跨进程通信机制还是要处理不少东西。怪不得我以前的头头说 MiniGUI 的多进程版就是一个 demo 而已，离真正使用还很远。现在我才能体会到。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/28/Android Binder 分析——死亡通知[DeathRecipient]/" data-title="Android Binder 分析——死亡通知（DeathRecipient） | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/28/Android Binder 分析——多线程支持/" title="Android Binder 分析——多线程支持">
  <strong>上一篇:</strong><br/>
  <span>
  Android Binder 分析——多线程支持</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——懒人的工具[AIDL]/"  title="Android Binder 分析——懒人的工具（AIDL）">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——懒人的工具（AIDL）
</span>
</a>
</div>

</nav>


	
<section class="comment">
	<div class="ds-thread" data-thread-key="Android Binder 分析——死亡通知（DeathRecipient）" data-title="Android Binder 分析——死亡通知（DeathRecipient）" 
      data-author-key="mingming" data-limit=10
      data-url="light3moon.com/2015/01/28/Android Binder 分析——死亡通知[DeathRecipient]/">
    </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#native_层的接口"><span class="toc-number">1.</span> <span class="toc-text">native 层的接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册死亡通知到_kernel"><span class="toc-number">2.</span> <span class="toc-text">注册死亡通知到 kernel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触发死亡通知"><span class="toc-number">3.</span> <span class="toc-text">触发死亡通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java_层接口"><span class="toc-number">4.</span> <span class="toc-text">java 层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊的_SM"><span class="toc-number">5.</span> <span class="toc-text">特殊的 SM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>30</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>46</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>22</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/android/" title="android">android<sup>76</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>26</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">哥的后勤处 o(^▽^)o</p>
    <ul>
      <li> <i class="fa fa-qqzone"></i> <a href="http://user.qzone.qq.com/544630305" target="_blank">QQ 空间</a></li>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">战斗力</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="commentlist">
  <p class="asidetitle">最近冒泡的小伙伴 ╰(●&#39;◡&#39;●)╮</p>
    <ul>
      <ul class="ds-recent-comments" 
        data-num-items="5" 
        data-show-avatars="1" 
        data-show-title="1"   
        data-show-time="1" 
        data-show-admin="1" 
        data-excerpt-length="30">
      </ul>
      <!-- duoshou js begin load, one page only load once -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"mingming"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- duoshou js load end -->
    </ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	
		<a href="http://user.qzone.qq.com/544630305" target="_blank" title="qqzone"></a>
		         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2015 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"mingming"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
