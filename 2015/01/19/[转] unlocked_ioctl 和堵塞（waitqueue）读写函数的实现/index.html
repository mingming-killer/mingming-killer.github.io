
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>(转) unlocked_ioctl 和堵塞（waitqueue）读写函数的实现 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="学习了驱动程序的设计，感觉在学习驱动的同时学习linux内核，也是很不错的过程哦，做了几个实验，该做一些总结，只有不停的作总结才能印象深刻。
我的平台是虚拟机，fedora14，内核版本为2.6.38.1.其中较之前的版本存在较大的差别，具体的实现已经在上一次总结中给出了。今天主要总结的是ioctl">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">三月学长的小站</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/19/[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现/" title="(转) unlocked_ioctl 和堵塞（waitqueue）读写函数的实现" itemprop="url">(转) unlocked_ioctl 和堵塞（waitqueue）读写函数的实现</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-19T02:31:16.000Z" itemprop="datePublished">2015 1月 19</time>
    更新日期:<time datetime="2015-01-19T02:31:16.000Z" itemprop="dateModified">2015 1月 19</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、ioctl函数的实现"><span class="toc-number">1.</span> <span class="toc-text">一、ioctl函数的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、设备的堵塞读写方式实现，通常采用等待队列。"><span class="toc-number">2.</span> <span class="toc-text">二、设备的堵塞读写方式实现，通常采用等待队列。</span></a></li></ol>
		</div>
		
		<p>学习了驱动程序的设计，感觉在学习驱动的同时学习linux内核，也是很不错的过程哦，做了几个实验，该做一些总结，只有不停的作总结才能印象深刻。</p>
<p>我的平台是虚拟机，fedora14，内核版本为2.6.38.1.其中较之前的版本存在较大的差别，具体的实现已经在上一次总结中给出了。今天主要总结的是ioctl和堵塞读写函数的实现。</p>
<h2 id="一、ioctl函数的实现">一、ioctl函数的实现</h2>
<p>首先说明在2.6.36以后ioctl函数已经不再存在了，而是用<code>unlocked_ioctl</code>和<code>compat_ioctl</code>两个函数实现以前版本的ioctl函数。同时在参数方面也发生了一定程度的改变，去除了原来ioctl中的struct inode参数，同时改变了返回值。</p>
<p>但是驱动设计过程中存在的问题变化并不是很大，同样在应用程序设计中我们还是采用ioctl实现访问，而并不是<code>unlocked_ioctl</code>函数，因此我们还可以称之为ioctl函数的实现。ioctl函数的实现主要是用来实现具体的硬件控制，采用相应的命令控制硬件的具体操作，这样就能使得硬件的操作不再是单调的读写操作。使得硬件的使用更加的方便。ioctl函数实现主要包括两个部分，首先是命令的定义，然后才是ioctl函数的实现，命令的定义是采用一定的规则。</p>
<p>ioctl的命令主要用于应用程序通过该命令操作具体的硬件设备，实现具体的操作，在驱动中主要是对命令进行解析，通过switch-case语句实现不同命令的控制，进而实现不同的硬件操作。</p>
<p>ioctl函数的命令定义方法：</p>
<pre>
int (*unlocked_ioctl)(struct file*filp,unsigned int cmd,unsigned long arg)
</pre>

<p>虽然其中没有指针的参数，但是通常采用arg传递指针参数。cmd是一个命令。<strong>每一个命令由一个整形数据构成（32bits），将一个命令分成四部分，每一部分实现具体的配置，设备类型（幻数）8bits，方向2bits，序号8bits，数据大小13/14bits</strong>。命令的实现实质上就是通过简单的移位操作，将各个部分组合起来而已。</p>
<p>一个命令的分布的大概情况如下：</p>
<pre config="brush:bash;toolbar:false;">
|---方向位(31-30)|----数据长度(29-16)----------------|---------设备类型（15-8）------|----------序号（7-0）----------|
|----------------------------------------------------------------------------------------------------------------------------------------|
</pre>

<p>其中方向位主要是表示对设备的操作，比如读设备，写设备等操作以及读写设备等都具有一定的方向，2个bits只有4种方向。数据长度表示每一次操作（读、写）数据的大小，一般而已每一个命令对应的数据大小都是一个固定的值，不会经常改变，14bits说明可以选择的数据长度最大为16k。</p>
<p>设备类型类似于主设备号（由于8bits，刚好组成一个字节，因此经常采用字符作为幻数，表示某一类设备的命令），用来区别不同的命令类型，也就是特定的设备类型对应特定的设备。序号主要是这一类命令中的具体某一个，类似于次设备号（256个命令），也就是一个设备支持的命令多达256个。</p>
<p>同时在内核中也存在具体的宏用来定义命令以及解析命令。但是大部分的宏都只是定义具体的方向，其他的都需要设计者定义。</p>
<p>主要的宏如下：</p>
<pre config="brush:bash;toolbar:false;">

#include<linux ioctl.h="">

_IO(type,nr)                表示定义一个没有方向的命令，
_IOR(type,nr,size)          表示定义一个类型为type，序号为nr，数据大小为size的读命令
_IOW(type,nr,size)          表示定义一个类型为type，序号为nr，数据大小为size的写命令
_IOWR(type,nr,size)         表示定义一个类型为type，序号为nr，数据大小为size的写读命令

</linux></pre>

<p>通常的type可采用某一个字母或者数字作为设备命令类型。是实际运用中通常采用如下的方法定义一个具体的命令:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//头文件</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;linux/ioctl.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/*定义一系列的命令*/</span></div><div class="line"><span class="comment">/*幻数，主要用于表示类型*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAGIC_NUM 'k'</span></div><div class="line"><span class="comment">/*打印命令*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_PRINTF _IO(MAGIC_NUM,1)</span></div><div class="line"><span class="comment">/*从设备读一个int数据*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_READ _IOR(MAGIC_NUM,2,int)</span></div><div class="line"><span class="comment">/*往设备写一个int数据*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEMDEV_WRITE _IOW(MAGIC_NUM,3,int)</span></div><div class="line"></div><div class="line"><span class="comment">/*最大的序列号*/</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MEM_MAX_CMD 3</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>还有对命令进行解析的宏，用来确定具体命令的四个部分（方向，大小，类型，序号）具体如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*确定命令的方向*/</span></div><div class="line">_IOC_DIR(nr)                    </div><div class="line"><span class="comment">/*确定命令的类型*/</span></div><div class="line">_IOC_TYPE(nr)                     </div><div class="line"><span class="comment">/*确定命令的序号*/</span></div><div class="line">_IOC_NR(nr)                           </div><div class="line"><span class="comment">/*确定命令的大小*/</span></div><div class="line">_IOC_SIZE(nr)</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的几个宏可以用来命令，实现命令正确性的检查。</p>
<p>ioctl的实现过程主要包括如下的过程：</p>
<ol>
<li>命令的检测</li>
<li>指针参数的检测</li>
<li>命令的控制switch-case语句</li>
</ol>
<p>1、命令的检测主要包括类型的检查，数据大小，序号的检测，通过结合上面的命令解析宏可以快速的确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*检查类型，幻数是否正确*/</span></div><div class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd)!=MAGIC_NUM)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"><span class="comment">/*检测命令序号是否大于允许的最大序号*/</span></div><div class="line"><span class="keyword">if</span>(_IOC_NR(cmd)&gt; MEM_MAX_CMD)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"></div></pre></td></tr></table></figure>

<p>2、主要是指针参数的检测。指针参数主要是因为内核空间和用户空间的差异性导致的，因此需要来自用户空间指针的有效性。使用<code>copy_from_user</code>,<code>copy_to_user</code>,<code>get_user</code>,<code>put_user</code>之类的函数时，由于函数会实现指针参量的检测，因此可以省略，但是采用<code>__get_user()</code>,<code>__put_user()</code>之类的函数时一定要进行检测。具体的检测方法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span>(_IOC_DIR(cmd) & _IOC_READ)</div><div class="line">        err = !access_ok(VERIFY_WRITE,(<span class="keyword">void</span> *)args,_IOC_SIZE(cmd));</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_IOC_DIR(cmd) & _IOC_WRITE)</div><div class="line">        err = !access_ok(VERIFY_READ,(<span class="keyword">void</span> *)args,_IOC_SIZE(cmd));</div><div class="line"><span class="keyword">if</span>(err)<span class="comment">/*返回错误*/</span></div><div class="line">        <span class="keyword">return</span> -EFAULT;</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>当方向是读时，说明是从设备读数据到用户空间，因此要检测用户空间的指针是否可写，采用<code>VERIFY_WRITE</code>，而当方向是写时，说明是往设备中写数据，因此需要检测用户空间中的指针的可读性<code>VERIFY_READ</code>。检查通常采用<code>access_ok()</code>实现检测，第一个参数为读写，第二个为检测的指针，第三个为数据的大小</strong>。</p>
<p>3、命名的控制：命令的控制主要是采用switch和case相结合实现的，这于window编程中的检测各种消息的实现方式是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*根据命令执行相应的操作*/</span></div><div class="line">        <span class="keyword">switch</span>(cmd)</div><div class="line">        {</div><div class="line">                <span class="keyword">case</span> MEMDEV_PRINTF:</div><div class="line">                        printk(<span class="string">"&lt;--------CMD MEMDEV_PRINTF Done------------&gt;\n\n"</span>);</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MEMDEV_READ:</div><div class="line">                        ioarg = &mem_devp-&gt;data;</div><div class="line">                        ...</div><div class="line">                        ret = __put_user(ioarg,(<span class="keyword">int</span> *)args);</div><div class="line">                        ioarg = <span class="number">0</span>;</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MEMDEV_WRITE:</div><div class="line">                        ...</div><div class="line">                        ret = __get_user(ioarg,(<span class="keyword">int</span> *)args);</div><div class="line">                        printk(<span class="string">"&lt;--------CMD MEMDEV_WRITE Done ioarg = %d---------&gt;\n\n"</span>,ioarg); </div><div class="line">                        ioarg = <span class="number">0</span>;</div><div class="line">                        ...</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                        ret = -EINVAL;</div><div class="line">                        printk(<span class="string">"&lt;-------INVAL CMD---------&gt;\n\n"</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这只是基本的框架结构，实际中根据具体的情况进行修改。这样就实现了基本的命令控制。<br>文件操作支持的集合如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*添加该模块的基本文件操作支持*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations mem_fops =</div><div class="line">{</div><div class="line">        <span class="comment">/*结尾不是分号，注意其中的差别*/</span></div><div class="line">        .owner = THIS_MODULE,</div><div class="line">        .llseek = mem_llseek,</div><div class="line">        .read = mem_read,</div><div class="line">        .write = mem_write,</div><div class="line">        .open = mem_open,</div><div class="line">        .release = mem_release,</div><div class="line">        <span class="comment">/*添加新的操作支持*/</span></div><div class="line">        .unlocked_ioctl = mem_ioctl,</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>需要注意不是ioctl,而是unlocked_ioctl。</p>
<h2 id="二、设备的堵塞读写方式实现，通常采用等待队列。">二、设备的堵塞读写方式实现，通常采用等待队列。</h2>
<p>设备的堵塞读写方式，默认情况下的读写操作都是堵塞型的，具体的就是如果需要读数据，当设备中没有数据可读的时候应该等待设备中有设备再读，当往设备中写数据时，如果上一次的数据还没有被读完成，则不应该写入数据，就会导致进程的堵塞，等待数据可读写。但是在应用程序中也可以采用非堵塞型的方式进行读写。只要在打开文件的时候添加一个<code>O_NONBLOCK</code>,这样在不能读写的时候就会直接返回，而不会等待。</p>
<p>因此我们在实际设计驱动设备的同时需要考虑读写操作的堵塞方式。堵塞方式的设计主要是通过等待队列实现，通常是将等待队列（实质就是一个链表）的头作为设备数据结构的一部分。在设备初始化过程中初始化等待队列的头。最后在设备读写操作的实现添加相应的等待队列节点，并进行相应的控制。</p>
<p>等待队列的操作基本如下：</p>
<p>1、等待队列的头定义并初始化的过程如下：</p>
<p>方法一：</p>
<pre>
struct wait_queue_head_t mywaitqueue;
init_waitqueue_head(&mywaitqueue);
</pre>
方法二：
<pre>
DECLARE_WAIT_QUEUE_HEAD(mywaitqueue);
</pre>
以上的两种都能实现定义和初始化等待队列头。

2、创建、移除一个等待队列的节点，并添加、移除相应的队列。
定义一个等待队列的节点:`DECLARE_WAITQUEUE(wait,tsk)`
其中tsk表示一个进程，可以采用current当前的进程。
添加到定义好的等待队列头中。
<pre>
add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
即：add_wait_queue(&mywaitqueue,&wait);
</pre>

<p>移除等待节点</p>
<pre>
remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
即：remove_wait_queue(&mywaitqueue,&wait);
</pre>

<p>3、等待事件<br><code>wait_event(queue,condition)</code>;当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下不能被信号打断。<br><code>wait_event_interruptible(queue,condition)</code>;当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下能被信号打断。</p>
<p>4、唤醒等待队列<br><code>wait_up(wait_queue_head_t *q)</code>,唤醒该等待队列头对应的所有等待。<br><code>wait_up_interruptible(wait_queue_head_t *q)</code>唤醒处于<code>TASK_INTERRUPTIBLE</code>的等待进程。</p>
<p>应该成对的使用。即<code>wait_event</code>于<code>wait_up</code>,而<code>wait_event_interruptible</code>与<code>wait_up_interruptible</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">wait_event和wait_event_interruptible的实现都是采用宏的方式，都是一个重新调度的过程，如下所示：</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> wait_event_interruptible(wq, condition)                \</span></div><div class="line">({                                    \</div><div class="line">    <span class="keyword">int</span> __ret = <span class="number">0</span>;                            \</div><div class="line">    <span class="keyword">if</span> (!(condition))                        \</div><div class="line">        __wait_event_interruptible(wq, condition, __ret);    \</div><div class="line">    __ret;                                \</div><div class="line">})</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> __wait_event_interruptible(wq, condition, ret)            \</span></div><div class="line"><span class="keyword">do</span> {                                    \</div><div class="line">     <span class="comment">/*此处存在一个声明等待队列的语句，因此不需要再重新定义一个等待队列节点*/</span></div><div class="line">    DEFINE_WAIT(__wait);                        \</div><div class="line">                                    \</div><div class="line">    <span class="keyword">for</span> (;;) {                            \</div><div class="line">        <span class="comment">/*此处就相当于add_wait_queue()操作，具体参看代码如下所示*/</span></div><div class="line">        prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);    \</div><div class="line">        <span class="keyword">if</span> (condition)                        \</div><div class="line">            <span class="keyword">break</span>;                        \</div><div class="line">        <span class="keyword">if</span> (!signal_pending(current)) {                \</div><div class="line">            <span class="comment">/*此处是调度，丢失CPU，因此需要wake_up函数唤醒当前的进程</span></div><div class="line"><span class="comment">		根据定义可知，如果条件不满足，进程就失去CPU,能够跳出for循环的出口只有</span></div><div class="line"><span class="comment">                1、当条件满足时2、当signal_pending（current）=1时。</span></div><div class="line"><span class="comment">                1、就是满足条件，也就是说wake_up函数只是退出了schedule函数，</span></div><div class="line"><span class="comment">                而真正退出函数还需要满足条件	</span></div><div class="line"><span class="comment">                2、说明进程可以被信号唤醒。也就是信号可能导致没有满足条件时就唤醒当前的进程。 </span></div><div class="line"><span class="comment">               这也是后面的代码采用while判断的原因.防止被信号唤醒。   </span></div><div class="line"><span class="comment">	   */</span></div><div class="line">            schedule();                    \</div><div class="line">            <span class="keyword">continue</span>;                    \</div><div class="line">        }                            \</div><div class="line">        ret = -ERESTARTSYS;                    \</div><div class="line">        <span class="keyword">break</span>;                            \</div><div class="line">    }                                \</div><div class="line">    finish_wait(&wq, &__wait);                    \</div><div class="line">} <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFINE_WAIT_FUNC(name, function)				\</span></div><div class="line">	wait_queue_t name = {						\</div><div class="line">		.<span class="keyword">private</span>	= current,				\</div><div class="line">		.func		= function,				\</div><div class="line">		.task_list	= LIST_HEAD_INIT((name).task_list),	\</div><div class="line">	}</div><div class="line"></div><div class="line"><span class="keyword">void</span> prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, <span class="keyword">int</span> state)</div><div class="line">{</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	wait-&gt;flags &= ~WQ_FLAG_EXCLUSIVE;</div><div class="line">	spin_lock_irqsave(&q-&gt;lock, flags);</div><div class="line">	<span class="keyword">if</span> (list_empty(&wait-&gt;task_list))</div><div class="line">               <span class="comment">/*添加节点到等待队列*/</span></div><div class="line">		__add_wait_queue(q, wait);</div><div class="line">	set_current_state(state);</div><div class="line">	spin_unlock_irqrestore(&q-&gt;lock, flags);</div><div class="line">}</div><div class="line">唤醒的操作也是类似的。</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> wake_up_interruptible(x)	__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></div><div class="line"> </div><div class="line">  <span class="keyword">void</span> __wake_up(wait_queue_head_t *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</div><div class="line">{</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	spin_lock_irqsave(&q-&gt;lock, flags);</div><div class="line">	__wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);</div><div class="line">	spin_unlock_irqrestore(&q-&gt;lock, flags);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(wait_queue_head_t *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</div><div class="line">{</div><div class="line">	wait_queue_t *curr, *next;</div><div class="line"></div><div class="line">	list_for_each_entry_safe(curr, next, &q-&gt;task_list, task_list) {</div><div class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &&</div><div class="line">				(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>等待队列通常用在驱动程序设计中的堵塞读写操作，并不需要手动的添加节点到队列中，直接调用即可实现，具体的实现方法如下：</p>
<p>1、在设备结构体中添加等待队列头，由于读写都需要堵塞，所以添加两个队列头，分别用来堵塞写操作，写操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;linux/wait.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> mem_dev</div><div class="line">{</div><div class="line">        <span class="keyword">char</span> *data;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line">        <span class="comment">/*添加一个并行机制*/</span></div><div class="line">        spinlock_t lock;</div><div class="line"></div><div class="line">        <span class="comment">/*添加一个等待队列t头*/</span></div><div class="line">        wait_queue_head_t rdqueue;</div><div class="line">        wait_queue_head_t wrqueue;</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>2、然后在模块初始化中初始化队列头:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*初始化函数*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> memdev_init(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">       ....</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MEMDEV_NR_DEVS; i)</div><div class="line">        {</div><div class="line">                mem_devp[i].size = MEMDEV_SIZE;</div><div class="line">                <span class="comment">/*对设备的数据空间分配空间*/</span></div><div class="line">                mem_devp[i].data = kmalloc(MEMDEV_SIZE,GFP_KERNEL);</div><div class="line">                <span class="comment">/*问题，没有进行错误的控制*/</span></div><div class="line">                <span class="built_in">memset</span>(mem_devp[i].data,<span class="number">0</span>,MEMDEV_SIZE);</div><div class="line"></div><div class="line">                <span class="comment">/*初始化定义的互信息量*/</span></div><div class="line">                <span class="comment">//初始化定义的自旋锁ua</span></div><div class="line">                spin_lock_init(&(mem_devp[i].lock));</div><div class="line">                <span class="comment">/*初始化两个等待队列头,需要注意必须用括号包含起来，使得优先级正确*/</span></div><div class="line">                init_waitqueue_head(&(mem_devp[i].rdqueue));</div><div class="line">                init_waitqueue_head(&(mem_devp[i].wrqueue));</div><div class="line">        }</div><div class="line">      ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p><strong>3、确定一个具体的条件，比如数据有无，具体的条件根据实际的情况设计。</strong></p>
<pre>
/*等待条件*/
static bool havedata = false;
</pre>

<p>4、在需要堵塞的读函数，写函数中分别实现堵塞，首先定义等待队列的节点，并添加到队列中去，然后等待事件的唤醒进程。但是由于读写操作的两个等待队列都是基于条件havedata的，所以在读完成以后需要唤醒写，写完成以后需要唤醒读操作，同时更新条件havedata，最后还要移除添加的等待队列节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*read函数的实现*/</span></div><div class="line"><span class="keyword">static</span> ssize_t mem_read(<span class="keyword">struct</span> file *filp,<span class="keyword">char</span> __user *buf, size_t size,loff_t *ppos)</div><div class="line">{</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> mem_dev *dev = filp-&gt;private_data;</div><div class="line"></div><div class="line">        <span class="comment">/*参数的检查，首先判断文件位置*/</span></div><div class="line">        <span class="keyword">if</span>(p &gt;= MEMDEV_SIZE)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">/*改正文件大小*/</span></div><div class="line">        <span class="keyword">if</span>(count &gt; MEMDEV_SIZE - p)</div><div class="line">                count = MEMDEV_SIZE - p;</div><div class="line">         <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*添加一个等待队列节点到当前进程中*/</span></div><div class="line">        DECLARE_WAITQUEUE(wait_r,current);</div><div class="line"></div><div class="line">        <span class="comment">/*将节点添加到等待队列中*/</span></div><div class="line">        add_wait_queue(&dev-&gt;rdqueue,&wait_r);</div><div class="line"></div><div class="line">        <span class="comment">/*添加等待队列，本来采用if即可，但是由于信号等可能导致等待队列的唤醒，因此采用循环，确保不会出现误判*/</span></div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!havedata)</div><div class="line">        {</div><div class="line">                <span class="comment">/*判断用户是否设置为非堵塞模式读,告诉用户再读*/</span></div><div class="line">                <span class="keyword">if</span>(filp-&gt;f_flags & O_NONBLOCK)</div><div class="line">                        <span class="keyword">return</span> -EAGAIN;</div><div class="line"></div><div class="line">                <span class="comment">/*依据条件havedata判断队列的状态，防止进程被信号唤醒*/</span></div><div class="line">                wait_event_interruptible(dev-&gt;rdqueue,havedata);</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_lock(&dev-&gt;lock);</div><div class="line">        <span class="comment">/*从内核读数据到用户空间，实质就通过private_data访问设备*/</span></div><div class="line">        <span class="keyword">if</span>(copy_to_user(buf,(<span class="keyword">void</span> *)(dev-&gt;data p),count))</div><div class="line">        {</div><div class="line">                <span class="comment">/*出错误*/</span></div><div class="line">                ret = -EFAULT;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">                <span class="comment">/*移动当前文件光标的位置*/</span></div><div class="line"></div><div class="line">                *ppos = count;</div><div class="line">                ret = count;</div><div class="line"></div><div class="line">                printk(KERN_INFO <span class="string">"read %d bytes(s) from %d\n"</span>,count,p);</div><div class="line">        }</div><div class="line">      </div><div class="line">        spin_unlock(&dev-&gt;lock);</div><div class="line">	 <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*将等待队列节点从读等待队列中移除*/</span></div><div class="line">        remove_wait_queue(&dev-&gt;rdqueue,&wait_r);</div><div class="line">	<span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">        <span class="comment">/*更新条件havedate*/</span></div><div class="line">        havedata = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">/*唤醒写等待队列*/</span></div><div class="line">        wake_up_interruptible(&dev-&gt;wrqueue);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*write函数的实现*/</span></div><div class="line"><span class="keyword">static</span> ssize_t mem_write(<span class="keyword">struct</span> file *filp,<span class="keyword">const</span> <span class="keyword">char</span> __user *buf,size_t size,loff_t *ppos)</div><div class="line">{</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*获得设备结构体的指针*/</span></div><div class="line">        <span class="keyword">struct</span> mem_dev *dev = filp-&gt;private_data;</div><div class="line"></div><div class="line">        <span class="comment">/*检查参数的长度*/</span></div><div class="line">        <span class="keyword">if</span>(p &gt;= MEMDEV_SIZE)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(count &gt; MEMDEV_SIZE - p)</div><div class="line">                count = MEMDEV_SIZE - p;</div><div class="line">	  <span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*定义并初始化一个等待队列节点，添加到当前进程中*/</span></div><div class="line">        DECLARE_WAITQUEUE(wait_w,current);</div><div class="line">        <span class="comment">/*将等待队列节点添加到等待队列中*/</span></div><div class="line">        add_wait_queue(&dev-&gt;wrqueue,&wait_w);</div><div class="line">        <span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="comment">/*添加写堵塞判断*/</span></div><div class="line">        <span class="comment">/*为何采用循环是为了防止信号等其他原因导致唤醒*/</span></div><div class="line">        <span class="keyword">while</span>(havedata)</div><div class="line">        {</div><div class="line">                <span class="comment">/*如果是以非堵塞方式*/</span></div><div class="line">                <span class="keyword">if</span>(filp-&gt;f_flags & O_NONBLOCK)</div><div class="line">                        <span class="keyword">return</span> -EAGAIN;</div><div class="line">        <span class="comment">/*分析源码发现，wait_event_interruptible 中存在DECLARE_WAITQUEUE和add_wait_queue的操作，因此不需要手动添加等待队列节点*/</span></div><div class="line">                wait_event_interruptible(&dev-&gt;wrqueue,(!havedata));</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_lock(&dev-&gt;lock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(copy_from_user(dev-&gt;data p,buf,count))</div><div class="line">                ret = -EFAULT;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">                <span class="comment">/*改变文件位置*/</span></div><div class="line">                *ppos = count;</div><div class="line">                ret = count;</div><div class="line">                printk(KERN_INFO <span class="string">"writted %d bytes(s) from %d\n"</span>,count,p);</div><div class="line">        }</div><div class="line"></div><div class="line">        spin_unlock(&dev-&gt;lock);</div><div class="line">	</div><div class="line">	<span class="preprocessor">#<span class="keyword">if</span> 0</span></div><div class="line">        <span class="comment">/*将该等待节点移除*/</span></div><div class="line">        remove_wait_queue(&dev-&gt;wrqueue,&wait_w);</div><div class="line">	<span class="preprocessor">#<span class="keyword">endif</span> </span></div><div class="line"></div><div class="line">        <span class="comment">/*更新条件*/</span></div><div class="line">        havedata = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">/*唤醒读等待队列*/</span></div><div class="line">        wake_up_interruptible(&dev-&gt;rdqueue);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>5、应用程序采用两个不同的进程分别进行读、写，然后检测顺序是否可以调换，检查等待是否正常。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/basics/">basics</a><a href="/tags/linux/">linux</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Basics-Knowledge/">Basics Knowledge</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/19/[转] unlocked_ioctl 和堵塞（waitqueue）读写函数的实现/" data-title="(转) unlocked_ioctl 和堵塞（waitqueue）读写函数的实现 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/19/[转] 内存对齐/" title="(转) 内存对齐">
  <strong>上一篇:</strong><br/>
  <span>
  (转) 内存对齐</span>
</a>
</div>


<div class="next">
<a href="/2015/01/19/ubuntu 安装 winusb/"  title="ubuntu 安装 winusb">
 <strong>下一篇:</strong><br/> 
 <span>ubuntu 安装 winusb
</span>
</a>
</div>

</nav>


	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、ioctl函数的实现"><span class="toc-number">1.</span> <span class="toc-text">一、ioctl函数的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、设备的堵塞读写方式实现，通常采用等待队列。"><span class="toc-number">2.</span> <span class="toc-text">二、设备的堵塞读写方式实现，通常采用等待队列。</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>32</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>49</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>24</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>9</sup></a></li>
		
			<li><a href="/categories/Performance/" title="Performance">Performance<sup>4</sup></a></li>
		
			<li><a href="/categories/VR/" title="VR">VR<sup>2</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/android/" title="android">android<sup>85</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>5</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/vr/" title="vr">vr<sup>4</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">我的链接</p>
    <ul>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">网站数据统计</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
      <li><i class="fa fa-book"></i> <a href="https://dongka.github.io" target="_blank">Dongka的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2021 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
