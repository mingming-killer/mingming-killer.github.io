
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>工作小笔记——Android 自带的应用统计服务（UsageStatsService） | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="最近要弄在 framework 中弄一个统计应用使用时长的功能。刚开始想着要怎么是不是要在 ActivityManagerService（AMS）的几个 Activity 的生命周期那埋几个统计点，后面发现 android 自带了一个 UsageStatsService（USS）的系统服务。这个东西">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">〜(￣△￣〜) 三月学长的根据地 (〜￣△￣)〜</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/31/工作小笔记——Android 自带的应用统计服务[UsageStatsService]/" title="工作小笔记——Android 自带的应用统计服务（UsageStatsService）" itemprop="url">工作小笔记——Android 自带的应用统计服务（UsageStatsService）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-31T02:33:16.000Z" itemprop="datePublished">2015 1月 31</time>
    更新日期:<time datetime="2015-03-31T09:27:16.000Z" itemprop="dateModified">2015 3月 31</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#UsageStatsService"><span class="toc-number">1.</span> <span class="toc-text">UsageStatsService</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初步认识"><span class="toc-number">1.1.</span> <span class="toc-text">初步认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计埋点"><span class="toc-number">1.3.</span> <span class="toc-text">统计埋点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#noteResumeComponent"><span class="toc-number">1.3.1.</span> <span class="toc-text">noteResumeComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notePauseComponent"><span class="toc-number">1.3.2.</span> <span class="toc-text">notePauseComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addLaunchTime"><span class="toc-number">1.3.3.</span> <span class="toc-text">addLaunchTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AMS_小分析"><span class="toc-number">1.3.4.</span> <span class="toc-text">AMS 小分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存数据"><span class="toc-number">1.4.</span> <span class="toc-text">保存数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改造"><span class="toc-number">2.</span> <span class="toc-text">改造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方案"><span class="toc-number">2.1.</span> <span class="toc-text">方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-number">2.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>最近要弄在 framework 中弄一个统计应用使用时长的功能。刚开始想着要怎么是不是要在 ActivityManagerService（AMS）的几个 Activity 的生命周期那埋几个统计点，后面发现 android 自带了一个 UsageStatsService（USS）的系统服务。这个东西统计的数据已经满足这边的需求了。只不过 android 好像只是统计了数据，并没怎么用（不过不排除 google 服务偷偷的用这个东西，google 服务应用是不开源的），所以还需要改造一下下。不过基本已经算是没啥难度了，不需要验证自己埋点是不是正确的（android 自己的服务准确性上还是值得信赖的）。这里把这个服务和之后自己的改造稍微分析一下，照例先把相关源码的位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># AMS 相关</span></div><div class="line">frameworks/base/services/java/com/android/server/am/UsageStatsService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityStack.java</div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityRecord.java</div><div class="line"></div><div class="line"><span class="comment"># WMS 相关</span></div><div class="line">frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/wm/AppWindowToken.java</div><div class="line"></div><div class="line"><span class="comment"># Parcel 相关</span></div><div class="line">frameworks/base/core/java/android/os/Parcel.java</div><div class="line">frameworks/base/jni/android_os_Parcel.cpp</div><div class="line"></div><div class="line">frameworks/native/libs/binder/Parcel.cpp</div><div class="line">frameworks/native/include/utils/Unicode.h</div><div class="line"></div></pre></td></tr></table></figure>

<h2 id="UsageStatsService">UsageStatsService</h2>
<h3 id="初步认识">初步认识</h3>
<p>USS 虽然说是一个单独系统服务，但是从代码位置来看隶属于 AMS 家族：代码位于 frameworks/base/services/java/com/android/server/am 下面（在 services 包下能单独开一个文件夹的 SS 都是十分庞大的，例如：AM、WM、PM 之类）。它是由 AM 来启动的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ===================== ActivityManagerService.java ========================</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>{</div><div class="line">... ...</div><div class="line"></div><div class="line">	<span class="comment">// USS 属于 AMS</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * information about component usage</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> UsageStatsService mUsageStatsService;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="title">ActivityManagerService</span>() {</div><div class="line">... ...</div><div class="line"></div><div class="line">        File dataDir = Environment.getDataDirectory();</div><div class="line">        File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>); </div><div class="line">        systemDir.mkdirs();</div><div class="line">        mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(<span class="keyword">new</span> File(</div><div class="line">                systemDir, <span class="string">"batterystats.bin"</span>).toString());</div><div class="line">        mBatteryStatsService.getActiveStatistics().readLocked();</div><div class="line">        mBatteryStatsService.getActiveStatistics().writeAsyncLocked();</div><div class="line">        mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></div><div class="line">                : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</div><div class="line">        mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 在 AMS 的构造函数被 new 出来</span></div><div class="line">		<span class="comment">// 这个 systemDir 从来上面代码来看是： /data/system，所以传给 USS 的目录是 /data/system/usagestats</span></div><div class="line">        mUsageStatsService = <span class="keyword">new</span> UsageStatsService(<span class="keyword">new</span> File(</div><div class="line">                systemDir, <span class="string">"usagestats"</span>).toString());</div><div class="line">        mHeadless = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"ro.config.headless"</span>, <span class="string">"0"</span>));</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">	<span class="comment">// 前面 Binder SS 篇有说到 SS 初始化的时候会调用 AMS 的 main 函数的</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Context <span class="title">main</span>(<span class="keyword">int</span> factoryTest) {</div><div class="line">        AThread thr = <span class="keyword">new</span> AThread();</div><div class="line">        thr.start();</div><div class="line">       </div><div class="line">        <span class="keyword">synchronized</span> (thr) {</div><div class="line">            <span class="keyword">while</span> (thr.mService == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    thr.wait();</div><div class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                } </div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        ActivityManagerService m = thr.mService;</div><div class="line">        mSelf = m;</div><div class="line">        ActivityThread at = ActivityThread.systemMain();</div><div class="line">        mSystemThread = at;</div><div class="line">        Context context = at.getSystemContext();</div><div class="line">        context.setTheme(android.R.style.Theme_Holo);</div><div class="line">        m.mContext = context; </div><div class="line">        m.mFactoryTest = factoryTest;</div><div class="line">        m.mMainStack = <span class="keyword">new</span> ActivityStack(m, context, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 调用 USS 的 publish 函数</span></div><div class="line">        m.mBatteryStatsService.publish(context);</div><div class="line">        m.mUsageStatsService.publish(context);</div><div class="line">    </div><div class="line">        <span class="keyword">synchronized</span> (thr) {</div><div class="line">            thr.mReady = <span class="keyword">true</span>;</div><div class="line">            thr.notifyAll();</div><div class="line">        }</div><div class="line">   </div><div class="line">        m.startRunning(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ===================== UsageStatsService.java ========================</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This service collects the statistics associated with usage</span></div><div class="line"><span class="comment"> * of various components, like when a particular package is launched or</span></div><div class="line"><span class="comment"> * paused and aggregates events like number of time a component is launched</span></div><div class="line"><span class="comment"> * total duration of a component launch.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageStatsService</span> <span class="keyword">extends</span> <span class="title">IUsageStats</span>.<span class="title">Stub</span> </span>{</div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span>(Context context) {</div><div class="line">        mContext = context;</div><div class="line">		<span class="comment">// 向 SM 注册自己</span></div><div class="line">        ServiceManager.addService(SERVICE_NAME, asBinder());</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里如果有个我写的 Binder 系列那些知识的话是很简单的，SS 启动 AMS，然后 AMS 创建 USS，再调用 USS 的 publish 向 SM 注册 USS，这样 framework 中的各个模块（原生的 USS 不对第三方应用开放接口的）就能通过 SM 调用 USS 提供的 IPC 接口了。那我们也清楚了 USS 是在 AMS 初始化的时候启动的。</p>
<h3 id="数据结构">数据结构</h3>
<p>我们初步认识了 USS 之后，来看下 USS 使用的数据结构。在 USS 中有2个内部类（代码不多一次贴全了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageStatsService</span> <span class="keyword">extends</span> <span class="title">IUsageStats</span>.<span class="title">Stub</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line">       </div><div class="line">    <span class="keyword">static</span> IUsageStats sService;</div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line">    <span class="comment">// 这个 Map 基本就是 USS 保存的所有数据了，以 pkg name 为 key，</span></div><div class="line">    <span class="comment">// 每一个 pkg 一个 PkgUsageStatsExtended 数据。</span></div><div class="line">    <span class="comment">// 注释中说这个保存的是从最后一次 checkin 之后的数据，这个后面再说是什么意思。</span></div><div class="line">    <span class="comment">// structure used to maintain statistics since the last checkin.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Map&lt;String, PkgUsageStatsExtended&gt; mStats; </div><div class="line"></div><div class="line">    <span class="comment">// 一共有十个时间范围，下面的时间单位是 ms</span></div><div class="line">    <span class="comment">// 就是说 USS 会给一个组件（component）启动时候划分到下面几个时间段：</span></div><div class="line">    <span class="comment">// 例如说： 250ms ~ 500ms, 2000ms ~ 3000ms, &gt; 5000ms 等</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_LAUNCH_TIME_BINS = <span class="number">10</span>; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] LAUNCH_TIME_BINS = {</div><div class="line">        <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>, <span class="number">1500</span>, <span class="number">2000</span>, <span class="number">3000</span>, <span class="number">4000</span>, <span class="number">5000</span></div><div class="line">    }; </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// TimeStats 主要是保存应用的组件启动时长信息</span></div><div class="line">    <span class="keyword">static</span> class TimeStats {</div><div class="line">        <span class="comment">// 一共启动了几次</span></div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="comment">// 这个是一个数组，里面存放的是 component 启动时间段分布信息，详细看上面的解说</span></div><div class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[NUM_LAUNCH_TIME_BINS];</div><div class="line"></div><div class="line">        TimeStats() {</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> incCount() {</div><div class="line">            count++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这个接口传入的参数是时长，通过时长标记这个组件启动的时间属于上面哪个时间段</span></div><div class="line">        <span class="comment">// 数组的每个元素的数值分布就代表启动的时间段的分布</span></div><div class="line">        <span class="keyword">void</span> add(<span class="keyword">int</span> val) {</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] bins = LAUNCH_TIME_BINS;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM_LAUNCH_TIME_BINS-<span class="number">1</span>; i++) {</div><div class="line">                <span class="keyword">if</span> (val &lt; bins[i]) {</div><div class="line">                    times[i]++;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            times[NUM_LAUNCH_TIME_BINS-<span class="number">1</span>]++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 从 Parcel 打包的数据中实例化自己</span></div><div class="line">        TimeStats(Parcel in) {</div><div class="line">            count = in.readInt();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] localTimes = times;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM_LAUNCH_TIME_BINS; i++) {</div><div class="line">                localTimes[i] = in.readInt();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 把自己写入 Parcel 数据包中，上面的实例化是根据写的顺序来读的</span></div><div class="line">        <span class="comment">// 这里没有显式实现 Parcelable 接口，而是直接写了这2个函数让下面</span></div><div class="line">        <span class="comment">// 的业务函数来调用的，只是内部使用的话都差不多了</span></div><div class="line">        <span class="keyword">void</span> writeToParcel(Parcel out) {</div><div class="line">            out.writeInt(count);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] localTimes = times;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUM_LAUNCH_TIME_BINS; i++) {</div><div class="line">                out.writeInt(localTimes[i]);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 这个算是 USS 中基本数据单元，单位是包（packagename）</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PkgUsageStatsExtended</span> </span>{</div><div class="line">        <span class="comment">// 这个 HaspMap 以 ComponentName（String） 为 key，</span></div><div class="line">        <span class="comment">// 保存了这个 pkg 中启动过的组件的时长信息</span></div><div class="line">        <span class="keyword">final</span> HashMap&lt;String, TimeStats&gt; mLaunchTimes</div><div class="line">                = <span class="keyword">new</span> HashMap&lt;String, TimeStats&gt;();</div><div class="line">        <span class="comment">// 这个 pkg 启动过几次</span></div><div class="line">        <span class="keyword">int</span> mLaunchCount;</div><div class="line">        <span class="comment">// 这个 pkg 当前总共使用了多长时间（ms）</span></div><div class="line">        <span class="keyword">long</span> mUsageTime;</div><div class="line">        <span class="comment">// 这个 pkg 当前组件 Paused 的时间戳（ms）</span></div><div class="line">        <span class="keyword">long</span> mPausedTime;</div><div class="line">        <span class="comment">// 这个 pkg 当前组件 Resumed 的时间戳（ms）</span></div><div class="line">        <span class="keyword">long</span> mResumedTime;</div><div class="line">             </div><div class="line">        PkgUsageStatsExtended() {</div><div class="line">            mLaunchCount = <span class="number">0</span>; </div><div class="line">            mUsageTime = <span class="number">0</span>; </div><div class="line">        }    </div><div class="line">        </div><div class="line">        <span class="comment">// 从 Parcel 打包的数据中实例化自己      </span></div><div class="line">        PkgUsageStatsExtended(Parcel in) {</div><div class="line">            mLaunchCount = in.readInt();</div><div class="line">            mUsageTime = in.readLong();</div><div class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launch count: "</span> + mLaunchCount</div><div class="line">                    + <span class="string">", Usage time:"</span> + mUsageTime);</div><div class="line">                 </div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numTimeStats = in.readInt();</div><div class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Reading comps: "</span> + numTimeStats);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numTimeStats; i++) {</div><div class="line">                String comp = in.readString();</div><div class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Component: "</span> + comp);</div><div class="line">                TimeStats times = <span class="keyword">new</span> TimeStats(in);</div><div class="line">                mLaunchTimes.put(comp, times);</div><div class="line">            }    </div><div class="line">        }   </div><div class="line">        </div><div class="line">        <span class="comment">// 更新 Resume 信息， AMS 中有组件 Resume 的时候调用</span></div><div class="line">        <span class="keyword">void</span> updateResume(String comp, <span class="keyword">boolean</span> launched) {</div><div class="line">            <span class="keyword">if</span> (launched) {</div><div class="line">                <span class="comment">// 在 launch Resume 的时候才算一次启动</span></div><div class="line">                <span class="comment">// 后面能看到 AMS 哪些地方会埋这个点的</span></div><div class="line">                mLaunchCount ++;</div><div class="line">            }</div><div class="line">            mResumedTime = SystemClock.elapsedRealtime();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 更新 Pause 信息</span></div><div class="line">        <span class="keyword">void</span> updatePause() {</div><div class="line">            mPausedTime =  SystemClock.elapsedRealtime();</div><div class="line">            <span class="comment">// Pause 的时候更新下使用时间</span></div><div class="line">            mUsageTime += (mPausedTime - mResumedTime);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 添加 pkg 组件启动次数信息</span></div><div class="line">        <span class="keyword">void</span> addLaunchCount(String comp) {</div><div class="line">            TimeStats times = mLaunchTimes.get(comp);</div><div class="line">            <span class="comment">// 如果是组件的话，new 一个 TimeStats</span></div><div class="line">            <span class="keyword">if</span> (times == <span class="keyword">null</span>) {</div><div class="line">                times = <span class="keyword">new</span> TimeStats();</div><div class="line">                mLaunchTimes.put(comp, times);</div><div class="line">            }</div><div class="line">            times.incCount();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 添加 pkg 组件启动时长信息</span></div><div class="line">        <span class="keyword">void</span> addLaunchTime(String comp, <span class="keyword">int</span> millis) {</div><div class="line">            TimeStats times = mLaunchTimes.get(comp);</div><div class="line">            <span class="keyword">if</span> (times == <span class="keyword">null</span>) {</div><div class="line">                times = <span class="keyword">new</span> TimeStats();</div><div class="line">                mLaunchTimes.put(comp, times);</div><div class="line">            }</div><div class="line">            times.add(millis);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 把自己写入 Parcel 数据包中，上面的实例化是根据写的顺序来读的</span></div><div class="line">        <span class="keyword">void</span> writeToParcel(Parcel out) {</div><div class="line">            out.writeInt(mLaunchCount);</div><div class="line">            out.writeLong(mUsageTime);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numTimeStats = mLaunchTimes.size();</div><div class="line">            out.writeInt(numTimeStats);</div><div class="line">            <span class="keyword">if</span> (numTimeStats &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, TimeStats&gt; ent : mLaunchTimes.entrySet()) {</div><div class="line">                    out.writeString(ent.getKey());</div><div class="line">                    TimeStats times = ent.getValue();</div><div class="line">                    times.writeToParcel(out);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 清除所有 pkg 信息（包括组件的 TimeStats 信息）</span></div><div class="line">        <span class="keyword">void</span> clear() {</div><div class="line">            mLaunchTimes.clear();</div><div class="line">            mLaunchCount = <span class="number">0</span>;</div><div class="line">            mUsageTime = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面基本上把 USS 的基本数据结构介绍清楚了。其结构是一个 Map，其中以安装了的 pkg 为条，每一条包括：</p>
<ul>
<li>启动总次数</li>
<li>总共时间时间</li>
<li>pkg 中每个组件启动的次数以及每次启动所需要的时间</li>
</ul>
<p>为了增加感性认识，dumpsys 一下 usagestats 这个服务能看到磁盘的保存了的 USS 的数据信息：</p>
<pre>
Date: 20150305
  com.android.systemui: 2 times, 26577889 ms
    com.android.systemui.usb.UsbStorageActivity: 2 starts, 2000-3000ms=2
  com.eebbk.mingming.notificationtest: 1 times, 8625444 ms
    com.eebbk.mingming.notificationtest.MainActivity: 1 starts, 500-750ms=1
  com.bbk.studyos.launcher: 3 times, 11220 ms
    com.bbk.studyos.launcher.activity.Launcher: 3 starts, >=5000ms=1
Date: 20150306
  com.android.systemui: 1 times, 30961918 ms
    com.android.systemui.usb.UsbStorageActivity: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 2 times, 8282 ms
    com.bbk.studyos.launcher.activity.Launcher: 2 starts, 2000-3000ms=1
Date: 20150307
  com.android.systemui: 3 times, 445073 ms
    com.android.systemui.usb.UsbStorageActivity: 3 starts, 250-500ms=1, 2000-3000ms=1
  com.android.providers.usagestats: 1 times, 41882 ms
    com.android.providers.usagestats.viewer.UsageStatsViewer: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 3 times, 27290376 ms
    com.bbk.studyos.launcher.activity.Launcher: 3 starts, >=5000ms=1
Date: 20150309
  com.android.systemui: 4 times, 6534068 ms
    com.android.systemui.usb.UsbStorageActivity: 4 starts, 250-500ms=2, 2000-3000ms=2
  com.eebbk.systemuimodedemo: 2 times, 612236 ms
    com.eebbk.systemuimodedemo.MainActivity: 2 starts, 750-1000ms=1
  com.eebbk.mingming.notificationtest: 1 times, 1813374 ms
    com.eebbk.mingming.notificationtest.MainActivity: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 7 times, 28509 ms
    com.bbk.studyos.launcher.activity.Launcher: 7 starts, 2000-3000ms=1, >=5000ms=2
Date: 20150310
  com.android.systemui: 1 times, 0 ms
    com.android.systemui.usb.UsbStorageActivity: 1 starts, 2000-3000ms=1
  com.bbk.studyos.launcher: 1 times, 1421 ms
    com.bbk.studyos.launcher.activity.Launcher: 1 starts
Date: history.xml (old data version)
</pre>

<p>（这里仔细看，发现组件启动那里的启动次数和后面的时间段分布有些时候会不对，时间段分别那有时会有少几次的情况出现，后面会知道偶尔出现这种情况的原因）</p>
<h3 id="统计埋点">统计埋点</h3>
<p>其实所有的统计流程基本上都是一样的，定下要统计的数据结构，下面就是埋点，然后上报数据，最后服务端保存数据。前面说了埋点是在 AMS 里面的。这里先看看 USS 提供给 AMS 的埋点接口，一共三个：</p>
<ul>
<li><strong>noteResumeComponent:</strong> 通知有组件跑了 Resume 生命周期</li>
<li><strong>notePauseComponent:</strong> 通知有组件跑了 Pause 生命周期</li>
<li><strong>noteLaunchTime:</strong> 通知组件的启动时间</li>
</ul>
<p>下面我们一个一个看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteResumeComponent</span>(ComponentName componentName) {</div><div class="line">    <span class="comment">// 检测下调用者权限</span></div><div class="line">    enforceCallingPermission();</div><div class="line">    String pkgName;</div><div class="line">    <span class="comment">// 喜闻乐见的 SS 业务多线程同步锁，这次 USS 访问 mStats 数据和写文件用的是2个单独的锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">        <span class="comment">// 这个组件必须要包含 pkg name 才能被统计（绝大多数组件都包含 pkg name 的）</span></div><div class="line">        <span class="keyword">if</span> ((componentName == <span class="keyword">null</span>) ||</div><div class="line">                ((pkgName = componentName.getPackageName()) == <span class="keyword">null</span>)) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这里有一个判断：如果当前 Resume 的这个组件和上一次那个是同一个，</span></div><div class="line">        <span class="comment">// 并且还没经过 Pause（后面指定经过 Pause 的话 mIsResumed 是 false 的），</span></div><div class="line">        <span class="comment">// 那么认为应该要调用下当前这个 pkg 的 updatePause 来更新下 Pause 信息。</span></div><div class="line">        <span class="comment">// 因为 Resume 要和 Pause 成对。这种情况的典型场景就是：</span></div><div class="line">        <span class="comment">// 一些启动 activity 的按钮处理没做好，用户一个不小心点击了好多下，</span></div><div class="line">        <span class="comment">// 然后就启动了好多个 activity，上面一个还没来得及 Pause 就有相同的 Resume 了。</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> samePackage = pkgName.equals(mLastResumedPkg);</div><div class="line">        <span class="keyword">if</span> (mIsResumed) {</div><div class="line">            <span class="keyword">if</span> (mLastResumedPkg != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// We last resumed some other package...  just pause it now</span></div><div class="line">                <span class="comment">// to recover.</span></div><div class="line">                <span class="keyword">if</span> (REPORT_UNEXPECTED) Slog.i(TAG, <span class="string">"Unexpected resume of "</span> + pkgName</div><div class="line">                        + <span class="string">" while already resumed in "</span> + mLastResumedPkg);</div><div class="line">                PkgUsageStatsExtended pus = mStats.get(mLastResumedPkg);</div><div class="line">                <span class="keyword">if</span> (pus != <span class="keyword">null</span>) {</div><div class="line">                    pus.updatePause();</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> sameComp = samePackage</div><div class="line">                && componentName.getClassName().equals(mLastResumedComp);</div><div class="line"></div><div class="line">        <span class="comment">// 把 mIsResumed 标志设置为 true</span></div><div class="line">        mIsResumed = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 保存下最后一次 Resume 的 pkg 和 comp 的名字</span></div><div class="line">        mLastResumedPkg = pkgName;</div><div class="line">        mLastResumedComp = componentName.getClassName();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.i(TAG, <span class="string">"started component:"</span> + pkgName);</div><div class="line">        <span class="comment">// 如果 pkg 是第一次，new 一个 PkgUsageStatsExtended 保存</span></div><div class="line">        PkgUsageStatsExtended pus = mStats.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pus == <span class="keyword">null</span>) {</div><div class="line">            pus = <span class="keyword">new</span> PkgUsageStatsExtended();</div><div class="line">            mStats.put(pkgName, pus);</div><div class="line">        }</div><div class="line">        <span class="comment">// 调用 updateResume 更新 Resume 信息，</span></div><div class="line">        <span class="comment">// 注意第二个参数，如果 Resume 是不同的 pkg，那么算这个 pkg 的一次启动次数</span></div><div class="line">        pus.updateResume(mLastResumedComp, !samePackage);</div><div class="line">        <span class="comment">// 如果 Resume 的是不同的组件，那么算这个 pkg 组件的一次启动次数</span></div><div class="line">        <span class="keyword">if</span> (!sameComp) {</div><div class="line">            pus.addLaunchCount(mLastResumedComp);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 这个 mLastResumeTimes 的统计数据我们暂时不管它</span></div><div class="line">        Map&lt;String, Long&gt; componentResumeTimes = mLastResumeTimes.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (componentResumeTimes == <span class="keyword">null</span>) {</div><div class="line">            componentResumeTimes = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</div><div class="line">            mLastResumeTimes.put(pkgName, componentResumeTimes);</div><div class="line">        }</div><div class="line">        componentResumeTimes.put(mLastResumedComp, System.currentTimeMillis());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后下面是通知 Pause 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notePauseComponent</span>(ComponentName componentName) {</div><div class="line">    <span class="comment">// 同样是检测调用者的权限</span></div><div class="line">    enforceCallingPermission();</div><div class="line"></div><div class="line">    <span class="comment">// 同样是喜闻乐见的同步锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">        <span class="comment">// 同样得判断这个组件有没有带 pkg name 信息</span></div><div class="line">        String pkgName;</div><div class="line">        <span class="keyword">if</span> ((componentName == <span class="keyword">null</span>) ||</div><div class="line">                ((pkgName = componentName.getPackageName()) == <span class="keyword">null</span>)) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 这个为了保证 Resume、Pause 的成对性，判断 mIsResumed 如果不是 true 就返回</span></div><div class="line">        <span class="keyword">if</span> (!mIsResumed) {</div><div class="line">            <span class="keyword">if</span> (REPORT_UNEXPECTED) Slog.i(TAG, <span class="string">"Something wrong here, didn't expect "</span></div><div class="line">                    + pkgName + <span class="string">" to be paused"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 设置 mIsResumed 为 false</span></div><div class="line">        mIsResumed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.i(TAG, <span class="string">"paused component:"</span>+pkgName);</div><div class="line"></div><div class="line">        <span class="comment">// 调用 updatePause 更新 Pause 信息</span></div><div class="line">        PkgUsageStatsExtended pus = mStats.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pus == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Weird some error here</span></div><div class="line">            Slog.i(TAG, <span class="string">"No package stats for pkg:"</span>+pkgName);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        pus.updatePause();</div><div class="line">    }   </div><div class="line">         </div><div class="line">    <span class="comment">// 在收到组件 Pause 信息的时候保存统计数据到文件中，这个我们后面再具体分析。</span></div><div class="line">    <span class="comment">// 这里稍微注意一下这个函数没在上面的 mStatsLock 的范围中。</span></div><div class="line">    <span class="comment">// 因为 USS 拿了2个锁处理多线程同步问题，读写文件的锁是另外一个，在这个函数会用的。  </span></div><div class="line">    <span class="comment">// Persist current data to file if needed.</span></div><div class="line">    writeStatsToFile(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后是通知启动需要的时间的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteLaunchTime</span>(ComponentName componentName, <span class="keyword">int</span> millis) {</div><div class="line">    <span class="comment">// 还是检测调用者的权限</span></div><div class="line">    enforceCallingPermission();</div><div class="line">    String pkgName;</div><div class="line">    <span class="keyword">if</span> ((componentName == <span class="keyword">null</span>) ||</div><div class="line">            ((pkgName = componentName.getPackageName()) == <span class="keyword">null</span>)) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 在收到组件启动时间的信息的时候也会激发写入文件的操作</span></div><div class="line">    <span class="comment">// 和上面的一样不在 mStatsLock 的范围内</span></div><div class="line">    <span class="comment">// Persist current data to file if needed.</span></div><div class="line">    writeStatsToFile(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 还是喜闻乐见的同步锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">        <span class="comment">// 调用 addLaunchTime 添加组件启动时长信息</span></div><div class="line">        PkgUsageStatsExtended pus = mStats.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pus != <span class="keyword">null</span>) {</div><div class="line">            pus.addLaunchTime(componentName.getClassName(), millis);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里能看到上面的 noteResume 和 notePause 中会有成对的判断（以后自己处理组件生命周期问题的时候也要多加注意）。还有这里组件启动次数和添加组件启动所需时长信息不在同一个地方，这就能解释为什么偶尔会发现这2个数据个数对不上的问题（埋点的地方不一样，总有几次漏的）。还有上面访问 mStats 和读写文件的锁是分开的，可以学习一下多线程互斥问题的时候，要多想想，不要一遇到互斥问题就所有的代码用一个锁锁住。细分可重入的代码块能提高程序并发访问的能力。</p>
<p>上面埋点的接口，下面我们来看下哪些地方埋了这些点，基本上在 AMS 和 WMS 中（AMS、WMS 的代码十分庞大，请善用 grep 神器）。我们还是分成3个部分来说：</p>
<h4 id="noteResumeComponent">noteResumeComponent</h4>
<p>这里我能省略的尽量省略，因为要如何分析 AMS 和 WMS 至少要好几篇才够，先上张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/noteResumeComponent.png" alt=""></p>
<p>Resume 的埋点在 AMS 的 ActivityStack（AS） 的 completeResumeLocked 中。前面一些分析说过 AMS 有一个 activity 的堆栈，相关操作（start activity、resume activity、pause activity 等等）集中在 AS 中。其中 AMS 好像有好几个 AS，但是这里和统计相关的只有一个叫 mMainStack 的主堆栈。大体可以分为2条路：</p>
<ul>
<li><strong>branch1:</strong></li>
</ul>
<p>第一条分支，是比较常见的调用 AMS 的 startActivity 发起的。然后和之前 Binder 的 SS 篇和 Broadcast 篇类似，分为 activity 的进程时候存在。如果不存在，继续走 branch1 后面的。如果进程已经存在，就算 branch 2 前面各种场景调用中的一种，可以直接调用 mMainStack 的 startActivity 相关函数，最后会调用 AS 的 resumeTopActivityLocked 然后去 branch2。这里我们先看进程不存在的情况，告诉 Zygote fork 出进程，然后会跑 ActivityThread（AT） 里面的 main 函数，然后 main 里面会 new AT，然后调用 AT 的 attach 函数，然后会 IPC 调用 AMS 的 attachApplication(Locked)（这些前面那些篇章都分析过了，省略贴代码了）。这里稍微说下 AMS 的 mMainStack（AS） 和 ActivityRecord（AR）这2个东西。在 AMS 的 main 里会创建一个 AS 这里就是主堆栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Context <span class="title">main</span>(<span class="keyword">int</span> factoryTest) {</div><div class="line">    AThread thr = <span class="keyword">new</span> AThread();   </div><div class="line">    thr.start();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (thr) {</div><div class="line">        <span class="keyword">while</span> (thr.mService == <span class="keyword">null</span>) { </div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                thr.wait();                    </div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">            }             </div><div class="line">        }                 </div><div class="line">    }</div><div class="line"></div><div class="line">    ActivityManagerService m = thr.mService;</div><div class="line">    mSelf = m;</div><div class="line">    ActivityThread at = ActivityThread.systemMain(); </div><div class="line">    mSystemThread = at;</div><div class="line">    Context context = at.getSystemContext();</div><div class="line">    context.setTheme(android.R.style.Theme_Holo);</div><div class="line">    m.mContext = context;</div><div class="line">    m.mFactoryTest = factoryTest;  </div><div class="line">    <span class="comment">// new 出来的 AS，最后一参数 mainStack 是 true</span></div><div class="line">    m.mMainStack = <span class="keyword">new</span> ActivityStack(m, context, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    m.mBatteryStatsService.publish(context);</div><div class="line">    m.mUsageStatsService.publish(context);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (thr) {</div><div class="line">        thr.mReady = <span class="keyword">true</span>;</div><div class="line">        thr.notifyAll();</div><div class="line">    }</div><div class="line"></div><div class="line">    m.startRunning(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后 AR 这个东西么，经过前面一些 SS 的分析都知道 SS 都喜欢管自己的一些数据结构叫 XxxxRecord（ProcessRecord, ServiceRecord, TaskRecord, BroadcastRecord … …），所以这里的 AR 对应的就是 activity 的记录了。然后在 AS 中的 startActivityLocked 会 new 一个 AR：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startActivityLocked(IApplicationThread caller,</div><div class="line">            Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo,</div><div class="line">            String resultWho, <span class="keyword">int</span> requestCode,</div><div class="line">            <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> startFlags, Bundle options,</div><div class="line">            <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity) {</div><div class="line"></div><div class="line">        <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 启动一个 activity 对应就有一个 AR</span></div><div class="line">        ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, <span class="keyword">this</span>, callerApp, callingUid,</div><div class="line">                intent, resolvedType, aInfo, mService.mConfiguration,</div><div class="line">                resultRecord, resultWho, requestCode, componentSpecified);</div><div class="line">        <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) {</div><div class="line">            outActivity[<span class="number">0</span>] = r;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            <span class="keyword">if</span> (mResumedActivity == <span class="keyword">null</span></div><div class="line">                    || mResumedActivity.info.applicationInfo.uid != callingUid) {</div><div class="line">                <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, <span class="string">"Activity start"</span>)) {</div><div class="line">                    PendingActivityLaunch pal = <span class="keyword">new</span> PendingActivityLaunch();</div><div class="line">                    pal.r = r;</div><div class="line">                    pal.sourceRecord = sourceRecord;</div><div class="line">                    pal.startFlags = startFlags;</div><div class="line">                    mService.mPendingActivityLaunches.add(pal);</div><div class="line">                    mDismissKeyguardOnNextActivity = <span class="keyword">false</span>;</div><div class="line">                    ActivityOptions.abort(options);</div><div class="line">                    <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (mService.mDidAppSwitch) {</div><div class="line">                <span class="comment">// This is the second allowed switch since we stopped switches,</span></div><div class="line">                <span class="comment">// so now just generally allow switches.  Use case: user presses</span></div><div class="line">                <span class="comment">// home (switches disabled, switch to home, mDidAppSwitch now true);</span></div><div class="line">                <span class="comment">// user taps a home icon (coming from home so allowed, we hit here</span></div><div class="line">                <span class="comment">// and now allow anyone to switch again).</span></div><div class="line">                mService.mAppSwitchesAllowedTime = <span class="number">0</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mService.mDidAppSwitch = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            mService.doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        err = startActivityUncheckedLocked(r, sourceRecord,</div><div class="line">                startFlags, <span class="keyword">true</span>, options);</div><div class="line">        <span class="keyword">if</span> (mDismissKeyguardOnNextActivity && mPausingActivity == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// Someone asked to have the keyguard dismissed on the next</span></div><div class="line">            <span class="comment">// activity start, but we are not actually doing an activity</span></div><div class="line">            <span class="comment">// switch...  just dismiss the keyguard now, because we</span></div><div class="line">            <span class="comment">// probably want to see whatever is behind it.</span></div><div class="line">            mDismissKeyguardOnNextActivity = <span class="keyword">false</span>;</div><div class="line">            mService.mWindowManager.dismissKeyguard();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> err;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里虽然没具体分析 startActivity 的过程，但是我们可以猜到一个 activity 对应一个 AR 记录。并且是在 startActivity 的时候创建的，所以等 AT attach AMS 的时候 AR 取最顶层的 AR 就是当前 startActivity 对应的 AR 记录。所以 AMS 会先调用 mMainStack(AS) topRunningActivityLocked 取顶层的 AR，然后 realStartActivityLocked 去真正的启动 activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span>(IApplicationThread thread,</div><div class="line">            <span class="keyword">int</span> pid) {</div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 取当前的启动 activity 的 AR 记录（顶层）</span></div><div class="line">        <span class="comment">// See if the top visible activity is waiting to run in this process...</span></div><div class="line">        ActivityRecord hr = mMainStack.topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (hr != <span class="keyword">null</span> && normalMode) {</div><div class="line">            <span class="keyword">if</span> (hr.app == <span class="keyword">null</span> && app.uid == hr.info.applicationInfo.uid</div><div class="line">                    && processName.equals(hr.processName)) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    <span class="keyword">if</span> (mHeadless) {</div><div class="line">                        <span class="comment">// 调用 mMainStack 的 realStartActivityLocked</span></div><div class="line">                        <span class="comment">// 传过去的 andResume 是 true</span></div><div class="line">                        Slog.e(TAG, <span class="string">"Starting activities not supported on headless device: "</span> + hr);</div><div class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (mMainStack.realStartActivityLocked(hr, app, <span class="keyword">true</span>, <span class="keyword">true</span>)) {</div><div class="line">                        didSomething = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                    Slog.w(TAG, <span class="string">"Exception in new application when starting activity "</span></div><div class="line">                          + hr.intent.getComponent().flattenToShortString(), e);</div><div class="line">                    badApp = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                mMainStack.ensureActivitiesVisibleLocked(hr, <span class="keyword">null</span>, processName, <span class="number">0</span>);</div><div class="line">            }</div><div class="line">        }   </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 AS 里的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> realStartActivityLocked(ActivityRecord r,</div><div class="line">            ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</div><div class="line">            <span class="keyword">throws</span> RemoteException {</div><div class="line"></div><div class="line">... ...</div><div class="line">        </div><div class="line">        <span class="comment">// 从 AMS 那里传过来的 andResume 是 true     </span></div><div class="line">        <span class="keyword">if</span> (andResume) {</div><div class="line">            <span class="comment">// As part of the process of launching, ActivityThread also performs</span></div><div class="line">            <span class="comment">// a resume.</span></div><div class="line">            r.state = ActivityState.RESUMED;</div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to RESUMED: "</span> + r</div><div class="line">                    + <span class="string">" (starting new instance)"</span>);</div><div class="line">            r.stopped = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 保存当前 resume 的 AR 记录</span></div><div class="line">            mResumedActivity = r;</div><div class="line">            r.task.touchActiveTime();</div><div class="line">            <span class="keyword">if</span> (mMainStack) {</div><div class="line">                mService.addRecentTaskLocked(r.task);</div><div class="line">            }       </div><div class="line">            <span class="comment">// AMS Resume 的集中埋点处</span></div><div class="line">            completeResumeLocked(r);</div><div class="line">            checkReadyForSleepLocked();</div><div class="line">            <span class="keyword">if</span> (DEBUG_SAVED_STATE) Slog.i(TAG, <span class="string">"Launch completed; removing icicle of "</span> + r.icicle);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// This activity is not starting in the resumed state... which</span></div><div class="line">            <span class="comment">// should look like we asked it to pause+stop (but remain visible),</span></div><div class="line">            <span class="comment">// and it has done so and reported back the current icicle and</span></div><div class="line">            <span class="comment">// other state.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to STOPPED: "</span> + r</div><div class="line">                    + <span class="string">" (starting in stopped state)"</span>);</div><div class="line">            r.state = ActivityState.STOPPED;</div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">        }                       </div><div class="line">                                </div><div class="line">        <span class="comment">// Launch the new version setup screen if needed.  We do this -after-</span></div><div class="line">        <span class="comment">// launching the initial activity (that is, home), so that it can have</span></div><div class="line">        <span class="comment">// a chance to initialize itself while in the background, making the</span></div><div class="line">        <span class="comment">// switch back to it faster and look better.</span></div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            mService.startSetupActivityLocked();</div><div class="line">        }       </div><div class="line">            </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后剩下的流程比较简单，我把代码合并在一起了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// =================== ActivityStack.java ======================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Once we know that we have asked an application to put an activity in</span></div><div class="line"><span class="comment">     * the resumed state (either by launching it or explicitly telling it),</span></div><div class="line"><span class="comment">     * this function updates the rest of our state to match that fact.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">completeResumeLocked</span>(ActivityRecord next) {</div><div class="line">        next.idle = <span class="keyword">false</span>;</div><div class="line">        next.results = <span class="keyword">null</span>;</div><div class="line">        next.newIntents = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// schedule an idle timeout in case the app doesn't do it for us.</span></div><div class="line">        Message msg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG);</div><div class="line">        msg.obj = next;</div><div class="line">        mHandler.sendMessageDelayed(msg, IDLE_TIMEOUT);</div><div class="line">                    </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) {</div><div class="line">            <span class="comment">// The activity was never told to pause, so just keep</span></div><div class="line">            <span class="comment">// things going as-is.  To maintain our own state,</span></div><div class="line">            <span class="comment">// we need to emulate it coming back and saying it is</span></div><div class="line">            <span class="comment">// idle.</span></div><div class="line">            msg = mHandler.obtainMessage(IDLE_NOW_MSG);</div><div class="line">            msg.obj = next;</div><div class="line">            mHandler.sendMessage(msg);</div><div class="line">        }   </div><div class="line">        </div><div class="line">        <span class="comment">// 调用 AMS 的 reportResumedActivityLocked，传递当前的 AR 记录</span></div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            mService.reportResumedActivityLocked(next);</div><div class="line">        }</div><div class="line">       </div><div class="line">        <span class="keyword">if</span> (mMainStack) {</div><div class="line">            mService.setFocusedActivityLocked(next);</div><div class="line">        }</div><div class="line">        next.resumeKeyDispatchingLocked();</div><div class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">        mService.mWindowManager.executeAppTransition();</div><div class="line">        mNoAnimActivities.clear();</div><div class="line"></div><div class="line">        <span class="comment">// Mark the point when the activity is resuming</span></div><div class="line">        <span class="comment">// TODO: To be more accurate, the mark should be before the onCreate,</span></div><div class="line">        <span class="comment">//       not after the onResume. But for subsequent starts, onResume is fine.</span></div><div class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">synchronized</span> (mService.mProcessStatsThread) {</div><div class="line">                next.cpuTimeAtResume = mService.mProcessStats.getCpuTimeForPid(next.app.pid);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            next.cpuTimeAtResume = <span class="number">0</span>; <span class="comment">// Couldn't get the cpu time of process</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// =================== ActivityManagerService.java ======================</span></div><div class="line"></div><div class="line">    <span class="keyword">void</span> reportResumedActivityLocked(ActivityRecord r) {</div><div class="line">        <span class="comment">//Slog.i(TAG, "**** REPORT RESUME: " + r);</span></div><div class="line">        updateUsageStats(r, <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">void</span> updateUsageStats(ActivityRecord resumedComponent, <span class="keyword">boolean</span> resumed) {</div><div class="line">        <span class="keyword">if</span> (resumed) {</div><div class="line">            <span class="comment">// 调用 USS 的 noteResumeComponent，当前的 AR 中有 ComponentName 信息</span></div><div class="line">            mUsageStatsService.noteResumeComponent(resumedComponent.realActivity);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mUsageStatsService.notePauseComponent(resumedComponent.realActivity);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>其实 AS 是 AMS 中分出去的一部分，AS 中还有不少回调用 AMS 的地方的。</p>
<ul>
<li><strong>branch2:</strong></li>
</ul>
<p>分支2的话主要是 AMS 和 AS 中有很多种情况会调用 AS 的 resumeTopActivityLocked，例如说按 Home 键回桌面；当前应用挂了，要恢复前一个应用；或者七七八八别的情况。由于这里主要不是分析 AMS 的地方，所以把这里省略了，主要从 resumeTopActivityLocked 这个入口开始说起（分支1中 startActivity 进程已经存在的情况最后也会走这个地方的）。从这里说其实就比较简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> resumeTopActivityLocked(ActivityRecord prev, Bundle options) {</div><div class="line">        <span class="comment">// 取最顶端的 AR 记录，作为下一个要 resume 的 activity</span></div><div class="line">        <span class="comment">// Find the first activity that is not finishing.</span></div><div class="line">        ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 要 resume 的 activity 进程还在</span></div><div class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span> && next.app.thread != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG, <span class="string">"Resume running: "</span> + next);</div><div class="line"></div><div class="line">            <span class="comment">// This activity is now becoming visible.</span></div><div class="line">            mService.mWindowManager.setAppVisibility(next.appToken, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            <span class="comment">// schedule launch ticks to collect information about slow apps.</span></div><div class="line">            next.startLaunchTickingLocked();</div><div class="line"></div><div class="line">            ActivityRecord lastResumedActivity = mResumedActivity;</div><div class="line">            ActivityState lastState = next.state;</div><div class="line"></div><div class="line">            mService.updateCpuStats();     </div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to RESUMED: "</span> + next + <span class="string">" (in existing)"</span>);</div><div class="line">            next.state = ActivityState.RESUMED;</div><div class="line">            <span class="comment">// 保存当前的 resume 的 AR 信息</span></div><div class="line">            mResumedActivity = next;       </div><div class="line">            next.task.touchActiveTime();   </div><div class="line">            <span class="keyword">if</span> (mMainStack) {</div><div class="line">                mService.addRecentTaskLocked(next.task);</div><div class="line">            }</div><div class="line">            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>);</div><div class="line">            updateLRUListLocked(next);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// Deliver all pending results.</span></div><div class="line">                ArrayList a = next.results;</div><div class="line">                <span class="keyword">if</span> (a != <span class="keyword">null</span>) {</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</div><div class="line">                    <span class="keyword">if</span> (!next.finishing && N &gt; <span class="number">0</span>) {</div><div class="line">                        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(</div><div class="line">                                TAG, <span class="string">"Delivering results to "</span> + next</div><div class="line">                                + <span class="string">": "</span> + a);</div><div class="line">                        next.app.thread.scheduleSendResult(next.appToken, a);</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) {</div><div class="line">                    next.app.thread.scheduleNewIntent(next.newIntents, next.appToken);</div><div class="line">                }</div><div class="line"></div><div class="line">                EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,</div><div class="line">                        next.userId, System.identityHashCode(next),</div><div class="line">                        next.task.taskId, next.shortComponentName);</div><div class="line"></div><div class="line">                next.sleeping = <span class="keyword">false</span>;</div><div class="line">                showAskCompatModeDialogLocked(next);</div><div class="line">                next.app.pendingUiClean = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 执行 activity 的 Resume 生命周期</span></div><div class="line">                next.app.thread.scheduleResumeActivity(next.appToken,</div><div class="line">                        mService.isNextTransitionForward());</div><div class="line"></div><div class="line">                checkReadyForSleepLocked();</div><div class="line"></div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// Whoops, need to restart this activity!</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Resume failed; resetting state to "</span></div><div class="line">                        + lastState + <span class="string">": "</span> + next);</div><div class="line">                next.state = lastState;</div><div class="line">                mResumedActivity = lastResumedActivity;</div><div class="line">                Slog.i(TAG, <span class="string">"Restarting because process died: "</span> + next);</div><div class="line">                <span class="keyword">if</span> (!next.hasBeenLaunched) {</div><div class="line">                    next.hasBeenLaunched = <span class="keyword">true</span>;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW && mMainStack) {</div><div class="line">                        mService.mWindowManager.setAppStartingWindow(</div><div class="line">                                next.appToken, next.packageName, next.theme,</div><div class="line">                                mService.compatibilityInfoForPackageLocked(</div><div class="line">                                        next.info.applicationInfo),</div><div class="line">                                next.nonLocalizedLabel,</div><div class="line">                                next.labelRes, next.icon, next.windowFlags,</div><div class="line">                                <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="comment">// 如果执行 activity Resume 生命周期出现错误的话（IPC 通信错误之类的）</span></div><div class="line">                <span class="comment">// 调用 startSpecificActivityLocked 重新启动这个 activity </span></div><div class="line">                <span class="comment">// 然后里面会调用 realStartActivityLocked 就和分支1后面一样了</span></div><div class="line">                startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// From this point on, if something goes wrong there is no way</span></div><div class="line">            <span class="comment">// to recover the activity.</span></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                next.visible = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 如果执行 activity Resume 生命周期没有错误的话就调用 completeResumeLocked</span></div><div class="line">                <span class="comment">// 之后的流程和分支1一样的</span></div><div class="line">                completeResumeLocked(next);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// If any exception gets thrown, toss away this</span></div><div class="line">                <span class="comment">// activity and try the next one.</span></div><div class="line">                Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</div><div class="line">                requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</div><div class="line">                        <span class="string">"resume-exception"</span>, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            next.stopped = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// Whoops, need to restart this activity!</span></div><div class="line">            <span class="keyword">if</span> (!next.hasBeenLaunched) {</div><div class="line">                next.hasBeenLaunched = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) {</div><div class="line">                    mService.mWindowManager.setAppStartingWindow(</div><div class="line">                            next.appToken, next.packageName, next.theme,</div><div class="line">                            mService.compatibilityInfoForPackageLocked(</div><div class="line">                                    next.info.applicationInfo),</div><div class="line">                            next.nonLocalizedLabel,</div><div class="line">                            next.labelRes, next.icon, next.windowFlags,</div><div class="line">                            <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG, <span class="string">"Restarting: "</span> + next);</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果要 resume 的 activity 的进程不在了，也需要重新启动</span></div><div class="line">            startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>分支2从各种情况调用到 AS 的 resumeTopActivityLocked，然后最后辗转几次还是到了 resume 的埋点函数 completeResumeLocked 这里。然后最后调用 USS 的接口，收集数据。</p>
<h4 id="notePauseComponent">notePauseComponent</h4>
<p>接下来是调用通知 Pause 的接口，也是先上图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/notePauseComponent.png" alt=""></p>
<p>首先从图上看，埋点函数是 AS 的 startPausingLocked:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startPausingLocked</span>(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping) {</div><div class="line">        <span class="comment">// 检测下当前是不是有 AR 正处于 Pause 的处理中，有的话就打印一个错误信息</span></div><div class="line">        <span class="comment">// 因为一次只能有一个 AR 处于 Pause 的处理中</span></div><div class="line">        <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) {</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException();</div><div class="line">            Slog.e(TAG, <span class="string">"Trying to pause when pause is already pending for "</span></div><div class="line">                  + mPausingActivity, e);</div><div class="line">        }</div><div class="line">        <span class="comment">// 要 Pause 是当前 Resume 的 AR，所以说 Resume 和 Pause 是成对的</span></div><div class="line">        ActivityRecord prev = mResumedActivity;</div><div class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 如果当前 Resume 的 AR 是 null 的话，说明有点问题，</span></div><div class="line">            <span class="comment">// 调用 resumeTopActivityLocked 去让一个 AR 处于 Resume 状态</span></div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException();</div><div class="line">            Slog.e(TAG, <span class="string">"Trying to pause when nothing is resumed"</span>, e);</div><div class="line">            resumeTopActivityLocked(<span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">"Moving to PAUSING: "</span> + prev);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Start pausing: "</span> + prev);</div><div class="line">        <span class="comment">// 把 mResumedActivity 设置为 null，</span></div><div class="line">        <span class="comment">// 之前那个 Resume 的 AR 保存为 mPausingActivity，顺带更新下 AR 的状态</span></div><div class="line">        <span class="comment">// mResumedActivity 的话在前面 resumeTopActivityLocked 和 realStartActivityLocked 有设置，</span></div><div class="line">        <span class="comment">// 可以倒回去看一下，所以说只有保证 activity 的 Resume 在 Pause 前面才真正常运作</span></div><div class="line">        mResumedActivity = <span class="keyword">null</span>;</div><div class="line">        mPausingActivity = prev;</div><div class="line">        mLastPausedActivity = prev;</div><div class="line">        prev.state = ActivityState.PAUSING;</div><div class="line">        prev.task.touchActiveTime();</div><div class="line">        prev.updateThumbnail(screenshotActivities(prev), <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        mService.updateCpuStats();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (prev.app != <span class="keyword">null</span> && prev.app.thread != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Enqueueing pending pause: "</span> + prev);</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</div><div class="line">                        prev.userId, System.identityHashCode(prev),</div><div class="line">                        prev.shortComponentName);</div><div class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</div><div class="line">                        userLeaving, prev.configChangeFlags);</div><div class="line">                <span class="keyword">if</span> (mMainStack) {</div><div class="line">                    <span class="comment">// 调用 AMS 的 updateUsageStats 接口，传递 Pause 的 AR，第二参数 resumed 为 false</span></div><div class="line">                    <span class="comment">// resumed 为 false 的话会调用 USS 的 notePauseComponent 接口，这里不贴代码了</span></div><div class="line">                    mService.updateUsageStats(prev, <span class="keyword">false</span>);</div><div class="line">                }</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// Ignore exception, if process died other code will cleanup.</span></div><div class="line">                Slog.w(TAG, <span class="string">"Exception thrown during pause"</span>, e);</div><div class="line">                mPausingActivity = <span class="keyword">null</span>;</div><div class="line">                mLastPausedActivity = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mPausingActivity = <span class="keyword">null</span>;</div><div class="line">            mLastPausedActivity = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后调用 AS 埋点函数的大致分为3个分支。每个分支也是 AMS 里面有很多有种情况会调用，照样省略：</p>
<ul>
<li><strong>branch1:</strong></li>
</ul>
<p>分支1 AMS 里面会有很多种情况调用 AS 的 finishActivityLocked，最常见的就是按 back 键或是调用 finishActivity 结束 activity，那按生命周期首先得进入 Pause 状态处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @return Returns true if this activity has been removed from the history</span></div><div class="line"><span class="comment">     * list, or false if it is still in the list and will be removed later.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> finishActivityLocked(ActivityRecord r, <span class="keyword">int</span> index,</div><div class="line">            <span class="keyword">int</span> resultCode, Intent resultData, String reason, <span class="keyword">boolean</span> oomAdj) {</div><div class="line">        <span class="keyword">return</span> finishActivityLocked(r, index, resultCode, resultData, reason, <span class="keyword">false</span>, oomAdj);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @return Returns true if this activity has been removed from the history</span></div><div class="line"><span class="comment">     * list, or false if it is still in the list and will be removed later.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> finishActivityLocked(ActivityRecord r, <span class="keyword">int</span> index, <span class="keyword">int</span> resultCode,</div><div class="line">            Intent resultData, String reason, <span class="keyword">boolean</span> immediate, <span class="keyword">boolean</span> oomAdj) {</div><div class="line">        <span class="keyword">if</span> (r.finishing) {</div><div class="line">            Slog.w(TAG, <span class="string">"Duplicate finish request for "</span> + r);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (immediate) {</div><div class="line">            <span class="keyword">return</span> finishCurrentActivityLocked(r, index,</div><div class="line">                    FINISH_IMMEDIATELY, oomAdj) == <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == r) {</div><div class="line">            <span class="keyword">boolean</span> endTask = index &lt;= <span class="number">0</span>   </div><div class="line">                    || (mHistory.get(index-<span class="number">1</span>)).task != r.task;</div><div class="line">            <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG, </div><div class="line">                    <span class="string">"Prepare close transition: finishing "</span> + r);</div><div class="line">            mService.mWindowManager.prepareAppTransition(endTask</div><div class="line">                    ? WindowManagerPolicy.TRANSIT_TASK_CLOSE</div><div class="line">                    : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE, <span class="keyword">false</span>);</div><div class="line">       </div><div class="line">            <span class="comment">// Tell window manager to prepare for this one to be removed.</span></div><div class="line">            mService.mWindowManager.setAppVisibility(r.appToken, <span class="keyword">false</span>);</div><div class="line">            </div><div class="line">            <span class="comment">// 如果没有 AR 正在处于 Pause 状态，调用 startPausingLocked 开始 Pause 状态处理 </span></div><div class="line">            <span class="keyword">if</span> (mPausingActivity == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Finish needs to pause: "</span> + r);</div><div class="line">                <span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG, <span class="string">"finish() =&gt; pause with userLeaving=false"</span>);</div><div class="line">                startPausingLocked(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (r.state != ActivityState.PAUSING) {</div><div class="line">            <span class="comment">// If the activity is PAUSING, we will complete the finish once</span></div><div class="line">            <span class="comment">// it is done pausing; else we can just directly finish it here.</span></div><div class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Finish not pausing: "</span> + r);</div><div class="line">            <span class="keyword">return</span> finishCurrentActivityLocked(r, index,</div><div class="line">                    FINISH_AFTER_PAUSE, oomAdj) == <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Finish waiting for pause of: "</span> + r);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li><strong>branch2:</strong></li>
</ul>
<p>分支2的话是前面说过的很多种情况会调用的 AS 的 resumeTopActivityLocked，例如启动一个新的 activity（前面说了会调用 resumeTopActivityLocked 的），就会先让当前处于前台的 activity 进入 Pause 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> resumeTopActivityLocked(ActivityRecord prev, Bundle options) {</div><div class="line">        <span class="comment">// Find the first activity that is not finishing.</span></div><div class="line">        ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 如果当前有正处于 Resume 的 AR，调用 startPausingLocked 把当前 Resume 的 AR</span></div><div class="line">        <span class="comment">// 变成 Pause 状态</span></div><div class="line">        <span class="comment">// We need to start pausing the current activity so the top one</span></div><div class="line">        <span class="comment">// can be resumed...</span></div><div class="line">        <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG, <span class="string">"Skip resume: need to start pausing"</span>);</div><div class="line">            <span class="comment">// At this point we want to put the upcoming activity's process</span></div><div class="line">            <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></div><div class="line">            <span class="comment">// very soon and it would be a waste to let it get killed if it</span></div><div class="line">            <span class="comment">// happens to be sitting towards the end.</span></div><div class="line">            <span class="keyword">if</span> (next.app != <span class="keyword">null</span> && next.app.thread != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// No reason to do full oom adj update here; we'll let that</span></div><div class="line">                <span class="comment">// happen whenever it needs to later.</span></div><div class="line">                mService.updateLruProcessLocked(next.app, <span class="keyword">false</span>);</div><div class="line">            }               </div><div class="line">            startPausingLocked(userLeaving, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<ul>
<li><strong>branch3:</strong></li>
</ul>
<p>分支3是很多种情况会调用的 AS 的 checkReadyForSleepLocked，好像是用处理休眠的。例如说放一段时间，设备会进入休眠状态，当然得把前台正在运行的 activity 变成 Pause 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">void</span> checkReadyForSleepLocked() {</div><div class="line">        <span class="keyword">if</span> (!mService.isSleeping()) {</div><div class="line">            <span class="comment">// Do not care.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!mSleepTimeout) {</div><div class="line">            <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// Still have something resumed; can't sleep until it is paused.</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Sleep needs to pause "</span> + mResumedActivity);</div><div class="line">                <span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG, <span class="string">"Sleep =&gt; pause with userLeaving=false"</span>);</div><div class="line">                <span class="comment">// 休眠没超时的会把当前处于前台的 activity 变成 Pause 状态</span></div><div class="line">                startPausingLocked(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// Still waiting for something to pause; can't sleep yet.</span></div><div class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG, <span class="string">"Sleep still waiting to pause "</span> + mPausingActivity);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">        mHandler.removeMessages(SLEEP_TIMEOUT_MSG);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mGoingToSleep.isHeld()) {</div><div class="line">            mGoingToSleep.release();</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (mService.mShuttingDown) {</div><div class="line">            mService.notifyAll();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<h4 id="addLaunchTime">addLaunchTime</h4>
<p>最后是记录启动时长的接口，也先上图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/addLaunchTime.png" alt=""></p>
<p>启动所需时长的埋点函数是 AR 中的 windowsDraw：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// stack(AS), service(AMS), realActivity(ComponentName) 都在 AS 的 startActivityLocked 的时候</span></div><div class="line"><span class="comment">// new AR 传过去的，代码前面有，可以倒回去看一下</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowsDrawn</span>() {</div><div class="line">    <span class="keyword">synchronized</span>(service) {</div><div class="line">        <span class="keyword">if</span> (launchTime != <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 取当前的时间</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> curTime = SystemClock.uptimeMillis();</div><div class="line">            <span class="comment">// 拿当前时间减启动时候的时间</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> thisTime = curTime - launchTime;</div><div class="line">            <span class="comment">// 看下 AS 的 mInitialStartTime 是不是 0，如果不是的话拿 AS 的 mInitialStartTime 来计算，</span></div><div class="line">            <span class="comment">// 如果 mInitialStartTime 是 0，那么当 launchTime 来计算</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> totalTime = stack.mInitialStartTime != <span class="number">0</span></div><div class="line">                    ? (curTime - stack.mInitialStartTime) : thisTime;</div><div class="line">            <span class="keyword">if</span> (ActivityManagerService.SHOW_ACTIVITY_START_TIME) {</div><div class="line">                EventLog.writeEvent(EventLogTags.AM_ACTIVITY_LAUNCH_TIME,</div><div class="line">                        userId, System.identityHashCode(<span class="keyword">this</span>), shortComponentName,</div><div class="line">                        thisTime, totalTime);</div><div class="line">                StringBuilder sb = service.mStringBuilder;</div><div class="line">                sb.setLength(<span class="number">0</span>);</div><div class="line">                sb.append(<span class="string">"Displayed "</span>);</div><div class="line">                sb.append(shortComponentName);</div><div class="line">                sb.append(<span class="string">": "</span>);</div><div class="line">                TimeUtils.formatDuration(thisTime, sb);</div><div class="line">                <span class="keyword">if</span> (thisTime != totalTime) {</div><div class="line">                    sb.append(<span class="string">" (total "</span>);</div><div class="line">                    TimeUtils.formatDuration(totalTime, sb);</div><div class="line">                    sb.append(<span class="string">")"</span>);</div><div class="line">                }   </div><div class="line">                Log.i(ActivityManagerService.TAG, sb.toString());</div><div class="line">            }   </div><div class="line">            stack.reportActivityLaunchedLocked(<span class="keyword">false</span>, <span class="keyword">this</span>, thisTime, totalTime);</div><div class="line">            <span class="comment">// 通过前面计算得到的时间，传给 USS 保存</span></div><div class="line">            <span class="keyword">if</span> (totalTime &gt; <span class="number">0</span>) {</div><div class="line">                service.mUsageStatsService.noteLaunchTime(realActivity, (<span class="keyword">int</span>)totalTime);</div><div class="line">            }   </div><div class="line">            launchTime = <span class="number">0</span>;</div><div class="line">            stack.mInitialStartTime = <span class="number">0</span>;</div><div class="line">        }   </div><div class="line">        startTime = <span class="number">0</span>;</div><div class="line">        finishLaunchTickingLocked();</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里 AR 的 launchTime 和对应的 AS（mMainStack） 的 mInitialStartTime 是在 AS 的 startSpecificActivityLocked 中设置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span>(ActivityRecord r,</div><div class="line">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig) {</div><div class="line">        <span class="comment">// Is this activity's application already running?</span></div><div class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</div><div class="line">                r.info.applicationInfo.uid);</div><div class="line">        </div><div class="line">        <span class="comment">// 如果要启动的 activity 对应的 AR 的 launchTime 为 0，取当前时间</span></div><div class="line">        <span class="keyword">if</span> (r.launchTime == <span class="number">0</span>) {     </div><div class="line">            r.launchTime = SystemClock.uptimeMillis();</div><div class="line">            <span class="keyword">if</span> (mInitialStartTime == <span class="number">0</span>) {</div><div class="line">                mInitialStartTime = r.launchTime;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mInitialStartTime == <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 或者如果 mInitialStartTime 为 0，也取当前时间</span></div><div class="line">            mInitialStartTime = SystemClock.uptimeMillis();</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们来看下在哪里调用了 startSpecificActivityLocked 这个函数。从 AMS 的 startActivity 开始，如果是第一次启动 activity，AS 中的 startActivityLocked 会创建新的 AR，然后转几下（什么 startActivityUncheckedLocked 什么之类的，中间很麻烦的，以后分析 AMS 的时候再具体说），最后到 resumeTopActivityLocked，由于这个时候 AR 的 app 信息是 null （第一次，进程还没跑）的就会调用到 startSpecificActivityLocked，然后由于 app 信息为 null，最后再调用到 AMS 的 startProcessLocked 去让 Zygote 去 fork 进程，然后就是前面 noteResumeComponent 的分支1流程了。如果不是第一次启动，然后进程信息还在（也就是 noteResumeComponent 的分支2），那么也会跑 startSpecificActivityLocked 的。</p>
<p>所以不管时候需要启动进程，startActivity 都要跑 startSpecificActivityLocked 这个函数，然后开始启动 activity 的计时（从这里可以看得出如果需要启动进程的话，计时肯定会很长的）。</p>
<p>弄清楚了从那开始计算时间，那么我看看在那结束计时的。从上面图来看，是在 WMS 中结束统计时长的，WMS 每一个 window 都有一个 AppWindowToken（AWT） 的结构，这个结构里面有一个 updateReportedVisibilityLocked 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> updateReportedVisibilityLocked() {</div><div class="line">    <span class="keyword">if</span> (appToken == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span>; </div><div class="line">    }       </div><div class="line"></div><div class="line">    <span class="keyword">int</span> numInteresting = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> numVisible = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> numDrawn = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> nowGone = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) Slog.v(WindowManagerService.TAG,</div><div class="line">            <span class="string">"Update reported visibility: "</span> + <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = allAppWindows.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">        WindowState win = allAppWindows.get(i);</div><div class="line">        <span class="keyword">if</span> (win == startingWindow || win.mAppFreezing</div><div class="line">                || win.mViewVisibility != View.VISIBLE</div><div class="line">                || win.mAttrs.type == TYPE_APPLICATION_STARTING</div><div class="line">                || win.mDestroying) {</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) {</div><div class="line">            Slog.v(WindowManagerService.TAG, <span class="string">"Win "</span> + win + <span class="string">": isDrawn="</span></div><div class="line">                    + win.isDrawnLw()</div><div class="line">                    + <span class="string">", isAnimating="</span> + win.mWinAnimator.isAnimating());</div><div class="line">            <span class="keyword">if</span> (!win.isDrawnLw()) {</div><div class="line">                Slog.v(WindowManagerService.TAG, <span class="string">"Not displayed: s="</span> + win.mWinAnimator.mSurface</div><div class="line">                        + <span class="string">" pv="</span> + win.mPolicyVisibility</div><div class="line">                        + <span class="string">" mDrawState="</span> + win.mWinAnimator.mDrawState</div><div class="line">                        + <span class="string">" ah="</span> + win.mAttachedHidden</div><div class="line">                        + <span class="string">" th="</span></div><div class="line">                        + (win.mAppToken != <span class="keyword">null</span></div><div class="line">                                ? win.mAppToken.hiddenRequested : <span class="keyword">false</span>)</div><div class="line">                        + <span class="string">" a="</span> + win.mWinAnimator.mAnimating);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        numInteresting++;</div><div class="line">        <span class="keyword">if</span> (win.isDrawnLw()) {</div><div class="line">            numDrawn++;</div><div class="line">            <span class="keyword">if</span> (!win.mWinAnimator.isAnimating()) {</div><div class="line">                numVisible++;</div><div class="line">            }</div><div class="line">            nowGone = <span class="keyword">false</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (win.mWinAnimator.isAnimating()) {</div><div class="line">            nowGone = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> nowDrawn = numInteresting &gt; <span class="number">0</span> && numDrawn &gt;= numInteresting;</div><div class="line">    <span class="keyword">boolean</span> nowVisible = numInteresting &gt; <span class="number">0</span> && numVisible &gt;= numInteresting;</div><div class="line">    <span class="keyword">if</span> (!nowGone) {</div><div class="line">        <span class="comment">// If the app is not yet gone, then it can only become visible/drawn.</span></div><div class="line">        <span class="keyword">if</span> (!nowDrawn) {</div><div class="line">            nowDrawn = reportedDrawn;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (!nowVisible) {</div><div class="line">            nowVisible = reportedVisible;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) Slog.v(WindowManagerService.TAG, <span class="string">"VIS "</span> + <span class="keyword">this</span> + <span class="string">": interesting="</span></div><div class="line">            + numInteresting + <span class="string">" visible="</span> + numVisible);</div><div class="line">    <span class="comment">// 前面那一堆 nowDrawn, reportedDrawn 有空再理会它们，</span></div><div class="line">    <span class="comment">// 反正这个 REPORT_APPLICATION_TOKEN_DRAWN 肯定能发出去的</span></div><div class="line">    <span class="keyword">if</span> (nowDrawn != reportedDrawn) {</div><div class="line">        <span class="keyword">if</span> (nowDrawn) {</div><div class="line">            Message m = service.mH.obtainMessage(</div><div class="line">                    H.REPORT_APPLICATION_TOKEN_DRAWN, <span class="keyword">this</span>);</div><div class="line">            service.mH.sendMessage(m);</div><div class="line">        }</div><div class="line">        reportedDrawn = nowDrawn;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (nowVisible != reportedVisible) {</div><div class="line">        <span class="keyword">if</span> (WindowManagerService.DEBUG_VISIBILITY) Slog.v(</div><div class="line">                WindowManagerService.TAG, <span class="string">"Visibility changed in "</span> + <span class="keyword">this</span></div><div class="line">                + <span class="string">": vis="</span> + nowVisible);</div><div class="line">        reportedVisible = nowVisible;</div><div class="line">        Message m = service.mH.obtainMessage(</div><div class="line">                H.REPORT_APPLICATION_TOKEN_WINDOWS,</div><div class="line">                nowVisible ? <span class="number">1</span> : <span class="number">0</span>,</div><div class="line">                nowGone ? <span class="number">1</span> : <span class="number">0</span>,</div><div class="line">                <span class="keyword">this</span>);</div><div class="line">        service.mH.sendMessage(m);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后是 WMS 里面的 Handler 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> REPORT_APPLICATION_TOKEN_DRAWN: {</div><div class="line">    <span class="keyword">final</span> AppWindowToken wtoken = (AppWindowToken)msg.obj;</div><div class="line">               </div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (DEBUG_VISIBILITY) Slog.v(</div><div class="line">                TAG, <span class="string">"Reporting drawn in "</span> + wtoken);</div><div class="line">        <span class="comment">// 这个 appToken 是 AR 那里实现的一个 Binder 对象</span></div><div class="line">        wtoken.appToken.windowsDrawn();</div><div class="line">    } <span class="keyword">catch</span> (RemoteException ex) { </div><div class="line">    } </div><div class="line">} <span class="keyword">break</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>懒得说 Binder 那些东西了，忘了的自觉去 Binder 篇相关的东西，直接上 AR 中相关的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> class Token extends IApplicationToken.Stub {</div><div class="line">        <span class="keyword">final</span> WeakReference&lt;ActivityRecord&gt; weakActivity;</div><div class="line"></div><div class="line">        Token(ActivityRecord activity) {</div><div class="line">            weakActivity = <span class="keyword">new</span> WeakReference&lt;ActivityRecord&gt;(activity);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowsDrawn</span>() <span class="keyword">throws</span> RemoteException {</div><div class="line">            <span class="comment">// 最后还是调用 AR 中的 windowsDrawn 了</span></div><div class="line">            ActivityRecord activity = weakActivity.get(); </div><div class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {        </div><div class="line">                activity.windowsDrawn();       </div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面 AWP 的 updateReportedVisibilityLocked 在 WMS 中也是有很多地方会调用的，例如 relayoutWindow、开始窗口变化动画等等地方。从这里可以看得出，USS 中统计 activity 启动需要的时间，是从发起 startActivity 请求（startSpecificActivityLocked）开始，直到对应 activity 的窗口开始绘制（窗口可见）这段时间。</p>
<h4 id="AMS_小分析">AMS 小分析</h4>
<p>这里算是把3个接口的埋点分析完了。本来说 AMS 和 WMS 太复杂了，留给以后再慢慢来看，但是没忍住还是稍微把 startActivity 的一般流程分析了一下，来一张图：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/startActivity.png" alt=""></p>
<p>这里就不上代码解说了，这篇已经够长了，看看图差不多大概明白流程是怎么回事了。图中我画了比较常见的3种情况（所有情况没画全，太多分支了）：</p>
<ul>
<li><p><strong>branch1:</strong><br>要 launch 的 activity 进程不存在。其中 mResumedActivity 代表之前有没有处于 Resume 状态的 activity，有的话要先那个变成 Pause 状态（一般都有，没有的情况就是刚开机 launch 桌面的时候，排除第一次开机那个 Provision，桌面是第一 launch 的 activity）。这种情况需要先让 Zygote fork 出对应的进程，然后等待进程启动后，调用 AMS 的 attachApplication 接口继续跑后面的流程（前面的 Service、Broadcast 都有类似的过程了）。</p>
</li>
<li><p><strong>branch2:</strong><br>要 launch 的 activity 进程已经存在，但是不存在对应的 TaskRecord(ActivityRecord)，launch 了 activity 在 AMS 中对应就有保存有 ActivityRecord（AR），但是如果调用 finishActivity（onDestroy）会销毁 ActivityRecord，典型的情况按 back 键返回。这种情况和 branch1 AMS attchApplication 接口后面的流程是一样的，就是不需要等待 Zygote fork 进程而已。</p>
</li>
<li><p><strong>branch3:</strong><br>要 launch 的 activity 进程已经，并且存在对应的 TaskRecord(ActivityRecord)，最典型的情况就是按 home 键回桌面。这种情况先把对应的 Task 移动到前台，然后让 activity 走下 Resume 流程就行了。</p>
</li>
</ul>
<p>上面我把我们开发应用熟悉的 activity 的那几个生命周期回调用红色标了出来，上面的埋点函数用紫色的标了一下，大家可以对比前面的解说再好好看看。最后上一个官方 sdk doc 上的 activity 的生命周期图，对 android activity 生命周期实现、管理有更加深入的理解：</p>
<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/activity_lifecycle.png" alt=""></p>
<p>然后再附上一段官方的说明：</p>
<ul>
<li><p><font color="#ff0000">The entire lifetime</font> of an activity happens between the first call to <strong>onCreate(Bundle)</strong> through to a single final call to onDestroy(). An activity will do all setup of “global” state in onCreate(), and release all remaining resources in <strong>onDestroy()</strong>. For example, if it has a thread running in the background to download data from the network, it may create that thread in onCreate() and then stop the thread in onDestroy().</p>
</li>
<li><p><font color="#ff0000">The visible lifetime</font> of an activity happens between a call to <strong>onStart()</strong> until a corresponding call to <strong>onStop()</strong>. During this time the user can see the activity on-screen, though it may not be in the foreground and interacting with the user. Between these two methods you can maintain resources that are needed to show the activity to the user. For example, you can register a BroadcastReceiver in onStart() to monitor for changes that impact your UI, and unregister it in onStop() when the user no longer sees what you are displaying. The onStart() and onStop() methods can be called multiple times, as the activity becomes visible and hidden to the user.</p>
</li>
<li><p><font color="#ff0000">The foreground lifetime</font> of an activity happens between a call to <strong>onResume()</strong> until a corresponding call to <strong>onPause()</strong>. During this time the activity is in front of all other activities and interacting with the user. An activity can frequently go between the resumed and paused states — for example when the device goes to sleep, when an activity result is delivered, when a new intent is delivered — so the code in these methods should be fairly lightweight. </p>
</li>
</ul>
<p>从 onCreate 到 onDestroy 算是 activity 的存在时间，从 onStart 到 onStop 算是 activity 处于可见的时间，从 onResume 到 onPause 算是 activity 的处于前台的时间。这里比较迷惑的是可见时间和处于前台的时候。这里稍微说明下，所谓处于前台是处于当前 activity 堆栈（AS）的最顶部，能够接收输入焦点，例如说正在交互的 activity。那所谓的可见时间呢，其实有些时候就算 activity 不在 AS 的最顶部，也是可见的，最典型的情况上当前正在交互的 activity 是个半透明的，所以它下面那个 activity 是可见的，但是不处于前台（处于 onPause 状态，但是没还到 onStop 状态）。所以上面的图，可见时间比前台时间要长就是这个原因。从这个来看 USS 统计的启动时长，感觉像是从 onCreate 到 onStart 那段时间。我本来还以为 onStart 要涉及 WMS，等待窗口开始绘制才会调用的，但是好像并不是我想的那样，就是在 onCreate 后几句就调用 onRestart，不过在 onStop 后还是有区别的，在 activity 的存在周期，onCreate 只会调用一次，但是 onStart 可能会有多次。</p>
<p>还有上面 onStop 这个回调的时间很有意思，官方的解说是： activity no longer visible。怎么才算 no longer visible ？？ 看上面的流程图会发现，当 activity 开始 Pasuing 流程的时候，AR 会保存到一个叫 mStopActivites 的列表中（进行 Resume 的时候会从里面删掉自己）。然后当一个 activity 的主线程（UI 线程）的 Handler 的消息队列（MessageQueue）为空的时候会激发一个 IdlerHandler 的回调（每个程序的 ActivityThread 会设置这个回调），它会向 AMS 报告 activity idle 消息，在 idle 消息处理中会查看 mStopActivites 中哪里 AR 可以进入 Stop 状态（进入之后会从 mStopActivites 中删除，AMS 的 idle 处理还有别的工作要做，这里只说 stop 处理）。其实激发 AMS activity idle 的地方还有别的地方，但是 Handler idle 是一个比较典型的地方。我说之前看到 Handler 的 MessageQueue 那有个啥 idle handler 的处理，不知道干什么，现在知道了。</p>
<p>所以这里可以知道一个比较好玩的东西，就是 android 认为 UI 线程的消息队列为空，就代表这个 activity 空闲了。其实这个设定也是合理的因为上层的应用交互都是基于消息队列驱动的。然后也明白了 no longer 是要等 activity 的 UI 线程的消息队列为空。以后有空把 Handler、Looper、MessageQueue 也好好整理分析下。</p>
<h3 id="保存数据">保存数据</h3>
<p>上面扯了一下 AMS 相关的流程（因为 USS 埋点要在 AMS 里面埋），现在回来把数据保存说一下。前面在说数据结构那，把 USS 保存过的数据 dump 出来了，然后它的结构就是一个 Map，以 pkg 为 key，一个 pkg 一条。然后每条里面有一个 TimeStats 的东西，又包含了一个 HashMap 以 ComponentName 为 key，一个 component 一条，所以从逻辑上来说内存结构应该是这样的（前面 dump 出来的数据也很直观了）：</p>
<p>pkg1:<br>  component1: xx xx xx xx<br>  component2: xx xx xx xx<br>  component3: xx xx xx xx<br>pkg2:<br>  component1: xx xx xx xx<br>pkg3:<br>  component1: xx xx xx xx<br>  component2: xx xx xx xx<br>… …</p>
<p>这里的保存，就是要把内存中的这些数据写到文件中。看到这个，在 android 中你就要想到 Parcel 要出场了。其实前面说数据结构的时候，就看到 PkgUsageStatsExtended 和 TimeStats 都有对应的 Parcelable 的函数（倒回去看一下）。先把这些说清楚，后面看起保存数据的代码就简单了。在上面埋点统计那，notePauseComponent 和 noteLaunchTime 会调用有一个函数 writeStatsToFile（代码不算太长，一次性贴完了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ======================== UsageStatsService.java =========================</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_PREFIX = <span class="string">"usage-"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FILE_WRITE_INTERVAL = <span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Calendar mCal; <span class="comment">// guarded by itself</span></div><div class="line"></div><div class="line">    <span class="comment">// java 的 Atomic 系列，能够保证访问、修改的原子性，也后可以也学学该怎么用这些东西</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mLastWriteDay = <span class="keyword">new</span> AtomicInteger(-<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong mLastWriteElapsedTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mUnforcedDiskWriteRunning = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 这个函数就是把 USS 统计数据写入文件保存的函数</span></div><div class="line">    <span class="comment">// 2个 boolean 参数，是否强制写入。虽然上面埋点那会调用这个函数，但是不是每次调用都会写文件，</span></div><div class="line">    <span class="comment">// USS 有一个保存策略的，代码看代码再具体说这个策略。当然可以传 true 无视这个策略。</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Conditionally start up a disk write if it's been awhile, or the</span></div><div class="line"><span class="comment">     * day has rolled over.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This is called indirectly from user-facing actions (when</span></div><div class="line"><span class="comment">     * 'force' is false) so it tries to be quick, without writing to</span></div><div class="line"><span class="comment">     * disk directly or acquiring heavy locks.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @params force  do an unconditional, synchronous stats flush</span></div><div class="line"><span class="comment">     *                to disk on the current thread.</span></div><div class="line"><span class="comment">     * @params forceWriteHistoryStats Force writing of historical stats.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeStatsToFile</span>(<span class="keyword">final</span> <span class="keyword">boolean</span> force, <span class="keyword">final</span> <span class="keyword">boolean</span> forceWriteHistoryStats) {</div><div class="line">        <span class="keyword">int</span> curDay;</div><div class="line">        <span class="comment">// 前面注释也有说用的时候要自己注意同步锁</span></div><div class="line">        <span class="keyword">synchronized</span> (mCal) {</div><div class="line">            mCal.setTimeInMillis(System.currentTimeMillis());</div><div class="line">            curDay = mCal.get(Calendar.DAY_OF_YEAR);</div><div class="line">        }    </div><div class="line">        <span class="comment">// 取当前的时候和最后一次保存的时间对比，看看是不是同一天</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> dayChanged = curDay != mLastWriteDay.get();</div><div class="line"></div><div class="line">        <span class="comment">// Determine if the day changed...  note that this will be wrong</span></div><div class="line">        <span class="comment">// if the year has changed but we are in the same day of year...</span></div><div class="line">        <span class="comment">// we can probably live with this.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currElapsedTime = SystemClock.elapsedRealtime();</div><div class="line"></div><div class="line">        <span class="comment">// 如果没有强制保存的话，这里就会应用一个保存策略：</span></div><div class="line">        <span class="comment">// 一天保存一次（dayChanged），并且本次保存要和上一次保存的间隔超过 FILE_WRITE_INTERVAL（30分钟）</span></div><div class="line">        <span class="comment">// 不满足的话直接返回，满足的话开一个线程来写（线程里面调用自己是强制写的）。</span></div><div class="line">        <span class="comment">// 不过我太不喜欢 java 这样随手匿名 new 一个线程就 run。</span></div><div class="line">        <span class="comment">// Fast common path, without taking the often-contentious</span></div><div class="line">        <span class="comment">// mFileLock.</span></div><div class="line">        <span class="keyword">if</span> (!force) {</div><div class="line">            <span class="keyword">if</span> (!dayChanged &&</div><div class="line">                (currElapsedTime - mLastWriteElapsedTime.get()) &lt; FILE_WRITE_INTERVAL) {</div><div class="line">                <span class="comment">// wait till the next update</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mUnforcedDiskWriteRunning.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</div><div class="line">                <span class="keyword">new</span> Thread(<span class="string">"UsageStatsService_DiskWriter"</span>) {</div><div class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="keyword">if</span> (localLOGV) Slog.d(TAG, <span class="string">"Disk writer thread starting."</span>);</div><div class="line">                            writeStatsToFile(<span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">                        } <span class="keyword">finally</span> {</div><div class="line">                            mUnforcedDiskWriteRunning.set(<span class="keyword">false</span>);</div><div class="line">                            <span class="keyword">if</span> (localLOGV) Slog.d(TAG, <span class="string">"Disk writer thread ending."</span>);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }.start();</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 满足上面的策略判断后就开始写文件。</span></div><div class="line">        <span class="comment">// 这里用的锁是专门用来锁读、写文件的，前面访问数据的用的是另外一个。</span></div><div class="line">        <span class="comment">// 访问内存数据和读写文件分开锁，能提供并发能力</span></div><div class="line">        <span class="keyword">synchronized</span> (mFileLock) {</div><div class="line">            <span class="comment">// 这里是获取最近保存一次的文件名，其实就是： FILE_PREFIX+当前的日期，</span></div><div class="line">            <span class="comment">// 类似这样的： usage-2015-03-06，具体代码不贴了</span></div><div class="line">            <span class="comment">// Get the most recent file</span></div><div class="line">            mFileLeaf = getCurrentDateStr(FILE_PREFIX);</div><div class="line">            <span class="comment">// Copy current file to back up</span></div><div class="line">            File backupFile = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 如果上一次保存过的文件在，那么先把上次的文件重命名为 xx.bak</span></div><div class="line">            <span class="comment">// 后面如果写文件失败，会再把原文件改个名字还远回去，这种做法值得学习</span></div><div class="line">            <span class="keyword">if</span> (mFile != <span class="keyword">null</span> && mFile.exists()) {</div><div class="line">                backupFile = <span class="keyword">new</span> File(mFile.getPath() + <span class="string">".bak"</span>);</div><div class="line">                <span class="keyword">if</span> (!backupFile.exists()) {</div><div class="line">                    <span class="keyword">if</span> (!mFile.renameTo(backupFile)) {</div><div class="line">                        Slog.w(TAG, <span class="string">"Failed to persist new stats"</span>);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    mFile.delete();</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 具体写的内容在下面这个函数中</span></div><div class="line">                <span class="comment">// Write mStats to file</span></div><div class="line">                writeStatsFLOCK(mFile);</div><div class="line">                <span class="comment">// 保存最后一次写文件的时间</span></div><div class="line">                mLastWriteElapsedTime.set(currElapsedTime);</div><div class="line">                <span class="comment">// 如果日期变更的话，成功把当前数据写入文件后，会清除当前的数据</span></div><div class="line">                <span class="comment">// 也就是说文件中保存的数据就是一天的统计情况（怪不得以一天的日期来命名）</span></div><div class="line">                <span class="keyword">if</span> (dayChanged) {</div><div class="line">                    mLastWriteDay.set(curDay);</div><div class="line">                    <span class="comment">// clear stats</span></div><div class="line">                    <span class="keyword">synchronized</span> (mStats) {</div><div class="line">                        mStats.clear();</div><div class="line">                    }</div><div class="line">                    <span class="comment">// 这个 mDir USS 初始化的时候 AMS 传递进来过的，</span></div><div class="line">                    <span class="comment">// 保存数据的路径是： /data/system/usagestats</span></div><div class="line">                    mFile = <span class="keyword">new</span> File(mDir, mFileLeaf);</div><div class="line">                    <span class="comment">// 检测下保存的文件数量（默认的 USS 只保存最近5天的文件）</span></div><div class="line">                    checkFileLimitFLOCK();</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 那个历史记录的这里不管先</span></div><div class="line">                <span class="keyword">if</span> (dayChanged || forceWriteHistoryStats) {</div><div class="line">                    <span class="comment">// Write history stats daily, or when forced (due to shutdown).</span></div><div class="line">                    writeHistoryStatsFLOCK(mHistoryFile);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 文件成功写入后，把之前的 .bak 文件删掉</span></div><div class="line">                <span class="comment">// Delete the backup file</span></div><div class="line">                <span class="keyword">if</span> (backupFile != <span class="keyword">null</span>) {</div><div class="line">                    backupFile.delete();</div><div class="line">                }</div><div class="line">            } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                Slog.w(TAG, <span class="string">"Failed writing stats to file:"</span> + mFile);</div><div class="line">                <span class="comment">// 如果写入文件失败，把 .bak 改个名字还远回去</span></div><div class="line">                <span class="keyword">if</span> (backupFile != <span class="keyword">null</span>) {</div><div class="line">                    mFile.delete();</div><div class="line">                    backupFile.renameTo(mFile);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.d(TAG, <span class="string">"Dumped usage stats."</span>);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeStatsFLOCK</span>(File file) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="comment">// 这里的流程是这样的，可以学习在 android 上怎么比较好的保存文件：</span></div><div class="line">        <span class="comment">// 1. 从一个存储介质路径创建一个 File 对象</span></div><div class="line">        <span class="comment">// 2. 从 File 文件中创建 java 输出流对象（FOS）</span></div><div class="line">        <span class="comment">// 3. new 一个 Parcel（下面的 Parcel.obtain 会有缓存效果）</span></div><div class="line">        <span class="comment">// 4. 拿 Parcel 给实现了 Parcelable 接口的对象打包数据到 Parcel 内存中</span></div><div class="line">        <span class="comment">// 5. 调用 Parcel 的 marshall 获取之前打包的内存字节流</span></div><div class="line">        <span class="comment">// 6. 把获取的内存字节流写入 FOS 中(flush FOS)</span></div><div class="line">        <span class="comment">// 7. 最后调用下 FOS 的文件描述 sync，然 FOS 的内存数据同步到存储介质（文件）上去</span></div><div class="line">        <span class="comment">// 8. 释放数据：回收 Parcel 数据，关闭输出流</span></div><div class="line">        FileOutputStream stream = <span class="keyword">new</span> FileOutputStream(file);                                  </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Parcel out = Parcel.obtain();  </div><div class="line">            writeStatsToParcelFLOCK(out);  </div><div class="line">            stream.write(out.marshall());</div><div class="line">            <span class="comment">// 用完了 Parcel 回收一下数据  </span></div><div class="line">            out.recycle();</div><div class="line">            stream.flush();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            FileUtils.sync(stream); </div><div class="line">            <span class="comment">// 关闭文件流       </span></div><div class="line">            stream.close();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeStatsToParcelFLOCK</span>(Parcel out) {</div><div class="line">        <span class="comment">// 这里要访问数据了，加数据同步锁</span></div><div class="line">        <span class="keyword">synchronized</span> (mStatsLock) {  </div><div class="line">            <span class="comment">// 先写入版本号（检测数据有效性用的）      </span></div><div class="line">            out.writeInt(VERSION);         </div><div class="line">            Set&lt;String&gt; keys = mStats.keySet();</div><div class="line">            <span class="comment">// 再写入有几条 PkgUsageStatsExtended 数据</span></div><div class="line">            out.writeInt(keys.size());</div><div class="line">            <span class="comment">// 后面就循环的把每一条 PkgUsageStatsExtended 写入</span></div><div class="line">            <span class="keyword">for</span> (String key : keys) {          </div><div class="line">                PkgUsageStatsExtended pus = mStats.get(key);</div><div class="line">                <span class="comment">// 先写 pkg name</span></div><div class="line">                out.writeString(key);</div><div class="line">                <span class="comment">// 然后调用 PkgUsageStatsExtended 的 Parcel 写入接口写数据</span></div><div class="line">                <span class="comment">// PkgUsageStatsExtended 的写入接口倒回去看数据结构那的代码</span></div><div class="line">                pus.writeToParcel(out);    </div><div class="line">            }                 </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ======================== FileUtils.java =========================</span></div><div class="line"></div><div class="line">    <span class="comment">// 这里就获取了下 FOS 的文件描述符，然后调用对应的文件描述符接口</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform an fsync on the given FileOutputStream.  The stream at this</span></div><div class="line"><span class="comment">     * point must be flushed but not yet closed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sync</span>(FileOutputStream stream) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (stream != <span class="keyword">null</span>) {          </div><div class="line">                stream.getFD().sync();         </div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {      </div><div class="line">        }                     </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面是从文件中读数据的接口： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readStatsFromFile</span>() {</div><div class="line">    File newFile = mFile;</div><div class="line">    <span class="comment">// 读写文件锁</span></div><div class="line">    <span class="keyword">synchronized</span> (mFileLock) {     </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (newFile.exists()) { </div><div class="line">                <span class="comment">// 真正的读数据在下面这个函数中       </span></div><div class="line">                readStatsFLOCK(newFile);       </div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 文件不存在就创建一个新的</span></div><div class="line">                <span class="comment">// Check for file limit before creating a new file</span></div><div class="line">                <span class="comment">// 检测下文件个数限制</span></div><div class="line">                checkFileLimitFLOCK();         </div><div class="line">                newFile.createNewFile();       </div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {      </div><div class="line">            Slog.w(TAG,<span class="string">"Error : "</span> + e + <span class="string">" reading data from file:"</span> + newFile);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">   </div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readStatsFLOCK</span>(File file) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="comment">// 从保存数据的文件中转载 Parcel 数据</span></div><div class="line">    Parcel in = getParcelForFile(file);</div><div class="line">    <span class="comment">// 先读版本号（顺序要和前面写的一致）</span></div><div class="line">    <span class="keyword">int</span> vers = in.readInt();       </div><div class="line">    <span class="comment">// 如果数据版本号和当前的不一样的，认为该数据无效</span></div><div class="line">    <span class="keyword">if</span> (vers != VERSION) {</div><div class="line">        Slog.w(TAG, <span class="string">"Usage stats version changed; dropping"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 读取 PkgUsageStatsExtended 的数量 </span></div><div class="line">    <span class="keyword">int</span> N = in.readInt();</div><div class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) {</div><div class="line">        N--;</div><div class="line">        <span class="comment">// 读每一条 PkgUsageStatsExtended 的 pkg name</span></div><div class="line">        String pkgName = in.readString();</div><div class="line">        <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Reading package #"</span> + N + <span class="string">": "</span> + pkgName);</div><div class="line">        <span class="comment">// 调用 PkgUsageStatsExtended 的 Parcelable 读接口填充数据</span></div><div class="line">        PkgUsageStatsExtended pus = <span class="keyword">new</span> PkgUsageStatsExtended(in);</div><div class="line">        <span class="keyword">synchronized</span> (mStatsLock) {</div><div class="line">            <span class="comment">// 将填充好的 PkgUsageStatsExtended 保存到 USS 数据列表中</span></div><div class="line">            mStats.put(pkgName, pus);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> Parcel <span class="title">getParcelForFile</span>(File file) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="comment">// 这里可以和上面写对应可以学习怎么从文件中利用 Parcel 读数据：</span></div><div class="line">    <span class="comment">// 1. 打开 File 对象</span></div><div class="line">    <span class="comment">// 2. 从 File 中创建 java 输入流对象（FIS）</span></div><div class="line">    <span class="comment">// 3. 从 FIS 中读出直接流到内存中（数据不多的可以一次性读完）</span></div><div class="line">    <span class="comment">// 4. new Parcel 对象（同样利用 Parcel.obtain 会有缓存效果）</span></div><div class="line">    <span class="comment">// 5. 把内存字节流传给 Parcel unmarshall 转载到 Parcel 中</span></div><div class="line">    <span class="comment">// 6. 关闭 FIS</span></div><div class="line">    <span class="comment">// 7. 把转载好数据的 Parcel 给 Parcelable 对象读数据</span></div><div class="line">    <span class="comment">// 8. 释放数据：关闭输入流，回收 Parcel 数据</span></div><div class="line">    <span class="comment">// 读这里好像没 recycle obtain 的 parcel，我觉得应该要 recycle 一下的，</span></div><div class="line">    <span class="comment">// 虽然说 recycle 会把 parcel 的内存释放掉，但是读的时候应该都 copy 到对象自己</span></div><div class="line">    <span class="comment">// 的数据里面来了吧，改天有空自己试一下这个东西</span></div><div class="line">    FileInputStream stream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">    <span class="keyword">byte</span>[] raw = readFully(stream);</div><div class="line">    Parcel in = Parcel.obtain();   </div><div class="line">    in.unmarshall(raw, <span class="number">0</span>, raw.length);</div><div class="line">    <span class="comment">// 注意下把数据指针移到初始位置</span></div><div class="line">    in.setDataPosition(<span class="number">0</span>);</div><div class="line">    stream.close();</div><div class="line">    <span class="keyword">return</span> in;</div><div class="line">}</div><div class="line">   </div><div class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] readFully(FileInputStream stream) <span class="keyword">throws</span> java.io.IOException {</div><div class="line">    <span class="comment">// java 的 I/O 操作，没啥好讲的，自己看看就行</span></div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> avail = stream.available();</div><div class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[avail]; </div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">        <span class="keyword">int</span> amt = stream.read(data, pos, data.length-pos);</div><div class="line">        <span class="keyword">if</span> (amt &lt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">return</span> data;</div><div class="line">        }</div><div class="line">        pos += amt;</div><div class="line">        avail = stream.available();    </div><div class="line">        <span class="keyword">if</span> (avail &gt; data.length-pos) { </div><div class="line">            <span class="keyword">byte</span>[] newData = <span class="keyword">new</span> <span class="keyword">byte</span>[pos+avail]; </div><div class="line">            System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, pos);</div><div class="line">            data = newData;                </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后我们看下文件数量的限制方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line">         </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM_FILES = <span class="number">5</span>;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getUsageStatsFileListFLOCK</span>() {</div><div class="line">        <span class="comment">// 首先列出 /data/system/usagestats 目录下的所有文件列表</span></div><div class="line">        <span class="comment">// Check if there are too many files in the system and delete older files</span></div><div class="line">        String fList[] = mDir.list();</div><div class="line">        <span class="keyword">if</span> (fList == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        ArrayList&lt;String&gt; fileList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String file : fList) {</div><div class="line">            <span class="comment">// 不是 usage- 开头的文件忽略</span></div><div class="line">            <span class="keyword">if</span> (!file.startsWith(FILE_PREFIX)) {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            } </div><div class="line">            <span class="comment">// 把一些遗留的备份文件删掉  </span></div><div class="line">            <span class="keyword">if</span> (file.endsWith(<span class="string">".bak"</span>)) {</div><div class="line">                (<span class="keyword">new</span> File(mDir, file)).delete();</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line">            <span class="comment">// 添加到文件列表</span></div><div class="line">            fileList.add(file); </div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> fileList;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkFileLimitFLOCK</span>() {</div><div class="line">        <span class="comment">// 收集 /data/system/usagestats 目录下的所有数据文件</span></div><div class="line">        <span class="comment">// Get all usage stats output files</span></div><div class="line">        ArrayList&lt;String&gt; fileList = getUsageStatsFileListFLOCK();</div><div class="line">        <span class="keyword">if</span> (fileList == <span class="keyword">null</span>) {        </div><div class="line">            <span class="comment">// Strange but we dont have to delete any thing</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">int</span> count = fileList.size(); </div><div class="line">        <span class="comment">// 没超过限制个数返回  </span></div><div class="line">        <span class="keyword">if</span> (count &lt;= MAX_NUM_FILES) {  </div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// 按照最近日期排个序列</span></div><div class="line">        <span class="comment">// Sort files</span></div><div class="line">        Collections.sort(fileList);    </div><div class="line">        count -= MAX_NUM_FILES;</div><div class="line">        <span class="comment">// 把超出限制范围的文件删掉        </span></div><div class="line">        <span class="comment">// Delete older files</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            String fileName = fileList.get(i);</div><div class="line">            File file = <span class="keyword">new</span> File(mDir, fileName);</div><div class="line">            Slog.i(TAG, <span class="string">"Deleting usage file : "</span> + fileName);</div><div class="line">            file.delete();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看完上面的了保存和读取接口，然后我们最后把 USS 调用到的地方看一下（这里不贴代码了，直接说那几个地方调用到了，用 grep 很容易找的）：</p>
<p>调用写（writeStatsToFile）的地方有：(调试的地方不算, true 代表强制写，false 使用保存策略)</p>
<ol>
<li>shutdown: true</li>
<li>notePauseComponent: false</li>
<li>noteLaunchTime: false</li>
</ol>
<p>调用读（readStatsFromFile）的地方有：</p>
<ol>
<li>UsageStatsService</li>
</ol>
<p>总结一下就能发现 USS 特性： 在收到 notePauseComponent 和 noteLaunchTime 的时候会激发保存动作，策略基本上是一天保存一次，一次保存为一个文件（以日期命名）。成功保存完之后，会把内存中的数据清零，所以一个文件中的数据差不多是一天统计的数据。但是上面在 USS 关闭（重启、关机 SystemServce 会调用各个 SS 的 shutdown 函数）的时候会强制写数据，然后在初始化的时候（构造函数）取当前日期的文件，如果有就去把这个文件中的数据转载到 mStats 中去（相当于读档）。这个操作能保证设备在还没用满一天的情况下重启、关机数据也能保存（正常的是要过了一天才会激发写文件操作的）。然后默认只会保留最近5天的数据，超过了就会删掉之前的。</p>
<p>搞清楚了 USS 的保存数据的方法和策略，我们最后来看实际数据的情况，加深一下理解。下面这张图就是 USS 一天的数据（拿 xxd 转化为 16进制，用 vi 打开），然后对应下 dump 的数据：</p>
<pre>
Date: 20150306
  com.android.systemui: 1 times, 30961918 ms
    com.android.systemui.usb.UsbStorageActivity: 1 starts, 250-500ms=1
  com.bbk.studyos.launcher: 2 times, 8282 ms
    com.bbk.studyos.launcher.activity.Launcher: 2 starts, 2000-3000ms=1
</pre>

<p><img src="http://7u2hy4.com1.z0.glb.clouddn.com/android/Worknote-usagestats/usage-data.png" alt=""></p>
<p>Binder 系列 Parcel 篇我们分析过 Parcel 就是一块内存自己来写，我们对着内存中的数据一个一个对照看一下。最开始写入的是版本号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Current on-disk Parcel version</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION = <span class="number">1007</span>;</div><div class="line"></div></pre></td></tr></table></figure>

<p>0x0000 03ef（注意一下，我手上机子的 cpu 是小端格式的）正好是 1007，writeInt 前面说过是 4byte 的（绿色部分）。然后接下来是 PkgUsageStatsExtended 的个数，0x0000 0002 是2个，看 dump 的输出，果然是2个，同样是 WriteInt 4byte（深蓝色部分）。接下来就是第一个 PkgUsageStatsExtended 的 pkg name，是用 writeString 写的（红色的部分）。这里我们补充下 Parcel 的一些知识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ======================== Parcel.java =========================</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Write a string value into the parcel at the current dataPosition(),</span></div><div class="line"><span class="comment">     * growing dataCapacity() if needed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeString</span>(String val) {</div><div class="line">        nativeWriteString(mNativePtr, val);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ======================== android_os_Parcel.cpp =========================</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Parcel_writeString(JNIEnv* env, jclass clazz, jint nativePtr, jstring val)</div><div class="line">{</div><div class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel != NULL) {</div><div class="line">        status_t err = NO_MEMORY;</div><div class="line">        <span class="keyword">if</span> (val) {</div><div class="line">            <span class="keyword">const</span> jchar* str = env-&gt;GetStringCritical(val, <span class="number">0</span>); </div><div class="line">            <span class="keyword">if</span> (str) {</div><div class="line">                err = parcel-&gt;writeString16(str, env-&gt;GetStringLength(val));</div><div class="line">                env-&gt;ReleaseStringCritical(val, str);</div><div class="line">            }   </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            err = parcel-&gt;writeString16(NULL, <span class="number">0</span>); </div><div class="line">        }   </div><div class="line">        <span class="keyword">if</span> (err != NO_ERROR) {</div><div class="line">            signalExceptionForError(env, clazz, err);</div><div class="line">        }   </div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ======================== Parcel.cpp ========================= </span></div><div class="line"></div><div class="line"><span class="comment">// 这里调用的是 writeString16 我之前分析的是 writeString8</span></div><div class="line">status_t Parcel::writeString16(<span class="keyword">const</span> char16_t* str, size_t len) </div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (str == NULL) <span class="keyword">return</span> writeInt32(-<span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 和之前的 writeString8 一样，第一个位置是写字符串的长度</span></div><div class="line">    status_t err = writeInt32(len);</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) {</div><div class="line">        <span class="comment">// 字符长度 x 一个字符所占的大小</span></div><div class="line">        <span class="comment">// char16_t 看下面的定义是 2byte</span></div><div class="line">        len *= sizeof(char16_t);</div><div class="line">        <span class="comment">// 注意看这里， len 还多加了一个字符的</span></div><div class="line">        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));</div><div class="line">        <span class="keyword">if</span> (data) {</div><div class="line">            memcpy(data, str, len);</div><div class="line">            <span class="comment">// 原来是拿来写 '/0' 结束符用的</span></div><div class="line">            *reinterpret_cast&lt;char16_t*&gt;(data+len) = <span class="number">0</span>; </div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line">        }</div><div class="line">        err = mError;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> err; </div><div class="line">}</div><div class="line"></div><div class="line">String16 Parcel::readString16() <span class="keyword">const</span></div><div class="line">{</div><div class="line">    size_t len;</div><div class="line">    <span class="keyword">const</span> char16_t* str = readString16Inplace(&len);</div><div class="line">    <span class="keyword">if</span> (str) <span class="keyword">return</span> String16(str, len);</div><div class="line">    ALOGE(<span class="string">"Reading a NULL string not supported here."</span>);</div><div class="line">    <span class="keyword">return</span> String16();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> char16_t* Parcel::readString16Inplace(size_t* outLen) <span class="keyword">const</span></div><div class="line">{</div><div class="line">    int32_t size = readInt32();</div><div class="line">    <span class="comment">// watch for potential int overflow from size+1</span></div><div class="line">    <span class="keyword">if</span> (size &gt;= <span class="number">0</span> && size &lt; INT32_MAX) {</div><div class="line">        *outLen = size;</div><div class="line">        <span class="comment">// 果然读的地方也要多加1个字符</span></div><div class="line">        <span class="keyword">const</span> char16_t* str = (<span class="keyword">const</span> char16_t*)readInplace((size+<span class="number">1</span>)*sizeof(char16_t));</div><div class="line">        <span class="keyword">if</span> (str != NULL) {</div><div class="line">            <span class="keyword">return</span> str;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    *outLen = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ======================== Unicode.h ========================= </span></div><div class="line"></div><div class="line">typedef uint32_t char32_t;</div><div class="line">typedef uint16_t char16_t;</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到上面 WriteString16 和 定义头文件的 Unicode 就能猜到 java 里面的 String 用的是 UCS-2（2byte 的unicode 编码，忘记了的去 <a href="http://light3moon.com/2015/01/31/[转] unicode 编码表" title="unicode 编码表" target="_blank" rel="external">unicode 编码表</a> 看看）。</p>
<p>好补充了上面的知识我们再接着看 pkg name。一开始长度： 0x0000 0014，20个字符，从 0x0063（”c” 的 UCS-2 码） 到红色最后一排那个 0x0069（”i” 的 UCS-2 码） 正好是 20 个（2byte x 20 = 40byte, 0x000000ch ~ 0x0000033h）。UCS-2 使用2个byte来代码一个码，如果是字母的就是 ACSII 的值，从右侧的显示也能看出是： com.android.systemui。但是这里稍微注意下，红色的部分，多个了2个 0x0000，第一个从前面 Parcel 的代码我们知道是 ‘/0’ 字符串结束符。但是怎么还多了一个出来？还记得 Parcel 篇说过 Parcel 数据都会 4byte 对齐的么，如果不算后面那个 0x0000 的话，我们算算看原来的数据是多少： 4byte(1个 32bit int len) + 40byte(20个 16bit UCS-2 字符) + 2byte（1个 16bit UCS-2 结束符）= 46byte，46 % 4 = 2，所以最后还要补上 2byte 作为 4byte 对齐用的。这里结合实际终能稍微能明白点字节对齐了。</p>
<p>补充完 Parcel 知识，继续往下看。倒回去看下 PkgUsageStatsExtended 的 writeToParcel 接口：</p>
<p>黄色部分，  4byte（writeInt）， mLaunchTime（启动次数），0x0000 0001，1次<br>淡蓝色部分，8byte（writeLong），mUsageTime（使用时长），0x0000 0000 01d8 70ef，30961918ms<br>紫色部分，  4byte（writeInt）， TimeStats 的个数，0x0000 0001，1个</p>
<p>然后后面就是循环写 TimeStats 了，和 PkgUsageStatsExtended 差不多一开始是 component name：红色部分，前面详细说了 pkg name 这里不多说了，照着前面的方法自己对照一下吧。然后就要看 TimeStats 的 writeToParcel 接口了：</p>
<p>紫色部分，4byte（writeInt），count 总共启动次数，0x0000 0001，1次。然后后面红色的部分是 TimeStats 的那个 int[] times 的数组的数值，全都是 4byte（writeInt），一共10个：正好从 0x00000a8h ~ 0x00000cfh 40byte。然后第2个为1，去翻下前面那个数组的定义：第二时间段正好是 250-500ms的（第一个是 &lt;250ms）。</p>
<p>然后剩下的就是循环重复了的，有兴趣的自己往下读一下了。从我们自己分析文件中的二进制数据发现，是和 USS 中的数据对得上的。</p>
<p>最后再说下前面说到 Parcel.obtain 带缓存效果是怎么回事，我们直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">... ...</div><div class="line">                 </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">6</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sOwnedPool = <span class="keyword">new</span> Parcel[POOL_SIZE];</div><div class="line">    <span class="comment">// pool 是 static 变量，每个进程中 Pacel 都有一个（6个元素的数组）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sHolderPool = <span class="keyword">new</span> Parcel[POOL_SIZE];</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">protected</span> <span class="keyword">final</span> Parcel <span class="title">obtain</span>(<span class="keyword">int</span> obj) { </div><div class="line">        <span class="keyword">final</span> Parcel[] pool = sHolderPool;</div><div class="line">        <span class="keyword">synchronized</span> (pool) { </div><div class="line">            Parcel p;</div><div class="line">            <span class="comment">// 会在 pool 中找到一个不为 null 的元素，取出来，</span></div><div class="line">            <span class="comment">// 然后先初始化一下大小，再把这个位置的元素设置为 null，表示已经被取走了</span></div><div class="line">            <span class="comment">// 最后返回取出来的元素给调用者使用</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) {</div><div class="line">                p = pool[i];</div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) {               </div><div class="line">                    pool[i] = <span class="keyword">null</span>;                </div><div class="line">                    <span class="keyword">if</span> (DEBUG_RECYCLE) {           </div><div class="line">                        p.mStack = <span class="keyword">new</span> RuntimeException();</div><div class="line">                    }</div><div class="line">                    p.init(obj);                   </div><div class="line">                    <span class="keyword">return</span> p;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// 如果 pool 中都是空的，只好重新 new 一个出来了</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parcel(obj);        </div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// 结合上面的 obtain 来看，这个 recycle 就是先把自己的内存释放掉，</span></div><div class="line">    <span class="comment">// 然后在 pool 中找一个空位置，把自己放进去，如果 pool 满了的话（没人用）就不管了</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Put a Parcel object back into the pool.  You must not touch</span></div><div class="line"><span class="comment">     * the object after this call.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recycle</span>() {</div><div class="line">        <span class="keyword">if</span> (DEBUG_RECYCLE) mStack = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 释放自己占用的内存</span></div><div class="line">        freeBuffer();</div><div class="line">    </div><div class="line">        <span class="comment">// 看样子 obtain 取不到 mOwnsNativeParcelObject 的 Parcel 的</span></div><div class="line">        <span class="keyword">final</span> Parcel[] pool; </div><div class="line">        <span class="keyword">if</span> (mOwnsNativeParcelObject) {</div><div class="line">            pool = sOwnedPool;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            mNativePtr = <span class="number">0</span>;</div><div class="line">            pool = sHolderPool;</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="keyword">synchronized</span> (pool) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) {</div><div class="line">                <span class="keyword">if</span> (pool[i] == <span class="keyword">null</span>) {</div><div class="line">                    pool[i] = <span class="keyword">this</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>从这里我们可以看出，在使用 Parcel 的时候，尽量调用 Parcel.obtain 来获取 Parcel 来使用，使用完之后要调用 recycle 把不用的 Parcel 还到缓存池中去，以便下次使用。这样能减少 GC 的概率。对了前面 Parcel 还有2个函数没说（java 中的直接挂 jni 的马甲，直接上 jni 代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ======================== android_os_Parcel.cpp ========================= </span></div><div class="line"></div><div class="line"><span class="keyword">static</span> jbyteArray android_os_Parcel_marshall(JNIEnv* env, jclass clazz, jint nativePtr)</div><div class="line">{</div><div class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel == NULL) {</div><div class="line">       <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// do not marshall if there are binder objects in the parcel</span></div><div class="line">    <span class="keyword">if</span> (parcel-&gt;objectsCount())</div><div class="line">    {</div><div class="line">        jniThrowException(env, <span class="string">"java/lang/RuntimeException"</span>, <span class="string">"Tried to marshall a Parcel that contained Binder objects."</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// new 了一个 parcel 数据大小的 java byte 数组</span></div><div class="line">    jbyteArray ret = env-&gt;NewByteArray(parcel-&gt;dataSize());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ret != NULL)</div><div class="line">    {</div><div class="line">        jbyte* <span class="built_in">array</span> = (jbyte*)env-&gt;GetPrimitiveArrayCritical(ret, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">array</span> != NULL)</div><div class="line">        {</div><div class="line">            <span class="comment">// 把 parcel 中的内存 copy 到刚刚 new 出来的 byte 数组中</span></div><div class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>, parcel-&gt;data(), parcel-&gt;dataSize());</div><div class="line">            env-&gt;ReleasePrimitiveArrayCritical(ret, <span class="built_in">array</span>, <span class="number">0</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_Parcel_unmarshall(JNIEnv* env, jclass clazz, jint nativePtr,</div><div class="line">                                         jbyteArray data, jint offset, jint length)</div><div class="line">{</div><div class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel == NULL || length &lt; <span class="number">0</span>) {</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 从 java byte 数组中获取指针</span></div><div class="line">    jbyte* <span class="built_in">array</span> = (jbyte*)env-&gt;GetPrimitiveArrayCritical(data, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>)</div><div class="line">    {</div><div class="line">        parcel-&gt;setDataSize(length);   </div><div class="line">        parcel-&gt;setDataPosition(<span class="number">0</span>);    </div><div class="line"></div><div class="line">        <span class="comment">// 让 parcel 分配指定的内存空间</span></div><div class="line">        <span class="keyword">void</span>* raw = parcel-&gt;writeInplace(length);</div><div class="line">        <span class="comment">// 把 java byte 数组 copy 到 parcel 的内存中</span></div><div class="line">        <span class="built_in">memcpy</span>(raw, (<span class="built_in">array</span> + offset), length);</div><div class="line"></div><div class="line">        env-&gt;ReleasePrimitiveArrayCritical(data, <span class="built_in">array</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>marshall 是从 Parcel 中获取打包好的直接流数据；unmarshall 正好反过来，把指定的字节流写入到 Parcel 中。</p>
<h2 id="改造">改造</h2>
<h3 id="方案">方案</h3>
<p>前面说了那么多，大概弄清楚 USS 统计了什么数据，如果保存的。从上面来看，如果要利用 USS 来进行应用时长统计，只要做一点点修改就行了。首先 USS 只会保存最近5天的数据，可以自己在 framework 中写一个 Provider 把 USS 的数据全部存到数据库中。我是在只建了一张表，就2个字段，一个是 long 时间，一个是 blob USS 每一个保存文件的对应的二进制数据（也就是 Parcel 中的内存结构）。这样做出于下面的的考虑：</p>
<ol>
<li>数据量不会太大，一天一个文件，也就是说一天一条记录，1000 条够3年多了。一般设备上安装的应用也不会特别多，所以对应每一条的 blob 数据也不会太大。</li>
<li>使用数据库方便查询，对于生成一些指定范围时间范围内的数据报表很有帮助，例如说最近一个星期、最近1个月的使用情况。</li>
<li>保存的是 USS 的原始数据，如果需要 USS 增加什么新数据的话，数据库不需要升级表字段。</li>
<li>Provider 接口方便多个进程调用。</li>
<li>因为相当于是把 USS 生成的文件保存到数据库中了，所以解析速度会稍微慢一点，但是对于查看统计应用时长的需要，转个圈圈加载一下下也没啥关系。</li>
</ol>
<p>但是需要注意一点：从上面的分析知道 USS 保存到文件中的数据并不是当前的实时数据，所以保存在数据库中的也不是实时数据，也就说从 Provider 读到的也不是实时数据。实时数据在 USS 的内存中（mStats），所以如果要判断当前某些应用使用多长时间（应用监控功能），需要在 USS 拉接口，去取 mStats 的数据。</p>
<h3 id="实现">实现</h3>
<p>上面把方案说了一下，实现的话这里简单说一下就行了，不贴代码了（这篇已经够长了，而且改造挺简单的）。新加一个 Provider 的话，可以在 packages/providers 下面新建一个 UsageStatsProvider 的模块，Android.mk 和 ContentProvider 的写法，可以照着同目录的几个 providers 抄一下。然后如果要随系统发布的话，记得把你新加的模块加到编译脚本中。然后去 frameworks/base/core/java/android/provider 下面加一个 UsageStats.java 的文件，把数据库的表字段、对外的 Provider URL 定义好（拉接口）。然后数据保存就弄得差不多了。</p>
<p>最后就是要让 USS 保存文件的时候调用下你写的 Provider 的接口，把文件顺带写到数据中。通过上面的分析，就在 writeToFileParcel 成功写入那加就行了，还有现成的 blob 数据（Parcel 的打包数据）。</p>
<p>然后 USS 拉接口的就要具体业务了，这里不多说了。</p>
<h2 id="总结">总结</h2>
<p>终于说完了。其实 USS 还有一些东西我没管（例如那个 resume 的历史记录 xml 文件），以后用到再说。还有顺带分析的 AMS 那里也是还有很多种情况没分析到的。还有这里只说了 startActivity，对应的 finishActivity 还没说，以后再说了。还有以后顺带把 Handler、Looper、MessageQueue 也整理一篇。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/31/工作小笔记——Android 自带的应用统计服务[UsageStatsService]/" data-title="工作小笔记——Android 自带的应用统计服务（UsageStatsService） | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/11/02/Android 应用内存泄漏分析/" title="Android 应用内存泄漏问题分析">
  <strong>上一篇:</strong><br/>
  <span>
  Android 应用内存泄漏问题分析</span>
</a>
</div>


<div class="next">
<a href="/2015/01/28/Android Binder 分析——原理/"  title="Android Binder 分析——原理">
 <strong>下一篇:</strong><br/> 
 <span>Android Binder 分析——原理
</span>
</a>
</div>

</nav>


	
<section class="comment">
	<div class="ds-thread" data-thread-key="工作小笔记——Android 自带的应用统计服务（UsageStatsService）" data-title="工作小笔记——Android 自带的应用统计服务（UsageStatsService）" 
      data-author-key="mingming" data-limit=10
      data-url="light3moon.com/2015/01/31/工作小笔记——Android 自带的应用统计服务[UsageStatsService]/">
    </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#UsageStatsService"><span class="toc-number">1.</span> <span class="toc-text">UsageStatsService</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初步认识"><span class="toc-number">1.1.</span> <span class="toc-text">初步认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计埋点"><span class="toc-number">1.3.</span> <span class="toc-text">统计埋点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#noteResumeComponent"><span class="toc-number">1.3.1.</span> <span class="toc-text">noteResumeComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notePauseComponent"><span class="toc-number">1.3.2.</span> <span class="toc-text">notePauseComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addLaunchTime"><span class="toc-number">1.3.3.</span> <span class="toc-text">addLaunchTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AMS_小分析"><span class="toc-number">1.3.4.</span> <span class="toc-text">AMS 小分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存数据"><span class="toc-number">1.4.</span> <span class="toc-text">保存数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改造"><span class="toc-number">2.</span> <span class="toc-text">改造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方案"><span class="toc-number">2.1.</span> <span class="toc-text">方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-number">2.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>31</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>46</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>23</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/android/" title="android">android<sup>77</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>27</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">哥的后勤处 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-qqzone"></i> <a href="http://user.qzone.qq.com/544630305" target="_blank">QQ 空间</a></li>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">战斗力</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="commentlist">
  <p class="asidetitle">最近冒泡的小伙伴 ╰(●&#39;◡&#39;●)╮</p>
    <ul>
      <ul class="ds-recent-comments" 
        data-num-items="5" 
        data-show-avatars="1" 
        data-show-title="1"   
        data-show-time="1" 
        data-show-admin="1" 
        data-excerpt-length="30">
      </ul>
      <!-- duoshou js begin load, one page only load once -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"mingming"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- duoshou js load end -->
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	
		<a href="http://user.qzone.qq.com/544630305" target="_blank" title="qqzone"></a>
		         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2015 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"mingming"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
