
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">

  
    <title>Android Broadcast 分析——发送、处理 | Light.Moon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Mingming">
    
    <meta name="description" content="上一篇分析了广播的注册流程，这篇来分析下广播的发送、处理流程。这里为什么把发送和处理和来一起说咧，那是因为其实这是一个过程，发送接口里面差不多就是处理过程了。我们先照例把相关代码位置啰嗦一下（4.2.2）：
1234567891011121314151617181920212223# Content">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/apple_icon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple_icon.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
		<div id="header_author">
		</div>
		

         <!--
         
           <div id="imglogo">
           <a href="/"><img src="/img/logo.svg" alt="Light.Moon" title="Light.Moon"/></a>
           </div>
         
         -->

			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Light.Moon">Light.Moon</a></h1>
				<h2 class="blog-motto">〜(￣△￣〜) 三月学长的根据地 (〜￣△￣)〜</h2>
			</div>

			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/1986/12/20/文章索引">索引</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					

                      <form class="search" action=http://search.light3moon.com/cse/search target="_blank">
                      <label>搜索</label>
                      <!--
                      <input name="s" type="hidden" value="undefined">
                      -->
                      <input name="s" type="hidden" value="12628367885198549364">
                      <input type="text" name="q" size="30" placeholder="搜索"> <br>

                      
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/01/22/Android Broadcast 分析——发送、处理/" title="Android Broadcast 分析——发送、处理" itemprop="url">Android Broadcast 分析——发送、处理</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://www.light3moon.com" title="Mingming">Mingming</a>
    </p>
  <p class="article-time">
    <time datetime="2015-01-22T02:15:16.000Z" itemprop="datePublished">2015 1月 22</time>
    更新日期:<time datetime="2017-02-07T13:47:54.000Z" itemprop="dateModified">2017 2月 7</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#发送接口"><span class="toc-number">1.</span> <span class="toc-text">发送接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用接口"><span class="toc-number">1.1.</span> <span class="toc-text">应用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统发送接口"><span class="toc-number">1.2.</span> <span class="toc-text">系统发送接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-_收集广播接收器"><span class="toc-number">2.</span> <span class="toc-text">a. 收集广播接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-a_收集静态注册接收器"><span class="toc-number">2.1.</span> <span class="toc-text">a.a 收集静态注册接收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-b_收集动态注册接收器"><span class="toc-number">2.2.</span> <span class="toc-text">a.b 收集动态注册接收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b-_分发广播给动态注册接收器"><span class="toc-number">3.</span> <span class="toc-text">b. 分发广播给动态注册接收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-_分发广播给静态注册接收器"><span class="toc-number">4.</span> <span class="toc-text">c. 分发广播给静态注册接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接收器进程已经启动"><span class="toc-number">4.1.</span> <span class="toc-text">接收器进程已经启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收器进程还没启动"><span class="toc-number">4.2.</span> <span class="toc-text">接收器进程还没启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先级问题"><span class="toc-number">5.</span> <span class="toc-text">优先级问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>上一篇分析了广播的注册流程，这篇来分析下广播的发送、处理流程。这里为什么把发送和处理和来一起说咧，那是因为其实这是一个过程，发送接口里面差不多就是处理过程了。我们先照例把相关代码位置啰嗦一下（4.2.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Content 广播相关的代码</span></div><div class="line">frameworks/base/core/java/android/app/ContextImpl.java</div><div class="line">frameworks/base/core/java/android/app/LoadedApk.java</div><div class="line">frameworks/base/core/java/android/app/ActivityThread.java</div><div class="line"></div><div class="line">frameworks/base/core/java/android/content/Intent.java</div><div class="line">frameworks/base/core/java/android/content/IntentFilter.java</div><div class="line">frameworks/base/core/java/android/content/BroadcastReceiver.java</div><div class="line">frameworks/base/core/java/android/content/IIntentReceiver.aidl</div><div class="line"></div><div class="line"><span class="comment"># 广播解析相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/IntentResolver.java</div><div class="line"></div><div class="line"><span class="comment"># AM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</div><div class="line">frameworks/base/services/java/com/android/server/am/RecevierList.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastQueue.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastFilter.java</div><div class="line">frameworks/base/services/java/com/android/server/am/BroadcastRecord.java</div><div class="line"></div><div class="line"><span class="comment"># PM 广播相关代码</span></div><div class="line">frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</div><div class="line"></div></pre></td></tr></table></figure>

<p>然后把处理流程贴张图：</p>
<p><img src="https://mingming-killer.github.io/img/pics/android/Broadcast-send/broadcast-send.png" alt=""><br>(这个图很夸张吧，拉一下本篇的滚动条就知道为啥这么夸张了；本来想分情况画几张的，画到后面还是合在一起了)</p>
<h2 id="发送接口">发送接口</h2>
<h3 id="应用接口">应用接口</h3>
<p>普通应用发送广播的接口和注册篇注册的一样，都在 Context 里面，但是实现在 ContextImpl 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span>(Intent intent) { </div><div class="line">    warnIfCallingFromSystemProcess();</div><div class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        intent.setAllowFds(<span class="keyword">false</span>);     </div><div class="line">        ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">            mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</div><div class="line">            Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</div><div class="line">            getUserId());</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里我们看最简单，也是最常见的那种，直接一个 Intent 发出去的。其实最后是调用到 AMS 里面的同名接口（前面一篇说过了，广播的处理是在 AMS 中的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span>(IApplicationThread caller,</div><div class="line">        Intent intent, String resolvedType, IIntentReceiver resultTo,</div><div class="line">        <span class="keyword">int</span> resultCode, String resultData, Bundle map,</div><div class="line">        String requiredPermission, <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId) {</div><div class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">        intent = verifyBroadcastLocked(intent);</div><div class="line"></div><div class="line">        <span class="comment">// 获取调用者的进程相关信息</span></div><div class="line">        <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">        <span class="comment">// 下面这个带 Locked 的函数才是关键</span></div><div class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</div><div class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>, </div><div class="line">                intent, resolvedType, resultTo,</div><div class="line">                resultCode, resultData, map, requiredPermission, serialized, sticky,</div><div class="line">                callingPid, callingUid, userId);</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    }     </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 里面的这个接口，有一个 boolean 参数 serialized（还有个 sticky 的，我们不管这个 stciky）。true 的话，表示发送的串行广播，false 表示发送并行广播。串行广播就是说，一个广播来了，有一对接收器， AMS 会等前一个执行完，才会发给下一个处理，<strong>接收器处理广播是一个接着一个处理的</strong>。并行的就是 AMS 把广播发给一个接收器之后，会马上返回，然后再发给下一个，直到发送完，<strong>接收器处理广播是并行的（同时处理）</strong>。用简单参数的接口，<strong>默认发送的是并行广播</strong>。</p>
<p>回到接口上，加了多线程互斥锁之后，调用 broadcastIntentLocked 处理。这个函数就是看名字是发送广播（Intent），其实就是处理过程，而且非常长，我们发到后面慢慢说。</p>
<h3 id="系统发送接口">系统发送接口</h3>
<p>我们来看看系统是怎么发送的。我们以前面说的 BOOT_COMPLETED 广播来看。这个广播是 AMS 中发出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> finishBooting() {</div><div class="line">        IntentFilter pkgFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">        pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</div><div class="line">        pkgFilter.addDataScheme(<span class="string">"package"</span>);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="comment">// Ensure that any processes we had put on hold are now started</span></div><div class="line">            <span class="comment">// up.</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {</div><div class="line">                <span class="comment">// Start looking for apps that are abusing wake locks.</span></div><div class="line">                Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</div><div class="line">                mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</div><div class="line">                <span class="comment">// Tell anyone interested that we are done booting!</span></div><div class="line">                SystemProperties.set(<span class="string">"sys.boot_completed"</span>, <span class="string">"1"</span>);</div><div class="line">                SystemProperties.set(<span class="string">"dev.bootcomplete"</span>, <span class="string">"1"</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mStartedUsers.size(); i++) {</div><div class="line">                    UserStartedState uss = mStartedUsers.valueAt(i);</div><div class="line">                    <span class="keyword">if</span> (uss.mState == UserStartedState.STATE_BOOTING) {</div><div class="line">                        uss.mState = UserStartedState.STATE_RUNNING;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> userId = mStartedUsers.keyAt(i);</div><div class="line">                        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_BOOT_COMPLETED, <span class="keyword">null</span>);</div><div class="line">                        intent.putExtra(Intent.EXTRA_USER_HANDLE, userId);</div><div class="line">                        <span class="comment">// AMS 里面自己发，直接调用这个函数了</span></div><div class="line">                        <span class="comment">// serialized 是 false，这个是一个并行广播</span></div><div class="line">                        broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</div><div class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                                android.Manifest.permission.RECEIVE_BOOT_COMPLETED,</div><div class="line">                                <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, userId);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 里面自己发广播，直接调用 broadcastIntentLocked 了。估计其他系统服务里面还是调用 AMS 的 broadcastIntent 接口的吧。</p>
<p>接下来说下广播处理流程。AMS 中处理广播的流程就是 broadcastIntentLocked 这个函数，这个函数也是非常长的（差不多6、7百行），我们分段慢慢来（会跳过一些非重要的部分）：</p>
<h2 id="a-_收集广播接收器">a. 收集广播接收器</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span>(ProcessRecord callerApp,</div><div class="line">            String callerPackage, Intent intent, String resolvedType,</div><div class="line">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">            Bundle map, String requiredPermission,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</div><div class="line">            <span class="keyword">int</span> userId) {</div><div class="line">        intent = <span class="keyword">new</span> Intent(intent);</div><div class="line"></div><div class="line">        <span class="comment">// By default broadcasts do not go to stopped apps.</span></div><div class="line">        intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(</div><div class="line">            TAG, (sticky ? <span class="string">"Broadcast sticky: "</span>: <span class="string">"Broadcast: "</span>) + intent</div><div class="line">            + <span class="string">" ordered="</span> + ordered + <span class="string">" userid="</span> + userId);</div><div class="line">        <span class="keyword">if</span> ((resultTo != <span class="keyword">null</span>) && !ordered) {</div><div class="line">            Slog.w(TAG, <span class="string">"Broadcast "</span> + intent + <span class="string">" not ordered but result callback requested!"</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 获取用户信息（用户中，不同用户的广播是分开的）</span></div><div class="line">        userId = handleIncomingUser(callingPid, callingUid, userId,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"broadcast"</span>, callerPackage);</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that the user who is receiving this broadcast is started.</span></div><div class="line">        <span class="comment">// If not, we will just skip it.</span></div><div class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (callingUid != Process.SYSTEM_UID || (intent.getFlags()</div><div class="line">                    & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) {</div><div class="line">                Slog.w(TAG, <span class="string">"Skipping broadcast of "</span> + intent</div><div class="line">                        + <span class="string">": user "</span> + userId + <span class="string">" is stopped"</span>);</div><div class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">            }     </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// 这里是一些发送权限，检测和 sticky 功能，我们通通跳过 </span></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] users;</div><div class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL) {</div><div class="line">            <span class="comment">// Caller wants broadcast to go to all started users.</span></div><div class="line">            users = mStartedUserArray;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// Caller wants broadcast to go to one specific user.</span></div><div class="line">            users = <span class="keyword">new</span> <span class="keyword">int</span>[] {userId};</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Figure out who all will receive this broadcast.</span></div><div class="line">        List receivers = <span class="keyword">null</span>;</div><div class="line">        List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// Need to resolve the intent to interested receivers...</span></div><div class="line">        <span class="comment">// 这里还有个判断，如果发送的广播并不是只能动态注册的才跑下面的（也是说静态的可以，真绕口）</span></div><div class="line">        <span class="keyword">if</span> ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)</div><div class="line">                 == <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 收集静态注册的接收器</span></div><div class="line">            receivers = collectReceiverComponents(intent, resolvedType, users);</div><div class="line">        }</div><div class="line">        <span class="comment">// 看样子发一条动态注册接收器能处理的广播，发的 Intent 必须要包含 Component 信息</span></div><div class="line">        <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 收集动态注册的接收器</span></div><div class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</div><div class="line">                    resolvedType, <span class="keyword">false</span>, userId);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</div><div class="line">                (intent.getFlags()&Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Enqueing broadcast: "</span> + intent.getAction()</div><div class="line">                + <span class="string">" replacePending="</span> + replacePending);</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>一个广播发出来了，AMS 要做的第一步，首先是要找到有哪些接收器要接收这条广播。前面一篇说了，注册接收器有动态注册和静态注册2种。这里看代码果然也是分开2步来收集的。我们先来看收集静态的：</p>
<h3 id="a-a_收集静态注册接收器">a.a 收集静态注册接收器</h3>
<p>静态注册接收器收集由 collectReceiverComponents 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> List&lt;ResolveInfo&gt; <span class="title">collectReceiverComponents</span>(Intent intent, String resolvedType,</div><div class="line">            <span class="keyword">int</span>[] users) {</div><div class="line">        List&lt;ResolveInfo&gt; receivers = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            HashSet&lt;ComponentName&gt; singleUserReceivers = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">boolean</span> scannedFirstReceivers = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> user : users) {</div><div class="line">                <span class="comment">// 去 PM 中取静态注册的接收器列表</span></div><div class="line">                List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</div><div class="line">                        .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);</div><div class="line"></div><div class="line">                <span class="comment">// 下面那一堆是关于多用户处理的，我们不管它们</span></div><div class="line">... ...</div><div class="line"></div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">            <span class="comment">// pm is in same process, this will never happen.</span></div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> receivers;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数虽然有 100 多行，但是我们关心的只有调用 PM 的那句 queryIntentReceivers 而已。前面一篇说了，静态注册的广播数据保存在 PMS 中，所以这里要调用 PM 的接口去 PMS 里面去取。所以我去 PMS 里面去看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntentReceivers</span>(Intent intent, String resolvedType, <span class="keyword">int</span> flags,</div><div class="line">        <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> Collections.emptyList(); </div><div class="line">    ComponentName comp = intent.getComponent();</div><div class="line">    <span class="keyword">if</span> (comp == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">if</span> (intent.getSelector() != <span class="keyword">null</span>) {    </div><div class="line">            intent = intent.getSelector();</div><div class="line">            comp = intent.getComponent();  </div><div class="line">        }       </div><div class="line">    }</div><div class="line">    <span class="comment">// 如果发送的广播带 ComponentName 信息，差不多就是显式广播了（指定了接收器包名、类名的）</span></div><div class="line">    <span class="comment">// 所以只要有一个接收器就行了</span></div><div class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) {</div><div class="line">        List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</div><div class="line">        ActivityInfo ai = getReceiverInfo(comp, flags, userId);</div><div class="line">        <span class="keyword">if</span> (ai != <span class="keyword">null</span>) {</div><div class="line">            ResolveInfo ri = <span class="keyword">new</span> ResolveInfo();</div><div class="line">            ri.activityInfo = ai;</div><div class="line">            list.add(ri);</div><div class="line">        }           </div><div class="line">        <span class="keyword">return</span> list;    </div><div class="line">    }                   </div><div class="line">                            </div><div class="line">    <span class="comment">// 但是一般的都是走下面这里的</span></div><div class="line">    <span class="comment">// 我们的例子 BOOT_COMPLETED 属于这种</span></div><div class="line">    <span class="comment">// reader                       </span></div><div class="line">    <span class="keyword">synchronized</span> (mPackages) { </div><div class="line">        String pkgName = intent.getPackage();</div><div class="line">        <span class="comment">// 一般隐式的也是不指定包名的</span></div><div class="line">        <span class="comment">// 我们的例子 BOOT_COMPLETED 属于这种</span></div><div class="line">        <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 所以一般是用这个收集静态注册接收器的                             </span></div><div class="line">            <span class="keyword">return</span> mReceivers.queryIntent(intent, resolvedType, flags, userId);</div><div class="line">        }</div><div class="line">        <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(pkgName);</div><div class="line">        <span class="keyword">if</span> (pkg != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers,</div><div class="line">                    userId);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们在说之前先看看 ResolveInfo 这个东西，好歹返回的列表里面是这个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Information that is returned from resolving an intent</span></div><div class="line"><span class="comment"> * against an IntentFilter. This partially corresponds to</span></div><div class="line"><span class="comment"> * information collected from the AndroidManifest.xml's</span></div><div class="line"><span class="comment"> * &lt;intent&gt; tags.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolveInfo</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>里面的具体东西我们就不看了，看下注释，是说一个 ResolverInfo 对应一个 IntentFilter。然后就是 mReceivers 这个 ActivityIntentResolver，注册篇已经提及过了。PMS 中就是它保存了静态注册的接收器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntent</span>(Intent intent, String resolvedType, <span class="keyword">int</span> flags,</div><div class="line">        <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    mFlags = flags;</div><div class="line">    <span class="comment">// 这个差不多就是直接调用父类的同名函数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.queryIntent(intent, resolvedType,</div><div class="line">            (flags & PackageManager.MATCH_DEFAULT_ONLY) != <span class="number">0</span>, userId);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们去看父类（IntentResolver）的 queryIntent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前面注册篇说了么，R 是输出类型</span></div><div class="line"><span class="keyword">public</span> List&lt;R&gt; <span class="title">queryIntent</span>(Intent intent, String resolvedType, <span class="keyword">boolean</span> defaultOnly,</div><div class="line">        <span class="keyword">int</span> userId) {</div><div class="line">    String scheme = intent.getScheme();</div><div class="line"></div><div class="line">    ArrayList&lt;R&gt; finalList = <span class="keyword">new</span> ArrayList&lt;R&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = localLOGV ||</div><div class="line">            ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (debug) Slog.v(</div><div class="line">        TAG, <span class="string">"Resolving type "</span> + resolvedType + <span class="string">" scheme "</span> + scheme</div><div class="line">        + <span class="string">" of intent "</span> + intent);</div><div class="line"></div><div class="line">    <span class="comment">// F 是输入，这几个数组分别对应注册篇说的 IntentResovler 中的那几个保存的 HashMap（Set）</span></div><div class="line">    F[] firstTypeCut = <span class="keyword">null</span>;</div><div class="line">    F[] secondTypeCut = <span class="keyword">null</span>;</div><div class="line">    F[] thirdTypeCut = <span class="keyword">null</span>;</div><div class="line">    F[] schemeCut = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// MIME type，我们的例子 BOOT_COMPLETED 是 null</span></div><div class="line">    <span class="comment">// If the intent includes a MIME type, then we want to collect all of</span></div><div class="line">    <span class="comment">// the filters that match that MIME type.</span></div><div class="line">    <span class="keyword">if</span> (resolvedType != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> slashpos = resolvedType.indexOf(<span class="string">'/'</span>);</div><div class="line">        <span class="keyword">if</span> (slashpos &gt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">final</span> String baseType = resolvedType.substring(<span class="number">0</span>, slashpos);</div><div class="line">            <span class="keyword">if</span> (!baseType.equals(<span class="string">"*"</span>)) {</div><div class="line">                <span class="keyword">if</span> (resolvedType.length() != slashpos+<span class="number">2</span></div><div class="line">                        || resolvedType.charAt(slashpos+<span class="number">1</span>) != <span class="string">'*'</span>) {</div><div class="line">                    <span class="comment">// Not a wild card, so we can just look for all filters that</span></div><div class="line">                    <span class="comment">// completely match or wildcards whose base type matches.</span></div><div class="line">                    firstTypeCut = mTypeToFilter.get(resolvedType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"First type cut: "</span> + firstTypeCut);</div><div class="line">                    secondTypeCut = mWildTypeToFilter.get(baseType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Second type cut: "</span> + secondTypeCut);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// We can match anything with our base type.</span></div><div class="line">                    firstTypeCut = mBaseTypeToFilter.get(baseType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"First type cut: "</span> + firstTypeCut);</div><div class="line">                    secondTypeCut = mWildTypeToFilter.get(baseType);</div><div class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Second type cut: "</span> + secondTypeCut);</div><div class="line">                }</div><div class="line">                <span class="comment">// Any */* types always apply, but we only need to do this</span></div><div class="line">                <span class="comment">// if the intent type was not already */*.</span></div><div class="line">                thirdTypeCut = mWildTypeToFilter.get(<span class="string">"*"</span>);</div><div class="line">                <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Third type cut: "</span> + thirdTypeCut);</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (intent.getAction() != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// The intent specified any type ({@literal *}/*).  This</span></div><div class="line">                <span class="comment">// can be a whole heck of a lot of things, so as a first</span></div><div class="line">                <span class="comment">// cut let's use the action instead.</span></div><div class="line">                firstTypeCut = mTypedActionToFilter.get(intent.getAction());</div><div class="line">                <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Typed Action list: "</span> + firstTypeCut);</div><div class="line">            }   </div><div class="line">        }           </div><div class="line">    }   </div><div class="line">                    </div><div class="line">    <span class="comment">// Scheme，我们的例子 BOOT_COMPLETED 也是 null</span></div><div class="line">    <span class="comment">// If the intent includes a data URI, then we want to collect all of</span></div><div class="line">    <span class="comment">// the filters that match its scheme (we will further refine matches</span></div><div class="line">    <span class="comment">// on the authority and path by directly matching each resulting filter).</span></div><div class="line">    <span class="keyword">if</span> (scheme != <span class="keyword">null</span>) {   </div><div class="line">        schemeCut = mSchemeToFilter.get(scheme);</div><div class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Scheme list: "</span> + schemeCut);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Action，我们的例子 BOOT_COMPLETED 本身就是 Action 啦</span></div><div class="line">    <span class="comment">// 所以这里 firstTypeCut 就是取前面注册篇中保存 Action 的列表了</span></div><div class="line">    <span class="comment">// If the intent does not specify any data -- either a MIME type or</span></div><div class="line">    <span class="comment">// a URI -- then we will only be looking for matches against empty</span></div><div class="line">    <span class="comment">// data.</span></div><div class="line">    <span class="keyword">if</span> (resolvedType == <span class="keyword">null</span> && scheme == <span class="keyword">null</span> && intent.getAction() != <span class="keyword">null</span>) {</div><div class="line">        firstTypeCut = mActionToFilter.get(intent.getAction());</div><div class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Action list: "</span> + firstTypeCut);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 这个 Categories，我们也暂时不管先</span></div><div class="line">    FastImmutableArraySet&lt;String&gt; categories = getFastIntentCategories(intent);</div><div class="line">    <span class="comment">// 然后按照顺序依次从匹配的 F 列表中构造出要查询的 R 返回给调用者</span></div><div class="line">    <span class="keyword">if</span> (firstTypeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, firstTypeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (secondTypeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, secondTypeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (thirdTypeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, thirdTypeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (schemeCut != <span class="keyword">null</span>) {</div><div class="line">        buildResolveList(intent, categories, debug, defaultOnly,</div><div class="line">                resolvedType, scheme, schemeCut, finalList, userId);</div><div class="line">    }</div><div class="line">    <span class="comment">// 对匹配的结果进行排序</span></div><div class="line">    sortResults(finalList);</div><div class="line"></div><div class="line">    <span class="comment">// 兼容老版本的，无视 ... ...</span></div><div class="line">    <span class="keyword">if</span> (VALIDATE) {</div><div class="line">        List&lt;R&gt; oldList = mOldResolver.queryIntent(intent, resolvedType, defaultOnly, userId);</div><div class="line">        <span class="keyword">if</span> (oldList.size() != finalList.size()) {</div><div class="line">            ValidationFailure here = <span class="keyword">new</span> ValidationFailure();</div><div class="line">            here.fillInStackTrace();</div><div class="line">            Log.wtf(TAG, <span class="string">"Query result "</span> + intent + <span class="string">" size is "</span> + finalList.size()</div><div class="line">                    + <span class="string">"; old implementation is "</span> + oldList.size(), here);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (debug) {</div><div class="line">        Slog.v(TAG, <span class="string">"Final result list:"</span>);</div><div class="line">        <span class="keyword">for</span> (R r : finalList) {</div><div class="line">            Slog.v(TAG, <span class="string">"  "</span> + r);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> finalList;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个函数前面是通过传过来的 Intent 从 IntentResolver 那一堆保存注册接收器数据的列表中选出匹配的 F（PMS 中的静态注册的 F 是 PackageParser.ActivityIntentInfo），一般来说匹配条件就是注册广播中 IntentFilter 可以设置的那一堆条件了：MIME type、Scheme、Action 等等（到这里的都是隐式的，显式的前面直接给解析好了）。然后我们就得去看看 buildResolveList 这个函数是怎么构造 R 出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildResolveList</span>(Intent intent, FastImmutableArraySet&lt;String&gt; categories,</div><div class="line">        <span class="keyword">boolean</span> debug, <span class="keyword">boolean</span> defaultOnly,</div><div class="line">        String resolvedType, String scheme, F[] src, List&lt;R&gt; dest, <span class="keyword">int</span> userId) {</div><div class="line">    <span class="keyword">final</span> String action = intent.getAction();</div><div class="line">    <span class="keyword">final</span> Uri data = intent.getData();</div><div class="line">    <span class="keyword">final</span> String packageName = intent.getPackage();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> excludingStopped = intent.isExcludingStopped();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = src != <span class="keyword">null</span> ? src.length : <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> hasNonDefaults = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    F filter;</div><div class="line">    <span class="comment">// 在选出的 F 数组里，循环根据 F 构造出 R</span></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N && (filter=src[i]) != <span class="keyword">null</span>; i++) {</div><div class="line">        <span class="keyword">int</span> match;</div><div class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Matching against filter "</span> + filter);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (excludingStopped && isFilterStopped(filter, userId)) {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter's target is stopped; skipping"</span>);</div><div class="line">            }   </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// Is delivery being limited to filters owned by a particular package?</span></div><div class="line">        <span class="keyword">if</span> (packageName != <span class="keyword">null</span> && !packageName.equals(packageForFilter(filter))) {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter is not from package "</span> + packageName + <span class="string">"; skipping"</span>);</div><div class="line">            }   </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// 这个 allowFilterResult 是由之类实现的，不过和我们这里的关系不大，不理它先</span></div><div class="line">        <span class="comment">// Do we already have this one?</span></div><div class="line">        <span class="keyword">if</span> (!allowFilterResult(filter, dest)) {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter's target already added"</span>);</div><div class="line">            }   </div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }   </div><div class="line"></div><div class="line">        <span class="comment">// IntentFilter 里面的匹配函数，我们也先忽略一下（就是拿上面几种类型匹配一下而已）</span></div><div class="line">        match = filter.match(action, resolvedType, scheme, data, categories, TAG);</div><div class="line">        <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"  Filter matched!  match=0x"</span> +</div><div class="line">                    Integer.toHexString(match));</div><div class="line">            <span class="keyword">if</span> (!defaultOnly || filter.hasCategory(Intent.CATEGORY_DEFAULT)) {</div><div class="line">                <span class="comment">// 这里 new R 出来的 newResult 也是由子类实现的，我们待会去看一下</span></div><div class="line">                <span class="keyword">final</span> R oneResult = newResult(filter, match, userId);</div><div class="line">                <span class="keyword">if</span> (oneResult != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">// 把 R 添加到输出列表中</span></div><div class="line">                    dest.add(oneResult);</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                hasNonDefaults = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (debug) {</div><div class="line">                String reason;</div><div class="line">                <span class="keyword">switch</span> (match) {</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_ACTION: reason = <span class="string">"action"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_CATEGORY: reason = <span class="string">"category"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_DATA: reason = <span class="string">"data"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_TYPE: reason = <span class="string">"type"</span>; <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">default</span>: reason = <span class="string">"unknown reason"</span>; <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                Slog.v(TAG, <span class="string">"  Filter did not match: "</span> + reason);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dest.size() == <span class="number">0</span> && hasNonDefaults) {</div><div class="line">        Slog.w(TAG, <span class="string">"resolveIntent failed: found match, but none with Intent.CATEGORY_DEFAULT"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 buildResolveList 中就是循环从输入的 F 数组中取出 F，然后传给一个叫 newResult 的函数构造 R。这个 newResult 是由不同的 IntentResovler 之类实现的。我们来看看 PMS 中的 ActivityIntentResolver newResult 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> ResolveInfo <span class="title">newResult</span>(PackageParser.ActivityIntentInfo info,</div><div class="line">        <span class="keyword">int</span> match, <span class="keyword">int</span> userId) {       </div><div class="line">    <span class="comment">// 下面一堆判断可以不用管先</span></div><div class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (!mSettings.isEnabledLPr(info.activity.info, mFlags, userId)) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">final</span> PackageParser.Activity activity = info.activity;</div><div class="line">    <span class="keyword">if</span> (mSafeMode && (activity.info.applicationInfo.flags</div><div class="line">            &ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    PackageSetting ps = (PackageSetting) activity.owner.mExtras;</div><div class="line">    <span class="keyword">if</span> (ps == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    ActivityInfo ai = PackageParser.generateActivityInfo(activity, mFlags,</div><div class="line">            ps.readUserState(userId), userId);</div><div class="line">    <span class="keyword">if</span> (ai == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// 下面就是构造 R（ResolverInfo） 的过程</span></div><div class="line">    <span class="keyword">final</span> ResolveInfo res = <span class="keyword">new</span> ResolveInfo();</div><div class="line">    res.activityInfo = ai;         </div><div class="line">    <span class="keyword">if</span> ((mFlags&PackageManager.GET_RESOLVED_FILTER) != <span class="number">0</span>) {</div><div class="line">        res.filter = info;             </div><div class="line">    }</div><div class="line">    <span class="comment">// 接收器的优先级在这里复制的哦</span></div><div class="line">    res.priority = info.getPriority();</div><div class="line">    res.preferredOrder = activity.owner.mPreferredOrder;</div><div class="line">    <span class="comment">//System.out.println("Result: " + res.activityInfo.className +</span></div><div class="line">    <span class="comment">//                   " = " + res.priority);</span></div><div class="line">    res.match = match;</div><div class="line">    res.isDefault = info.hasDefault;</div><div class="line">    res.labelRes = info.labelRes;</div><div class="line">    res.nonLocalizedLabel = info.nonLocalizedLabel;</div><div class="line">    res.icon = info.icon;</div><div class="line">    res.system = isSystemApp(res.activityInfo.applicationInfo);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面就是 new 了一个 ResolverInfo（R），然后用 F（PackageParser.ActivityIntentInfo） 中相应的字段填充自己的字段而已。后面 AMS 从自己那里收集动态注册的接收器，也是差不多的。所以说注册的时候保存的数据，差不多可以说就是接收器数据。</p>
<p>构造完 R 之后，queryIntent 最后对匹配的 R 进行了一下排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sortResults</span>(List&lt;R&gt; results) {</div><div class="line">    Collections.sort(results, mResolvePrioritySorter);</div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">// 注释说得很清楚了，按照优先级进行排序</span></div><div class="line"><span class="comment">// Sorts a List of IntentFilter objects into descending priority order.</span></div><div class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator mResolvePrioritySorter = <span class="keyword">new</span> Comparator() {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Object o1, Object o2) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> q1 = ((IntentFilter) o1).getPriority();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> q2 = ((IntentFilter) o2).getPriority();</div><div class="line">        <span class="keyword">return</span> (q1 &gt; q2) ? -<span class="number">1</span> : ((q1 &lt; q2) ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个优先级在注册篇说过了，在 manifest 里面声明 receiver 的 filter 那里设置的（只有系统应用有权限设置）。</p>
<h3 id="a-b_收集动态注册接收器">a.b 收集动态注册接收器</h3>
<p>上面看过收集静态的过程，下面我们来看看收集动态注册的接收器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">registeredReceivers = mReceiverResolver.queryIntent(intent,</div><div class="line">        resolvedType, <span class="keyword">false</span>, userId);</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个其实和上面静态流程是一样的，只不过 IntentResolver 的实现子类是 AMS 的匿名的一个类而已，我们就直接看看关键的 newResult 就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">protected</span> BroadcastFilter <span class="title">newResult</span>(BroadcastFilter filter, <span class="keyword">int</span> match, <span class="keyword">int</span> userId) {</div><div class="line">            <span class="keyword">if</span> (userId == UserHandle.USER_ALL || filter.owningUserId == UserHandle.USER_ALL</div><div class="line">                    || userId == filter.owningUserId) {</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.newResult(filter, match, userId);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line"></div><div class="line"><span class="comment">// ================ IntentResovler.java ============================</span></div><div class="line"></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">protected</span> R <span class="title">newResult</span>(F filter, <span class="keyword">int</span> match, <span class="keyword">int</span> userId) { </div><div class="line">        <span class="keyword">return</span> (R)filter;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 里面的除去前面那个判断，就是直接 new 了一个 R，也难怪，AMS 里面的 F 和 R 都是 BroadcastFilter。到这里 AMS 的 broadcastIntentLocked 就收集到了2个 List：</p>
<pre>
List receivers = null;
List<broadcastfilter> registeredReceivers = null;
</broadcastfilter></pre>

<p>分别是静态注册的接收器（ResolveInfo）和动态注册的接收器（BoradcastFilter）。</p>
<h2 id="b-_分发广播给动态注册接收器">b. 分发广播给动态注册接收器</h2>
<p>收集完广播匹配的接收器（静态和动态），就要开始分发了。我们接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span>(ProcessRecord callerApp,</div><div class="line">            String callerPackage, Intent intent, String resolvedType,</div><div class="line">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">            Bundle map, String requiredPermission,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</div><div class="line">            <span class="keyword">int</span> userId) {</div><div class="line">... ...</div><div class="line">            </div><div class="line">        <span class="keyword">int</span> NR = registeredReceivers != <span class="keyword">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</div><div class="line">        <span class="comment">// 判断如果不是串行广播并且有动态注册的接收器，就走下面的代码</span></div><div class="line">        <span class="comment">// 我们的例子（BOOT_COMPLETED）是并行广播，并且有不少动态注册的接收器的</span></div><div class="line">        <span class="keyword">if</span> (!ordered && NR &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// If we are not serializing this broadcast, then send the</span></div><div class="line">            <span class="comment">// registered receivers separately so they don't wait for the</span></div><div class="line">            <span class="comment">// components to be launched.</span></div><div class="line">            <span class="comment">// 取广播对应的广播队列：分为前台广播队列和后台广播队列</span></div><div class="line">            <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">            <span class="comment">// new 一个 BroadcastRecord，注意有传动态注册接收器的列表进去</span></div><div class="line">            BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</div><div class="line">                    callerPackage, callingPid, callingUid, requiredPermission,</div><div class="line">                    registeredReceivers, resultTo, resultCode, resultData, map,</div><div class="line">                    ordered, sticky, <span class="keyword">false</span>, userId);</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                    TAG, <span class="string">"Enqueueing parallel broadcast "</span> + r);</div><div class="line">            <span class="comment">// 这个 replaced 大概就是检测下现在发的这个 Intent 是不是和广播队列中的有一样的，</span></div><div class="line">            <span class="comment">// 如果有的话，说明之前发过一次了，但是还没处理，所以就忽略这次发送（代码不贴了）</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> replaced = replacePending && queue.replaceParallelBroadcastLocked(r);</div><div class="line">            <span class="keyword">if</span> (!replaced) {</div><div class="line">                <span class="comment">// 把前面 new 出来的 BroadcastRecord 送去并行的广播队列排队，然后执行发送</span></div><div class="line">                queue.enqueueParallelBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            }</div><div class="line">            registeredReceivers = <span class="keyword">null</span>;</div><div class="line">            NR = <span class="number">0</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">... ....</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里出现了2个新的数据结构：BroadcastQueue 和 BroadcastRecord。我们来一个一个看，首先是 BroadcastQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * BROADCASTS</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We keep two broadcast queues and associated bookkeeping, one for those at</span></div><div class="line"><span class="comment"> * foreground priority, and one for normal (background-priority) broadcasts.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastQueue</span> </span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BroadcastQueue"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG_MU = ActivityManagerService.TAG_MU;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_BROADCAST = ActivityManagerService.DEBUG_BROADCAST;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_BROADCAST_LIGHT = ActivityManagerService.DEBUG_BROADCAST_LIGHT;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_MU = ActivityManagerService.DEBUG_MU;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BROADCAST_HISTORY = <span class="number">25</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BROADCAST_SUMMARY_HISTORY = <span class="number">100</span>; </div><div class="line"></div><div class="line">    <span class="keyword">final</span> ActivityManagerService mService;</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Recognizable moniker for this queue</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> String mQueueName;</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Timeout period for this queue's broadcasts</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> mTimeoutPeriod;</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * Lists of all active broadcasts that are to be executed immediately</span></div><div class="line"><span class="javadoc">     * (without waiting for another broadcast to finish).  Currently this only</span></div><div class="line"><span class="javadoc">     * contains broadcasts to registered receivers, to avoid spinning up</span></div><div class="line"><span class="javadoc">     * a bunch of processes to execute IntentReceiver components.  Background-</span></div><div class="line"><span class="javadoc">     * and foreground-priority broadcasts are queued separately.</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts</div><div class="line">            = <span class="keyword">new</span> ArrayList&lt;BroadcastRecord&gt;();</div><div class="line">    <span class="javadoc">/**</span></div><div class="line"><span class="javadoc">     * List of all active broadcasts that are to be executed one at a time.</span></div><div class="line"><span class="javadoc">     * The object at the top of the list is the currently activity broadcasts;</span></div><div class="line"><span class="javadoc">     * those after it are waiting for the top to finish.  As with parallel</span></div><div class="line"><span class="javadoc">     * broadcasts, separate background- and foreground-priority queues are</span></div><div class="line"><span class="javadoc">     * maintained.</span></div><div class="line"><span class="javadoc">     */</span></div><div class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts</div><div class="line">            = <span class="keyword">new</span> ArrayList&lt;BroadcastRecord&gt;();</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>看注释，说 AMS 中有2个这种 BroacastQueue，一个是前台的，一个是后台的，前台的处理优先级比后台的高一些。然后里面有2个比较重要的 ArrayList：mParallelBroadcasts 和 mOrderedBroadcasts。看名字就很明显了，一个是串行广播记录的，一个是并行广播记录的。然后我们再来看下 BroadcastRecord 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * An active intent broadcast.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">class BroadcastRecord extends Binder {</div><div class="line">    <span class="keyword">final</span> Intent intent;    <span class="comment">// the original intent that generated us</span></div><div class="line">    <span class="keyword">final</span> ProcessRecord callerApp; <span class="comment">// process that sent this</span></div><div class="line">    <span class="keyword">final</span> String callerPackage; <span class="comment">// who sent this</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingPid;   <span class="comment">// the pid of who sent this</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid;   <span class="comment">// the uid of who sent this</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;  <span class="comment">// serialize the send to receivers?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;   <span class="comment">// originated from existing sticky data?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> initialSticky; <span class="comment">// initial broadcast from register to sticky?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId;       <span class="comment">// user id this broadcast was for</span></div><div class="line">    <span class="keyword">final</span> String requiredPermission; <span class="comment">// a permission the caller has required</span></div><div class="line">    <span class="keyword">final</span> List receivers;   <span class="comment">// contains BroadcastFilter and ResolveInfo</span></div><div class="line">    IIntentReceiver resultTo; <span class="comment">// who receives final result if non-null</span></div><div class="line">    <span class="keyword">long</span> dispatchTime;      <span class="comment">// when dispatch started on this set of receivers</span></div><div class="line">    <span class="keyword">long</span> dispatchClockTime; <span class="comment">// the clock time the dispatch started</span></div><div class="line">    <span class="keyword">long</span> receiverTime;      <span class="comment">// when current receiver started for timeouts.</span></div><div class="line">    <span class="keyword">long</span> finishTime;        <span class="comment">// when we finished the broadcast.</span></div><div class="line">    <span class="keyword">int</span> resultCode;         <span class="comment">// current result code value.</span></div><div class="line">    String resultData;      <span class="comment">// current result data value.</span></div><div class="line">    Bundle resultExtras;    <span class="comment">// current result extra data values.</span></div><div class="line">    <span class="keyword">boolean</span> resultAbort;    <span class="comment">// current result abortBroadcast value.</span></div><div class="line">    <span class="keyword">int</span> nextReceiver;       <span class="comment">// next receiver to be executed.</span></div><div class="line">    IBinder receiver;       <span class="comment">// who is currently running, null if none.</span></div><div class="line">    <span class="keyword">int</span> state;</div><div class="line">    <span class="keyword">int</span> anrCount;           <span class="comment">// has this broadcast record hit any ANRs?</span></div><div class="line">    BroadcastQueue queue;   <span class="comment">// the outbound queue handling this broadcast</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个类很简单，除了构造函数给上面一堆字段赋值以外，就没别的的啥操作了。然后上面注意那个 List 记录了 AMS 收集到的广播接收器的信息。接下来我们回到 broadcastIntentLocked 中看看 broadcastQueueForIntent 是怎么决定用哪个广播队列的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 顺带把初始化的地方贴出来</span></div><div class="line">    <span class="keyword">private</span> <span class="title">ActivityManagerService</span>() {</div><div class="line">        Slog.i(TAG, <span class="string">"Memory class: "</span> + ActivityManager.staticGetMemoryClass());</div><div class="line">                    </div><div class="line">        <span class="comment">// 这里创建广播队列的时候就设置好了广播超时时间（这个时间的作用，后面再说）</span></div><div class="line">        mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT);</div><div class="line">        mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT);</div><div class="line">        mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</div><div class="line">        mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</div><div class="line">... ...</div><div class="line">       </div><div class="line">    } </div><div class="line"></div><div class="line">    BroadcastQueue broadcastQueueForIntent(Intent intent) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() & Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (DEBUG_BACKGROUND_BROADCAST) {</div><div class="line">            Slog.i(TAG, <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></div><div class="line">                    + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>)</div><div class="line">                    + <span class="string">" queue"</span>);</div><div class="line">        }   </div><div class="line">        <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看样子是根据发广播的时候的 Intent 的 flags 来决定的，默认不设置就是后台广播队列。我搜了下代码，发现就只有 AMS 中会发几个是前台的。我们确定了我们的列子 BOOT_COMPLETED 是用后台广播队列之后，就来看看 BroadcastQueue 中的加入队列和执行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueParallelBroadcastLocked</span>(BroadcastRecord r) {</div><div class="line">    mParallelBroadcasts.add(r);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>入队操作很简单，直接插入到并行广播记录的列表中。排好队之后就到执行广播了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span>() {</div><div class="line">    RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</div><div class="line">    here.fillInStackTrace();</div><div class="line">    Slog.d(TAG, <span class="string">"call statck is"</span>, here);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Schedule broadcasts ["</span></div><div class="line">            + mQueueName + <span class="string">"]: current="</span></div><div class="line">            + mBroadcastsScheduled);</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前队列正在执行广播操作，则返回</span></div><div class="line">    <span class="comment">// 也就是说一个广播队列要等上一次广播操作执行完才会接收新的执行命令</span></div><div class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }    </div><div class="line">    <span class="comment">// 发了一个消息去 Handler 里面</span></div><div class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</div><div class="line">    <span class="comment">// 把正在执行的标志设置为 true</span></div><div class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个 Handler 没有使用额外的线程，</span></div><div class="line"><span class="comment">// 所以这里的作用应该是为了能够马上返回吧</span></div><div class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() {</div><div class="line">    <span class="comment">//public Handler() {</span></div><div class="line">    <span class="comment">//    if (localLOGV) Slog.v(TAG, "Handler started!");</span></div><div class="line">    <span class="comment">//}</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">        <span class="keyword">switch</span> (msg.what) {</div><div class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: {</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                        TAG, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</div><div class="line">                processNextBroadcast(<span class="keyword">true</span>);</div><div class="line">            } <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: {</div><div class="line">                <span class="keyword">synchronized</span> (mService) {</div><div class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</div><div class="line">                }</div><div class="line">            } <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></pre></td></tr></table></figure>

<p>最后执行操作是由 processNextBroadcast 这个函数来完成的。这个函数非常的长（将近 500 行），我们得分功能一段一段来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {</div><div class="line">            BroadcastRecord r;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"processNextBroadcast ["</span></div><div class="line">                    + mQueueName + <span class="string">"]: "</span></div><div class="line">                    + mParallelBroadcasts.size() + <span class="string">" broadcasts, "</span></div><div class="line">                    + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</div><div class="line"></div><div class="line">            mService.updateCpuStats();</div><div class="line"></div><div class="line">            <span class="comment">// 如果从 scheduleBroadcastsLocked 发 Handler 过来的，</span></div><div class="line">            <span class="comment">// 这里就把正在执行的标志设置为 false 了。</span></div><div class="line">            <span class="comment">// Handler 处理了一个就可以让下一个在 Handler 的消息队列里面排队了</span></div><div class="line">            <span class="keyword">if</span> (fromMsg) {</div><div class="line">                mBroadcastsScheduled = <span class="keyword">false</span>;</div><div class="line">            }    </div><div class="line"></div><div class="line">            <span class="comment">// 这里一个循环把并行广播列表中的广播记录全部处理了</span></div><div class="line">            <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></div><div class="line">            <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) { </div><div class="line">                r = mParallelBroadcasts.remove(<span class="number">0</span>);</div><div class="line">                r.dispatchTime = SystemClock.uptimeMillis();</div><div class="line">                r.dispatchClockTime = System.currentTimeMillis();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Processing parallel broadcast ["</span></div><div class="line">                        + mQueueName + <span class="string">"] "</span> + r);</div><div class="line">                <span class="comment">// 一个广播会有多个接收器（前面 AMS 收集的 List），一个一个的分发</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                    Object target = r.receivers.get(i);</div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG,</div><div class="line">                            <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></div><div class="line">                            + target + <span class="string">": "</span> + r);</div><div class="line">                    <span class="comment">// 分发广播给接收器</span></div><div class="line">                    <span class="comment">// 看样子在并行列表里面的必须是动态注册的，因为这里写死认为是 BroadcastFilter 了</span></div><div class="line">                    <span class="comment">// 静态注册的是 ResolveInfo</span></div><div class="line">                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</div><div class="line">                }    </div><div class="line">                addBroadcastToHistoryLocked(r);</div><div class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Done with parallel broadcast ["</span></div><div class="line">                        + mQueueName + <span class="string">"] "</span> + r);</div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接下去看 deliverToRegisteredReceiverLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span>(BroadcastRecord r,</div><div class="line">        BroadcastFilter filter, <span class="keyword">boolean</span> ordered) {</div><div class="line">    <span class="comment">// 权限检测，有些广播只能有权限的接收器（进程）才能接收的</span></div><div class="line">    <span class="comment">// 我们先不管这些</span></div><div class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(filter.requiredPermission,</div><div class="line">                r.callingPid, r.callingUid, -<span class="number">1</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">            Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></div><div class="line">                    + r.intent.toString()</div><div class="line">                    + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></div><div class="line">                    + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></div><div class="line">                    + <span class="string">" requires "</span> + filter.requiredPermission</div><div class="line">                    + <span class="string">" due to registered receiver "</span> + filter);</div><div class="line">            skip = <span class="keyword">true</span>;</div><div class="line">        }    </div><div class="line">    }    </div><div class="line">    <span class="keyword">if</span> (!skip && r.requiredPermission != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(r.requiredPermission,</div><div class="line">                filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">            Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></div><div class="line">                    + r.intent.toString()</div><div class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</div><div class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</div><div class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></div><div class="line">                    + <span class="string">" requires "</span> + r.requiredPermission</div><div class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</div><div class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</div><div class="line">            skip = <span class="keyword">true</span>;</div><div class="line">        }    </div><div class="line">    }   </div><div class="line"></div><div class="line">    <span class="comment">// 我们就当有权限的情况</span></div><div class="line">    <span class="keyword">if</span> (!skip) {</div><div class="line">        <span class="comment">// 串行广播好像会保持原来的什么状态，先不管这个先</span></div><div class="line">        <span class="comment">// If this is not being sent as an ordered broadcast, then we</span></div><div class="line">        <span class="comment">// don't want to touch the fields that keep track of the current</span></div><div class="line">        <span class="comment">// state of ordered broadcasts.</span></div><div class="line">        <span class="keyword">if</span> (ordered) {</div><div class="line">            r.receiver = filter.receiverList.receiver.asBinder();</div><div class="line">            r.curFilter = filter;</div><div class="line">            filter.receiverList.curBroadcast = r; </div><div class="line">            r.state = BroadcastRecord.CALL_IN_RECEIVE;</div><div class="line">            <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// Bump hosting application to no longer be in background</span></div><div class="line">                <span class="comment">// scheduling class.  Note that we can't do that if there</span></div><div class="line">                <span class="comment">// isn't an app...  but we can only be in that case for</span></div><div class="line">                <span class="comment">// things that directly call the IActivityManager API, which</span></div><div class="line">                <span class="comment">// are already core system stuff so don't matter for this.</span></div><div class="line">                r.curApp = filter.receiverList.app;</div><div class="line">                filter.receiverList.app.curReceiver = r;</div><div class="line">                mService.updateOomAdjLocked();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) {</div><div class="line">                <span class="keyword">int</span> seq = r.intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">                Slog.i(TAG, <span class="string">"Delivering to "</span> + filter</div><div class="line">                        + <span class="string">" (seq="</span> + seq + <span class="string">"): "</span> + r);</div><div class="line">            }</div><div class="line">            <span class="comment">// 这个才是真正的执行操作</span></div><div class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</div><div class="line">                <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData,</div><div class="line">                r.resultExtras, r.ordered, r.initialSticky, r.userId);</div><div class="line">            <span class="keyword">if</span> (ordered) {</div><div class="line">                r.state = BroadcastRecord.CALL_DONE_RECEIVE;</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">            Slog.w(TAG, <span class="string">"Failure sending broadcast "</span> + r.intent, e);</div><div class="line">            <span class="keyword">if</span> (ordered) {</div><div class="line">                r.receiver = <span class="keyword">null</span>;</div><div class="line">                r.curFilter = <span class="keyword">null</span>;</div><div class="line">                filter.receiverList.curBroadcast = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) {</div><div class="line">                    filter.receiverList.app.curReceiver = <span class="keyword">null</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个分发函数把前面的权限检测和那个串行处理忽略掉之后，就剩下 performReceiveLocked 这个处理了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performReceiveLocked</span>(ProcessRecord app, IIntentReceiver receiver,</div><div class="line">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</div><div class="line">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></div><div class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> && app.thread != <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// If we have an app thread, do the call through that so it is</span></div><div class="line">        <span class="comment">// correctly ordered with other one-way calls.</span></div><div class="line">        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class="line">                data, extras, ordered, sticky, sendingUser);</div><div class="line">    } <span class="keyword">else</span> {    </div><div class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class="line">                sticky, sendingUser);</div><div class="line">    }   </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里首先，我们复习下传过来的参数： ProcessRecord 是动态注册的时候构造 ReceiverList 保存的接收器注册者的进程记录信息；IIntentReceiver 这个东西也是在动态注册的时候构造 BroadcastFilter 保存的接收器注册者的 LoadedApk.ReceiverDispatcher.InnerReceiver 这个对象的 Bp 端（这个的 Bn 端就有接收器最终的 onReceiver 回调，忘记了去注册篇复习下）。这里虽然分了2种情况：</p>
<ol>
<li>接收器进程还在运行（app != null &amp;&amp; app.thread != null）</li>
<li>接收器进程已经挂了</li>
</ol>
<p>我个人认为正常情况，只有会第一种，第二种是不会有的，就算有这次的广播也无法正常发送。为什么呢，下面来解释一下（这里我没做验证，是光看代码的，但是感觉应该没错）：</p>
<p>第一，如果发生了第二种情况，IIntentReceiver 这个接口的实现是用 aidl 弄的，自己去 out 下翻一下，会发现这个接口没有判断 Bn 不在的情况下，启动进程的情况，也就是说如果接收器进程挂了，调用这个 IPC 接口，根本不会重新启动接收器进程。那就是说这种情况下 IPC 通信是会失败的，因为 Bn 没了。</p>
<p>第二，其实正常情况下，上面那种情况不会出现。去注册篇仔细看下 AMS 的 registerReceiver 注册了一个 IIntentReceiver 的死亡通知回调：</p>
<pre>
receiver.asBinder().linkToDeath(rl, 0);
</pre>

<p>当动态动态的接收器进程挂了，会调用这个一个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class ReceiverList extends ArrayList&lt;BroadcastFilter&gt;</div><div class="line">        implements IBinder.DeathRecipient {</div><div class="line">    <span class="keyword">final</span> ActivityManagerService owner;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IIntentReceiver receiver;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span>() {</div><div class="line">        linkedToDeath = <span class="keyword">false</span>;</div><div class="line">        owner.unregisterReceiver(receiver);</div><div class="line">    }</div><div class="line"></div><div class="line">... ....</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>就相当于如果动态注册的接收器进程挂了，AMS 会自动注销它的，我们稍微看下 AMS 的 unregisterReceiver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span>(IIntentReceiver receiver) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Unregister receiver: "</span> + receiver);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> { </div><div class="line">        <span class="keyword">boolean</span> doTrim = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">            ReceiverList rl</div><div class="line">            = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</div><div class="line">            <span class="keyword">if</span> (rl != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// 这里是后面串行广播处理相关的，这里可以不用管先</span></div><div class="line">                <span class="keyword">if</span> (rl.curBroadcast != <span class="keyword">null</span>) {</div><div class="line">                    BroadcastRecord r = rl.curBroadcast;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> doNext = finishReceiverLocked(</div><div class="line">                            receiver.asBinder(), r.resultCode, r.resultData,</div><div class="line">                            r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">if</span> (doNext) {</div><div class="line">                        doTrim = <span class="keyword">true</span>; </div><div class="line">                        r.queue.processNextBroadcast(<span class="keyword">false</span>);</div><div class="line">                    }     </div><div class="line">                }     </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) {</div><div class="line">                    rl.app.receivers.remove(rl);</div><div class="line">                }     </div><div class="line">                <span class="comment">// 接下去看下这个 remove 函数</span></div><div class="line">                removeReceiverLocked(rl);</div><div class="line">                <span class="keyword">if</span> (rl.linkedToDeath) {</div><div class="line">                    rl.linkedToDeath = <span class="keyword">false</span>;</div><div class="line">                    rl.receiver.asBinder().unlinkToDeath(rl, <span class="number">0</span>);</div><div class="line">                }     </div><div class="line">            }     </div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="comment">// If we actually concluded any broadcasts, we might now be able</span></div><div class="line">        <span class="comment">// to trim the recipients' apps from our working set</span></div><div class="line">        <span class="keyword">if</span> (doTrim) {</div><div class="line">            trimApplications();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> removeReceiverLocked(ReceiverList rl) {</div><div class="line">    mRegisteredReceivers.remove(rl.receiver.asBinder());</div><div class="line">    <span class="keyword">int</span> N = rl.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">        <span class="comment">// 调用 IntentResolver 的 removeFilter 去删除</span></div><div class="line">        <span class="comment">// 和 addFilter 对应的，这里不多分析这个了，</span></div><div class="line">        <span class="comment">// 反正就是删掉之后，查询的时候就查不到这个接收器的 filter 了</span></div><div class="line">        mReceiverResolver.removeFilter(rl.get(i));</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>所以说正常情况下，动态注册的接收器进程挂了，broadcastIntentLocked 的时候根本就查询不到有这个接收器的。所以第二种情况基本上不会发生吧。这里我们直接看第一种情况，就是接收器进程正在运行（这才是正常情况，要不然怎么叫动态注册咧）。这个时候就可以直接调用 IApplicationThread 的 scheduleRegisteredReceiver 函数执行接收器函数。看这个名字就知道 IPC 调用了，这个是当然的，接收器在另外的进程里面（广播处理的是在 AMS 中，system_server 进程）。然后我们去 Bn 端看看（这个时候我们是在接收器的进程了，）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ================== ActivityThread.java =======================</span></div><div class="line"></div><div class="line">    <span class="comment">// 看这个继承类的名字，没有用 aidl，Bp 和 Interface 实现都是自己写的</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// This function exists to make sure all receiver dispatching is</span></div><div class="line">        <span class="comment">// correctly ordered, since these are one-way calls and the binder driver</span></div><div class="line">        <span class="comment">// applies transaction ordering per object for such calls.</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span>(IIntentReceiver receiver, Intent intent,</div><div class="line">                <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</div><div class="line">                <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) <span class="keyword">throws</span> RemoteException {</div><div class="line">            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class="line">                    sticky, sendingUser);</div><div class="line">        }  </div><div class="line"></div><div class="line">... ... </div><div class="line">                </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>IIntentReceiver 再经过 IPC 传到接收器进程，已经是 Bn 端了，我们终于可以去看注册篇里面那个 LoadedApk 的内部类的内部类的 InnerReceiver 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> class InnerReceiver extends IIntentReceiver.Stub { </div><div class="line">    <span class="keyword">final</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</div><div class="line">    <span class="keyword">final</span> LoadedApk.ReceiverDispatcher mStrongRef;</div><div class="line"></div><div class="line">    InnerReceiver(LoadedApk.ReceiverDispatcher rd, <span class="keyword">boolean</span> strong) {</div><div class="line">        mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</div><div class="line">        mStrongRef = strong ? rd : <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span>(Intent intent, <span class="keyword">int</span> resultCode, String data,</div><div class="line">            Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">        LoadedApk.ReceiverDispatcher rd = mDispatcher.get();</div><div class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) {</div><div class="line">            <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>); </div><div class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Receiving broadcast "</span> + intent.getAction() + <span class="string">" seq="</span> + seq</div><div class="line">                    + <span class="string">" to "</span> + (rd != <span class="keyword">null</span> ? rd.mReceiver : <span class="keyword">null</span>));</div><div class="line">        }</div><div class="line">        <span class="comment">// 还得绕一下</span></div><div class="line">        <span class="keyword">if</span> (rd != <span class="keyword">null</span>) {              </div><div class="line">            rd.performReceive(intent, resultCode, data, extras,</div><div class="line">                    ordered, sticky, sendingUser); </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// 看注释，可能在 AMS 分发广播给这个接收器之前，这个接收器就被注销了</span></div><div class="line">            <span class="comment">// 所以这里发送完成消息，注意这个完成消息对于串行广播的处理很关键的</span></div><div class="line">            <span class="comment">// The activity manager dispatched a broadcast to a registered</span></div><div class="line">            <span class="comment">// receiver in this process, but before it could be delivered the</span></div><div class="line">            <span class="comment">// receiver was unregistered.  Acknowledge the broadcast on its</span></div><div class="line">            <span class="comment">// behalf so that the system's broadcast sequence can continue.</span></div><div class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing broadcast to unregistered receiver"</span>);</div><div class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="keyword">if</span> (extras != <span class="keyword">null</span>) {          </div><div class="line">                    extras.setAllowFds(<span class="keyword">false</span>);     </div><div class="line">                }</div><div class="line">                mgr.finishReceiver(<span class="keyword">this</span>, resultCode, data, extras, <span class="keyword">false</span>);</div><div class="line">            } <span class="keyword">catch</span> (RemoteException e) {  </div><div class="line">                Slog.w(ActivityThread.TAG, <span class="string">"Couldn't finish broadcast to unregistered receiver"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里继续去看 LoadedApk.ReceiverDispatcher 的 performReceive：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span>(Intent intent, <span class="keyword">int</span> resultCode, String data,</div><div class="line">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) {</div><div class="line">        <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>); </div><div class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Enqueueing broadcast "</span> + intent.getAction() + <span class="string">" seq="</span> + seq</div><div class="line">                + <span class="string">" to "</span> + mReceiver);         </div><div class="line">    }</div><div class="line">    <span class="comment">// 这里 post 了一个 Runnable（Args 实现了 Runnable）</span></div><div class="line">    Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</div><div class="line">            sticky, sendingUser);          </div><div class="line">    <span class="keyword">if</span> (!mActivityThread.post(args)) {</div><div class="line">        <span class="keyword">if</span> (mRegistered && ordered) {  </div><div class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</div><div class="line">            <span class="comment">// 对于注册的接收器并且是串行广播的话</span></div><div class="line">            <span class="comment">// 如果 post 失败，发送完成消息，前面说这个对于串行广播很关键的</span></div><div class="line">            args.sendFinished(mgr);        </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>还记得注册篇中注册的接口时候有一个 Handler 的可选参数的么，那个是可以让调用者指定接收器运行的线程（Handler 所运行的线程，如果没指定的话，默认使用调用者所在进程的主线程）。这个 mActivityThread 就是保存了注册时候的那个 Handler：</p>
<pre>
final Handler mActivityThread; 
</pre>

<p>叫 mActivityThread 其实是一个 Handler，所以这里其实是<strong>把接收器扔到注册的时候指定的线程去执行去了</strong>。然后我们接下去看 Args 这个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 果然是实现了 Runnable</span></div><div class="line"><span class="keyword">final</span> class Args extends BroadcastReceiver.PendingResult implements Runnable {</div><div class="line">    <span class="keyword">private</span> Intent mCurIntent;     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mOrdered;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Args</span>(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser) {</div><div class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras,</div><div class="line">                mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED,</div><div class="line">                ordered, sticky, mIIntentReceiver.asBinder(), sendingUser);</div><div class="line">        mCurIntent = intent;           </div><div class="line">        mOrdered = ordered;            </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {            </div><div class="line">        <span class="comment">// Args 是 LoadedApk.ReceiverDispatcher 的内部类</span></div><div class="line">        <span class="comment">// 这个 mReceiver 就是当初注册接收器的时候 new LoadedApk.ReceiverDispatcher </span></div><div class="line">        <span class="comment">// 保存传过来的 BroadcastRecevier 对象</span></div><div class="line">        <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) {</div><div class="line">            <span class="keyword">int</span> seq = mCurIntent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Dispatching broadcast "</span> + mCurIntent.getAction()</div><div class="line">                    + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</div><div class="line">            Slog.i(ActivityThread.TAG, <span class="string">"  mRegistered="</span> + mRegistered </div><div class="line">                    + <span class="string">" mOrderedHint="</span> + ordered); </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        <span class="keyword">final</span> Intent intent = mCurIntent;</div><div class="line">        mCurIntent = <span class="keyword">null</span>;             </div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || mForgotten) {</div><div class="line">            <span class="keyword">if</span> (mRegistered && ordered) {</div><div class="line">                <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                        <span class="string">"Finishing null broadcast to "</span> + mReceiver);</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveReg"</span>);</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 暂时没明白这里保存接收器的 ClassLoader 有什么用</span></div><div class="line">            <span class="comment">// 可能要 new 什么东西出来吧，这里先不管这么多了</span></div><div class="line">            ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class="line">            intent.setExtrasClassLoader(cl);</div><div class="line">            setExtrasClassLoader(cl);</div><div class="line">            <span class="comment">// 广播好像可以带返回信息的，这里也先不管先</span></div><div class="line">            receiver.setPendingResult(<span class="keyword">this</span>);</div><div class="line">            <span class="comment">// 反正最后终于调用到接收器的 onReceive 了</span></div><div class="line">            receiver.onReceive(mContext, intent);</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            <span class="comment">// 如果前面执行出了什么异常，记得要发送完成信息</span></div><div class="line">            <span class="keyword">if</span> (mRegistered && ordered) {</div><div class="line">                <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                        <span class="string">"Finishing failed broadcast to "</span> + mReceiver);</div><div class="line">                sendFinished(mgr);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</div><div class="line">                    !mInstrumentation.onException(mReceiver, e)) {</div><div class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Error receiving broadcast "</span> + intent</div><div class="line">                    + <span class="string">" in "</span> + mReceiver, e);</div><div class="line">            } </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) {</div><div class="line">            finish();</div><div class="line">        }</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">    }               </div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>LoadedApk.ReceiverDispatcher 的 mReceiver 就是注册广播接收器的时候 new LoadedApk.ReceiverDispatcher 传进来那个 BroadcastReceiver 对象（忘记的回去注册篇看看）。这里在执行的线程中跑 run 函数，最终调用到了注册者实现的 BroadcastReceiver 的 onReceive 回调。到这里一个动态注册的广播接收器就算处理完成了。</p>
<p>这里回到前面 performReceive 的 mActivityThread.post 那里。前面说了现在是处理并行广播，怎么体现出来是并行的咧。再回去远一点，从接收器进程回到 AMS 的 processNextBroadcast 的那个 while 循环那里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {</div><div class="line">            <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) { </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</div><div class="line">                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</div><div class="line">                }    </div><div class="line">            }</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>因为 performReceive 那里是 post 了一个 Runnable（LoadedApk.ReceiverDispatcher.Args）到一个 Handler 中，所以会马上返回（不会等待接收器的执行），所以 IPC 也会马上从接收器进程返回到 AMS 这边，所以 while（for）循环就会继续往下执行下一个接收器的处理。从精确的角度说虽然还是会有先后，但是广播这的东西本身不是什么太精准的东西，所以约等于是并行处理了。</p>
<p>这里我们从 processNextBroadcast 分段那里直接返回，因为后面是串行广播的处理（静态注册的接收器），然后我们就可以回到 AMS 的 broadcastIntentLocked 继续往下走了。</p>
<h2 id="c-_分发广播给静态注册接收器">c. 分发广播给静态注册接收器</h2>
<p>我们接着往下看 broadcastIntentLocked，下面是这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里是将前面还没处理的动态接收器和静态接收器合并为一个接收器列表</span></div><div class="line"><span class="comment">// 这里是合并到 receivers（之前是收集了静态的接收器）</span></div><div class="line"><span class="comment">// 这里知道为什么 receivers 要声明为 List 了，因为里面可能存2种类型的数据</span></div><div class="line"><span class="comment">// Merge into one list.</span></div><div class="line"><span class="keyword">int</span> ir = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (receivers != <span class="keyword">null</span>) {</div><div class="line">    <span class="comment">// 这段是说，如果一个应该刚安装上，还没被用户运行，那么将它静态注册的接收器排除掉</span></div><div class="line">    <span class="comment">// 这么做的目的是防止应用一刚装上就能够接收广播，然后被偷偷摸摸的启动起来</span></div><div class="line">    <span class="comment">// 可以预防一些恶意软件偷偷摸摸干坏事</span></div><div class="line">    <span class="comment">// A special case for PACKAGE_ADDED: do not allow the package</span></div><div class="line">    <span class="comment">// being added to see this broadcast.  This prevents them from</span></div><div class="line">    <span class="comment">// using this as a back door to get run as soon as they are</span></div><div class="line">    <span class="comment">// installed.  Maybe in the future we want to have a special install</span></div><div class="line">    <span class="comment">// broadcast or such for apps, but we'd like to deliberately make</span></div><div class="line">    <span class="comment">// this decision.</span></div><div class="line">    String skipPackages[] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</div><div class="line">            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</div><div class="line">            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {</div><div class="line">        Uri data = intent.getData();</div><div class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) {</div><div class="line">            String pkgName = data.getSchemeSpecificPart();</div><div class="line">            <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>) {</div><div class="line">                skipPackages = <span class="keyword">new</span> String[] { pkgName };</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {</div><div class="line">        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (skipPackages != <span class="keyword">null</span> && (skipPackages.length &gt; <span class="number">0</span>)) {</div><div class="line">        <span class="keyword">for</span> (String skipPackage : skipPackages) {</div><div class="line">            <span class="keyword">if</span> (skipPackage != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">int</span> NT = receivers.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> it=<span class="number">0</span>; it&lt;NT; it++) {</div><div class="line">                    ResolveInfo curt = (ResolveInfo)receivers.get(it);</div><div class="line">                    <span class="keyword">if</span> (curt.activityInfo.packageName.equals(skipPackage)) {</div><div class="line">                        receivers.remove(it);</div><div class="line">                        it--;</div><div class="line">                        NT--;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 下面这段是取前面剩下的动态注册的接收器。为什么说剩下，因为前面如果动态注册的接收器处理了，</span></div><div class="line">    <span class="comment">// NR 是 0，registeredReceivers 也会变成 null。</span></div><div class="line">    <span class="comment">// 但是如果发送的是串行广播，那前面处理动态注册接收器的并行处理就不会执行，</span></div><div class="line">    <span class="comment">// 动态注册的接收器就只能留到下面和静态注册的接收一起串行处理进行。</span></div><div class="line">    <span class="keyword">int</span> NT = receivers != <span class="keyword">null</span> ? receivers.size() : <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> it = <span class="number">0</span>;</div><div class="line">    ResolveInfo curt = <span class="keyword">null</span>;</div><div class="line">    BroadcastFilter curr = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (it &lt; NT && ir &lt; NR) {</div><div class="line">        <span class="keyword">if</span> (curt == <span class="keyword">null</span>) {</div><div class="line">            curt = (ResolveInfo)receivers.get(it);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (curr == <span class="keyword">null</span>) {</div><div class="line">            curr = registeredReceivers.get(ir);</div><div class="line">        }</div><div class="line">        <span class="comment">// 这里判断一下剩下的动态注册的接收器的优先级是否比静态注册的要高</span></div><div class="line">        <span class="comment">// 如果高的话，就插到 list 的前面， it 计数是从 0 开始的。</span></div><div class="line">        <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) {</div><div class="line">            <span class="comment">// Insert this broadcast record into the final list.</span></div><div class="line">            receivers.add(it, curr);</div><div class="line">            ir++;</div><div class="line">            curr = <span class="keyword">null</span>;</div><div class="line">            it++;</div><div class="line">            NT++;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// Skip to the next ResolveInfo in the final list.</span></div><div class="line">            it++;</div><div class="line">            curt = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// 经过上面的筛选，剩下的动态注册的接收器优先级都是没静态注册的优先级高的，</span></div><div class="line"><span class="comment">// 全部插到 list 的最后。</span></div><div class="line"><span class="keyword">while</span> (ir &lt; NR) {</div><div class="line">    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) {</div><div class="line">        receivers = <span class="keyword">new</span> ArrayList();</div><div class="line">    }</div><div class="line">    receivers.add(registeredReceivers.get(ir));</div><div class="line">    ir++;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这段就是将剩下还没处理的动态注册的接收器合并到静态注册接收器的 list 里面去了，然后下面是 broadcastIntentLocked 的最后一段，串行处理静态注册接收器（包括强制发串行广播的动态注册的接收器）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span>(ProcessRecord callerApp,</div><div class="line">            String callerPackage, Intent intent, String resolvedType,</div><div class="line">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">            Bundle map, String requiredPermission,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</div><div class="line">            <span class="keyword">int</span> userId) {</div><div class="line">... ...</div><div class="line">        </div><div class="line">        <span class="comment">// 这段代码和前面处理动态注册接收器那几乎是一样的 ... ...</span></div><div class="line">        <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> && receivers.size() &gt; <span class="number">0</span>)</div><div class="line">                || resultTo != <span class="keyword">null</span>) {</div><div class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">            <span class="comment">// 区别一：这里传给 BroadcastRecord 是 receivers（合并过的接收器列表，可以说是静态接收器吧）</span></div><div class="line">            <span class="comment">// 前面是 registeredReceivers，动态注册接收器</span></div><div class="line">            BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</div><div class="line">                    callerPackage, callingPid, callingUid, requiredPermission,</div><div class="line">                    receivers, resultTo, resultCode, resultData, map, ordered,</div><div class="line">                    sticky, <span class="keyword">false</span>, userId);</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</div><div class="line">                    TAG, <span class="string">"Enqueueing ordered broadcast "</span> + r</div><div class="line">                    + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) {</div><div class="line">                <span class="keyword">int</span> seq = r.intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">                Slog.i(TAG, <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction() + <span class="string">" seq="</span> + seq);</div><div class="line">            }</div><div class="line">            <span class="keyword">boolean</span> replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);</div><div class="line">            <span class="keyword">if</span> (!replaced) {</div><div class="line">                <span class="comment">// 区别二：前面是插入并行队列，这里是串行队列</span></div><div class="line">                queue.enqueueOrderedBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里唯一和前面的区别就是处理的接收器的列表不一样，然后在 BroadcastQueue 中排队的队列也不一样。我们可以直接跳到前面的 processNextBroadcast 返回那里（前面那些流程都是一样的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Now take care of the next serialized one...</span></div><div class="line"></div><div class="line"><span class="comment">// 看到这个 Pending 命名的是不是有点眼熟，去看下 Binder 普通服务对象篇，</span></div><div class="line"><span class="comment">// 目标进程没启动，就是使用了一个叫 mPendingService 的来保存需要等待目标</span></div><div class="line"><span class="comment">// 进程启动来做一些事情的。这里也是一样的，不过这里留到后面去分析</span></div><div class="line"><span class="comment">// If we are waiting for a process to come up to handle the next</span></div><div class="line"><span class="comment">// broadcast, then do nothing at this point.  Just in case, we</span></div><div class="line"><span class="comment">// check that the process we're waiting for still exists.</span></div><div class="line"><span class="keyword">if</span> (mPendingBroadcast != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) {</div><div class="line">        Slog.v(TAG, <span class="string">"processNextBroadcast ["</span></div><div class="line">                + mQueueName + <span class="string">"]: waiting for "</span></div><div class="line">                + mPendingBroadcast.curApp);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> isDead;</div><div class="line">    <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) {</div><div class="line">        isDead = (mService.mPidsSelfLocked.get(</div><div class="line">                mPendingBroadcast.curApp.pid) == <span class="keyword">null</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!isDead) {</div><div class="line">        <span class="comment">// It's still alive, so keep waiting</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Slog.w(TAG, <span class="string">"pending app  ["</span></div><div class="line">                + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</div><div class="line">                + <span class="string">" died before responding to broadcast"</span>);</div><div class="line">        mPendingBroadcast.state = BroadcastRecord.IDLE;</div><div class="line">        mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</div><div class="line">        mPendingBroadcast = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> looped = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">do { </div><div class="line">    <span class="comment">// 前面处理并行的不说后面可以直接返回么，就是这个判断了，</span></div><div class="line">    <span class="comment">// 如果串行队列里没数据，就直接 return，不过现在有数据了。</span></div><div class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) { </div><div class="line">        <span class="comment">// No more broadcasts pending, so all done!</span></div><div class="line">        mService.scheduleAppGcsLocked();</div><div class="line">        <span class="keyword">if</span> (looped) {</div><div class="line">            <span class="comment">// If we had finished the last ordered broadcast, then</span></div><div class="line">            <span class="comment">// make sure all processes have correct oom and sched</span></div><div class="line">            <span class="comment">// adjustments.</span></div><div class="line">            mService.updateOomAdjLocked();</div><div class="line">        }    </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }    </div><div class="line">    r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">    <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 下面这段我们留到后面讲串行广播的实现的时候再说</span></div><div class="line">    ... ...</div><div class="line">    </div><div class="line">} <span class="keyword">while</span> (r == <span class="keyword">null</span>);</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的简单过过就行，一些东西我们这里不去深究，继续看下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意这个 nextReceiver++，后面会知道这个的作用</span></div><div class="line"><span class="comment">// Get the next receiver...    </span></div><div class="line"><span class="keyword">int</span> recIdx = r.nextReceiver++; </div><div class="line"></div><div class="line"><span class="comment">// 这里设置接收器接收到广播的时间为当前的系统时间，</span></div><div class="line"><span class="comment">// 然后设置一个超时等待（为什么要设置超时等待后面再说）</span></div><div class="line"><span class="comment">// Keep track of when this receiver started, and make sure there</span></div><div class="line"><span class="comment">// is a timeout message pending to kill it if need be.</span></div><div class="line">r.receiverTime = SystemClock.uptimeMillis();</div><div class="line"><span class="keyword">if</span> (recIdx == <span class="number">0</span>) {</div><div class="line">    r.dispatchTime = r.receiverTime;</div><div class="line">    r.dispatchClockTime = System.currentTimeMillis();</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Processing ordered broadcast ["</span></div><div class="line">            + mQueueName + <span class="string">"] "</span> + r);           </div><div class="line">}</div><div class="line"><span class="comment">// 如果没有设置超时的话，设置一个超时（这个超时的作用后面再说）</span></div><div class="line"><span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) {</div><div class="line">    <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG,</div><div class="line">            <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></div><div class="line">            + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</div><div class="line">    setBroadcastTimeoutLocked(timeoutTime);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面这种情况很简单，其实就是前面的动态注册接收器推迟到这里处理而已。</span></div><div class="line"><span class="comment">// (BroadcastFilter 是动态注册的类型 AMS 里面的，ResolveInfo 是静态的， PMS 里面的)</span></div><div class="line"><span class="comment">// 如果发送串行广播，动态注册接收器就无法并行执行，所以放到这里串行执行。</span></div><div class="line">Object nextReceiver = r.receivers.get(recIdx);</div><div class="line"><span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) {</div><div class="line">    <span class="comment">// Simple case: this is a registered receiver who gets</span></div><div class="line">    <span class="comment">// a direct call.              </span></div><div class="line">    BroadcastFilter filter = (BroadcastFilter)nextReceiver; </div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">            <span class="string">"Delivering ordered ["</span>         </div><div class="line">            + mQueueName + <span class="string">"] to registered "</span></div><div class="line">            + filter + <span class="string">": "</span> + r);                 </div><div class="line">    deliverToRegisteredReceiverLocked(r, filter, r.ordered);</div><div class="line">    <span class="keyword">if</span> (r.receiver == <span class="keyword">null</span> || !r.ordered) {</div><div class="line">        <span class="comment">// The receiver has already finished, so schedule to</span></div><div class="line">        <span class="comment">// process the next one.       </span></div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Quick finishing ["</span></div><div class="line">                + mQueueName + <span class="string">"]: ordered="</span>   </div><div class="line">                + r.ordered + <span class="string">" receiver="</span> + r.receiver);</div><div class="line">        r.state = BroadcastRecord.IDLE;</div><div class="line">        scheduleBroadcastsLocked();</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>到这里其实都还不是静态注册接收器的处理，只是把前面动态注册的接收器串行处理了而已，流程前面说过了。现在我们继续往下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Hard case: need to instantiate the receiver, possibly</span></div><div class="line"><span class="comment">// starting its application process to host it.</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的是静态注册的接收器了，ResolverInfo PMS 中的</span></div><div class="line">ResolveInfo info =</div><div class="line">    (ResolveInfo)nextReceiver;</div><div class="line">ComponentName component = <span class="keyword">new</span> ComponentName(</div><div class="line">        info.activityInfo.applicationInfo.packageName,</div><div class="line">        info.activityInfo.name);</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">int</span> perm = mService.checkComponentPermission(info.activityInfo.permission,</div><div class="line">        r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</div><div class="line">        info.activityInfo.exported);</div><div class="line"><span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">    <span class="keyword">if</span> (!info.activityInfo.exported) {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></div><div class="line">                + r.intent.toString()</div><div class="line">                + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</div><div class="line">                + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></div><div class="line">                + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</div><div class="line">                + <span class="string">" due to receiver "</span> + component.flattenToShortString());</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></div><div class="line">                + r.intent.toString()</div><div class="line">                + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</div><div class="line">                + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></div><div class="line">                + <span class="string">" requires "</span> + info.activityInfo.permission</div><div class="line">                + <span class="string">" due to receiver "</span> + component.flattenToShortString());</div><div class="line">    }</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &&</div><div class="line">    r.requiredPermission != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        perm = AppGlobals.getPackageManager().</div><div class="line">                checkPermission(r.requiredPermission,</div><div class="line">                        info.activityInfo.applicationInfo.packageName);</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        perm = PackageManager.PERMISSION_DENIED;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></div><div class="line">                + r.intent + <span class="string">" to "</span></div><div class="line">                + component.flattenToShortString()</div><div class="line">                + <span class="string">" requires "</span> + r.requiredPermission</div><div class="line">                + <span class="string">" due to sender "</span> + r.callerPackage</div><div class="line">                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</div><div class="line">        skip = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">boolean</span> isSingleton = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">try</span> {</div><div class="line">    isSingleton = mService.isSingleton(info.activityInfo.processName,</div><div class="line">            info.activityInfo.applicationInfo,</div><div class="line">            info.activityInfo.name, info.activityInfo.flags);</div><div class="line">} <span class="keyword">catch</span> (SecurityException e) {</div><div class="line">    Slog.w(TAG, e.getMessage());</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ((info.activityInfo.flags&ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) {</div><div class="line">    <span class="keyword">if</span> (ActivityManager.checkUidPermission(</div><div class="line">            android.Manifest.permission.INTERACT_ACROSS_USERS,</div><div class="line">            info.activityInfo.applicationInfo.uid)</div><div class="line">                    != PackageManager.PERMISSION_GRANTED) {</div><div class="line">        Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</div><div class="line">                + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></div><div class="line">                + android.Manifest.permission.INTERACT_ACROSS_USERS);</div><div class="line">        skip = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> && r.curApp.crashing) {</div><div class="line">    <span class="comment">// If the target process is crashing, just skip it.</span></div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG,</div><div class="line">            <span class="string">"Skipping deliver ordered ["</span></div><div class="line">            + mQueueName + <span class="string">"] "</span> + r + <span class="string">" to "</span> + r.curApp</div><div class="line">            + <span class="string">": process crashing"</span>);</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> (skip) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG,</div><div class="line">            <span class="string">"Skipping delivery of ordered ["</span></div><div class="line">            + mQueueName + <span class="string">"] "</span> + r + <span class="string">" for whatever reason"</span>);</div><div class="line">    r.receiver = <span class="keyword">null</span>;</div><div class="line">    r.curFilter = <span class="keyword">null</span>;</div><div class="line">    r.state = BroadcastRecord.IDLE;</div><div class="line">    scheduleBroadcastsLocked();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面这一段我们也可以简单略过，就是权限检测，检测当前这个接收器有没有权限处理这次的广播，如果没有就忽略这个接收器；还有判断了接收器所在的进程是不是挂掉了，挂掉了也忽略这个接收器。我们接下来继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意一下，这里处理的时候把状态设置为了 APP_RECEIVE</span></div><div class="line">r.state = BroadcastRecord.APP_RECEIVE;</div><div class="line"><span class="comment">// 获取接收器进程信息</span></div><div class="line">String targetProcess = info.activityInfo.processName;</div><div class="line">r.curComponent = component;</div><div class="line"><span class="keyword">if</span> (r.callingUid != Process.SYSTEM_UID && isSingleton) {</div><div class="line">    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, <span class="number">0</span>);</div><div class="line">}</div><div class="line"><span class="comment">// 这个 info 就是 AMS 从 PMS 那查询到匹配的静态注册的接收器的数据结构 ResolveInfo</span></div><div class="line"><span class="comment">// 把这个关键信息保存到 BroadcastRecord 的 curReceiver 中</span></div><div class="line">r.curReceiver = info.activityInfo;</div><div class="line"><span class="keyword">if</span> (DEBUG_MU && r.callingUid &gt; UserHandle.PER_USER_RANGE) {</div><div class="line">    Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></div><div class="line">            + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></div><div class="line">            + info.activityInfo.applicationInfo.uid);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这里估计是禁止去把接收器的 apk 设置为 stop 状态吧</span></div><div class="line"><span class="comment">// Broadcast is being executed, its package can't be stopped.</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</div><div class="line">            r.curComponent.getPackageName(), <span class="keyword">false</span>, UserHandle.getUserId(r.callingUid));</div><div class="line">} <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">} <span class="keyword">catch</span> (IllegalArgumentException e) {</div><div class="line">    Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></div><div class="line">            + r.curComponent.getPackageName() + <span class="string">": "</span> + e);</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>下面就要分2种情况来讨论。还记得 <a href="http://light3moon.com/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递" title="Android Binder 分析——普通服务 Binder 对象的传递" target="_blank" rel="external">Android Binder 分析——普通服务 Binder 对象的传递</a>  中分了3种情况来讨论启动普通应用的服务，这里也是同样的道理。要分为接收器的进程是否已经启动在讨论：</p>
<h3 id="接收器进程已经启动">接收器进程已经启动</h3>
<p>我们先来看简单的情况，接收器的进程已经启动。这种情况不需要等待接收器进程启动，可以直接发起 IPC 调用，在接收器进程中跑处理广播的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 取接收器进程的记录（这个 ProcessRecord 经过 Binder 篇应该不陌生了）</span></div><div class="line"><span class="comment">// Is this receiver's application already running?</span></div><div class="line">ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</div><div class="line">        info.activityInfo.applicationInfo.uid);</div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">if</span> (app != <span class="keyword">null</span> && app.thread != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// 这个 addPackage 有啥用我们先不管</span></div><div class="line">        app.addPackage(info.activityInfo.packageName);</div><div class="line">        <span class="comment">// 到下面这个函数了，然后后面直接返回</span></div><div class="line">        processCurBroadcastLocked(r, app);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">        Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></div><div class="line">              + r.curComponent, e);</div><div class="line">    } <span class="keyword">catch</span> (RuntimeException e) {</div><div class="line">        <span class="comment">// 注意下这里的出错处理也是比较关键的，我们后面再说</span></div><div class="line">        Log.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></div><div class="line">                + r.curComponent + <span class="string">" with "</span> + r.intent, e);</div><div class="line">        <span class="comment">// If some unexpected exception happened, just skip</span></div><div class="line">        <span class="comment">// this broadcast.  At this point we are not in the call</span></div><div class="line">        <span class="comment">// from a client, so throwing an exception out from here</span></div><div class="line">        <span class="comment">// will crash the entire system instead of just whoever</span></div><div class="line">        <span class="comment">// sent the broadcast.</span></div><div class="line">        logBroadcastReceiverDiscardLocked(r);</div><div class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">                r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">        scheduleBroadcastsLocked();</div><div class="line">        <span class="comment">// We need to reset the state if we failed to start the receiver.</span></div><div class="line">        r.state = BroadcastRecord.IDLE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// If a dead object exception was thrown -- fall through to</span></div><div class="line">    <span class="comment">// restart the application.</span></div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们接着去看 processCurBroadcastLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processCurBroadcastLocked</span>(BroadcastRecord r,</div><div class="line">        ProcessRecord app) <span class="keyword">throws</span> RemoteException {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">            <span class="string">"Process cur broadcast "</span> + r + <span class="string">" for app "</span> + app);</div><div class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) {      </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();   </div><div class="line">    }</div><div class="line">    <span class="comment">// 取得接收器进程 IBinder 对象</span></div><div class="line">    r.receiver = app.thread.asBinder();</div><div class="line">    r.curApp = app;</div><div class="line">    app.curReceiver = r;</div><div class="line">    mService.updateLruProcessLocked(app, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Tell the application to launch this receiver.</span></div><div class="line">    r.intent.setComponent(r.curComponent);</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;       </div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG,</div><div class="line">                <span class="string">"Delivering to component "</span> + r.curComponent</div><div class="line">                + <span class="string">": "</span> + r);                                    </div><div class="line">        mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());</div><div class="line">        <span class="comment">// 这个和前面动态注册的调用的 IApplicationThread 接口有点像，但是不是同一个</span></div><div class="line">        <span class="comment">// （动态注册调用的是 scheduleRegisteredReceiver）</span></div><div class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> Intent(r.intent), r.curReceiver,</div><div class="line">                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),</div><div class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId);</div><div class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">                <span class="string">"Process cur broadcast "</span> + r + <span class="string">" DELIVERED for app "</span> + app);</div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        <span class="keyword">if</span> (!started) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">                    <span class="string">"Process cur broadcast "</span> + r + <span class="string">": NOT STARTED!"</span>);</div><div class="line">            r.receiver = <span class="keyword">null</span>;             </div><div class="line">            r.curApp = <span class="keyword">null</span>;               </div><div class="line">            app.curReceiver = <span class="keyword">null</span>;        </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>和前面动态注册的一样，经过 IPC 调用，我们得跑到接收器的进程中去了，还是 ActivityThread.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleReceiver</span>(Intent intent, ActivityInfo info,</div><div class="line">                CompatibilityInfo compatInfo, <span class="keyword">int</span> resultCode, String data, Bundle extras,</div><div class="line">                <span class="keyword">boolean</span> sync, <span class="keyword">int</span> sendingUser) {</div><div class="line">            <span class="comment">// 这里的 ActivityInfo 是 AMS 那里传过来的，是 AMS 从 PMS 那里查询到的</span></div><div class="line">            <span class="comment">// （忘记了的去看看前面的代码）</span></div><div class="line">            <span class="comment">// 然后 new 了一个 ReceiverData 出来，把这个 info 赋值给了 ReceiverData</span></div><div class="line">            ReceiverData r = <span class="keyword">new</span> ReceiverData(intent, resultCode, data, extras,</div><div class="line">                    sync, <span class="keyword">false</span>, mAppThread.asBinder(), sendingUser);</div><div class="line">            r.info = info;</div><div class="line">            r.compatInfo = compatInfo;     </div><div class="line">            queueOrSendMessage(H.RECEIVER, r);</div><div class="line">        }</div><div class="line">... ... </div><div class="line">                </div><div class="line">    }</div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里其实就是用了一个 Handler 又绕了半天，最终的处理函数是 handleReceiver： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>{</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</div><div class="line">    </div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="comment">// if the thread hasn't started yet, we don't have the handler, so just</span></div><div class="line">    <span class="comment">// save the messages until we're ready.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueOrSendMessage</span>(<span class="keyword">int</span> what, Object obj) {</div><div class="line">        queueOrSendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">            </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueOrSendMessage</span>(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2) {</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(</div><div class="line">                TAG, <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what)</div><div class="line">                + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</div><div class="line">            Message msg = Message.obtain();</div><div class="line">            msg.what = what;</div><div class="line">            msg.obj = obj;</div><div class="line">            msg.arg1 = arg1;</div><div class="line">            msg.arg2 = arg2;</div><div class="line">            mH.sendMessage(msg);</div><div class="line">        }   </div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</div><div class="line">... ...</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVER                = <span class="number">113</span>; </div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_SERVICE          = <span class="number">114</span>; </div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</div><div class="line">            <span class="keyword">switch</span> (msg.what) {</div><div class="line">... ...</div><div class="line">                <span class="keyword">case</span> RECEIVER:</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveComp"</span>);</div><div class="line">                    handleReceiver((ReceiverData)msg.obj);</div><div class="line">                    maybeSnapshot();</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">... ...</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&lt;&lt;&lt; done: "</span> + codeToString(msg.what));</div><div class="line">        }</div><div class="line">... ...</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleReceiver</span>(ReceiverData data) {</div><div class="line">        <span class="comment">// If we are getting ready to gc after going to the background, well</span></div><div class="line">        <span class="comment">// we are back active so skip it.</span></div><div class="line">        unscheduleGcIdler();</div><div class="line"></div><div class="line">        String component = data.intent.getComponent().getClassName();</div><div class="line"></div><div class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class="line">                data.info.applicationInfo, data.compatInfo);</div><div class="line"></div><div class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line"></div><div class="line">        BroadcastReceiver receiver;    </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 这里的 ClassLoader 是用来 new BroadcastReceiver 用的</span></div><div class="line">            <span class="comment">// 为什么前面动态注册的接收器通过 IPC 传递过来，然后直接调用，这里的需要 new</span></div><div class="line">            <span class="comment">// 那是因为动态注册的是把 BroadcastReceiver 保存在了 ReceiverDispatcher 中，</span></div><div class="line">            <span class="comment">// 然后 AMS IPC 调到接收器进程这边直接从 ReceiverDispatcher 中取的。</span></div><div class="line">            <span class="comment">// 这里静态注册的，注册进程这边就没有 BroadcastRecevier，所以现在要 new 出来</span></div><div class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class="line">            data.intent.setExtrasClassLoader(cl);</div><div class="line">            data.setExtrasClassLoader(cl); </div><div class="line">            receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</div><div class="line">                    <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent()); </div><div class="line">            <span class="comment">// 注意出错了，又发送 finish 消息</span></div><div class="line">            data.sendFinished(mgr);        </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(    </div><div class="line">                <span class="string">"Unable to instantiate receiver "</span> + component</div><div class="line">                + <span class="string">": "</span> + e.toString(), e);     </div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(         </div><div class="line">                TAG, <span class="string">"Performing receive of "</span> + data.intent</div><div class="line">                + <span class="string">": app="</span> + app               </div><div class="line">                + <span class="string">", appName="</span> + app.getPackageName()</div><div class="line">                + <span class="string">", pkg="</span> + packageInfo.getPackageName() </div><div class="line">                + <span class="string">", comp="</span> + data.intent.getComponent().toShortString()</div><div class="line">                + <span class="string">", dir="</span> + packageInfo.getAppDir());</div><div class="line"></div><div class="line">            ContextImpl context = (ContextImpl)app.getBaseContext();</div><div class="line">            sCurrentBroadcastIntent.set(data.intent);</div><div class="line">            receiver.setPendingResult(data);</div><div class="line">            <span class="comment">// 这里也调用到 BroadcastReceiver 的 onReceive 回调了</span></div><div class="line">            receiver.onReceive(context.getReceiverRestrictedContext(),</div><div class="line">                    data.intent);                  </div><div class="line">        } <span class="keyword">catch</span> (Exception e) {        </div><div class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</div><div class="line">                    <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent());</div><div class="line">            <span class="comment">// 出错还是会发送 finish 消息</span></div><div class="line">            data.sendFinished(mgr);</div><div class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(receiver, e)) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Unable to start receiver "</span> + component</div><div class="line">                    + <span class="string">": "</span> + e.toString(), e);</div><div class="line">            }</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            sCurrentBroadcastIntent.set(<span class="keyword">null</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) {</div><div class="line">            <span class="comment">// 这里很关键，有一个 finish 的调用</span></div><div class="line">            data.finish();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">... ...</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>上面的处理最终调到 onReceiver 了。但是想想看，还是有一个地方没搞明白。前面说了静态注册的接收器是串行执行广播处理的，就是等到当前的那个执行完，才能执行下一个。好了，现在我们来解释下这个串行执行是怎么实现的。回到 AMS 那边的 processNextBroadcast 调用 processCurBroadcastLocked 那里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> {</div><div class="line">    app.addPackage(info.activityInfo.packageName);</div><div class="line">    processCurBroadcastLocked(r, app);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">} <span class="keyword">catch</span></div><div class="line"></div></pre></td></tr></table></figure>

<p>这里就是刚刚我们上面分析的流程，IPC 调用到接收器进程的 onReceive 回调。然后这里 processNextBroadcast 就返回了。AMS 执行 BroadcastQueue.scheduleBroadcastsLocked() 早就返回了，因为 BroadcastQueue 里面是发到 Handler 里面处理 processNextBroadcast 的，然后 processNextBroadcast 结束后， AMS 好像这次广播处理就结束了。可是这才执行了第一个静态注册的接收器而已啊。这个时候去看接收器 handleReceiver 最后有一个：</p>
<pre>
data.finish()
</pre>

<p>这个 finish 是要等到 onReceive 执行完才会调用的（也就是说这个接收器处理完了）。前面说了这个 finish 很关键的，我们来看看 finish 里面做了什么事情。在这里之前得先看看 ReceiverData 这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> class ReceiverData extends BroadcastReceiver.PendingResult {</div><div class="line">    <span class="keyword">public</span> <span class="title">ReceiverData</span>(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</div><div class="line">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, IBinder token, <span class="keyword">int</span> sendingUser) {</div><div class="line">        <span class="comment">// 注意这里传给父类的是 TYPE_COMPONENT</span></div><div class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras, TYPE_COMPONENT, ordered, sticky,</div><div class="line">                token, sendingUser);           </div><div class="line">        <span class="keyword">this</span>.intent = intent;          </div><div class="line">    }</div><div class="line"></div><div class="line">    Intent intent;</div><div class="line">    ActivityInfo info;</div><div class="line">    CompatibilityInfo compatInfo;  </div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {     </div><div class="line">        <span class="keyword">return</span> <span class="string">"ReceiverData{intent="</span> + intent + <span class="string">" packageName="</span> +</div><div class="line">                info.packageName + <span class="string">" resultCode="</span> + getResultCode()</div><div class="line">                + <span class="string">" resultData="</span> + getResultData() + <span class="string">" resultExtras="</span></div><div class="line">                + getResultExtras(<span class="keyword">false</span>) + <span class="string">"}"</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 ReceiverData 是前面 scheduleReceiver 那里 new 出来的，它是继承自 BroadcastReceiver.PendingResult，这得去父类里面去看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Finish the broadcast.  The current result will be sent and the</span></div><div class="line"><span class="comment"> * next broadcast will proceed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finish</span>() {</div><div class="line">    <span class="keyword">if</span> (mType == TYPE_COMPONENT) {</div><div class="line">        <span class="comment">// 这里走的是这里</span></div><div class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        <span class="comment">// 我们先不管下面这个 PendingWork</span></div><div class="line">        <span class="keyword">if</span> (QueuedWork.hasPendingWork()) {</div><div class="line">            <span class="comment">// If this is a broadcast component, we need to make sure any</span></div><div class="line">            <span class="comment">// queued work is complete before telling AM we are done, so</span></div><div class="line">            <span class="comment">// we don't have our process killed before that.  We now know</span></div><div class="line">            <span class="comment">// there is pending work; put another piece of work at the end</span></div><div class="line">            <span class="comment">// of the list to finish the broadcast, so we don't block this</span></div><div class="line">            <span class="comment">// thread (which may be the main thread) to have it finished.</span></div><div class="line">            <span class="comment">//  </span></div><div class="line">            <span class="comment">// Note that we don't need to use QueuedWork.add() with the</span></div><div class="line">            <span class="comment">// runnable, since we know the AM is waiting for us until the</span></div><div class="line">            <span class="comment">// executor gets to it.</span></div><div class="line">            QueuedWork.singleThreadExecutor().execute( <span class="keyword">new</span> Runnable() {</div><div class="line">                <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                            <span class="string">"Finishing broadcast after work to component "</span> + mToken);</div><div class="line">                    Slog.i(ActivityThread.TAG,</div><div class="line">                            <span class="string">"Finishing broadcast after work to component "</span> + mToken);</div><div class="line">                    sendFinished(mgr);</div><div class="line">                }   </div><div class="line">            }); </div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing broadcast to component "</span> + mToken);</div><div class="line">            Slog.i(ActivityThread.TAG,</div><div class="line">                    <span class="string">"Finishing broadcast to component "</span> + mToken);</div><div class="line">            <span class="comment">// 这里最后调用这个函数</span></div><div class="line">            sendFinished(mgr);</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mOrderedHint && mType != TYPE_UNREGISTERED) {</div><div class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                <span class="string">"Finishing broadcast to "</span> + mToken);</div><div class="line">        Slog.i(ActivityThread.TAG,</div><div class="line">                <span class="string">"Finishing broadcast to "</span> + mToken);</div><div class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">        sendFinished(mgr);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>继续去看 sendFinished：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @hide */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFinished</span>(IActivityManager am) {</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">if</span> (mFinished) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Broadcast already finished"</span>);</div><div class="line">        }</div><div class="line">        mFinished = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (mResultExtras != <span class="keyword">null</span>) {</div><div class="line">                mResultExtras.setAllowFds(<span class="keyword">false</span>);</div><div class="line">            }</div><div class="line">            <span class="comment">// 这个 mOrderedHint 如果是串行广播就是 true，这里是 true</span></div><div class="line">            <span class="keyword">if</span> (mOrderedHint) {</div><div class="line">                <span class="comment">// 最后这里果然调用 AMS 里面去了</span></div><div class="line">                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,</div><div class="line">                        mAbortBroadcast);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// This broadcast was sent to a component; it is not ordered,</span></div><div class="line">                <span class="comment">// but we still need to tell the activity manager we are done.</span></div><div class="line">                am.finishReceiver(mToken, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (RemoteException ex) {</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>好，这里接收器进程处理完广播之后，finish 最后有调回 AMS 里面，看到这里是不是猜到了什么呢。对的，没错，串行广播一个接一个的执行是<strong>靠前一个接收器执行完，通知 AMS 把广播发给下一个接收器接着处理来实现的</strong>。虽然猜到了，但是我们还是继续去 AMS 里面看完流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishReceiver</span>(IBinder who, <span class="keyword">int</span> resultCode, String resultData,</div><div class="line">        Bundle resultExtras, <span class="keyword">boolean</span> resultAbort) {</div><div class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Finish receiver: "</span> + who);</div><div class="line"></div><div class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></div><div class="line">    <span class="keyword">if</span> (resultExtras != <span class="keyword">null</span> && resultExtras.hasFileDescriptors()) {  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Bundle"</span>);</div><div class="line">    }   </div><div class="line">    </div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">boolean</span> doNext = <span class="keyword">false</span>;</div><div class="line">        BroadcastRecord r = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) {</div><div class="line">            <span class="comment">// 这里先去取上次处理完的 BroadcastRecord</span></div><div class="line">            r = broadcastRecordForReceiverLocked(who);</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">                <span class="comment">// 这里先调用 BroadcastQueue 的 finishReceiverLocked</span></div><div class="line">                <span class="comment">// 来判断是否需要继续往下处理</span></div><div class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</div><div class="line">                    resultData, resultExtras, resultAbort, <span class="keyword">true</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 如果需要继续处理的话，就调用 BroadcastQueue 的 processNextBroadcast</span></div><div class="line">        <span class="keyword">if</span> (doNext) {</div><div class="line">            <span class="comment">// 注意这里参数是 false</span></div><div class="line">            r.queue.processNextBroadcast(<span class="keyword">false</span>);</div><div class="line">        }</div><div class="line">        trimApplications();</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们先来看看怎么取上次处理完成的 BroadcastRecord 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    BroadcastRecord broadcastRecordForReceiverLocked(IBinder receiver) {</div><div class="line">        <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) {</div><div class="line">            BroadcastRecord r = queue.getMatchingOrderedReceiver(receiver);</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    } </div><div class="line"></div><div class="line"><span class="comment">// ========== BroadcastQueue.java ===============</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> BroadcastRecord <span class="title">getMatchingOrderedReceiver</span>(IBinder receiver) {</div><div class="line">        <span class="comment">// 这里只认串行广播的（并行的并不需要这种处理）</span></div><div class="line">        <span class="keyword">if</span> (mOrderedBroadcasts.size() &gt; <span class="number">0</span>) {</div><div class="line">            <span class="comment">// 这里只认第一个（上一个处理的就是第一个）</span></div><div class="line">            <span class="keyword">final</span> BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">            <span class="comment">// 还是要判断下 IBinder 对象是不是同一个</span></div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> && r.receiver == receiver) {</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>这里取到了上一个接收器的 BroadcastRecord，接着去 BroadcastQueue 中看看 finishReceiverLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span>(BroadcastRecord r, <span class="keyword">int</span> resultCode,</div><div class="line">        String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort,</div><div class="line">        <span class="keyword">boolean</span> explicit) {   </div><div class="line">    <span class="comment">// 这里取上一个接收器的 state         </span></div><div class="line">    <span class="keyword">int</span> state = r.state;</div><div class="line">    <span class="comment">// 然后把 state 设置为 IDLE 状态</span></div><div class="line">    r.state = BroadcastRecord.IDLE;</div><div class="line">    <span class="comment">// 正常来说上一个的 state 应该是 APP_RECEIVE 的</span></div><div class="line">    <span class="comment">// 如果不是的话，说明有异常，打印一下警告</span></div><div class="line">    <span class="keyword">if</span> (state == BroadcastRecord.IDLE) {</div><div class="line">        <span class="keyword">if</span> (explicit) {</div><div class="line">            Slog.w(TAG, <span class="string">"finishReceiver ["</span> + mQueueName + <span class="string">"] called but state is IDLE"</span>); </div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 然后下面基本上都设置为 null</span></div><div class="line">    r.receiver = <span class="keyword">null</span>;</div><div class="line">    r.intent.setComponent(<span class="keyword">null</span>);   </div><div class="line">    <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span>) {        </div><div class="line">        r.curApp.curReceiver = <span class="keyword">null</span>;   </div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (r.curFilter != <span class="keyword">null</span>) {     </div><div class="line">        r.curFilter.receiverList.curBroadcast = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line">    r.curFilter = <span class="keyword">null</span>;</div><div class="line">    r.curApp = <span class="keyword">null</span>;</div><div class="line">    r.curComponent = <span class="keyword">null</span>;</div><div class="line">    r.curReceiver = <span class="keyword">null</span>;</div><div class="line">    mPendingBroadcast = <span class="keyword">null</span>;      </div><div class="line"></div><div class="line">    r.resultCode = resultCode;</div><div class="line">    r.resultData = resultData;</div><div class="line">    r.resultExtras = resultExtras;</div><div class="line">    r.resultAbort = resultAbort;</div><div class="line"></div><div class="line">    <span class="comment">// 最后这里正常来说上一个 state 是 APP_RECEIVE 的，所以一般是返回 true 的</span></div><div class="line">    <span class="comment">// We will process the next receiver right now if this is finishing</span></div><div class="line">    <span class="comment">// an app receiver (which is always asynchronous) or after we have</span></div><div class="line">    <span class="comment">// come back from calling a receiver.</span></div><div class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</div><div class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>这个 BroadcastRecord 的 state，待会我们再讨论。这里正常 finishReceiverLocked 返回 true，就意味着 AMS 会继续调用 BroadcastQueue 的 processNextBroadcast 继续处理。这个 processNextBroadcast 我们前面分析了好久了，不过这里和前面不太一样，首先传过去的参数为 false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> processNextBroadcast(<span class="keyword">boolean</span> fromMsg) {</div><div class="line">        <span class="keyword">synchronized</span>(mService) {       </div><div class="line">            BroadcastRecord r;</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// false 说明不会强制把这个标志设置为 false</span></div><div class="line">            <span class="comment">// 也就是 BroadcastQueue 会继续保持正在执行广播的状态</span></div><div class="line">            <span class="keyword">if</span> (fromMsg) {</div><div class="line">                mBroadcastsScheduled = <span class="keyword">false</span>;  </div><div class="line">            }</div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// Now take care of the next serialized one...</span></div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">            <span class="comment">// 现在我们可以来说说前面略过的这一段了</span></div><div class="line">            do {</div><div class="line">                <span class="comment">// 串行广播列表 size 为0，说明已经没有匹配的接收器了</span></div><div class="line">                <span class="comment">// 可以结束本次广播处理了， return 返回。 </span></div><div class="line">                <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) { </div><div class="line">                    <span class="comment">// No more broadcasts pending, so all done!</span></div><div class="line">                    mService.scheduleAppGcsLocked();</div><div class="line">                    <span class="keyword">if</span> (looped) {</div><div class="line">                        <span class="comment">// If we had finished the last ordered broadcast, then</span></div><div class="line">                        <span class="comment">// make sure all processes have correct oom and sched</span></div><div class="line">                        <span class="comment">// adjustments.</span></div><div class="line">                        mService.updateOomAdjLocked();</div><div class="line">                    }    </div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line">                <span class="comment">// 这里取到的还是上一个处理完的接收器的 BroadcastRecord</span></div><div class="line">                r = mOrderedBroadcasts.get(<span class="number">0</span>);</div><div class="line">                <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 下面这里是判断下这个接收器是不是超时了。</span></div><div class="line">                <span class="comment">// dispatchTime 前面有一个地方记录了广播发到这个接收器的时间。</span></div><div class="line">                <span class="comment">// 然后拿之前记录的时候和现在对比，看是不是超过了特定的时间，</span></div><div class="line">                <span class="comment">// 是的话就执行广播超时处理</span></div><div class="line">                <span class="comment">// Ensure that even if something goes awry with the timeout</span></div><div class="line">                <span class="comment">// detection, we catch "hung" broadcasts here, discard them,</span></div><div class="line">                <span class="comment">// and continue to make progress.</span></div><div class="line">                <span class="comment">//   </span></div><div class="line">                <span class="comment">// This is only done if the system is ready so that PRE_BOOT_COMPLETED</span></div><div class="line">                <span class="comment">// receivers don't get executed with timeouts. They're intended for</span></div><div class="line">                <span class="comment">// one time heavy lifting after system upgrades and can take</span></div><div class="line">                <span class="comment">// significant amounts of time.</span></div><div class="line">                <span class="keyword">int</span> numReceivers = (r.receivers != <span class="keyword">null</span>) ? r.receivers.size() : <span class="number">0</span>; </div><div class="line">                <span class="keyword">if</span> (mService.mProcessesReady && r.dispatchTime &gt; <span class="number">0</span>) { </div><div class="line">                    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                    <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &&</div><div class="line">                            (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) {</div><div class="line">                        Slog.w(TAG, <span class="string">"Hung broadcast ["</span></div><div class="line">                                + mQueueName + <span class="string">"] discarded after timeout failure:"</span></div><div class="line">                                + <span class="string">" now="</span> + now</div><div class="line">                                + <span class="string">" dispatchTime="</span> + r.dispatchTime</div><div class="line">                                + <span class="string">" startTime="</span> + r.receiverTime</div><div class="line">                                + <span class="string">" intent="</span> + r.intent</div><div class="line">                                + <span class="string">" numReceivers="</span> + numReceivers</div><div class="line">                                + <span class="string">" nextReceiver="</span> + r.nextReceiver</div><div class="line">                                + <span class="string">" state="</span> + r.state);</div><div class="line"></div><div class="line">                        broadcastTimeoutLocked(<span class="keyword">false</span>); <span class="comment">// forcibly finish this broadcast</span></div><div class="line">                        forceReceive = <span class="keyword">true</span>;</div><div class="line">                        r.state = BroadcastRecord.IDLE;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                </div><div class="line">                <span class="comment">// BroadcastRecord 初始 state 是 IDLE，后面接到广播的时候会变成 APP_RECEIVE</span></div><div class="line">                <span class="comment">// 最后完成的时候（finishReceiver）又会变成 IDLE。</span></div><div class="line">                <span class="comment">// 这里如果不是 IDLE 的话，说明状态异常</span></div><div class="line">                <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) {</div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG,</div><div class="line">                            <span class="string">"processNextBroadcast("</span></div><div class="line">                            + mQueueName + <span class="string">") called when not idle (state="</span></div><div class="line">                            + r.state + <span class="string">")"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// 这里是判断的关键，numReceivers 上面取的这个 BroadcastRecord 的 receiver list 有多少个 receiver。</span></div><div class="line">                <span class="comment">// BroadcastRecord 的 nextReceiver 初始值是 0，下面处理一个 receiver 会加 1</span></div><div class="line">                <span class="comment">// 然后我们这里以 receiver list 1 为例子，那么这个 BroadcastRecord 处理完一次后，</span></div><div class="line">                <span class="comment">// r.nextReceiver &gt;= numReceivers 这个判断就会成立，就会跑下面的代码</span></div><div class="line">                <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</div><div class="line">                        || r.resultAbort || forceReceive) {</div><div class="line">                    <span class="comment">// No more receivers for this broadcast!  Send the final</span></div><div class="line">                    <span class="comment">// result if requested...</span></div><div class="line">                    <span class="comment">// 我们先不管带返回信息的广播</span></div><div class="line">                    <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) {</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            <span class="keyword">if</span> (DEBUG_BROADCAST) {</div><div class="line">                                <span class="keyword">int</span> seq = r.intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</div><div class="line">                                Slog.i(TAG, <span class="string">"Finishing broadcast ["</span></div><div class="line">                                        + mQueueName + <span class="string">"] "</span> + r.intent.getAction()</div><div class="line">                                        + <span class="string">" seq="</span> + seq + <span class="string">" app="</span> + r.callerApp);</div><div class="line">                            }</div><div class="line">                            performReceiveLocked(r.callerApp, r.resultTo,</div><div class="line">                                <span class="keyword">new</span> Intent(r.intent), r.resultCode,</div><div class="line">                                r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</div><div class="line">                            <span class="comment">// Set this to null so that the reference</span></div><div class="line">                            <span class="comment">// (local and remote) isnt kept in the mBroadcastHistory.</span></div><div class="line">                            r.resultTo = <span class="keyword">null</span>;</div><div class="line">                        } <span class="keyword">catch</span> (RemoteException e) {</div><div class="line">                            Slog.w(TAG, <span class="string">"Failure ["</span></div><div class="line">                                    + mQueueName + <span class="string">"] sending broadcast result of "</span></div><div class="line">                                    + r.intent, e);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="comment">// 这里上一个接收器算是正式处理完了，所以把上次设置的超时取消掉（到下一个接收器重新设一个）</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG, <span class="string">"Cancelling BROADCAST_TIMEOUT_MSG"</span>);</div><div class="line">                    cancelBroadcastTimeoutLocked();</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG, <span class="string">"Finished with ordered broadcast "</span></div><div class="line">                            + r);</div><div class="line"></div><div class="line">                    <span class="comment">// ... and on to the next...</span></div><div class="line">                    addBroadcastToHistoryLocked(r);</div><div class="line">                    <span class="comment">// 上一个接收器处理完了，所以就把它从串行列表中删掉</span></div><div class="line">                    mOrderedBroadcasts.remove(<span class="number">0</span>);</div><div class="line">                    r = <span class="keyword">null</span>;</div><div class="line">                    looped = <span class="keyword">true</span>;</div><div class="line">                    <span class="comment">// 结束本循环，去前面取串行队列的下一个 BroadcastRecord</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">            } <span class="keyword">while</span> (r == <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 这里其实应该是上一轮的代码， nextReceiver++（顺带贴这里了）</span></div><div class="line">            <span class="comment">// Get the next receiver...</span></div><div class="line">            <span class="keyword">int</span> recIdx = r.nextReceiver++;</div><div class="line"></div></pre></td></tr></table></figure>

<p>解释基本上代码的注释中，然后贴下 BroadcastRecord 初始化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">BroadcastRecord(BroadcastQueue _queue,</div><div class="line">        Intent _intent, ProcessRecord _callerApp, String _callerPackage,</div><div class="line">        <span class="keyword">int</span> _callingPid, <span class="keyword">int</span> _callingUid, String _requiredPermission,</div><div class="line">        List _receivers, IIntentReceiver _resultTo, <span class="keyword">int</span> _resultCode,</div><div class="line">        String _resultData, Bundle _resultExtras, <span class="keyword">boolean</span> _serialized,</div><div class="line">        <span class="keyword">boolean</span> _sticky, <span class="keyword">boolean</span> _initialSticky,</div><div class="line">        <span class="keyword">int</span> _userId) {</div><div class="line">    queue = _queue;</div><div class="line">    intent = _intent;</div><div class="line">    callerApp = _callerApp;</div><div class="line">    callerPackage = _callerPackage;</div><div class="line">    callingPid = _callingPid;</div><div class="line">    callingUid = _callingUid;</div><div class="line">    requiredPermission = _requiredPermission;</div><div class="line">    receivers = _receivers;</div><div class="line">    resultTo = _resultTo;</div><div class="line">    resultCode = _resultCode;</div><div class="line">    resultData = _resultData;</div><div class="line">    resultExtras = _resultExtras;</div><div class="line">    ordered = _serialized;</div><div class="line">    sticky = _sticky;</div><div class="line">    initialSticky = _initialSticky;</div><div class="line">    userId = _userId;</div><div class="line">    <span class="comment">// 注意下下面这个初始值</span></div><div class="line">    nextReceiver = <span class="number">0</span>;</div><div class="line">    state = IDLE;</div><div class="line">}</div><div class="line"></div></pre></td></tr></table></figure>

<p>APP_RECEIVE 的 state 在静态注册接收器分2种情况讨论那里设置的（文章有点长，有搜索倒回去看看吧）。这个 state 的变化流程是：</p>
<pre>
IDLE(init) --> APP_RECEIVE(handle) --> IDLE(finish)
</pre>

<p>然后后面处理下一个接收器就是和前面一样的了，然后直到 mOrderedBroadcasts 中没有待处理的接收器为止。这样就形成了静态注册接收器一个接一个的处理。不过细心的你应该发现了一点，这种实现有个很不靠谱的地方：那就是它要假设上一个接收器正常完成处理。那么如果上一个接收器在处理的过程中挂掉了，或是在处理的时候耗费了大量时间还没处理，是不是串行广播就没法发送到下一个接收器了呢。这个问题我们留在后面再讨论，我们得继续回去把静态注册接收器的第二种情况讨论完，再说这个问题（不然越扯越远，前面说的什么都忘记了）。</p>
<p>PS：头有点晕的回最开始看一下图。</p>
<h3 id="接收器进程还没启动">接收器进程还没启动</h3>
<p>好现在是比较复杂的情况了，接收器进程还没启动，经过之前 Binder 普通服务篇大致能猜到这里也是发请求给 AMS 去启动指定的进程，然后等待接收器进程启动，再做广播处理。我们先接着看 processNextBroadcast 最后的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not running -- get it started, to be executed when the app comes up.</span></div><div class="line"><span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG, </div><div class="line">        <span class="string">"Need to start app ["</span>          </div><div class="line">        + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</div><div class="line"><span class="comment">// 果然是调用 AMS 去启动目标进程</span></div><div class="line"><span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</div><div class="line">        info.activityInfo.applicationInfo, <span class="keyword">true</span>,</div><div class="line">        r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND, </div><div class="line">        <span class="string">"broadcast"</span>, r.curComponent,   </div><div class="line">        (r.intent.getFlags()&Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>))</div><div class="line">                == <span class="keyword">null</span>) {                     </div><div class="line">    <span class="comment">// Ah, this recipient is unavailable.  Finish it if necessary,</span></div><div class="line">    <span class="comment">// and mark the broadcast record as ready for the next.</span></div><div class="line">    Slog.w(TAG, <span class="string">"Unable to launch app "</span></div><div class="line">            + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></div><div class="line">            + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></div><div class="line">            + r.intent + <span class="string">": process is bad"</span>);</div><div class="line">    logBroadcastReceiverDiscardLocked(r);</div><div class="line">    <span class="comment">// 经过上面的分析，下面这2个函数的调用是结束当前这个接收器的处理接着处理下一个，</span></div><div class="line">    <span class="comment">// 因为如果启动接收器进程失败了，就忽略这个，接着要处理下一个</span></div><div class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</div><div class="line">            r.resultExtras, r.resultAbort, <span class="keyword">true</span>);</div><div class="line">    scheduleBroadcastsLocked();    </div><div class="line">    r.state = BroadcastRecord.IDLE;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这里保存一下等待接收器进程启动的广播对象和索引</span></div><div class="line">mPendingBroadcast = r;         </div><div class="line">mPendingBroadcastRecvIndex = recIdx;</div><div class="line"></div></pre></td></tr></table></figure>

<p>AMS 启动进程的 startProcessLocked 接口这里不再多说，可以去 <a href="http://light3moon.com/2015/01/28/Android Binder 分析——普通服务 Binder 对象的传递/#服务进程没有启动，服务代码也还没执行" title="Binder 普通服务篇的相关章节" target="_blank" rel="external">Binder 普通服务篇的相关章节</a> 看一下。然后后面把当前这一次的 BroadcastRecord 保存到了 mPendingBroadcast 中。这个变量前面有看到过，但是没细说。不过经过 Binder 普通服务篇应该不陌生了，这就是要等候接收器进程启动起来，然后 AMS 接着处理的时候能找回之前等待进程启动的 BroadcastRecord（进程启动最后是会通知 AMS 做一些事情的）。虽然说基本流程我们已经猜得差不多了，但是还是继续把代码看完吧。</p>
<p>上面这里就是 processNextBroadcast 最后的部分了。发送启动接收器进程请求给 AMS 之后，这次的广播处理暂时就完了。然后如果接收器进程正常启动的话那么它的 ActivityThread 会调用 AMS 的 attachApplication：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span>(IApplicationThread thread) {</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity(); </div><div class="line">            attachApplicationLocked(thread, callingPid);</div><div class="line">            Binder.restoreCallingIdentity(origId);</div><div class="line">        }</div><div class="line">    } </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span>(IApplicationThread thread,</div><div class="line">            <span class="keyword">int</span> pid) {</div><div class="line">        </div><div class="line">        <span class="comment">// Find the application record that is being attached...  either via</span></div><div class="line">        <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></div><div class="line">        <span class="comment">// next app record if we are emulating process with anonymous threads.</span></div><div class="line">        ProcessRecord app;</div><div class="line">        <span class="keyword">if</span> (pid != MY_PID && pid &gt;= <span class="number">0</span>) {</div><div class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) {</div><div class="line">                app = mPidsSelfLocked.get(pid);</div><div class="line">            }   </div><div class="line">        } <span class="keyword">else</span> {    </div><div class="line">            app = <span class="keyword">null</span>; </div><div class="line">        }  </div><div class="line"></div><div class="line">... ...</div><div class="line"></div><div class="line">        <span class="comment">// 这里检测下是不是有广播在等待新启动的进程</span></div><div class="line">        <span class="comment">// Check if a next-broadcast receiver is in this process...</span></div><div class="line">        <span class="keyword">if</span> (!badApp && isPendingBroadcastProcessLocked(pid)) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 如果有的话就要继续执行广播处理</span></div><div class="line">                didSomething = sendPendingBroadcastsLocked(app);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></div><div class="line">                badApp = <span class="keyword">true</span>; </div><div class="line">            }     </div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="comment">// Check whether the next backup agent is in this process...</span></div><div class="line">        <span class="keyword">if</span> (!badApp && mBackupTarget != <span class="keyword">null</span> && mBackupTarget.appInfo.uid == app.uid) {</div><div class="line">            <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG, <span class="string">"New app is backup target, launching agent for "</span> + app); </div><div class="line">            ensurePackageDexOpt(mBackupTarget.appInfo.packageName);</div><div class="line">            <span class="keyword">try</span> { </div><div class="line">                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</div><div class="line">                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</div><div class="line">                        mBackupTarget.backupMode);</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                Slog.w(TAG, <span class="string">"Exception scheduling backup agent creation: "</span>);</div><div class="line">                e.printStackTrace();</div><div class="line">            }     </div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (badApp) {</div><div class="line">            <span class="comment">// todo: Also need to kill application to deal with all</span></div><div class="line">            <span class="comment">// kinds of exceptions.</span></div><div class="line">            handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!didSomething) {</div><div class="line">            updateOomAdjLocked();</div><div class="line">        }     </div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>我们来看是怎么检测的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">boolean</span> isPendingBroadcastProcessLocked(<span class="keyword">int</span> pid) {</div><div class="line">        <span class="keyword">return</span> mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid)</div><div class="line">                || mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ============== BroadcastQueue.java ====================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPendingBroadcastProcessLocked</span>(<span class="keyword">int</span> pid) {</div><div class="line">        <span class="keyword">return</span> mPendingBroadcast != <span class="keyword">null</span> && mPendingBroadcast.curApp.pid == pid;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>果然前面保存的 mPendingBroadcast 是要等着后面用的。然后我们继续看 AMS 的 sendPendingBroadcastsLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 这注释已经说得很清楚了</span></div><div class="line">    <span class="comment">// The app just attached; send any pending broadcasts that it should receive</span></div><div class="line">    <span class="keyword">boolean</span> sendPendingBroadcastsLocked(ProcessRecord app) { </div><div class="line">        <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) {</div><div class="line">            didSomething |= queue.sendPendingBroadcastsLocked(app);</div><div class="line">        }   </div><div class="line">        <span class="keyword">return</span> didSomething;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// ============== BroadcastQueue.java ====================</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendPendingBroadcastsLocked</span>(ProcessRecord app) {</div><div class="line">        <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 取之前等待接收器进程启动的 BroadcastRecord</span></div><div class="line">        <span class="keyword">final</span> BroadcastRecord br = mPendingBroadcast; </div><div class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span> && br.curApp.pid == app.pid) {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="comment">// 这里接上处理之后，就把 mPendingBroadcast 设置成 null</span></div><div class="line">                mPendingBroadcast = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">// 下面这个函数就接上接收器进程已经启动的流程了</span></div><div class="line">                processCurBroadcastLocked(br, app);</div><div class="line">                didSomething = <span class="keyword">true</span>;</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                Slog.w(TAG, <span class="string">"Exception in new application when starting receiver "</span></div><div class="line">                        + br.curComponent.flattenToShortString(), e);</div><div class="line">                logBroadcastReceiverDiscardLocked(br);</div><div class="line">                <span class="comment">// 出错了继续要把广播发给一下个接收器</span></div><div class="line">                finishReceiverLocked(br, br.resultCode, br.resultData,</div><div class="line">                        br.resultExtras, br.resultAbort, <span class="keyword">true</span>);</div><div class="line">                scheduleBroadcastsLocked();</div><div class="line">                <span class="comment">// We need to reset the state if we failed to start the receiver.</span></div><div class="line">                br.state = BroadcastRecord.IDLE;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</div><div class="line">            }       </div><div class="line">        }                   </div><div class="line">        <span class="keyword">return</span> didSomething;</div><div class="line">    }</div><div class="line"></div></pre></td></tr></table></figure>

<p>看到 processCurBroadcastLocked 就松了一口气，后面的流程就和上面静态接收器进程已经启动的情况一样了。好像有了之前的知识（Binder 普通服务篇），这种复杂的情况这里说起来也没多复杂的样子，果然稍微明白 android 的一些设计手法之后很多地方都通用的说。</p>
<p>然后这里补充一个细节，在前面在串行广播处理中有多出错的地方（例如说启动接收器进程失败，或者是接收器为 null 的情况）都会调用</p>
<pre>
finishReceiverLocked();
scheduleBroadcastsLocked();
</pre>

<p>这是为了能然广播能够分发下去，当前的出错了就跳过去，然后面的继续执行。</p>
<p>PS：头有点晕的继续回最开始看一下图。</p>
<h2 id="优先级问题">优先级问题</h2>
<p>到这里广播的发送、处理流程就差不多说完了。不过前面有说到优先级的问题，这里详细讨论一下。注册篇说到静态注册系统级应用可以在 manifest 的 ‘<intent-filter>‘ 设置优先级。这样在收集静态注册接收器的时候优先级高的能排在串行广播列表的前面，就会优先收到广播。但是从上面的处理流程来看，如果广播不是串行的（默认并行），那么动态注册的接收器优先级永远比静态注册的要高（并行处理的我们认为它们同一个时间接到广播）。</intent-filter></p>
<p>这里可以稍微理解下 android 的设计： 虽然说并行广播的本意是让所有接收器一起响应。但是通过前面的分析知道，动态注册的进程都是已经启动起来了的；静态注册的进程基本上都还需要启动。动态切换换字体那篇工作小笔记分析 zygote 的时候知道，启动一个进程在 android 中是十分巨大的一个操作。而且如果静态注册的接收器的进程全都没有启动，那么就需要启动很多个进程。如果同时在后台启动这么多个进程，会造成系统响应严重顿卡。所以 android 广播的处理原则是（并行广播）：优先让动态注册的接收器处理广播，然后再让静态注册的接收器串行一个接着一个的处理（这样一次只会启动一个进程）。</p>
<p>然后回来讨论优先级问题。静态注册的接收器按照 manifest 里声明的优先级排序。注册篇说到动态注册的接收器 IntentFilter 有一个 setPriority 可以设置（这个没限制系统应用才能设置），然后动态注册的时候 IntentResolver 也会根据这个优先级排序。前面说在并行广播中（默认）动态注册的接收器优先级肯定排在静态注册的前面，所以动态注册接收器的优先级在并行广播中用处不大。但是在串行广播中，动态注册的接收会合并到静态注册接收器的列表中（前面合有分析合并代码的）。这个时候动态注册接收器的优先级就有用了，合并操作对比动态注册接收器和静态注册接收器的优先级，然后决定动态注册接收器的插入位置（排在静态注册的前面还是后面）。</p>
<p>最后总结一下，前面话太多不直观，来几点：</p>
<ol>
<li>并行广播下，动态注册优先级 &gt; 静态注册，静态注册按自己的优先级排序</li>
<li>串行广播下，动态注册和静态注册按各自的优先级一起排序</li>
</ol>
<h2 id="总结">总结</h2>
<p>经过注册篇和本篇的讲解能看得出，广播是集中由 AMS 来处理的：</p>
<ol>
<li>通过 AMS 接口可以动态注册接收器到 AMS（存储在 AMS 中）</li>
<li>通过 manifest 声明可以静态注册，由 PMS 扫描（存储在 PMS 中）</li>
<li>通过 AMS 发送广播时，AMS 会收集（匹配）自己和 PMS 中的保存的接收器，获取接收器列表（BroadcastRecord）</li>
<li>将 BroadcastRecord 放入指定队列（前台 or 后台），执行广播队列（BroadcastQueue）处理</li>
<li>广播队列按照优先级将依次（或者并行）广播分发到接收器进程 BroadcastReceiver 回调</li>
</ol>
<p>前面还有一个讨论串行广播等待处理完成的问题（包括超时问题），鉴于本篇已经很长了，新开一篇来说吧。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-Framework/">Android Framework</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.light3moon.com/2015/01/22/Android Broadcast 分析——发送、处理/" data-title="Android Broadcast 分析——发送、处理 | Light.Moon" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/01/22/Android Broadcast 分析——注册/" title="Android Broadcast 分析——注册">
  <strong>上一篇:</strong><br/>
  <span>
  Android Broadcast 分析——注册</span>
</a>
</div>


<div class="next">
<a href="/2015/01/22/Android Broadcast 分析——超时或异常/"  title="Android Broadcast 分析——超时或异常">
 <strong>下一篇:</strong><br/> 
 <span>Android Broadcast 分析——超时或异常
</span>
</a>
</div>

</nav>


	
<section class="comment">
	<div class="ds-thread" data-thread-key="Android Broadcast 分析——发送、处理" data-title="Android Broadcast 分析——发送、处理" 
      data-author-key="mingming" data-limit=10
      data-url="light3moon.com/2015/01/22/Android Broadcast 分析——发送、处理/">
    </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#发送接口"><span class="toc-number">1.</span> <span class="toc-text">发送接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用接口"><span class="toc-number">1.1.</span> <span class="toc-text">应用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统发送接口"><span class="toc-number">1.2.</span> <span class="toc-text">系统发送接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-_收集广播接收器"><span class="toc-number">2.</span> <span class="toc-text">a. 收集广播接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-a_收集静态注册接收器"><span class="toc-number">2.1.</span> <span class="toc-text">a.a 收集静态注册接收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-b_收集动态注册接收器"><span class="toc-number">2.2.</span> <span class="toc-text">a.b 收集动态注册接收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b-_分发广播给动态注册接收器"><span class="toc-number">3.</span> <span class="toc-text">b. 分发广播给动态注册接收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-_分发广播给静态注册接收器"><span class="toc-number">4.</span> <span class="toc-text">c. 分发广播给静态注册接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接收器进程已经启动"><span class="toc-number">4.1.</span> <span class="toc-text">接收器进程已经启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收器进程还没启动"><span class="toc-number">4.2.</span> <span class="toc-text">接收器进程还没启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先级问题"><span class="toc-number">5.</span> <span class="toc-text">优先级问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android-Development/" title="Android Development">Android Development<sup>35</sup></a></li>
		
			<li><a href="/categories/Android-Framework/" title="Android Framework">Android Framework<sup>47</sup></a></li>
		
			<li><a href="/categories/Basics-Knowledge/" title="Basics Knowledge">Basics Knowledge<sup>11</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>25</sup></a></li>
		
			<li><a href="/categories/MiniGUI/" title="MiniGUI">MiniGUI<sup>12</sup></a></li>
		
			<li><a href="/categories/Other/" title="Other">Other<sup>8</sup></a></li>
		
			<li><a href="/categories/Server/" title="Server">Server<sup>1</sup></a></li>
		
			<li><a href="/categories/Window/" title="Window">Window<sup>10</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/android/" title="android">android<sup>82</sup></a></li>
		
			<li><a href="/tags/basics/" title="basics">basics<sup>11</sup></a></li>
		
			<li><a href="/tags/install/" title="install">install<sup>9</sup></a></li>
		
			<li><a href="/tags/linux/" title="linux">linux<sup>28</sup></a></li>
		
			<li><a href="/tags/minigui/" title="minigui">minigui<sup>13</sup></a></li>
		
			<li><a href="/tags/opengl/" title="opengl">opengl<sup>3</sup></a></li>
		
			<li><a href="/tags/other/" title="other">other<sup>5</sup></a></li>
		
			<li><a href="/tags/server/" title="server">server<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>5</sup></a></li>
		
			<li><a href="/tags/window/" title="window">window<sup>11</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">哥的后勤处 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-qqzone"></i> <a href="http://user.qzone.qq.com/544630305" target="_blank">QQ 空间</a></li>
      <li><i class="fa fa-github"></i> <a href="https://github.com/mingming-killer" target="_blank">GitHub</a></li>
      
        
          <li><i class="fa fa-analytics"></i> <a href="http://tongji.baidu.com/web/welcome/ico?s=fa045dbd45ffce238b146e00f91ba6a3" target="_blank">战斗力</a></li>
        
      
      <li><i class="fa fa-markdown-help"></i> <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank">Makrdown</a></li>
    </ul>
</div>


  <div class="commentlist">
  <p class="asidetitle">最近冒泡的小伙伴 ╰(●&#39;◡&#39;●)╮</p>
    <ul>
      <ul class="ds-recent-comments" 
        data-num-items="6" 
        data-show-avatars="1" 
        data-show-title="1"   
        data-show-time="1" 
        data-show-admin="1" 
        data-excerpt-length="30">
      </ul>
      <!-- duoshou js begin load, one page only load once -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"mingming"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- duoshou js load end -->
    </ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接 o(^▽^)o</p>
    <ul>
      <li><i class="fa fa-book"></i> <a href="http://taoyuanxiaoqi.com" target="_blank">桃园小七的博客</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
<!--
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
-->

     <!-- this is defined in footer.styl, line holder -->
	<div class="line">
	</div>
     
<!--
	<div class="social-font clearfix">
		
		
		
		
		
		<a href="https://github.com/mingming-killer" target="_blank" title="github"></a>
		
        	
		<a href="http://user.qzone.qq.com/544630305" target="_blank" title="qqzone"></a>
		         
	</div>
-->

		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/mingming-killer/Lightmoon" target="_blank" title="Lightmoon">Lightmoon</a> © 2019 
		
		<a href="http://www.light3moon.com" target="_blank" title="Mingming">Mingming</a>
		
		</p>

  <!-- baidu search verification -->
  
    <meta name="baidu-site-verification" content="w1BSX6yZ9k" />
  

  <!-- swiftype search verification -->
  

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"mingming"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fa045dbd45ffce238b146e00f91ba6a3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
